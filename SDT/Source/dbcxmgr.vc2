*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="dbcxmgr.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS basemgr AS custom 		&& Base DBCX Extension manager (superclass for all DBCX extensions)
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "dbcxmgr.h"
	*<DefinedPropArrayMethod>
		*m: addrow		&& This method is called when a new object is added to the meta data
		*m: cdbcxmergealias_access
		*m: checkdbcxmeta		&& Check the DBCX meta table structure to see if it needs to be converted to a new format
		*m: closemergecursors		&& Closes any cursors opened by CreateXMLMergeFile.
		*m: convertdbcxmeta		&& Converts the DBCX meta table to a new structure
		*m: createdbcxmeta		&& Creates the meta data table
		*m: dbcxcreateprop		&& Adds a property to an extension. NOTE: This function strips the property prefix automatically.
		*m: dbcxdeleteprop		&& Removes a property from an extension.
		*m: dbcxdeleterow		&& Deletes a row of information from the extension table.
		*m: dbcxgetprop		&& Retrieve the passed property from the appropriate DBCX object.
		*m: dbcxgetproplist		&& Inserts records into a cursor for all the properties for the Current DBCX Manager.
		*m: dbcxgetrowprop		&& Retrieves all property names and values into an array.
		*m: dbcxnotify		&& This is called for each extension when a change has been made in another extension.
		*m: dbcxpackmeta		&& Packs the Meta Data table.
		*m: dbcxremoveorphan
		*m: dbcxrenameobject		&& Renames an object in the meta data
		*m: dbcxsetprop		&& Set the passed property and value in the appropriate DBCX object.
		*m: dbcxsetpropertyobject		&& Saves the properties for the specified object from a passed object
		*m: dbcxsetrowprop		&& Sets all properties using the values from an array.
		*m: ensureoneobject		&& Ensures we have one and only one record for the object in the meta data table
		*m: findobject		&& Locates the specified object in the meta data table
		*m: flagunprocessed		&& Flags all records for a given object and object type as unprocessed before validation begins
		*m: getdataname		&& Returns the field name in the extension table for a given property
		*m: getmergedata		&& Retrieves data for a specific database and adds the result to a pass object representing an XMLAdapter.
		*m: getobjectname		&& Returns the object name from the DBC based on the format of the tcObject parameter.
		*m: getparentname		&& Returns the parent object name from the DBC based on the format of the tcObject parameter.
		*m: getpropertyname		&& Returns the property name for a given field in the meta data table
		*m: insertmergedata		&& Inserts a new record in the metadata table based on data in a merge table.
		*m: isprocessed		&& Returns .T. if the current object was validated by this manager
		*m: loadmetadatafromobject		&& Updates metadata from an XMLAdapter object.
		*m: opencursor		&& Opens a table or view
		*m: opendbcxmeta		&& Opens the meta data table
		*m: processmergedata		&& Processes the merge data cursor.
		*m: showui		&& Displays the user interface for this manager in the DBCXMgr form
		*m: validate		&& Validates the extension information to the DBC
		*m: validateconnection		&& Validates a connection
		*m: validatedatabase		&& Validates a database
		*m: validatefield		&& Validates a field
		*m: validateindex		&& Validates an index
		*m: validaterelation		&& Validates a relation
		*m: validatetable		&& Validates a table
		*m: validateview		&& Validates a view
		*m: validateviewindex		&& Validates a view index
		*m: warning		&& Displays an error message
		*p: cdbc		&& The database container name used by the extension manager
		*p: cdbcnamefield		&& The name of the field in the meta data table containing the database name for an object
		*p: cdbcxalias		&& Alias used for the extension table
		*p: cdbcxmergealias		&& The alias of the cursor holding the merge data.
		*p: cdbcxtable		&& The name of the extension table
		*p: cdbcxtag		&& Default index tag for the extension table
		*p: cobjectnamefield		&& The name of the field in the meta data table containing the object name
		*p: cobjecttypeshandled		&& A string of object types this manager will validate
		*p: cprefix		&& The prefix used for properties of this extension
		*p: cprocessfield		&& The name of the field in the meta data table that indicates which objects are processed during validation
		*p: cproductname		&& The name of the product that uses this extension
		*p: crectypefield		&& The name of the field in the meta data table containing the type of an object
		*p: cversion		&& The version of the class
		*p: luicreated		&& .T. if the user interface has already been displayed in the DBCXMgr form
		*p: lvalidateobject		&& .T if the object was validated
		*p: oerror		&& An object to handle errors
	*</DefinedPropArrayMethod>

	PROTECTED cdbc,cdbcnamefield,cdbcxtag,cobjectnamefield,cprocessfield,luicreated
	cdbc = 		&& The database container name used by the extension manager
	cdbcnamefield = DBCName		&& The name of the field in the meta data table containing the database name for an object
	cdbcxalias = 		&& Alias used for the extension table
	cdbcxmergealias = 		&& The alias of the cursor holding the merge data.
	cdbcxtable = 		&& The name of the extension table
	cdbcxtag = ObjectName		&& Default index tag for the extension table
	cobjectnamefield = ObjectName		&& The name of the field in the meta data table containing the object name
	cobjecttypeshandled = DTVCRFIPU		&& A string of object types this manager will validate
	cprefix = 		&& The prefix used for properties of this extension
	cprocessfield = LastUpdate		&& The name of the field in the meta data table that indicates which objects are processed during validation
	cproductname = 		&& The name of the product that uses this extension
	crectypefield = RecType		&& The name of the field in the meta data table containing the type of an object
	cversion = 2007.03.26		&& The version of the class
	luicreated = .F.		&& .T. if the user interface has already been displayed in the DBCXMgr form
	Name = "basemgr"
	oerror = .NULL.		&& An object to handle errors
	Width = 17
	
	PROCEDURE addrow		&& This method is called when a new object is added to the meta data
		*==============================================================================
		* Method:			AddRow
		* Status:			Public
		* Purpose:			Adds a record to the meta data table
		* Author:			Toni M. Feltman, F1 Technologies
		*					W. Michael Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/09/97
		* Parameters:		tiID         - the DBCX ID for the new record (a manager
		*						may choose to ignore this value)
		*					tcDBC        - the database the object belongs to
		*					tcObjectName - the name of the object without the database
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T. if the record was added
		* Note:				this is an abstract method; each manager will have their
		*						own way to do this. For example, the simplest might be:
		*
		*						if left(tcObjectType, 1) $ This.cObjectTypesHandled and ;
		*							not This.FindObject(tcObjectName, tcObjectType, tcDBC)
		*							insert into (This.cDBCXAlias) ;
		*									(ObjectName, ;
		*									RecType, ;
		*									DBCName) ;
		*								values ;
		*									(tcObjectName, ;
		*									tcObjectType, ;
		*									tcDBC)
		*						endif
		*
		*						(the call to FindObject ensures the object isn't added
		*						if it already exists)
		*==============================================================================
		
		lparameters tiID, ;
			tcDBC, ;
			tcObjectName, ;
			tcObjectType
		return .T.
		
	ENDPROC

	PROCEDURE cdbcxmergealias_access
		*==============================================================================
		* Method:			cDBCXMergeAlias_Access
		* Purpose:			If this property is emtpy, default to the cDBCXAlias
		*					plus the word MergeCursor.
		* Author:			Toni M. Feltman, F1 Technologies
		* Parameters:		None
		* Returns:			None
		* Added:			08/18/2004
		*==============================================================================
		WITH This
		
			IF EMPTY(.cDBCXMergeAlias) AND NOT EMPTY(.cDBCXAlias)
				.cDBCXMergeAlias = ALLTRIM(.cDBCXAlias) + [MergeCursor]
			ENDIF
		
		ENDWITH
				
		RETURN THIS.cDBCXMergeAlias
		
	ENDPROC

	PROCEDURE checkdbcxmeta		&& Check the DBCX meta table structure to see if it needs to be converted to a new format
		*==============================================================================
		* Method:			CheckDBCXMeta
		* Status:			Public
		* Purpose:			Check the DBCX meta table structure to see if it needs to
		*						be converted to a new format
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/06/98
		* Parameters:		none
		* Returns:			.T. if the structure needs to be converted
		* Environment in:	the meta data table must exist
		* Environment out:	none
		* Note:				each manager must implement its own technique of doing this
		*==============================================================================
		
		return .F.
		
	ENDPROC

	PROCEDURE closemergecursors		&& Closes any cursors opened by CreateXMLMergeFile.
		*==============================================================================
		* Method:			CloseMergeCursors
		* Purpose:			Closes any cursors opened by CreateXMLMergeFile.
		* Author:			Toni M. Feltman, F1 Technologies
		* Parameters:		None
		* Returns:			None
		* Added:			08/18/2004
		*==============================================================================
		LOCAL ;
			lcMergeCursor AS Character
			
		lcMergeCursor = This.cDBCXMergeAlias 
		
		IF NOT EMPTY(lcMergeCursor) AND USED(lcMergeCursor)
			USE IN (lcMergeCursor)
		ENDIF	
	ENDPROC

	PROCEDURE convertdbcxmeta		&& Converts the DBCX meta table to a new structure
		*==============================================================================
		* Method:			ConvertDBCXMeta
		* Status:			Public
		* Purpose:			Converts the DBCX meta table to a new structure
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/06/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	the meta data table must exist
		* Environment out:	the meta data table is converted to a new structure
		* Note:				each manager must implement its own technique of doing this
		*==============================================================================
		
	ENDPROC

	PROCEDURE createdbcxmeta		&& Creates the meta data table
		*==============================================================================
		* Method:			CreateDBCXMeta
		* Status:			Public
		* Purpose:			Creates the meta data table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	05/24/2001
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.Parent.cRegistryPath contains the path where the table
		*						should be created, This.cDBCXTable contains the
		*						table name, and This.cDBCXAlias contains the alias
		* Environment out:	the meta data table was created
		* Note:				each manager must implement its own technique of creating
		*						the meta data table
		*==============================================================================
		
	ENDPROC

	PROCEDURE dbcxcreateprop		&& Adds a property to an extension. NOTE: This function strips the property prefix automatically.
		*==============================================================================
		* Method:			DBCXCreateProp
		* Status:			Public
		* Purpose:			Creates a new property in an extension table
		* Author:			Toni M. Feltman, F1 Technologies
		*					Y. Alan Griver, Flash Creative Management
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcName     - the name for the new property
		*					tcLongName - the long name for the new property (optional:
		*						if it isn't specified, tcName is used)
		*					tcDataType - the data type for the new property (optional:
		*						if it isn't specified, Memo is used)
		*					tnLen      - the size of the new property (optional: if it
		*						isn't specified, the appropriate size for the data type
		*						or 10 for Character and Numeric fields is used)
		*					tnDecimals - the number of decimal places in the new
		*						property (optional: if it isn't specified, 0 is used)
		* Returns:			.T. if the property was added
		* Environment in:	the meta data table must be available to be opened
		*						exclusively
		* Environment out:	see This.OpenDBCXMeta() for changes to the environment
		*					the DBCX properties cursor is updated to reflect the new
		*						property
		*==============================================================================
		
		lparameters tcName, ;
			tcLongName, ;
			tcDataType, ;
			tnLen, ;
			tnDecimals
		local llReturn, ;
			lcDataType, ;
			lnLen, ;
			lnDecimals, ;
			lcName, ;
			lcCommandString, ;
			lcProperty, ;
			lcLongName
		with This
		
		* Open our meta data table exclusively.
		
			if used(.cDBCXAlias)
				use in (.cDBCXAlias)
			endif used(.cDBCXAlias)
			llReturn = .OpenDBCXMeta(.T.)
			if llReturn
		
		* Handle parameters.
		
				lcDataType = tcDataType
				do case
					case pcount() = 5
						lnLen      = tnLen
						lnDecimals = tnDecimals
					case pcount() = 2
						lcDataType = 'M'
						lnLen      = 4
						lnDecimals = 0
					case pcount() = 4
						lnLen      = tnLen
						lnDecimals = 0
					case tcDataType = 'Y'
						lnLen      = 8
						lnDecimals = 0
					case tcDataType = 'D'
						lnLen      = 8
						lnDecimals = 0
					case tcDataType = 'T'
						lnLen      = 8
						lnDecimals = 0
					case tcDataType = 'B'
						lnLen      = 8
						lnDecimals = 0
					case tcDataType = 'I'
						lnLen      = 4
						lnDecimals = 0
					case tcDataType = 'L'
						lnLen      = 1
						lnDecimals = 0
					case tcDataType = 'M'
						lnLen      = 4
						lnDecimals = 0
					case tcDataType = 'G'
						lnLen      = 4
						lnDecimals = 0
					otherwise
						lnLen      = 10
						lnDecimals = 0
				endcase
		
		* Get the name of the field and add it to our meta data table.
		
				lcName = .GetDataName(tcName)
				if lcDataType = 'B'
					lcCommandString = 'ALTER TABLE ' + .cDBCXAlias + ;
						' ADD COLUMN ' + lcName + ' ' + lcDataType + ;
						' (' + str(lnDecimals) + ')'
				else
					lcCommandString = 'ALTER TABLE ' + .cDBCXAlias + ;
						' ADD COLUMN ' + lcName + ' ' + lcDataType + ;
						' (' + str(lnLen) + ', ' + str(lnDecimals) + ')'
				endif lcDataType = 'B'
				&lcCommandString
		
		* Reopen the table in shared mode.
		
				use in (.cDBCXAlias)
				.OpenDBCXMeta()
		
		* Ensure the new property was added. If so, add the new property to the
		* properties cursor.
		
				lcProperty = .GetPropertyName(tcName)
				lcLongName = iif(vartype(tcLongName) = 'C' and not empty(tcLongName), ;
					tcLongName, lcProperty)
				llReturn   = type(alltrim(.cDBCXAlias) + '.' + alltrim(lcName)) <> 'U'
				do case
					case not llReturn
						.Warning(strtran(ccERR_CANT_CREATE_PROPERTY, ccMSG_INSERT1, ;
							lcProperty))
					case not .Parent.CreatePropCursor()
						.Warning(ccERR_CANT_CREATE_PROPCURSOR)
					otherwise
						insert into (.Parent.cPropCursorName) ;
								(cProperty, ;
								cObject, ;
								cProdName, ;
								cLongName) ;
							values ;
								(upper(lcProperty), ;
								.Name, ;
								.cProductName, ;
								upper(lcLongName))
				endcase
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxdeleteprop		&& Removes a property from an extension.
		*==============================================================================
		* Method:			DBCXDeleteProp
		* Status:			Public
		* Purpose:			Removes a property from the meta data table
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	10/21/98
		* Parameters:		tcName - the name for the property to delete
		*					tcDBCX - for backward compatibility only
		* Returns:			.T. if the property was deleted
		* Environment in:	the meta data table must be available to be opened
		*						exclusively
		* Environment out:	the field name storing the values for the specified
		*						property has been deleted
		*==============================================================================
		
		lparameters tcName, ;
			tcDBCX
		local llReturn, ;
			lcPropName, ;
			lcName
		with This
		
		* Open our meta data table exclusively.
		
			if used(.cDBCXAlias)
				use in (.cDBCXAlias)
			endif used(.cDBCXAlias)
			llReturn = .OpenDBCXMeta(.T.)
			if llReturn
		
		* Get the actual field name for the property and delete the specified field.
		
				lcPropName = padr(upper(alltrim(tcName)), 30)
				lcName     = .GetDataName(tcName)
				alter table (.cDBCXAlias) drop column (lcName)
		
		* Reopen the meta data table in shared mode.
		
				use in (.cDBCXAlias)
				.OpenDBCXMeta()
		
		* Ensure the field was deleted. If so, remove the property from the Properties
		* cursor if the cursor is open and we can both find and lock the appropriate
		* record.
		
				llReturn = type(alltrim(.cDBCXAlias) + '.' + alltrim(lcName)) = 'U'
				if llReturn
					lcPropCursor = .Parent.cPropCursorName
					if .Parent.CreatePropCursor() and ;
						seek(lcPropName, lcPropCursor, 'cProperty') and ;
						rlock(lcPropCursor)
						delete in (lcPropCursor)
						unlock in (lcPropCursor)
						if not eof(lcPropCursor)
							skip in (lcPropCursor)
						endif not eof(lcPropCursor)
						if eof(lcPropCursor)
							go bottom in (lcPropCursor)
						endif eof(lcPropCursor)
					endif .Parent.CreatePropCursor() ...
				else
					.Warning(strtran(ccERR_CANT_DELETE_PROPERTY, ccMSG_INSERT1, ;
						tcName))
				endif llReturn
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxdeleterow		&& Deletes a row of information from the extension table.
		*==============================================================================
		* Method:			DBCXDeleteRow
		* Status:			Public
		* Purpose:			Delete an object's record (and all child records) from the
		*						meta data
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	01/09/2004
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T. if no errors occurred
		* Environment in:	the meta data table must be available to be opened
		* Environment out:	if this method returns .T., the meta data records for the
		*						object and all child objects are deleted
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType
		local llReturn, ;
			lcDBCField, ;
			lcObjectField, ;
			lcTypeField, ;
			lcDBC, ;
			lcObjectName, ;
			lcFullObject, ;
			lcObjectType, ;
			lnSelect
		with This
		
		* Ensure the meta data table is open.
		
			if not .OpenDBCXMeta()
				return llReturn
			endif not .OpenDBCXMeta()
		
		* Get the database and object name, and try to find the object in the meta data
		* table.
		
			lcDBCField    = .cDBCNameField
			lcObjectField = .cObjectNameField
			lcTypeField   = .cRecTypeField
			lcDBC         = iif(upper(tcObjectType) = 'DATABASE', ;
				tcObjectName, .Parent.GetDatabase(tcObjectName))
			lcDBC         = padr(lcDBC, fsize(lcDBCField, .cDBCXAlias))
			lcObjectName  = lower(.Parent.StripDatabase(tcObjectName))
			lcFullObject  = padr(lcObjectName, fsize(lcObjectField, .cDBCXAlias))
			lcObjectType  = upper(left(tcObjectType, 1))
			do case
		
		* If we don't handle this type of object, just return .T. so DBCXMgr doesn't
		* think we failed.
		
				case not lcObjectType $ This.cObjectTypesHandled
					llReturn = .T.
		
		* If we can find the record, delete all objects with the same name (for
		* example, all fields and indexes for the table if the table name changes).
		* We'll use optimistic table buffering so we can undo all the changes if
		* necessary.
		
				case .FindObject(lcObjectName, tcObjectType, lcDBC)
					lnSelect = select()
					select (.cDBCXAlias)
					cursorsetprop('Buffering', DB_BUFOPTTABLE)
					llReturn = .T.
					scan for lower(&lcDBCField) = lcDBC and (lcObjectType = 'D' or ;
						(lower(&lcObjectField) = lcFullObject and ;
						&lcTypeField = lcObjectType) or ;
						lower(&lcObjectField) = lcObjectName + '.' or ;
						(&lcTypeField = 'R' and lcObjectType $ 'TI' and ;
						(lower(&lcObjectField) = lcObjectName + ',' or ;
						',' + lcObjectName + '.' $ lower(&lcObjectField) or ;
						',' + lcObjectName + ' '$ lower(&lcObjectField))))
						if rlock()
							delete
							unlock
						else
							llReturn = .F.
							exit
						endif rlock()
					endscan for lower(&lcDBCField) = lcDBC ...
		
		* Give an error if not all objects could be removed.
		
					if not llReturn or not tableupdate(1)
						tablerevert(.T.)
						.Warning(ccERR_CANT_DELETE_RECORD)
					endif not llReturn ...
		
		* Restore the things we changed.
		
					cursorsetprop('Buffering', DB_BUFOFF)
					select (lnSelect)
		
		* The object wasn't found.
		
				otherwise
					.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
						tcObjectName))
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxgetprop		&& Retrieve the passed property from the appropriate DBCX object.
		*==============================================================================
		* Method:			DBCXGetProp
		* Status:			Public
		* Purpose:			Get the specified property for the specified object
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/03/97
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection"
		*					tcProperty   - the desired DBCX property to return
		* Returns:			the value of the specified property if the object and
		*						property exist or .NULL. if not
		* Environment in:	the meta data table must either be open or available to be
		*						opened
		* Environment out:	see This.OpenDBCXMeta() and This.FindProperty() for changes
		*						to the environment
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcProperty
		local luReturn, ;
			lcProperty, ;
			lcField, ;
			lcDBC, ;
			lcObjectName, ;
			lcExpression
		with This
		
		* Ensure the meta data table is open.
		
			luReturn = .NULL.
			if not .OpenDBCXMeta()
				return luReturn
			endif not .OpenDBCXMeta()
		
		* Find out what field in the meta data table holds the specified property.
		
			lcProperty   = alltrim(tcProperty)
			lcField      = .cDBCXAlias + '.' + .GetDataName(lcProperty)
			lcDBC        = .Parent.GetDatabase(tcObjectName)
			lcObjectName = .Parent.StripDatabase(tcObjectName)
			do case
		
		* We don't have such a field.
		
				case type(lcField) = 'U'
					.Warning(strtran(ccERR_INVALID_PROPERTY_NAME, ccMSG_INSERT1, ;
						lcProperty))
		
		* Find the object in the meta data table. If we found it, get the value from
		* the appropriate field. If the value is a string, trim it.
		
				case .FindObject(lcObjectName, tcObjectType, lcDBC)
					luReturn = evaluate(lcField)
					if type(lcField) = 'C'
						luReturn = trim(luReturn)
					endif type(lcField) = 'C'
		
		* The object wasn't found.
		
				otherwise
					.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
						tcObjectName))
			endcase
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE dbcxgetproplist		&& Inserts records into a cursor for all the properties for the Current DBCX Manager.
		*==============================================================================
		* Method:			DBCXGetPropList
		* Status:			Public
		* Purpose:			Populates a cursor with the name of all properties in the
		*						extension
		* Author:			Toni M. Feltman, F1 Technologies
		*					Y. Alan Griver, Flash Creative Management
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/03/97
		* Returns:			.T. if everything went OK
		* Parameters:		tcCursorName - the name of the cursor to populate
		* Environment in:	the specified cursor must be open
		*					the meta data table for this manager must either be open or
		*						available to be opened
		* Environment out:	the meta data table for this manager may have been opened
		*					the specified cursor is updated with properties managed by
		*						this manager
		*==============================================================================
		
		lparameters tcCursorName
		local lnI, ;
			lcField
		with This
		
		* Ensure our meta data table is open.
		
			if not .OpenDBCXMeta()
				return .F.
			endif not .OpenDBCXMeta()
		
		* Update the cursor holding all DBCX properties to include our properties.
		
			for lnI = 1 to fcount(.cDBCXAlias)
				lcField = field(lnI, .cDBCXAlias)
				insert into (tcCursorName) ;
						(CPROPERTY, ;
						COBJECT, ;
						CPRODNAME, ;
						CLONGNAME) ;
					values ;
						(.GetPropertyName(lcField), ;
						.Name, ;
						.cProductName, ;
						lcField)
			next lnI
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE dbcxgetrowprop		&& Retrieves all property names and values into an array.
		*==============================================================================
		* Method:			DBCXGetRowProp
		* Status:			Public
		* Purpose:			Gets all property names and values into an array
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	01/09/2004
		* Parameters:		taArray      - the array to populate (must be passed by
		*						reference)
		*					tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T. if the array was populated with property values
		* Environment in:	the meta data table must be open or available to be opened
		* Environment out:	the array is populated with property names and values
		*					the meta data table is positioned to the record for the
		*						specified object
		*==============================================================================
		
		lparameters taArray, ;
			tcObjectName, ;
			tcObjectType
		local llReturn, ;
			lcDBC, ;
			lcObjectName, ;
			lcObjectType, ;
			lnRows, ;
			lnCols, ;
			lnCounter, ;
			lcField, ;
			luValue
		external array taArray
		with This
		
		* Ensure the meta data table is open.
		
			if not .OpenDBCXMeta()
				return llReturn
			endif not .OpenDBCXMeta()
		
		* Get the database and object name.
		
			lcDBC        = .Parent.GetDatabase(tcObjectName)
			lcObjectName = .Parent.StripDatabase(tcObjectName)
			lcObjectType = upper(left(tcObjectType, 1))
			do case
		
		* If we don't handle this type of object, just return .T. so DBCXMgr doesn't
		* think we failed.
		
				case not lcObjectType $ This.cObjectTypesHandled
					llReturn = .T.
		
		* Find the object in the meta data table. If we found it, put the value from
		* each field in the meta data table into the array. If the value is a string,
		* trim it.
		
				case .FindObject(lcObjectName, tcObjectType, lcDBC)
					lnRows = alen(taArray, 1)
					lnCols = alen(taArray, 2)
					for lnCounter = 1 to fcount(.cDBCXAlias)
						lcField = field(lnCounter, .cDBCXAlias)
						if not empty(taArray[1, 1])
							lnRows = lnRows + 1
							dimension taArray[lnRows, lnCols]
						endif not empty(taArray[1, 1])
						taArray[lnRows, 1] = .Name
						taArray[lnRows, 2] = .GetPropertyName(lcField)
						lcField = .cDBCXAlias + '.' + lcField
						luValue = evaluate(lcField)
						if type(lcField) = 'C'
							luValue = alltrim(luValue)
						endif type(lcField) = 'C'
						taArray[lnRows, 3] = luValue
					next lnCounter
					llReturn = .T.
		
		* The object wasn't found.
		
				otherwise
					.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
						tcObjectName))
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxnotify		&& This is called for each extension when a change has been made in another extension.
		*==============================================================================
		* Method:			DBCXNotify
		* Status:			Public
		* Purpose:			This method is called any time a property value is changed
		*						in another extension
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/04/97
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcManager    - the name of the manager managing the changed
		*						property (upper-cased)
		*					tcProperty   - the property that was changed (upper-cased)
		*					tuValue      - the value it was changed to
		* Returns:			.T.
		* Environment in:	the meta data table must be open or available to be opened
		* Environment out:	depends on the manager
		* Note:				this is an abstract method; each manager will have to
		*						implement its own method
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcManager, ;
			tcProperty, ;
			tuValue
		return .T.
		
	ENDPROC

	PROCEDURE dbcxpackmeta		&& Packs the Meta Data table.
		*==============================================================================
		* Method:			DBCXPackMeta
		* Status:			Public
		* Purpose:			Packs the meta data table
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	10/20/98
		* Parameters:		none
		* Returns:			.T. if it succeeded
		* Environment in:	the meta data table must be available to be opened
		*						exclusively
		* Environment out:	the meta data table has been packed
		*==============================================================================
		
		local llReturn, ;
			lnSelect
		with This
		
		* Open our meta data table exclusively.
		
			if used(.cDBCXAlias)
				use in (.cDBCXAlias)
			endif used(.cDBCXAlias)
			llReturn = .OpenDBCXMeta(.T.)
			if llReturn
		
		* Pack it and reopen it in shared mode.
		
				lnSelect = select()
				select (.cDBCXAlias)
				pack
				use in (.cDBCXAlias)
				select (lnSelect)
			endif llReturn
			.OpenDBCXMeta()
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxremoveorphan
		*==============================================================================
		* Method:			DBCXRemoveOrphan
		* Status:			Public
		* Purpose:			Removes any orphan records from the meta data table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	08/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	the meta data table must be open somewhere
		*					This.cProcessField contains the name of the field that if
		*						blank means this is an orphan record
		*					This.cRecTypeField contains the name of the field that
		*						contain the object type
		*					This.cObjectTypesHandled contains the list of which object
		*						types this manager handles
		* Environment out:	any orphan records have been deleted
		*==============================================================================
		
		local lcProcessField, ;
			lcRecTypeField, ;
			lcDBCField, ;
			lcDBC
		with This
			lcProcessField = .cProcessField
			lcRecTypeField = .cRecTypeField
			lcDBCField     = .cDBCNameField
			lcDBC          = lower(juststem(.Parent.cCurrentDBC))
			lcDBC          = padr(lcDBC, fsize(lcDBCField, .cDBCXAlias))
			delete for &lcDBCField = lcDBC and (empty(&lcProcessField) or ;
				not &lcRecTypeField $ This.cObjectTypesHandled) ;
				in (.cDBCXAlias)
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE dbcxrenameobject		&& Renames an object in the meta data
		*==============================================================================
		* Method:			DBCXRenameObject
		* Status:			Public
		* Purpose:			Rename an object in the meta data
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	01/09/2004
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcNewName    - the new name of the object in VFP DBC syntax
		* Returns:			.T. if no errors occurred
		* Environment in:	the meta data table must be available to be opened
		* Environment out:	if this method returns .T., the new name has been placed in
		*						all meta data records for the object and its children
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcNewName
		local llReturn, ;
			lcDBCField, ;
			lcObjectField, ;
			lcTypeField, ;
			lcDBC, ;
			lcObjectName, ;
			lcFullObject, ;
			lcNewDBC, ;
			lcNewName, ;
			llChangeDBC, ;
			lcObjectType, ;
			lnSelect, ;
			lcObject
		with This
		
		* Ensure the meta data table is open.
		
			if not .OpenDBCXMeta()
				return llReturn
			endif not .OpenDBCXMeta()
		
		* Get the database and object name, and try to find the object in the meta data
		* table.
		
			lcDBCField    = .cDBCNameField
			lcObjectField = .cObjectNameField
			lcTypeField   = .cRecTypeField
			lcDBC         = padr(.Parent.GetDatabase(tcObjectName), ;
				fsize(lcDBCField, .cDBCXAlias))
			lcObjectName  = lower(.Parent.StripDatabase(tcObjectName))
			lcFullObject  = padr(lcObjectName, fsize(lcObjectField, .cDBCXAlias))
			lcNewDBC      = padr(.Parent.GetDatabase(tcNewName), ;
				fsize(lcDBCField, .cDBCXAlias))
			lcNewName     = lower(.Parent.StripDatabase(tcNewName))
			llChangeDBC   = not lcDBC        == lcNewDBC
			lcObjectType  = upper(left(tcObjectType, 1))
			do case
		
		* If we don't handle this type of object, just return .T. so DBCXMgr doesn't
		* think we failed.
		
				case not lcObjectType $ This.cObjectTypesHandled
					llReturn = .T.
		
		* If we can find the record, rename all objects with the same name (for
		* example, all fields and indexes for the table if the table name changes).
		* We'll use optimistic table buffering so we can undo all the changes if
		* necessary.
		
				case .FindObject(lcObjectName, tcObjectType, lcDBC)
					lnSelect = select()
					select (.cDBCXAlias)
					cursorsetprop('Buffering', DB_BUFOPTTABLE)
					llReturn = .T.
					scan for lower(&lcDBCField) = lcDBC and ;
						((lower(&lcObjectField) = lcFullObject and ;
						&lcTypeField = lcObjectType) or ;
						lower(&lcObjectField) = lcObjectName + '.' or ;
						(&lcTypeField = 'R' and lcObjectType $ 'TI' and ;
						(lower(&lcObjectField) = lcObjectName + ',' or ;
						',' + lcObjectName + '.' $ lower(&lcObjectField) or ;
						',' + lcObjectName + ' '$ lower(&lcObjectField))))
						lcObject = evaluate(lcObjectField)
						do case
							case not rlock()
								llReturn = .F.
								exit
							case llChangeDBC
								replace (lcDBCField) with lcNewDBC
								unlock
							case lower(&lcObjectField) = lcObjectName + '.'
								replace (lcObjectField) with lcNewName + ;
									substr(lcObject, at('.', lcObject))
								unlock
							case lower(&lcObjectField) = lcObjectName + ','
								replace (lcObjectField) with lcNewName + ;
									substr(lcObject, at(',', lcObject))
								unlock
							case ',' + lcObjectName + '.' $ lower(&lcObjectField)
								replace (lcObjectField) with ;
									left(lcObject, at(',', lcObject)) + lcNewName + ;
									substr(lcObject, at('.', lcObject, 2))
								unlock
							case ',' + lcObjectName + ' ' $ lower(&lcObjectField)
								replace (lcObjectField) with ;
									left(lcObject, at(',', lcObject)) + lcNewName
								unlock
							otherwise
								replace (lcObjectField) with lcNewName
								unlock
						endcase
					endscan for &lcDBCField = lcDBC ...
		
		* Give an error if not all objects could be renamed.
		
					if not llReturn or not tableupdate(1)
						tablerevert(.T.)
						.Warning(ccERR_CANT_RENAME_RECORD)
					endif not llReturn ...
		
		* Restore the things we changed.
		
					cursorsetprop('Buffering', DB_BUFOFF)
					select (lnSelect)
		
		* The object wasn't found.
		
				otherwise
					.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
						tcObjectName))
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxsetprop		&& Set the passed property and value in the appropriate DBCX object.
		*==============================================================================
		* Method:			DBCXSetProp
		* Status:			Public
		* Purpose:			Set the specified property for the specified object
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	09/25/2002
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection"
		*					tcProperty   - the desired DBCX property to set
		*					tuValue      - the value to assign to the property
		* Returns:			.T. if the object and property exist and the data type of
		*						tuValue is proper or .F. if not
		* Environment in:	the meta data table must either be open or available to be
		*						opened
		* Environment out:	see This.OpenDBCXMeta() and This.FindProperty() for changes
		*						to the environment
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcProperty, ;
			tuValue
		local llReturn, ;
			lcProperty, ;
			lcField, ;
			lcType, ;
			lcDBC, ;
			lcObjectName
		with This
		
		* Ensure the meta data table is open.
		
			if not .OpenDBCXMeta()
				return llReturn
			endif not .OpenDBCXMeta()
		
		* Find out what field in the meta data table holds the specified property.
		
			lcProperty   = alltrim(tcProperty)
			lcField      = .cDBCXAlias + '.' + .GetDataName(lcProperty)
			lcType       = type(lcField)
			lcDBC        = .Parent.GetDatabase(tcObjectName)
			lcObjectName = .Parent.StripDatabase(tcObjectName)
			do case
		
		* We don't have such a field.
		
				case lcType = 'U'
					.Warning(strtran(ccERR_INVALID_PROPERTY_NAME, ccMSG_INSERT1, ;
						lcProperty))
		
		* The data type of tuValue doesn't match that of the property.
		
				case lcType <> vartype(tuValue) and lcType <> 'M' and ;
					vartype(tuValue) <> 'C'
					.Warning(strtran(ccERR_INVALID_DATA_TYPE, ccMSG_INSERT1, ;
						lcProperty))
		
		* Find the object in the meta data table. If we found it, set the value for
		* the appropriate field.
		
				case .FindObject(lcObjectName, tcObjectType, lcDBC)
					replace (lcField) with tuValue, (.cProcessField) with datetime() ;
						in (.cDBCXAlias)
					llReturn = .T.
		
		* The object wasn't found.
		
				otherwise
					.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
						tcObjectName))
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxsetpropertyobject		&& Saves the properties for the specified object from a passed object
		*==============================================================================
		* Method:			DBCXSetPropertyObject
		* Status:			Public
		* Purpose:			Sets all properties from values contained in an array
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	01/09/2004
		* Parameters:		toObject     - the object containing the properties for the
		*						data object
		*					tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T. if everything went OK
		* Environment in:	the meta data table must be open or available to be opened
		*					the object may have property names matching field names in
		*						the meta data table
		* Environment out:	the meta data table is positioned to the record for the
		*						specified object and the values in fields have been
		*						changed
		*==============================================================================
		
		lparameters toObject, ;
			tcObjectName, ;
			tcObjectType
		local llReturn, ;
			lcDBC, ;
			lcObjectName, ;
			lcObjectType, ;
			lnSelect, ;
			lcFields, ;
			lnI, ;
			lcField
		with This
		
		* Ensure the meta data table is open.
		
			llReturn = .T.
			if not .OpenDBCXMeta()
				return .F.
			endif not .OpenDBCXMeta()
		
		* Get the database and object name.
		
			lcDBC        = .Parent.GetDatabase(tcObjectName)
			lcObjectName = .Parent.StripDatabase(tcObjectName)
			lcObjectType = upper(left(tcObjectType, 1))
			do case
		
		* If we don't handle this type of object, just return .T. so DBCXMgr doesn't
		* think we failed.
		
				case not lcObjectType $ This.cObjectTypesHandled
		
		* Find the object in the meta data table. If we found it, save its record
		* values.
		
				case .FindObject(lcObjectName, tcObjectType, lcDBC)
					lnSelect = select()
					select (.cDBCXAlias)
					lcFields = ''
					for lnI = 1 to fcount()
						lcField = field(lnI)
						if not inlist(lcField, 'IID', upper(.cDBCNameField), ;
							upper(.cObjectNameField), upper(.cRecTypeField))
							lcFields = lcFields + iif(empty(lcFields), '', ',') + lcField
						endif not inlist(lcField ...
					next lnI
					gather name toObject memo fields &lcFields
					replace (.cProcessField) with datetime()
					select (lnSelect)
		
		* The object wasn't found.
		
				otherwise
					.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
						tcObjectName))
					llReturn = .F.
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxsetrowprop		&& Sets all properties using the values from an array.
		*==============================================================================
		* Method:			DBCXSetRowProp
		* Status:			Public
		* Purpose:			Sets all properties from values contained in an array
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	01/09/2004
		* Parameters:		taArray      - the array containing properties and values
		*						(must be passed by reference)
		*					tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T. if everything went OK
		* Environment in:	the meta data table must be open or available to be opened
		* Environment out:	the array is populated with property names and values
		*					the meta data table is positioned to the record for the
		*						specified object
		*==============================================================================
		
		lparameters taArray, ;
			tcObjectName, ;
			tcObjectType
		local llReturn, ;
			llOneFailed, ;
			lcDBC, ;
			lcObjectName, ;
			lcObjectType, ;
			lnRows, ;
			lnSelect, ;
			laHoldValues[1], ;
			lnCounter, ;
			lcProperty, ;
			luValue, ;
			lcFieldName, ;
			lcFieldType, ;
			lcValueType
		external array taArray
		with This
		
		* Ensure the meta data table is open.
		
			llReturn = .T.
			if not .OpenDBCXMeta()
				return .F.
			endif not .OpenDBCXMeta()
		
		* Get the database and object name.
		
			lcDBC        = .Parent.GetDatabase(tcObjectName)
			lcObjectName = .Parent.StripDatabase(tcObjectName)
			lcObjectType  = upper(left(tcObjectType, 1))
			do case
		
		* If we don't handle this type of object, just return .T. so DBCXMgr doesn't
		* think we failed.
		
				case not lcObjectType $ This.cObjectTypesHandled
		
		* Find the object in the meta data table. If we found it, save its record
		* values and then process each row in the array that belongs to this manager.
		
				case .FindObject(lcObjectName, tcObjectType, lcDBC)
					lnRows   = alen(taArray, 1)
					lnSelect = select()
					select (.cDBCXAlias)
					scatter to laHoldValues memo
					for lnCounter = 1 to lnRows
						if upper(taArray[lnCounter, 1]) = upper(.Name)
							lcProperty  = taArray[lnCounter, 2]
							luValue     = taArray[lnCounter, 3]
							lcFieldName = .GetDataName(lcProperty)
							lcFieldType = type(lcFieldName)
							lcValueType = vartype(luValue)
							do case
		
		* Ensure the specified property exists. If not, we just won't handle it.
		
								case lcFieldType = 'U'
		
		* Ensure the field type and new value type match. If not, we'll undo all
		* changes.
		
								case not (lcFieldType = lcValueType or ;
									(lcFieldType = 'M' and lcValueType = 'C'))
									.Warning(strtran(ccERR_INVALID_DATA_TYPE, ;
										ccMSG_INSERT1, lcProperty))
									llOneFailed = .T.
									exit
		
		* Only update the value if it's different than the current value.
		
								case not evaluate(lcFieldName) == luValue
									replace (lcFieldName) with luValue
							endcase
						endif upper(taArray[lnCounter, 1]) = upper(.Name)
					next lnCounter
		
		* If the update failed, undo the changes.
		
					if llOneFailed
						gather from laHoldValues memo
						llReturn = .F.
					else
						replace (.cProcessField) with datetime() in (.cDBCXAlias)
					endif llOneFailed
					select (lnSelect)
		
		* The object wasn't found.
		
				otherwise
					.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
						tcObjectName))
				llReturn = .F.
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE Destroy
		*==============================================================================
		* Method:			Destroy
		* Status:			Public
		* Purpose:			Closes the database and tabls associated with the
		*						extension manager when the object is released
		* Author:			Toni M. Feltman, F1 Technologies
		*					Y. Alan Griver, Flash Creative Management
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/06/2001
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.cDBCXAlias contains the alias of the meta data table
		*						and This.cDBC contains the name of the database
		*						associated with the extension manager
		* Environment out:	the table specified in This.cDBCXAlias is closed and any
		*						database specified in This.cDBC is closed
		*					This.oError is .NULL.
		* Note:				although DBCXMgr has a private datasession and thus it
		*						wouldn't be necessary to specifically close the table,
		*						the MetaMgr subclass of DBCXMgr uses the default
		*						datasession
		*==============================================================================
		
		with This
			if not empty(.cDBC) and dbused(.cDBC)
				set database to (.cDBC)
				close database
			endif not empty(.cDBC) ...
			if used(.cDBCXAlias)
				use in (.cDBCXAlias)
			endif used(.cDBCXAlias)
			.oError = .NULL.
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE ensureoneobject		&& Ensures we have one and only one record for the object in the meta data table
		*==============================================================================
		* Method:			EnsureOneObject
		* Status:			Protected
		* Purpose:			Ensures we have one and only one record for the object in
		*						the meta data table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/09/97
		* Parameters:		tcObjectName - the name of the object without the database
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T.
		* Environment in:	see This.FindObject for environment in
		* Environment out:	if the object wasn't found in the meta data table,
		*						DBCXMgr.AddRow is called so the object is added to all
		*						extension managers
		*					see This.FindObject and DBCXMgr.AddRow for environment out
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcDBC
		with This
			if not .FindObject(tcObjectName, tcObjectType, tcDBC)
				.Parent.AddRow(tcDBC + '!' + tcObjectName, tcObjectType)
			endif not .FindObject(tcObjectName, tcObjectType, tcDBC)
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handle an error
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	03/04/2003
		* Parameters:		tnError  - the error number
		*					tcMethod - the method the error occurred in
		*					tnLine   - the line number the error occurred on
		* Returns:			.T.
		* Environment In:	This.Parent.nDataSessionID contains the "normal"
		*						datasession number for DBCXMgr
		* Environment Out:	the error may have been handled or passed to DBCXMgr or
		*						an object referenced in oError
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnDataSession, ;
			lcUMethod, ;
			lcMethod, ;
			laError[1], ;
			lcReturn, ;
			lcCurrDBC, ;
			lcDBC, ;
			lcCursor
		with This
		
		* Just in case, let's switch back to our datasession.
		
			lnDataSession = set('DATASESSION')
			if .Parent.nDataSessionID <> 0
				set datasession to .Parent.nDataSessionID
			endif .Parent.nDataSessionID <> 0
			lcUMethod = upper(tcMethod)
			lcMethod  = iif(lcUMethod = upper(.Name) + '.', tcMethod, ;
				.Name + '.' + tcMethod)
			aerror(laError)
			do case
		
		* Handle a "File is in use" error when trying to open the meta data by doing
		* nothing else.
		
				case 'OPENDBCXMETA' $ lcUMethod and inlist(tnError, cnERR_FILE_IN_USE, ;
					cnERR_ACCESS_DENIED)
					lcReturn = ccMSG_CONTINUE
		
		* Handle a "file not found" error on a DBC during Validate. First, try to close it in
		* the default data session. If it isn't there, display an error.
		
				case 'OPENCURSOR' $ lcUMethod and tnError = cnERR_FILE_NOT_FOUND and ;
					'.DBC' $ upper(laError[3]) and not empty(dbc())
					lcCurrDBC = dbc()
					lcDBC     = forcepath(laError[3], justpath(lcCurrDBC))
					if file(lcDBC)
						open database (lcDBC)
						set database to (lcCurrDBC)
						lcReturn = ccMSG_RETRY
					else
						.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, laError[3]))
						.Parent.lErrorOccurred = .T.
						lcReturn = ccMSG_CONTINUE
					endif file(lcDBC)
		
		* Handle a "file is in use" error during Validate. First, try to close it in
		* the default data session. If it isn't there, display an error.
		
				case 'OPENCURSOR' $ lcUMethod and tnError = cnERR_FILE_IN_USE
					lcCursor = strtran(.Parent.cValidateObjectName, ' ', '_')
					set datasession to 1
					if used(lcCursor)
						use in (lcCursor)
						lcReturn = ccMSG_RETRY
					else
						.Warning(strtran(ccERR_CANT_OPEN_FILE, ccMSG_INSERT1, ;
							.Parent.cValidateObjectName))
						.Parent.lErrorOccurred = .T.
						lcReturn = ccMSG_CONTINUE
					endif used(lcCursor)
		
		* Handle a "Field does not accept null values" error.
		
				case 'DBCXSETPROP' $ lcUMethod and ;
					tnError = cnERR_FIELD_NOT_ACCEPT_NULL
					lcReturn = ccMSG_CONTINUE
		
		* Pass the error on to DBCXMgr's Error method.
		
				case vartype(.Parent.oError) = 'O'
					lcReturn = .Parent.Error(tnError, lcMethod, tnLine)
		
		* We're trying to validate an invalid view, so just continue (Validate will
		* ask what to do in that case).
		
				case 'OPENCURSOR' $ lcUMethod and ;
					inlist(tnError, cnERR_BASE_FIELDS_CHANGED, ;
					cnERR_SQL_COLUMN_NOT_FOUND, cnERR_FILE_NOT_FOUND, cnERR_ODBC)
					lcReturn = ccMSG_CONTINUE
		
		* Pass the error on to DBCXMgr's Error method.
		
				otherwise
					lcReturn = .Parent.Error(tnError, lcMethod, tnLine)
			endcase
		
		* Restore the datasession and handle the return value.
		
			set datasession to lnDataSession
			do case
				case '.' $ tcMethod
					return lcReturn
				case lcReturn = ccMSG_DEBUG
					debug
					suspend
				case lcReturn = ccMSG_RETRY
					retry
				case lcReturn = ccMSG_CANCEL
					cancel
				otherwise
					return
			endcase
		endwith
		
	ENDPROC

	PROCEDURE findobject		&& Locates the specified object in the meta data table
		*==============================================================================
		* Method:			FindObject
		* Status:			Public
		* Purpose:			Locate the specified object in the meta data table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	03/05/2003
		* Parameters:		tcObjectName - the name of the object without a database
		*						prefix
		*					tcObjectType - the type of the object
		*					tcDBC        - the database the object belongs to
		* Returns:			.T. if the object was found in the meta data table
		* Environment in:	the meta data table specified in This.cDBCXTable is open
		*					This.cDBCNameField contains the name of the meta data field
		*						containing the database name
		*					This.cObjectNameField contains the name of the meta data
		*						field containing the object name
		*					the tag specified in This.cDBCXTag has a key which is the
		*						database name, the object type, and the object name,
		*						with the entire key upper-cased
		* Environment out:	the meta data table is positioned to the record for the
		*						object if the object was found or EOF if not
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcDBC
		local lcDBC, ;
			llFound
		with This
			lcDBC   = juststem(tcDBC)
			lcDBC   = iif(upper(tcObjectType) = 'DATABASE', ;
				tcObjectName, lcDBC)
			llFound = seek(upper(padr(lcDBC, fsize(.cDBCNameField, .cDBCXAlias)) + ;
				left(tcObjectType, 1) + ;
				padr(tcObjectName, fsize(.cObjectNameField, .cDBCXAlias))), ;
				.cDBCXAlias, .cDBCXTag)
		endwith
		return llFound
		
	ENDPROC

	PROTECTED PROCEDURE flagunprocessed		&& Flags all records for a given object and object type as unprocessed before validation begins
		*==============================================================================
		* Method:			FlagUnprocessed
		* Status:			Protected
		* Purpose:			Flags all records for a given object and object type as
		*						unprocessed before validation begins
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	02/09/99
		* Parameters:		tcObjectName - the name of the object without the database
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcDBC        - the database the object belongs to
		* Returns:			.T.
		* Environment in:	the meta data table for this manager must be open
		* Environment out:	the process field for every record for the specified object
		*						is blanked
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcDBC
		local lnSelect, ;	
			lcObjectField, ;
			lcObjectName, ;
			lcDBCField, ;
			lcDBCName, ;
			lcRecTypeField, ;
			lcObjectType
		with This
			lnSelect = select()
			select (.cDBCXAlias)
			lcObjectField  = .cObjectNameField
			lcObjectName   = lower(padr(tcObjectName, fsize(lcObjectField, ;
				.cDBCXAlias)))
			lcDBCField     = .cDBCNameField
			lcDBCName      = lower(padr(tcDBC, fsize(lcDBCField, .cDBCXAlias)))
			lcRecTypeField = .cRecTypeField
			lcObjectType   = upper(left(tcObjectType, 1))
			blank fields (.cProcessField) ;
				for lower(&lcObjectField) == lcObjectName and ;
				&lcRecTypeField = lcObjectType and lower(&lcDBCField) == lcDBCName
			do case
		
		* For databases, blank most of the records for this database (we'll ignore
		* user-defined objects).
		
				case lcObjectType = 'D'
					blank fields (.cProcessField) for ;
						lower(&lcDBCField) == lcDBCName and &lcRecTypeField <> 'U'
		
		* For tables and views, blank all field and index records for this table or
		* view.
		
				case lcObjectType $ 'TV'
					blank fields (.cProcessField) for ;
						lower(&lcObjectField) = alltrim(lcObjectName) + '.' and ;
						inlist(&lcRecTypeField, 'F', 'I') and ;
						lower(&lcDBCField) == lcDBCName
			endcase
			select (lnSelect)
		endwith
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE getdataname		&& Returns the field name in the extension table for a given property
		*==============================================================================
		* Method:			GetDataName
		* Status:			Protected
		* Purpose:			Returns the field name in the extension table for a given
		*						property
		* Author:			Y. Alan Griver, Flash Creative Management
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/23/97
		* Parameters:		tcProperty - the name of the property
		* Returns:			the actual name of the data item associated with the
		*						property
		* Environment in:	This.cPrefix contains the property prefix used by this
		*						manager
		* Environment out:	none
		*==============================================================================
		
		lparameters tcProperty
		local lcPrefix, ;
			lnLen, ;
			lcReturn
		lcPrefix = upper(alltrim(This.cPrefix))
		lnLen    = len(lcPrefix)
		do case
			case empty(lcPrefix)
				lcReturn = tcProperty
			case upper(left(tcProperty, lnLen)) = lcPrefix
				lcReturn = substr(tcProperty, lnLen + 1)
			otherwise
				lcReturn = tcProperty
		endcase
		return lcReturn
		
	ENDPROC

	PROCEDURE getmergedata		&& Retrieves data for a specific database and adds the result to a pass object representing an XMLAdapter.
		*==============================================================================
		* Method:			GetMergeData
		* Purpose:			Retrieves data for a specific database and adds the result 
		*					to a pass object representing an XMLAdapter.
		* Author:			Toni M. Feltman, F1 Technologies
		* Parameters:		tcDBC, The DBC to generate XML data for.
		*					toXMLAdapter, The XML Adapter object.
		* Returns:			Logical, True if the data is added. Otherwise false.
		* Added:			08/18/2004
		*==============================================================================
		LPARAMETERS ;
			tcDBC, ;
			toXMLAdapter
		
		LOCAL ;
			lcDBC AS Character, ; 
			lcDBCField AS Character, ;
			llReturn AS Logical 
		
		lcDBC = LOWER(ALLTRIM(tcDBC))
		llReturn = .F.
		
		WITH This
			if not .OpenDBCXMeta()
				return llReturn
			endif not .OpenDBCXMeta()
		
			llReturn = .T.
			lcDBCField = .cDBCNameField 
		
			SELECT * ;
			FROM ;
				(.cDBCXAlias) ;
			WHERE ;
				LOWER(&lcDBCField) == lcDBC ;
			INTO CURSOR ;
				(.cDBCXMergeAlias)
				
			IF _TALLY > 0
				toXMLAdapter.AddTableSchema(.cDBCXMergeAlias)
			ENDIF
			
		ENDWITH
		
		RETURN llReturn
	ENDPROC

	PROTECTED PROCEDURE getobjectname		&& Returns the object name from the DBC based on the format of the tcObject parameter.
		*==============================================================================
		* Method:			GetObjectName
		* Status:			Protected
		* Purpose:			Strips any alias and database off an object name
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/03/97
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		* Returns:			the object name without an alias or database name (in the
		*						case of relations, it returns <child alias>.<tag>)
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcObjectName
		local lcReturn
		do case
			case ',' $ tcObjectName
				lcReturn = alltrim(substr(tcObjectName, at(',', tcObjectName) + 1))
			case '.' $ tcObjectName
				lcReturn = alltrim(substr(tcObjectName, at('.', tcObjectName) + 1))
			case '!' $ tcObjectName
				lcReturn = alltrim(substr(tcObjectName, at('!', tcObjectName) + 1))
			otherwise
				lcReturn = alltrim(tcObjectName)
		endcase
		lcReturn = lower(lcReturn)
		return lcReturn
		
	ENDPROC

	PROTECTED PROCEDURE getparentname		&& Returns the parent object name from the DBC based on the format of the tcObject parameter.
		*==============================================================================
		* Method:			GetParentName
		* Status:			Protected
		* Purpose:			Returns the parent object name
		* Author:			W. Michael Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName - the name of the object
		* Returns:			the parent name of the object
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcObjectName
		local lcReturn
		do case
			case vartype(tcObjectName) <> 'C'
				lcReturn = ''
			case '.' $ upper(tcObjectName)
				lcReturn = alltrim(left(tcObjectName, at('.', tcObjectName) - 1))
			case ',' $ upper(tcObjectName)
				lcReturn = alltrim(left(tcObjectName, at(',', tcObjectName) - 1))
			otherwise
				lcReturn = alltrim(tcObjectName)
		endcase
		lcReturn = lower(lcReturn)
		return lcReturn
		
	ENDPROC

	PROTECTED PROCEDURE getpropertyname		&& Returns the property name for a given field in the meta data table
		*==============================================================================
		* Method:			GetPropertyName
		* Status:			Protected
		* Purpose:			Returns the property name for a given field in the meta
		*						data table
		* Author:			Y. Alan Griver, Flash Creative Management
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/23/97
		* Parameters:		tcDataName - the name of the field in the meta data table
		* Returns:			the field name prefixed by This.cPrefix
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcDataName
		local lcPrefix, ;
			lnLen, ;
			lcReturn
		lcPrefix = upper(alltrim(This.cPrefix))
		lnLen    = len(lcPrefix)
		lcReturn = iif(empty(lcPrefix) or upper(left(tcDataName, lnLen)) = lcPrefix, ;
			'', lcPrefix) + alltrim(tcDataName)
		return lcReturn
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			If the cDBCXTable property hasn't been filled in, use the
		*						alias
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	05/24/2001
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.cDBCXAlias contains the alias of the meta data table
		* Environment out:	if This.cDBCXTable was empty, it contains This.cDBCXAlias
		*						with a DBF extension
		*==============================================================================
		
		with This
			if empty(.cDBCXTable)
				.cDBCXTable = forceext(.cDBCXAlias, 'DBF')
			endif empty(.cDBCXTable)
		endwith
		
	ENDPROC

	PROCEDURE insertmergedata		&& Inserts a new record in the metadata table based on data in a merge table.
		*==============================================================================
		* Method:			InsertMergeData
		* Purpose:			Inserts a new record in the metadata table based on data 
		*					in a merge table.
		* Author:			Toni M. Feltman, F1 Technologies
		* Last revision:	03/26/2007
		* Parameters:		toData, A SCATTER NAME object with the data to insert.
		* Returns:			None
		* Added:			08/19/2004
		*==============================================================================
		LPARAMETERS ;
			toData
		local lnSelect
		lnSelect = select()
		select (This.cDBCXAlias)
		append blank
		gather name toData memo
		select (lnSelect)
		
	ENDPROC

	PROCEDURE isprocessed		&& Returns .T. if the current object was validated by this manager
		*==============================================================================
		* Method:			IsProcessed
		* Status:			Public
		* Purpose:			Returns .T. if the current object was validated by this
		*						manager
		* Author:			Toni M. Feltman, F1 Technologies
		* Last revision:	02/12/99
		* Parameters:		none
		* Returns:			returns .T. if the current object has been validated
		* Environment in:	the meta data table for this manager is in use and
		*						positioned to the desired record
		* Environment out:	none
		*==============================================================================
		
		return not empty(evaluate(This.cDBCXAlias + '.' + This.cProcessField))
		
	ENDPROC

	PROCEDURE loadmetadatafromobject		&& Updates metadata from an XMLAdapter object.
		*==============================================================================
		* Method:			LoadMetadataFromObject
		* Purpose:			Updates metadata from an XMLAdapter object.
		* Author:			Toni M. Feltman, F1 Technologies
		* Parameters:		toXMLAdapter, An object reference to the XML adapter object.
		* Returns:			None
		* Added:			08/18/2004
		*==============================================================================
		LPARAMETERS ;
			toXMLAdapter
		
		LOCAL ;
			llReturn AS Logical, ;
			lcDBCXMergeAlias AS Character, ;
			loTable AS XMLTable 
			
		llReturn = .F.
		
		WITH This
			if not .OpenDBCXMeta()
				return llReturn
			endif not .OpenDBCXMeta()
			
			llReturn = .T.
			lcDBCXMergeAlias = UPPER(.cDBCXMergeAlias )
			
			FOR EACH loTable IN toXMLAdapter.Tables
				
				IF UPPER(loTable.Alias) = lcDBCXMergeAlias 		&& The cursor we are looking for.
					loTable.ToCursor()
					.ProcessMergeData()
					.CloseMergeCursors()
					.DBCXRemoveOrphan()
					.DBCXPackMeta()
					.Parent.cCurrentDBC = []
				ENDIF
		
			ENDFOR
			
		ENDWITH
		
		RETURN llReturn
	ENDPROC

	PROTECTED PROCEDURE opencursor		&& Opens a table or view
		*==============================================================================
		* Method:			OpenCursor
		* Status:			Protected
		* Purpose:			Opens a table or view
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/30/2001
		* Parameters:		tcName  - the name (and possibly path) of the table or view
		*					tcAlias - the alias that should be used (optional: if it
		*						isn't specified, the default alias is used)
		* Returns:			.T. if the table or view is open
		* Environment in:	the table or view is open or available to be opened
		* Environment out:	the table or view is opened in the current workarea with
		*						the specified or default alias; in the case of a view,
		*						it's opened NODATA, and any tables involved in the view
		*						are also opened
		*==============================================================================
		
		lparameter tcName, ;
			tcAlias
		local lcAlias, ;
			lcName, ;
			lcFullpath
		
		* Use either the passed or a default alias (the same as tcName with spaces
		* changed to underscores).
		
		if pcount() = 2
			lcAlias = tcAlias
		else
			lcAlias = strtran(juststem(tcName), ' ', '_')
		endif pcount() = 2
		lcName = upper(tcName)
		lcName = lcName + iif(rat('.', lcName) = 0, '.DBF', '')
		
		* Ensure FULLPATH is on.
		
		lcFullPath = set('FULLPATH')
		set fullpath on
		do case
		
		* If the alias is already open, select it.
		
			case used(lcAlias)
				select (lcAlias)
		
		* Open a view.
		
			case not empty(dbc()) and indbc(tcName, 'View')
				select 0
				use (tcName) again alias (lcAlias) shared nodata
		
		* Open a table.
		
			case not empty(dbc()) and indbc(tcName, 'Table') and ;
				file(fullpath(dbgetprop(tcName, 'Table', 'Path'), dbc()))
				select 0
				use (tcName) again alias (lcAlias) shared
		
		* The table is a free table and it exists.
		
			case file(lcName)
				select 0
				use (lcName) again alias (lcAlias) shared
		endcase
		
		* Clean up and return.
		
		if lcFullPath = 'OFF'
			set fullpath off
		endif lcFullPath = 'OFF'
		return used(lcAlias)
		
	ENDPROC

	PROCEDURE opendbcxmeta		&& Opens the meta data table
		*==============================================================================
		* Method:			OpenDBCXMeta
		* Status:			Public
		* Purpose:			Opens the meta data table
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	05/24/2001
		* Parameters:		tlExclusive - .T. to open the table exclusively
		* Returns:			.T. if the meta data table is open
		* Environment in:	the meta data table must be open or available to be opened
		* Environment out:	the meta data table is open
		*==============================================================================
		
		lparameters tlExclusive
		local lcDBCXTable, ;
			llReturn, ;
			lcMode
		with This
			lcDBCXTable = .Parent.cRegistryPath + .cDBCXTable
			do case
		
		* If the alias is already in use, do nothing.
		
				case used(.cDBCXAlias)
		
		* If the file doesn't exist, give an error.
		
				case not file(lcDBCXTable)
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, lcDBCXTable))
		
		* Open the meta data table.
		
				otherwise
					lcMode = iif(tlExclusive, 'exclusive', 'shared')
					use (lcDBCXTable) alias (.cDBCXAlias) again in 0 &lcMode
					if used(.cDBCXAlias) and ;
						cursorgetprop('Buffering', .cDBCXAlias) > 1
						cursorsetprop('Buffering', 1, .cDBCXAlias)
					endif used(.cDBCXAlias) ...
			endcase
		
		* Flag if the table is open or not.
		
			llReturn = used(.cDBCXAlias)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE processmergedata		&& Processes the merge data cursor.
		*==============================================================================
		* Method:			ProcessMergeData
		* Purpose:			Processes the merge data cursor.
		* Author:			Toni M. Feltman, F1 Technologies
		* Parameters:		None
		* Returns:			None
		* Added:			08/19/2004
		*==============================================================================
		LOCAL ;
			lcDBC AS Character
			
		LOCAL ;
			lnSelect
		
		lnSelect = SELECT()
		
		WITH This
			SELECT (.cDBCXMergeAlias)
			GO TOP
			lcDBC = EVALUATE(.cDBCNameField)
			.Parent.cCurrentDBC = lcDBC
			* Call FlagUnprocessed for the DBC in the first record in the merge cursor.
			.FlagUnProcessed(lcDBC, [DATABASE], lcDBC)
		
			* SCAN the merge cursor 
			SELECT (.cDBCXMergeAlias)
		
			SCAN
				* Update the process field with datetime.	
				REPLACE (.cProcessField) with DATETIME() in (.cDBCXMergeAlias)
				* Copy the current record to an object.
				SCATTER MEMO NAME loValues
				.InsertMergeData(loValues)
			ENDSCAN
			
			SELECT (lnSelect)
		
		ENDWITH
		
		
		
		
	ENDPROC

	PROCEDURE showui		&& Displays the user interface for this manager in the DBCXMgr form
		*==============================================================================
		* Method:			ShowUI
		* Status:			Public
		* Purpose:			Displays the user interface for this manager in the DBCXMgr
		*						form
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/06/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.lUICreated is .T.
		* Note:				Each manager must implement its own technique of displaying
		*						a user interface. It should not do anything if
		*						This.lUICreated is already .T. and it should set it to
		*						.T. once it's done
		*==============================================================================
		
		This.lUICreated = .T.
		
	ENDPROC

	PROCEDURE validate		&& Validates the extension information to the DBC
		*==============================================================================
		* Method:			Validate
		* Status:			Public
		* Purpose:			Validates the specified object
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	03/04/2003
		* Parameters:		tcObjectName - the name of the object without the database
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcDBC        - the database the object belongs to
		* Returns:			.T. if the object could be validated or if the user wants
		*						to continue validation anyway
		* Environment in:	This.cObjectTypesHandled contains the first letter of each
		*						object type the manager will validate
		*					This.Parent.lCloseAfterValidate indicates whether we're
		*						supposed to close any cursors we opened
		* Environment out:	a record may have been added to the meta data for the
		*						object
		*					the object's record was updated
		*					This.lValidateObject is .T if the object was validated
		*					if This.Parent.lCloseAfterValidate is .F., any cursors we
		*						opened are left open (except the view if we validated
		*						a view)
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcDBC
		local llReturn, ;
			lcPath, ;
			lcObject, ;
			lcParent, ;
			lcAlias, ;
			lcDBC, ;
			llFree, ;
			laUsed[1], ;
			lnI, ;
			lcField, ;
			lcIndex, ;
			laTags[1], ;
			lnTags, ;
			lcObjectName
		with This
		
		* Ensure the meta data table is open.
		
			if not .OpenDBCXMeta()
				return llReturn
			endif not .OpenDBCXMeta()
		
		* Get the alias for the object and convert it to a name VFP will use. Get the
		* name of the database and flag if the object is "free" or not.
			
			llReturn = .T.
			lcPath   = iif(inlist(tcObjectType, 'Table', 'View'), tcObjectName, ;
				.GetObjectName(tcObjectName))
			lcObject = juststem(lcPath)
			lcParent = iif(inlist(tcObjectType, 'Table', 'View'), lcObject, ;
				.GetParentName(tcObjectName))
			lcAlias  = strtran(lcParent, ' ', '_')
			lcDBC    = juststem(tcDBC)
			llFree   = empty(lcDBC)
			.lValidateObject = .T.
		
		* Get a snapshot of open tables in case we need to close things at the end.
		
			if .Parent.lCloseAfterValidate
				aused(laUsed)
			endif .Parent.lCloseAfterValidate
			do case
		
		* Validate a table: try to open the table, then validate it and all its fields
		* and indexes.
		
				case tcObjectType = 'Table' and 'T' $ This.cObjectTypesHandled
					llReturn = .OpenCursor(lcPath)
					if llReturn
						.FlagUnprocessed(lcObject, tcObjectType, lcDBC)
						.EnsureOneObject(lcObject, tcObjectType, lcDBC)
						.ValidateTable(lcObject, lcAlias, llFree)
		
		* Validate all the fields for the table.
		
						if 'F' $ This.cObjectTypesHandled
							for lnI = 1 to fcount(lcAlias)
								lcField = field(lnI, lcAlias)
								.EnsureOneObject(lcParent + '.' + lcField, 'Field', ;
									lcDBC)
								.ValidateField(lcParent, lcAlias, lcField, llFree)
							next lnI
						endif 'F' $ This.cObjectTypesHandled
		
		* Validate all the indexes for the table.
		
						if 'I' $ This.cObjectTypesHandled
							for lnI = 1 to tagcount('', lcAlias)
								lcIndex = tag('', lnI, lcAlias)
								.EnsureOneObject(lcParent + '.' + lcIndex, 'Index', ;
									lcDBC)
								.ValidateIndex(lcParent, lcAlias, lcIndex, llFree)
							next lnI
						endif 'I' $ This.cObjectTypesHandled
		
		* We couldn't open the table.
		
					else
						llReturn = messagebox(strtran(ccERR_CANT_VALIDATE, ;
							ccMSG_INSERT1, lcPath), MB_YESNO + MB_ICONSTOP, ;
							.Parent.cCaption) = IDYES
						.lValidateObject = .F.
					endif llReturn
		
		* Validate a view: try to open the view, then validate it and all its fields.
		
				case tcObjectType = 'View' and 'V' $ This.cObjectTypesHandled
					llReturn = .OpenCursor(lcObject)
					if llReturn
						.FlagUnprocessed(lcObject, tcObjectType, lcDBC)
						.EnsureOneObject(lcObject, tcObjectType, lcDBC)
						.ValidateView(lcObject, lcAlias)
		
		* Validate all the fields for the view.
		
						if 'F' $ This.cObjectTypesHandled
							for lnI = 1 to fcount(lcAlias)
								lcField = field(lnI, lcAlias)
								.EnsureOneObject(lcParent + '.' + lcField, 'Field', ;
									lcDBC)
								.ValidateField(lcParent, lcAlias, lcField, .F.)
							next lnI
						endif 'F' $ This.cObjectTypesHandled
		
		* Validate all the indexes for the view.
		
						if 'I' $ This.cObjectTypesHandled
							lnTags = .Parent.DBCXGetAllObjects('Index ' + lcParent, ;
								@laTags)
							for lnI = 1 to lnTags
								lcIndex = .GetObjectName(laTags[lnI])
								.FindObject(lcParent + '.' + lcIndex, 'Index', lcDBC)
								.ValidateViewIndex(lcParent, lcAlias, lcIndex)
							next lnI
						endif 'I' $ This.cObjectTypesHandled
		
		* We couldn't open the view.
		
					else
						llReturn = messagebox(strtran(ccERR_CANT_VALIDATE, ;
							ccMSG_INSERT1, lcObject), MB_YESNO + MB_ICONSTOP, ;
							.Parent.cCaption) = IDYES
						.lValidateObject = .F.
					endif llReturn
		
		* Validate fields.
		
				case tcObjectType = 'Field' and 'F' $ This.cObjectTypesHandled
					llReturn = .OpenCursor(lcParent)
					if llReturn
						.EnsureOneObject(tcObjectName, tcObjectType, lcDBC)
						.ValidateField(lcParent, lcAlias, lcObject, llFree)
		
		* We couldn't open the cursor.
		
					else
						llReturn = messagebox(strtran(ccERR_CANT_VALIDATE, ;
							ccMSG_INSERT1, lcParent), MB_YESNO + MB_ICONSTOP, ;
							.Parent.cCaption) = IDYES
						.lValidateObject = .F.
					endif llReturn
		
		* Validate indexes.
		
				case tcObjectType = 'Index' and 'I' $ This.cObjectTypesHandled
					llReturn = .OpenCursor(lcParent)
					if llReturn
						.EnsureOneObject(tcObjectName, tcObjectType, lcDBC)
						.ValidateIndex(lcParent, lcAlias, lcObject, llFree)
		
		* We couldn't open the table.
		
					else
						llReturn = messagebox(strtran(ccERR_CANT_VALIDATE, ;
							ccMSG_INSERT1, lcParent), MB_YESNO + MB_ICONSTOP, ;
							.Parent.cCaption) = IDYES
						.lValidateObject = .F.
					endif llReturn
		
		* Validate databases.
		
				case tcObjectType = 'Database' and 'D' $ This.cObjectTypesHandled
					lcObjectName = juststem(tcObjectName)
					.FlagUnprocessed(lcObjectName, tcObjectType, lcDBC)
					.EnsureOneObject(lcObjectName, tcObjectType, lcDBC)
					.ValidateDatabase(lcObjectName)
		
		* Validate connections.
		
				case tcObjectType = 'Connection' and 'C' $ This.cObjectTypesHandled
					.FlagUnprocessed(tcObjectName, tcObjectType, lcDBC)
					.EnsureOneObject(tcObjectName, tcObjectType, lcDBC)
					.ValidateConnection(tcObjectName)
		
		* Validate relations.
		
				case tcObjectType = 'Relation' and 'R' $ This.cObjectTypesHandled
					.FlagUnprocessed(tcObjectName, tcObjectType, lcDBC)
					.EnsureOneObject(tcObjectName, tcObjectType, lcDBC)
					.ValidateRelation(tcObjectName)
			endcase
		
		* Close any tables and views we opened if necessary.
		
			do case
				case .Parent.lCloseAfterValidate
					.Parent.CloseOpenedCursors(@laUsed)
				case tcObjectType = 'View' and used(lcAlias)
					use in (lcAlias)
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE validateconnection		&& Validates a connection
		*==============================================================================
		* Method:			ValidateConnection
		* Status:			Protected
		* Purpose:			Validates the specified connection
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/08/97
		* Parameters:		tcObjectName - the name of the connection
		* Returns:			.T. if the validation succeeded
		* Environment in:	the manager's meta data table is positioned to the record
		*						for the connection
		* Environment out:	specific to each manager
		* Note:				each manager must implement its own technique of validating
		*						the object
		*==============================================================================
		
		lparameters tcObjectName
		replace (This.cProcessField) with datetime() in (This.cDBCXAlias)
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE validatedatabase		&& Validates a database
		*==============================================================================
		* Method:			ValidateDatabase
		* Status:			Protected
		* Purpose:			Validates the specified database
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/08/97
		* Parameters:		tcObjectName - the database name
		* Returns:			.T. if the validation succeeded
		* Environment in:	the manager's meta data table is positioned to the record
		*						for the database
		* Environment out:	specific to each manager
		* Note:				each manager must implement its own technique of validating
		*						the object
		*==============================================================================
		
		lparameters tcObjectName
		replace (This.cProcessField) with datetime() in (This.cDBCXAlias)
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE validatefield		&& Validates a field
		*==============================================================================
		* Method:			ValidateField
		* Status:			Protected
		* Purpose:			Validates the specified field
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/08/97
		* Parameters:		tcParent - the name of the parent table
		*					tcAlias  - the alias the table is open with
		*					tcField  - the name of the field
		*					tlFree   - .T. if the table is free
		* Returns:			.T. if the validation succeeded
		* Environment in:	the table is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the field
		* Environment out:	specific to each manager
		* Note:				each manager must implement its own technique of validating
		*						the object
		*==============================================================================
		
		lparameters tcParent, ;
			tcAlias, ;
			tcField, ;
			tlFree
		replace (This.cProcessField) with datetime() in (This.cDBCXAlias)
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE validateindex		&& Validates an index
		*==============================================================================
		* Method:			ValidateIndex
		* Status:			Protected
		* Purpose:			Validates the specified index
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	07/21/98
		* Parameters:		tcParent - the name of the parent table
		*					tcAlias  - the alias the table is open with
		*					tcIndex  - the tag name
		*					tlFree   - .T. if the table is free
		* Returns:			.T. if the validation succeeded
		* Environment in:	the table is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the index
		* Environment out:	specific to each manager
		* Note:				each manager must implement its	own technique of validating
		*						the object
		*==============================================================================
		
		lparameters tcParent, ;
			tcAlias, ;
			tcIndex, ;
			tlFree
		replace (This.cProcessField) with datetime() in (This.cDBCXAlias)
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE validaterelation		&& Validates a relation
		*==============================================================================
		* Method:			ValidateRelation
		* Status:			Protected
		* Purpose:			Validates the specified relation
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/08/97
		* Parameters:		tcObjectName - the name of the relation:
		*						<parent alias>.<tag>,<child alias>.<tag>
		* Returns:			.T. if the validation succeeded
		* Environment in:	the manager's meta data table is positioned to the record
		*						for the relation
		* Environment out:	specific to each manager
		* Note:				each manager must implement its own technique of validating
		*						the object
		*==============================================================================
		
		lparameters tcObjectName
		replace (This.cProcessField) with datetime() in (This.cDBCXAlias)
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE validatetable		&& Validates a table
		*==============================================================================
		* Method:			ValidateTable
		* Status:			Protected
		* Purpose:			Validates the specified table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/08/97
		* Parameters:		tcObjectName - the name of the table
		*					tcAlias      - the alias the table is open with
		*					tlFree       - .T. if the table is free
		* Returns:			.T. if the validation succeeded
		* Environment in:	the table is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the table
		* Environment out:	specific to each manager
		* Note:				each manager must implement its own technique of validating
		*						the object
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcAlias, ;
			tlFree
		replace (This.cProcessField) with datetime() in (This.cDBCXAlias)
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE validateview		&& Validates a view
		*==============================================================================
		* Method:			ValidateView
		* Status:			Protected
		* Purpose:			Validates the specified view
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/08/97
		* Parameters:		tcObjectName - the name of the view
		*					tcAlias      - the alias the view is open with
		* Returns:			.T. if the validation succeeded
		* Environment in:	the view is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the view
		* Environment out:	specific to each manager
		* Note:				each manager must implement its own technique of validating
		*						the object
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcAlias
		replace (This.cProcessField) with datetime() in (This.cDBCXAlias)
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE validateviewindex		&& Validates a view index
		*==============================================================================
		* Method:			ValidateViewIndex
		* Status:			Protected
		* Purpose:			Validates the specified view index
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcParent - the name of the view
		*					tcAlias  - the alias the view is open with
		*					tcIndex  - the tag name
		* Returns:			.T. if the validation succeeded
		* Environment in:	the view is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the index
		* Environment out:	if the CoreMgr validated the view index, so does this
		*						manager (a manager could implement its own technique of
		*						validating the object if desired)
		*==============================================================================
		
		lparameters tcParent, ;
			tcAlias, ;
			tcIndex
		local llReturn, ;
			lcDBC
		with This
			lcDBC = evaluate(.cDBCXAlias + '.' + .cDBCNameField)
			if type('.Parent.oCoreMgr.Name') = 'C' and ;
				.Parent.oCoreMgr.FindObject(tcParent + '.' + tcIndex, 'Index', ;
				lcDBC) and .Parent.oCoreMgr.IsProcessed()
				replace (.cProcessField) with datetime() in (.cDBCXAlias)
				llReturn = .T.
			endif type('.Parent.oCoreMgr.Name') = 'C' ...
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE warning		&& Displays an error message
		*==============================================================================
		* Method:			Warning
		* Status:			Protected
		* Purpose:			Displays an error message
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/19/2002
		* Parameters:		tcMessage   - the message to display
		*					tcMethod    - the method in which the warning occurred
		*						(optional: if it isn't specified, the calling stack is
		*						examined to find the name of the calling routine)
		*					tcOtherInfo - additional information for the error array
		*						(optional)
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the message was displayed
		*==============================================================================
		
		lparameters tcMessage, ;
			tcMethod, ;
			tcOtherInfo
		This.Parent.Warning(tcMessage, tcMethod, tcOtherInfo)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS coremgr AS basemgr OF "dbcxmgr.vcx" 		&& Core DBCX Properties Manager
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "dbcxmgr.h"
	*<DefinedPropArrayMethod>
		*p: lindexerror		&& .T. if an error occurred validating an index
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lindexerror
	cdbcnamefield = cDBCName
	cdbcxalias = CoreMeta
	cobjectnamefield = cObjectNam
	cobjecttypeshandled = DTVCRFIU
	cprefix = CB
	cprocessfield = tLastMod
	cproductname = Core Manager
	crectypefield = cRecType
	cversion = 2005.02.14
	lindexerror = .F.		&& .T. if an error occurred validating an index
	Name = "coremgr"
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addrow
		*==============================================================================
		* Method:			AddRow
		* Status:			Public
		* Purpose:			Adds a record to the meta data table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/30/2001
		* Parameters:		tiID         - the DBCX ID for the new record
		*					tcDBC        - the database the object belongs to
		*					tcObjectName - the name of the object without the database
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T.
		* Environment in:	the meta data table for this manager must be open
		* Environment out:	if a record for the specified object doesn't already exist,
		*						one is created
		*==============================================================================
		
		lparameters tiID, ;
			tcDBC, ;
			tcObjectName, ;
			tcObjectType
		local lcDBC, ;
			lcObjectType, ;
			lcCaption
		with This
			lcDBC = lower(juststem(tcDBC))
			lcObjectType = left(tcObjectType, 1)
			if lcObjectType $ This.cObjectTypesHandled and ;
				not .FindObject(tcObjectName, tcObjectType, tcDBC)
				insert into (.cDBCXAlias) ;
						(iID, ;
						cObjectNam, ;
						cRecType, ;
						cDBCName, ;
						tLastMod) ;
					values ;
						(tiID, ;
						lower(tcObjectName) , ;
						tcObjectType, ;
						lcDBC, ;
						datetime())
				if lcObjectType <> 'F' or empty(lcDBC)
					lcCaption = proper(strtran(.GetObjectName(tcObjectName), '_', ' '))
					replace cCaption with lcCaption in (.cDBCXAlias)
				endif lcObjectType <> 'F' ...
			endif lcObjectType ...
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE checkdbcxmeta
		*==============================================================================
		* Method:			CheckDBCXMeta
		* Status:			Public
		* Purpose:			Check the DBCX meta table structure to see if it needs to
		*						be converted to a new format
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	10/29/2002
		* Parameters:		none
		* Returns:			.T. if the structure needs to be converted
		* Environment in:	the DBCX registry table must be open
		* Environment out:	the DBCX registry table is positioned to the Codebook
		*						record if there is one
		*==============================================================================
		
		return seek('CODEBOOK', This.Parent.cRegistryName, 'cProdName') or ;
			(This.OpenDBCXMeta() and type(This.cDBCXAlias + '.nStepValue') = 'U')
		
	ENDPROC

	PROCEDURE convertdbcxmeta
		*==============================================================================
		* Method:			ConvertDBCXMeta
		* Status:			Public
		* Purpose:			Converts the DBCX meta table to a new structure
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	05/22/2003
		* Parameters:		none
		* Returns:			.T. if it succeeded
		* Environment in:	the DBCX registry table must be open
		* Environment out:	CoreMeta is populated with records in CDBKMETA
		*					if a Codebook record was found in the DBCX registry table,
		*						it's removed and the Codebook manager disabled
		*==============================================================================
		
		local llSuccess, ;
			lnSelect, ;
			lnI, ;
			lcField, ;
			mPath, ;
			mFormat, ;
			cCaption, ;
			cObjectNam, ;
			lnRow, ;
			lnManagers
		with This
		
		* See if the structure needed to be converted. If so, display a message and
		* open our meta data table exclusively.
		
			llSuccess = .T.
			if .CheckDBCXMeta()
				if used(.cDBCXAlias)
					use in (.cDBCXAlias)
				endif used(.cDBCXAlias)
				llSuccess = .OpenDBCXMeta(.T.)
				do case
		
		* We couldn't open our meta data table exclusively.
		
					case not llSuccess
		
		* If the nNextValue field is missing, add it and nStepValue.
		
					case type(.cDBCXAlias + '.nNextValue') = 'U'
						wait window strtran(ccMSG_CONVERTING, ccMSG_INSERT1, ;
							.cDBCXAlias) nowait
						alter table (.cDBCXAlias) add column nStepValue I add column nNextValue I
		
		* If we're supposed to update from an existing CDBKMETA, do so.
		
					case file(.Parent.cRegistryPath + 'CDBKMETA.DBF')
						wait window strtran(ccMSG_CONVERTING, ccMSG_INSERT1, ;
							'CDBKMETA') nowait
						lnSelect = select()
						select 0
						use (.Parent.cRegistryPath + 'CDBKMETA') shared again
		
		* Declare a local variable for each field in CDBKMETA.
		
						for lnI = 1 to fcount()
							lcField = field(lnI)
							local &lcField
						next lnI
		
		* Process each record in CDBKMETA and update certain fields in CoreMeta.
		
						scan
							scatter memvar memo
							mPath    = ''
							mFormat  = ''
							cCaption = ''
							cCursor  = lower(alltrim(cCursor))
							cTagName = lower(alltrim(cTagName))
							cTagName = iif(M.cTagName = M.cCursor + '.', ;
								substr(M.cTagName, at('.', M.cTagName) + 1), ;
								M.cTagName)
							cDBCName = lower(cDBCName)
							do case
								case empty(cRecType)
									loop
								case cRecType = 'D'
									cObjectNam = lower(cDBCName)
									cCaption   = proper(strtran(alltrim(cDBCName), ;
										'_', ' '))
								case cRecType = 'J'
									cRecType   = 'R'
									cObjectNam = lower(M.cCursor + '.' + mParntExpr + ;
										',' + alltrim(cChildTbl) + '.' + mChildExpr)
								case cRecType = 'C' and cType = 'V'
									cRecType   = 'V'
									cObjectNam = M.cCursor
									cCaption   = proper(strtran(M.cCursor, '_', ' '))
									cType      = ''
								case cRecType = 'C' and (cType = 'T' or empty(cType))
									cRecType   = 'T'
									cObjectNam = M.cCursor
									cCaption   = proper(strtran(M.cCursor, '_', ' '))
									cType      = ''
								case cRecType = 'F'
									cObjectNam = M.cCursor + '.' + lower(cField)
									mFormat    = mInFormat
								case cRecType = 'I'
									cObjectNam = M.cCursor + '.' + M.cTagName
									cCaption   = proper(strtran(M.cTagName, '_', ' '))
							endcase
							insert into (.cDBCXAlias) from memvar
						endscan
						use
						select (lnSelect)
		
		* Unregister CdbkMgr in DBCXREG.DBF.
		
						.Parent.UnRegisterManager('Codebook')
				endcase
		
		* Reopen our meta data table in shared mode.
		
				if llSuccess
					use in (.cDBCXAlias)
					.OpenDBCXMeta()
				endif llSuccess
				wait clear
			endif .CheckDBCXMeta()
		endwith
		return llSuccess
		
	ENDPROC

	PROCEDURE createdbcxmeta
		*==============================================================================
		* Method:			CreateDBCXMeta
		* Status:			Public
		* Purpose:			Creates the meta data table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	03/03/2003
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	DBCXMgr.cRegistryPath contains the path where the table
		*						should be created, This.cDBCXTable contains the table
		*						name, and This.cDBCXAlias contains the alias
		* Environment out:	the meta data table was created
		*==============================================================================
		
		local lcFile, ;
			lcCollate
		with This
			lcFile = .Parent.cRegistryPath + .cDBCXTable
			if not file(lcFile)
				create table (lcFile) free ;
					(IID I, ;
					CDBCNAME C(119), ;
					CRECTYPE C(1), ;
					COBJECTNAM C(120), ;
					MPATH M, ;
					NCODEPAGE N(5), ;
					NBLOCKSIZE N(5), ;
					CCAPTION C(128), ;
					MTAGFILTER M, ;
					MTAGEXPR M, ;
					CTAGTYPE C(1), ;
					CCOLLATE C(10), ;
					LASCENDING L, ;
					MEXPR M, ;
					NFIELD N(3), ;
					CTYPE C(1), ;
					LBINARY L, ;
					NSIZE N(3), ;
					NDECIMALS N(3), ;
					LNULL L, ;
					MFORMAT M, ;
					MINPUTMASK M, ;
					NSTEPVALUE I, ;
					NNEXTVALUE I, ;
					MNOTES M, ;
					MCOMMENT M, ;
					TLASTMOD T)
				lcCollate = set('COLLATE')
				set collate to 'MACHINE'
				index on iID tag iID
				index on deleted() tag Deleted
				index on upper(cDBCName + cRecType + cObjectNam) tag ObjectName
				if not empty(lcCollate)
					set collate to lcCollate
				endif not empty(lcCollate)
				use
			endif not file(lcFile)
			use (lcFile) shared again alias (.cDBCXAlias) in 0
			if cursorgetprop('Buffering', .cDBCXAlias) > 1
				cursorsetprop('Buffering', 1, .cDBCXAlias)
			endif cursorgetprop('Buffering', .cDBCXAlias) > 1
		endwith
		
	ENDPROC

	PROCEDURE dbcxgetproplist
		*==============================================================================
		* Method:			DBCXGetPropList
		* Status:			Public
		* Purpose:			Populates a cursor with the name of all properties in the
		*						extension
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	07/24/98
		* Parameters:		tcCursorName - the name of the cursor to populate
		* Returns:			.T. if everything went OK
		* Environment in:	the specified cursor must be open
		*					the meta data table for this manager must either be open or
		*						available to be opened
		* Environment out:	the meta data table for this manager may have been opened
		*					the specified cursor is updated with properties managed by
		*						this manager
		*==============================================================================
		
		lparameters tcCursorName
		local lnI, ;
			lcField, ;
			lcName
		with This
		
		* Ensure our meta data table is open.
		
			if not .OpenDBCXMeta()
				return .F.
			endif not .OpenDBCXMeta()
		
		* Update the cursor holding all DBCX properties to include our properties.
		
			for lnI = 1 to fcount(.cDBCXAlias)
				lcField = field(lnI, .cDBCXAlias)
				lcName  = substr(lcField, 2)
				do case
					case lcName = 'OBJECTNAM'
						lcName = 'OBJECTNAME'
					case lcName = 'LASTMOD'
						lcName = 'LASTMODIFIED'
					case lcName = 'EXPR'
						lcName = 'EXPRESSION'
					case lcName = 'FORMAT'
						insert into (tcCursorName) ;
								(CPROPERTY, ;
								COBJECT, ;
								CPRODNAME, ;
								CLONGNAME) ;
							values ;
								(.GetPropertyName(lcField), ;
								.Name, ;
								.cProductName, ;
								'CBMINFORMAT')
				endcase
				insert into (tcCursorName) ;
						(CPROPERTY, ;
						COBJECT, ;
						CPRODNAME, ;
						CLONGNAME) ;
					values ;
						(.GetPropertyName(lcField), ;
						.Name, ;
						.cProductName, ;
						lcName)
			next lnI
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE dbcxrenameobject
		*==============================================================================
		* Method:			DBCXRenameObject
		* Status:			Public
		* Purpose:			Rename an object in the meta data
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	08/01/2001
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcNewName    - the new name of the object in VFP DBC syntax
		* Returns:			.T. if no errors occurred
		* Environment in:	the meta data table must be available to be opened
		* Environment out:	if this method returns .T., the new name has been placed in
		*						all meta data records for the object and its children
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcNewName
		local llReturn, ;
			lcDBCField, ;
			lcObjectField, ;
			lcTypeField, ;
			lcDBC, ;
			lcObjectName, ;
			lcFullObject, ;
			lcNewDBC, ;
			lcNewName, ;
			llChangeDBC, ;
			lcObjectType, ;
			llFound, ;
			lnSelect, ;
			lcObject, ;
			lcExpr, ;
			lnPos, ;
			lnLen
		with This
		
		* Ensure the meta data table is open.
		
			if not .OpenDBCXMeta()
				return llReturn
			endif not .OpenDBCXMeta()
		
		* Get the database and object name, and try to find the object in the meta data
		* table.
		
			lcDBCField    = .cDBCNameField
			lcObjectField = .cObjectNameField
			lcTypeField   = .cRecTypeField
			lcDBC         = padr(.Parent.GetDatabase(tcObjectName), ;
				fsize(lcDBCField, .cDBCXAlias))
			lcObjectName  = lower(.Parent.StripDatabase(tcObjectName))
			lcFullObject  = padr(lcObjectName, fsize(lcObjectField, .cDBCXAlias))
			lcNewDBC      = padr(.Parent.GetDatabase(tcNewName), ;
				fsize(lcDBCField, .cDBCXAlias))
			lcNewName     = lower(.Parent.StripDatabase(tcNewName))
			llChangeDBC   = not lcDBC        == lcNewDBC
			lcObjectType  = upper(left(tcObjectType, 1))
			llFound       = .FindObject(lcObjectName, tcObjectType, lcDBC)
		
		* If we can find the record, rename all objects with the same name (for
		* example, all fields and indexes for the table if the table name changes).
		* We'll use optimistic table buffering so we can undo all the changes if
		* necessary.
		
			if llFound
				lnSelect = select()
				select (.cDBCXAlias)
				cursorsetprop('Buffering', DB_BUFOPTTABLE)
				llReturn = .T.
				scan for lower(&lcDBCField) = lcDBC and ;
					((lower(&lcObjectField) = lcFullObject and ;
					&lcTypeField = lcObjectType) or ;
					lower(&lcObjectField) = lcObjectName + '.' or ;
					(&lcTypeField = 'R' and lcObjectType $ 'TI' and ;
					(lower(&lcObjectField) = lcObjectName + ',' or ;
					',' + lcObjectName + '.' $ lower(&lcObjectField) or ;
					',' + lcObjectName + ' '$ lower(&lcObjectField)))) or ;
					atc(lcObjectName, mExpr) > 0
					lcObject = evaluate(lcObjectField)
					do case
						case not rlock()
							llReturn = .F.
							exit
						case llChangeDBC
							replace (lcDBCField) with lcNewDBC
							unlock
						case lower(&lcObjectField) = lcObjectName + '.'
							replace (lcObjectField) with lcNewName + ;
								substr(lcObject, at('.', lcObject))
							if not empty(mExpr)
								lcExpr = mExpr
								lnPos  = atc(lcObjectName + '.', lcExpr)
								lnLen  = len(lcObjectName + '.')
								do while lnPos > 0
									lcExpr = stuff(lcExpr, lnPos, lnLen, lcNewName + ;
										'.')
									lnPos  = atc(lcObjectName + '.', lcExpr)
								enddo while lnPos > 0
								replace mExpr with lcExpr
							endif not empty(mExpr)
							unlock
						case lower(&lcObjectField) = lcObjectName + ','
							replace (lcObjectField) with lcNewName + ;
								substr(lcObject, at(',', lcObject))
							unlock
						case ',' + lcObjectName + '.' $ lower(&lcObjectField)
							replace (lcObjectField) with ;
								left(lcObject, at(',', lcObject)) + lcNewName + ;
								substr(lcObject, at('.', lcObject, 2))
							unlock
						case ',' + lcObjectName + ' ' $ lower(&lcObjectField)
							replace (lcObjectField) with ;
								left(lcObject, at(',', lcObject)) + lcNewName
							unlock
						case atc(lcObjectName, mExpr) > 0
							lcExpr = mExpr
							lnPos  = atc(lcObjectName, lcExpr)
							lnLen  = len(lcObjectName)
							do while lnPos > 0
								lcExpr = stuff(lcExpr, lnPos, lnLen, lcNewName)
								lnPos  = atc(lcObjectName, lcExpr)
							enddo while lnPos > 0
							replace mExpr with lcExpr
							unlock
						otherwise
							replace (lcObjectField) with lcNewName
							unlock
					endcase
				endscan for &lcDBCField = lcDBC ...
		
		* Give an error if not all objects could be renamed.
		
				if not llReturn or not tableupdate(1)
					tablerevert(.T.)
					.Warning(ccERR_CANT_RENAME_RECORD)
				endif not llReturn ...
		
		* Restore the things we changed.
		
				cursorsetprop('Buffering', DB_BUFOFF)
				select (lnSelect)
		
		* The object wasn't found.
		
			else
				.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
					tcObjectName))
			endif llFound
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles an error
		* Author:			Toni M. Feltman, F1 Technologies
		* Last revision:	06/05/2001
		* Parameters:		tnError  - the error number
		*					tcMethod - the error method
		*					tnLine   - the error line
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	if an error occurred in ValidateViewIndex, This.lIndexError
		*						is .T.
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		if upper(tcMethod) = 'VALIDATEVIEWINDEX'
			This.lIndexError = .T.
			return
		else
			lcReturn = dodefault(tnError, This.Name + '.' + tcMethod, tnLine)
			do case
				case '.' $ tcMethod
					return lcReturn
				case lcReturn = ccMSG_DEBUG
					debug
					suspend
				case lcReturn = ccMSG_RETRY
					retry
				case lcReturn = ccMSG_CANCEL
					cancel
				otherwise
					return
			endcase
		endif upper(tcMethod) = 'VALIDATEVIEWINDEX'
		
	ENDPROC

	PROCEDURE insertmergedata
		*==============================================================================
		* Method:			InsertMergeData
		* Purpose:			Generate a new iId before the default behavior.
		* Author:			Toni M. Feltman, F1 Technologies
		* Parameters:		toData, The object containing data.
		* Returns:			None
		* Added:			08/19/2004
		*==============================================================================
		LPARAMETERS ;
			toData
		
		LOCAL ;
			liId AS Integer
			
		liId = This.Parent.NewId()
		
		IF liId > 0
			toData.iId = liId
		ENDIF
		
		RETURN DODEFAULT(toData)
	ENDPROC

	PROCEDURE validatedatabase
		*==============================================================================
		* Method:			ValidateDatabase
		* Status:			Protected
		* Purpose:			Validates the specified database
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	05/24/2001
		* Parameters:		tcObjectName - the name of the database
		* Returns:			.T.
		* Environment in:	the database is open
		*					the manager's meta data table is positioned to the record
		*						for the database
		* Environment out:	the database's record is populated with appropriate
		*						information for the database
		*==============================================================================
		
		lparameters tcObjectName
		replace mPath    with sys(2014, dbc(), This.Parent.cRegistryPath), ;
				tLastMod with datetime() ;
			in (This.cDBCXAlias)
		return .T.
		
	ENDPROC

	PROCEDURE validatefield
		*==============================================================================
		* Method:			ValidateField
		* Status:			Protected
		* Purpose:			Validates the specified field
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	02/14/2005
		* Parameters:		tcParent - the name of the parent table
		*					tcAlias  - the alias the table is open with
		*					tcField  - the name of the field
		*					tlFree   - .T. if the table is free
		* Returns:			.T.
		* Environment in:	the table is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the field
		* Environment out:	the field's record is populated with appropriate
		*						information for the field
		*==============================================================================
		
		lparameters tcParent, ;
			tcAlias, ;
			tcField, ;
			tlFree
		local laFields[1], ;
			lnFields, ;
			lnI, ;
			lnField, ;
			llReturn
		
		* Get an array of fields in the table, then find the field in it.
		
		lnFields = afields(laFields, tcAlias)
		lcField  = upper(alltrim(tcField))
		lnField  = 0
		for lnI = 1 to lnFields
			if lcField == laFields[lnI, 1]
				lnField = lnI
				exit
			endif lcField == laFields[lnI, 1]
		next lnI
		llReturn = lnField > 0
		
		* If we found it, update the meta data.
		
		if llReturn
			replace nField with lnField, ;
				cType      with laFields[lnField, 2], ;
				nSize      with laFields[lnField, 3], ;
				nDecimals  with laFields[lnField, 4], ;
				lNull      with laFields[lnField, 5], ;
				lBinary    with laFields[lnField, 6], ;
				tLastMod   with datetime() ;
				in (This.cDBCXAlias)
			if alen(laFields, 2) > 16
				replace nStepValue with laFields[lnField, 18], ;
					nNextValue with laFields[lnField, 17] ;
					in (This.cDBCXAlias)
			endif alen(laFields, 2) > 16
		endif llReturn
		return llReturn
		
	ENDPROC

	PROCEDURE validateindex
		*==============================================================================
		* Method:			ValidateIndex
		* Status:			Protected
		* Purpose:			Validates the specified index
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	01/04/2005
		* Parameters:		tcParent - the name of the parent table
		*					tcAlias  - the alias the table is open with
		*					tcIndex  - the tag name
		*					tlFree   - .T. if the table is free
		* Returns:			.T.
		* Environment in:	the table is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the index
		*					if the index used PHDBASE, PHDBASE.FLL must be in the VFP
		*						path or current directory
		* Environment out:	the index's record is populated with appropriate
		*						information for the index
		*==============================================================================
		
		lparameters tcParent, ;
			tcAlias, ;
			tcIndex, ;
			tlFree
		local lnIndex, ;
			llReturn, ;
			lcType, ;
			lcKey, ;
			lnSelect
		with This
			lnIndex  = tagno(tcIndex, '', tcAlias)
			llReturn = lnIndex > 0
			if llReturn
				do case
					case primary(lnIndex, tcAlias) or (not tlFree and ;
						indbc(tcParent, 'Table') and ;
						dbgetprop(tcParent, 'Table', 'PrimaryKey') == tcIndex)
						lcType = 'P'
					case candidate(lnIndex, tcAlias)
						lcType = 'C'
					case unique(lnIndex, tcAlias)
						lcType = 'U'
					case version(5) >= 900 and .Parent.Binary(lnIndex, tcAlias)
						lcType = 'B'
					otherwise
						lcType = 'R'
				endcase
				lcKey = key('', lnIndex, tcAlias)
				replace mTagFilter with sys(2021, lnIndex, tcAlias), ;
					cTagType   with lcType, ;
					cCollate   with idxcollate(lnIndex, tcAlias), ;
					lAscending with not descending('', lnIndex, tcAlias), ;
					tLastMod   with datetime() ;
					in (.cDBCXAlias)
				if lcKey = 'PHD('
					do case
						case '\PHDBASE.' $ upper(set('LIBRARY'))
						case file('PHDBASE.V50')
							set library to ('PHDBASE.V50') additive
						case file('PHDBASE.FLL')
							set library to ('PHDBASE') additive
					endcase
					if '\PHDBASE.' $ upper(set('LIBRARY'))
						lnSelect = select()
						select (tcAlias)
						lcKey = 'phd("index ' + evaluate('phd("key")') + '")'
						select (lnSelect)
					endif '\PHDBASE.' $ upper(set('LIBRARY'))
				endif lcKey = 'PHD('
				replace mTagExpr with lcKey in (.cDBCXAlias)
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE validatetable
		*==============================================================================
		* Method:			ValidateTable
		* Status:			Protected
		* Purpose:			Validates the specified table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	01/16/2001
		* Parameters:		tcObjectName - the name of the table
		*					tcAlias      - the alias the table is open with
		*					tlFree       - .T. if the table is free
		* Returns:			.T.
		* Environment in:	the table is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the table
		* Environment out:	the table's record is populated with appropriate
		*						information for the table
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcAlias, ;
			tlFree
		local lcPath, ;
			lnBlockSize
		with This
			if tlFree
				lcPath = evaluate(.cDBCXAlias + '.mPath')
				if left(lcPath, 1) <> '='
					lcPath = sys(2014, dbf(tcAlias), .Parent.cRegistryPath)
				endif left(lcPath, 1) <> '='
			else
				lcPath = ''
			endif tlFree
			lnBlockSize = val(sys(2012, tcAlias))
			replace mPath  with lcPath, ;
				nCodePage  with cpdbf(tcAlias), ;
				nBlockSize with iif(lnBlockSize = 0, set('BLOCKSIZE'), lnBlockSize), ;
				tLastMod   with datetime() ;
				in (.cDBCXAlias)
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE validateviewindex
		*==============================================================================
		* Method:			ValidateViewIndex
		* Status:			Protected
		* Purpose:			Validates the specified view index
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		*					Toni M. Feltman, F1 Technologies
		* Last revision:	06/04/2001
		* Parameters:		tcParent - the name of the view
		*					tcAlias  - the alias the view is open with
		*					tcIndex  - the tag name
		* Returns:			.T. if the validation succeeded
		* Environment in:	the view is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the index
		* Environment out:	if the index and for expressions are valid, the view index
		*						record's tLastMod field has the current datetime
		*==============================================================================
		
		lparameters tcParent, ;
			tcAlias, ;
			tcIndex
		local lcExpr, ;
			lcFor, ;
			lnSelect, ;
			luExprValue, ;
			lcForValue, ;
			llReturn
		with This
			lcExpr   = evaluate(.cDBCXAlias + '.mTagExpr')
			lcFor    = evaluate(.cDBCXAlias + '.mTagFilter')
			lnSelect = select()
			select (tcAlias)
			luExprValue = evaluate(lcExpr)
			if not empty(lcFor)
				luForValue = evaluate(lcFor)
			endif not empty(lcFor)
			llReturn = not .lIndexError and vartype(luExprValue) <> 'U' and ;
				(empty(lcFor) or vartype(luForValue) = 'L')
			if llReturn
				replace tLastMod with datetime() in (.cDBCXAlias)
			endif llReturn
			.lIndexError = .F.
			select (lnSelect)
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS dbcxmgr AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "dbcxmgr.h"
	*<DefinedPropArrayMethod>
		*m: addbs		&& For backward compatibility only
		*m: adddatabasetoobjectname		&& Adds the database to the object name
		*m: addrow		&& Calls each extension manager's AddRow method when a new object is added to the meta data
		*m: addviewindex		&& Defines an index for a view in the meta data
		*m: binary		&& Return .T. if the specified index is a binary index
		*m: closeopenedcursors		&& Closed cursors opened in a method
		*m: convertdbcxmeta		&& Converts the Registry table to the latest structure
		*m: cpropertystring_access
		*m: createdbcxmeta		&& Creates the DBCX registry table
		*m: createpropcursor		&& Creates and populates the DBCX properties cursor
		*m: createxmlmergefile		&& Creates an XML document that can be used to merge different versions of the metadata. The data in the XML document will be for a single DBC.
		*m: dbcxcreateprop		&& Calls an extension's DBCXCreateProp method to create a property
		*m: dbcxdeleteprop		&& Calls an extension's DBCXDeleteProp method to remove a property
		*m: dbcxdeleterow		&& Deletes an object from the meta data
		*m: dbcxgetallobjects		&& Find all data objects having a certain property set a certain way
		*m: dbcxgetprop		&& Retrieves a property from a DBCX table
		*m: dbcxgetpropertyobject		&& Returns an object that holds all of the properties for the specified object
		*m: dbcxgetrowprop		&& Retrieves all property names and values into an array
		*m: dbcxnotify		&& Notifies all extensions of a change in another extension
		*m: dbcxnotifyoneproperty		&& Notify all extension managers of a property change
		*m: dbcxpackmeta		&& Pack the meta data tables for each extension manager
		*m: dbcxrenameobject		&& Renames a object in the meta data
		*m: dbcxsetprop		&& Sets a property in a DBCX table
		*m: dbcxsetpropertyobject		&& Saves the properties for the specified object from a passed object
		*m: dbcxsetrowprop		&& Sets all properties using the values from an array
		*m: execute		&& Executes a VFP command
		*m: findobject		&& Locates the specified object in the CoreMgr meta data table
		*m: findproperty		&& Finds a property in the properties cursor
		*m: getcoremgrid		&& Returns the CoreMgr iID property for the specified object
		*m: getdatabase		&& Returns the database name for a specified object
		*m: instantiatemanager		&& Instantiates a single extension manager
		*m: ismanagerregistered		&& Determine if the specified extension manager is registered
		*m: justfname		&& For backward compatibility only
		*m: justpath		&& For backward compatibility only
		*m: juststem		&& For backward compatibility only
		*m: loadxmlmergefile		&& Takes the contents of an XML document and updates metadata tables from it.
		*m: logerror		&& Logs an error in aErrorInfo
		*m: newid		&& Generates the next DBCX ID
		*m: opendbcxmeta		&& Open the DBCX Registry table
		*m: postvalidate		&& Hook method called after an object is validated
		*m: prevalidate		&& Hook method called before an object is validated
		*m: registercoremgr		&& Registers the CoreMgr in the DBCX registry table
		*m: registermanager		&& Registers a DBCX extension manager
		*m: reseterror		&& Resets error information
		*m: setdatabase		&& Sets the cCurrentDBC property and selects the database
		*m: showstatus		&& Display a message indicating a process is taking place
		*m: stripdatabase		&& Removes the database from an object name
		*m: unregistermanager		&& Removes a manager from the Registry table
		*m: validate		&& Validates the information in the extension manager
		*m: validateall		&& Validates the entire meta data
		*m: warning		&& Handles an warning condition
		*p: ccaption		&& The caption to display for the form
		*p: ccurrentdbc		&& The default database container (used if an object name doesn't specify its database using <database>!<object name> syntax)
		*p: cobjectname		&& The last database object we accessed
		*p: cobjecttype		&& The last object type we accessed
		*p: cpropcursorname		&& Name of a cursor containing the master list of DBCx properties
		*p: cpropertystring		&& A comma delimited list of all the properties in all of the extensions, including aliases
		*p: cregistryname		&& Extension Manager Table
		*p: cregistrypath		&& The path to the DBCX registry table
		*p: cregistrytag		&& The index tag name for the registry table
		*p: cvalidateobjectname		&& The name of the object being validated (so an error handler can handle it)
		*p: cvalidateobjecttype		&& The type of the object being validated (so an error handler can handle it)
		*p: cversion		&& The version number
		*p: lcloseaftervalidate		&& .T. to close tables and views after they've been validated (may be necessary if number of file handles is restricted)
		*p: ldebugmode		&& .T. if warning and error messages should be displayed
		*p: lerroroccurred		&& If .T., an error occurred
		*p: levaluate		&& .T. for DBCXGetProp to evaluate expressions in properties, .F. to return the property directly
		*p: lnotify		&& .T. if we're in "notify" mode
		*p: lpersistpropcursor		&& .T. to persist the properties cursor to a table
		*p: lshowstatus		&& Display status messages during processing (such as Validate)
		*p: lsuppresserrors		&& If .T., an error message isn't displayed when an error occurs
		*p: ndatasessionid		&& The DataSessionID property when DBCXMgr was instantiated
		*p: nmaxretries		&& The number of retries before returning an error
		*p: nretries		&& The number of retries on an error in a COM server
		*p: oerror		&& An object to handle errors
		*a: aerrorinfo[1,0]		&& An array containing information about warnings and errors
		*a: amanagers[1,1]		&& An array of the names of all managers in a registry
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED amanagers,cobjectname,cobjecttype,lnotify,nretries
	Caption = "DBCX Manager"
	ccaption = 		&& The caption to display for the form
	ccurrentdbc = 		&& The default database container (used if an object name doesn't specify its database using <database>!<object name> syntax)
	cobjectname = 		&& The last database object we accessed
	cobjecttype = 		&& The last object type we accessed
	cpropcursorname = DBCXProps		&& Name of a cursor containing the master list of DBCx properties
	cpropertystring = 		&& A comma delimited list of all the properties in all of the extensions, including aliases
	cregistryname = DBCXReg		&& Extension Manager Table
	cregistrypath = 		&& The path to the DBCX registry table
	cregistrytag = cProdName		&& The index tag name for the registry table
	cvalidateobjectname = 		&& The name of the object being validated (so an error handler can handle it)
	cvalidateobjecttype = 		&& The type of the object being validated (so an error handler can handle it)
	cversion = 2005.05.27		&& The version number
	DataSession = 2
	Desktop = .T.
	DoCreate = .T.
	lcloseaftervalidate = .F.		&& .T. to close tables and views after they've been validated (may be necessary if number of file handles is restricted)
	ldebugmode = .F.		&& .T. if warning and error messages should be displayed
	lerroroccurred = .F.		&& If .T., an error occurred
	levaluate = .T.		&& .T. for DBCXGetProp to evaluate expressions in properties, .F. to return the property directly
	lnotify = .F.		&& .T. if we're in "notify" mode
	lpersistpropcursor = .F.		&& .T. to persist the properties cursor to a table
	lshowstatus = .F.		&& Display status messages during processing (such as Validate)
	lsuppresserrors = .F.		&& If .T., an error message isn't displayed when an error occurs
	Name = "dbcxmgr"
	ndatasessionid = 0		&& The DataSessionID property when DBCXMgr was instantiated
	nmaxretries = 100		&& The number of retries before returning an error
	nretries = 0		&& The number of retries on an error in a COM server
	oerror = .NULL.		&& An object to handle errors
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addbs		&& For backward compatibility only
		lparameters tcPath
		return addbs(tcPath)
		
	ENDPROC

	PROTECTED PROCEDURE adddatabasetoobjectname		&& Adds the database to the object name
		*==============================================================================
		* Method:			AddDatabaseToObjectName
		* Status:			Protected
		* Purpose:			Adds the database to the object name
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	07/21/98
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			the object name with the database name and "!" as a prefix
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType
		local lcObjectType, ;
			lcObjectName
		lcObjectType = lower(tcObjectType)
		
		* If the database is already specified, we'll just return the passed name.
		* Otherwise, let GetDatabase figure out which database to use.
		
		do case
			case '!' $ tcObjectName
				lcObjectName = tcObjectName
			case upper(tcObjectType) = 'DATABASE'
				lcObjectName = tcObjectName + '!' + tcObjectName
			otherwise
				lcObjectName = This.GetDatabase(tcObjectName) + '!' + tcObjectName
		endcase
		return lcObjectName
		
	ENDPROC

	PROCEDURE addrow		&& Calls each extension manager's AddRow method when a new object is added to the meta data
		*==============================================================================
		* Method:			AddRow
		* Status:			Public
		* Purpose:			Calls each extension manager's AddRow() method when a new
		*						object is added to the meta data
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T.
		* Environment in:	This.aManagers contains the name of each extension manager
		* Environment out:	the iLastID field in the "system record" in the registry
		*						table is incremented
		*					a record is added in each extension manager's meta data
		*					This.cObjectName and This.cObjectType contain tcObjectName
		*						and tcObjectType
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType
		local lcDBC, ;
			lcObjectName, ;
			lcObjectType, ;
			liNewID, ;
			lnManagers, ;
			lnI, ;
			lcManager
		with This
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(tcObjectName) <> 'C' or empty(tcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(tcObjectType) <> 'C' or empty(tcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
		
		* Get the current database if one wasn't specified, then get the next available
		* DBCX ID.
		
				otherwise
					lcDBC        = .GetDatabase(tcObjectName)
					lcObjectName = .StripDatabase(tcObjectName)
					lcObjectType = upper(tcObjectType)
					liNewID      = .NewID()
		
		* Call the AddRow() method of each manager so they each get a chance to add the
		* object to their meta data with the same DBCX ID value.
		
					lnManagers = alen(.aManagers, 1)
					for lnI = 1 to lnManagers
						lcManager = 'This.' + alltrim(.aManagers[lnI, 1])
						if type(lcManager) = 'O'
							= evaluate(lcManager + '.AddRow(liNewID, lcDBC, ' + ;
								'lcObjectName, lcObjectType)')
						endif type(lcManager) = 'O'
					next lnI
		
		* Save the specified object and type in cObjectName and cObjectType.
		
					.cObjectName = lcDBC + '!' + lcObjectName
					.cObjectType = lcObjectType
			endcase
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE addviewindex		&& Defines an index for a view in the meta data
		*==============================================================================
		* Method:			AddViewIndex
		* Status:			Public
		* Purpose:			Defines an index for a view in the meta data
		* Author:			W. Michael Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName - the name of the view
		*					tcTagName    - the name of the tag
		*					tcExpression - the index expression
		*					tcFor        - the FOR expression for the index (optional)
		*					tlNoValidate - .T. to not validate the index but just store
		*						it
		* Returns:			.T. if everything went OK
		* Environment in:	the database the view belongs to is open
		* Environment out:	see Validate()
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcTagName, ;
			tcExpression, ;
			tcFor, ;
			tlNoValidate
		local lcObjectName, ;
			lcDBC, ;
			lcView, ;
			lcDatabase, ;
			lcTag, ;
			llSuppress, ;
			laUsed[1], ;
			lnSelect, ;
			lnBuffer, ;
			llReturn
		with This
		
		* Ensure we have valid view and tag names.
		
			if vartype(tcObjectName) <> 'C' or empty(tcObjectName)
				.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				return .F.
			endif vartype(tcObjectName) <> 'C' ...
			if vartype(tcTagName) <> 'C' or empty(tcTagName)
				.Warning(ccERR_INVALID_PARAMETERS)
				return .F.
			endif vartype(tcTagName) <> 'C' ...
		
		* Get information from the view name.
		
			lcObjectName = alltrim(tcObjectName)
			lcDBC        = .GetDatabase(lcObjectName)
			lcView       = .StripDatabase(lcObjectName)
			lcTag        = alltrim(tcTagName)
			lcObjectName = lcDBC + '!' + lcView + '.' + lcTag
		
		* Open the database if necessary.
		
			lcDatabase = iif(empty(dbc()), '', '"' + dbc() + '"')
			if not empty(lcDBC) and not dbused(lcDBC) and ;
				(file(lcDBC) or file(lcDBC + '.DBC'))
				open database (lcDBC)
			endif not empty(lcDBC) ...
		
		* Ensure we have valid parameters.
		
			do case
				case empty(lcView)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(tcExpression) <> 'C' or empty(tcExpression)
					.Warning(ccERR_INVALID_PARAMETERS)
				case pcount() > 3 and not vartype(tcFor) $ 'CL'
					.Warning(ccERR_INVALID_PARAMETERS)
				case empty(lcDBC)
					.Warning(ccERR_NO_DBC_SPECIFIED)
				case not dbused(lcDBC)
					.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
		
		* If we don't want any validation, we'll just store the view index.
		
				case tlNoValidate
					llReturn = .AddRow(lcObjectName, 'Index')
					llReturn = llReturn and ;
						.DBCXSetProp('CBcCaption',   proper(strtran(lcTag, '_', ' ')))
					llReturn = llReturn and ;
						.DBCXSetProp('CBmTagFilter', iif(vartype(tcFor) = 'C', tcFor, ;
						''))
					llReturn = llReturn and ;
						.DBCXSetProp('CBmTagExpr',   tcExpression)
					llReturn = llReturn and ;
						.DBCXSetProp('CBcTagType',   'R')
					llReturn = llReturn and ;
						.DBCXSetProp('CBcCollate',   set('COLLATE'))
					llReturn = llReturn and ;
						.DBCXSetProp('CBlAscending', .T.)
		
		* Select the database and see if the view exists. If so, suppress error
		* handling and try to open the view.
		
				otherwise
					set database to (lcDBC)
					if indbc(lcView, 'View')
						llSuppress = .lSuppressErrors
						.lSuppressErrors = .T.
						.ResetError()
						aused(laUsed)
						lnSelect = select()
						select 0
						use (lcView) nodata again
		
		* If we could open the view, create the index for it (we need to turn off
		* table buffering if necessary) and then call Validate to store the meta data
		* for it.
		
						if not empty(alias())
							lnBuffer = cursorgetprop('Buffering')
							if lnBuffer > DB_BUFOPTRECORD
								cursorsetprop('Buffering', DB_BUFOPTRECORD)
							endif lnBuffer > DB_BUFOPTRECORD
							if not empty(tcFor) and type(tcFor) = 'L'
								index on &tcExpression tag &lcTag for &tcFor
							else
								index on &tcExpression tag &lcTag
							endif not empty(tcFor) ...
							if lnBuffer > DB_BUFOPTRECORD
								cursorsetprop('Buffering', lnBuffer)
							endif lnBuffer > DB_BUFOPTRECORD
							llReturn = not .lErrorOccurred and ;
								.Validate(lcObjectName, 'Index')
		
		* We couldn't open the view, so give an error.
		
						else
							.Warning(strtran(ccERR_CANT_OPEN_FILE, ccMSG_INSERT1, ;
								lcView))
						endif not empty(alias())
		
		* Clean up before we exit.
		
						.CloseOpenedCursors(@laUsed)
						select (lnSelect)
						.lSuppressErrors = llSuppress
		
		* The view doesn't exist, so give an error.
		
					else
						.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
							lcView))
					endif indbc(lcView, 'View')
			endcase
			set database to &lcDatabase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE binary		&& Return .T. if the specified index is a binary index
		*==============================================================================
		* Method:			Binary
		* Status:			Public
		* Purpose:			Determines if the specified index is a binary index
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	07/16/2004
		* Parameters:		tnIndex - the index number
		*					tcAlias - the alias
		* Returns:			.T. if the index is binary
		* Environment in:	the table specified in tcAlias is open
		*					This.cValidateObjectName and This.cValidateObjectType
		* Environment out:	none
		*==============================================================================
		
		lparameters tnIndex, ;
			tcAlias
		#if version(5) >= 900
		local lcAlias, ;
			laTags[1]
		lcAlias = iif(vartype(tcAlias) = 'C', tcAlias, '')
		ataginfo(laTags, '', tcAlias)
		return laTags[tnIndex, 2] = 'BINARY'
		#else
		return .F.
		#endif
		
	ENDPROC

	PROCEDURE closeopenedcursors		&& Closed cursors opened in a method
		*==============================================================================
		* Method:			CloseOpenedCursors
		* Status:			Public
		* Purpose:			Closes any tables opened since a snapshot was taken
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	11/28/97
		* Parameters:		taUsed - a array of cursors opened when the snapshot was
		*						taken
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	any cursors that weren't open in taUsed but are open now
		*						are closed
		*==============================================================================
		
		lparameters taUsed
		local laCursor[1], ;
			lnCursors, ;
			lnI, ;
			lcCursor
		
		* Get an array of currently open cursors and go through them one at a time. If
		* the cursor wasn't open before, close it.
		
		lnCursors = aused(laCursors)
		for lnI = 1 to lnCursors
			lcCursor = laCursors[lnI, 1]
			if not empty(lcCursor) and ascan(taUsed, lcCursor) = 0
				use in (lcCursor)
			endif not empty(lcCursor) ...
		next lnI
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE convertdbcxmeta		&& Converts the Registry table to the latest structure
		*==============================================================================
		* Method:			ConvertDBCXMeta
		* Status:			Public
		* Purpose:			Converts the Registry table to the latest structure
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	03/04/2003
		* Parameters:		none
		* Returns:			.T. if it succeeded
		* Environment in:	the DBCX registry table must be open
		* Environment out:	the DBCX registry table is converted to the latest
		*						structure
		*==============================================================================
		
		local llSuccess
		with This
		
		* Display a message and close the Registry table.
		
			.ShowStatus(strtran(ccMSG_CONVERTING, ccMSG_INSERT1, 'DBCXREG'))
			if used(.cRegistryName)
				use in (.cRegistryName)
			endif used(.cRegistryName)
		
		* If we can open the Registry table exclusively, add cObjName (if necessary)
		* and reopen in shared mode.
		
			llSuccess = .OpenDBCXMeta(.T.)
			if llSuccess
				if type(.cRegistryName + '.cObjName') = 'U'
					alter table (.cRegistryName) ;
						add column cObjName C(30)
				endif type(.cRegistryName + '.cObjName') = 'U'
				use in (.cRegistryName)
				.OpenDBCXMeta()
			endif llSuccess
			if .lShowStatus
				wait clear
			endif .lShowStatus
		endwith
		return llSuccess
		
	ENDPROC

	PROCEDURE cpropertystring_access
		*==============================================================================
		* Method:			cPropertyString_Access
		* Purpose:			Creates a comma delimited list of all of the properties in 
		*					all extensions and stores it to the cPropertyString 
		*					property for subsequent use
		* Author:			Mike Feltman, F1 Technologies
		* Last revision:	08/04/99
		* Parameters:		None
		* Returns:			the string of properties
		* Notes:			if extensions are added or removed on the fly,
		*						This.cPropertyString should be cleared so it's
		*						recreated the next time it's accessed
		*==============================================================================
		
		local lcString, ;
			lnManagers, ;
			lnI, ;
			lcManagerAlias, ;
			lnJ
		with This
			if empty(.cPropertyString)
				lcString   = ''
				lnManagers = alen(.aManagers,1)
				for lnI = 1 to lnManagers
					lcManagerAlias = evaluate('.' + .aManagers[lnI, 1] + '.cDBCXAlias')
					if evaluate('.' + .aManagers[lnI, 1] + '.OpenDBCXMeta()')
						for lnJ = 1 to fcount(lcManagerAlias)
							lcString = iif(empty(lcString), '', lcString + ',') + ;
								lcManagerAlias + '.' + field(lnJ, lcManagerAlias)
						next lnJ
					endif evaluate('.' + .aManagers[lnI, 1] + '.OpenDBCXMeta()')
				next lnI
				.cPropertyString = lcString
			endif empty(.cPropertyString)
		endwith
		return This.cPropertyString
		
	ENDPROC

	PROTECTED PROCEDURE createdbcxmeta		&& Creates the DBCX registry table
		*==============================================================================
		* Method:			CreateDBCXMeta
		* Status:			Protected
		* Purpose:			Creates the DBCX registry table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	03/20/98
		* Parameters:		none
		* Returns:			.T. if the table was successfully created
		* Environment in:	This.cRegistryPath contains the path to the registry table
		*					This.cRegistryName contains the name of the registry table
		* Environment out:	if this method returns .T., the registry table is created
		*						in the directory contained in This.cRegistryPath, it
		*						contains a SYSTEM RECORD record, and it's open
		*					the CoreMgr manager is instantiated and registered in the
		*						registry table
		*==============================================================================
		
		local lcFile, ;
			llSuccess
		with This
			lcFile = .cRegistryPath + .cRegistryName
			create table (lcFile) free ;
				(CPRODNAME C(40), ;
				MLIBPATH M(4), ;
				CLIBNAME C(12), ;
				CCLASSNAME C(30), ;
				ILASTID I(4), ;
				TLASTUPDT T(8), ;
				COBJNAME C(30))
			llSuccess = used(.cRegistryName)
			if llSuccess
				insert into (.cRegistryName) ;
						(cProdName, ;
						tLastUpdt) ;
					values ;
						('System Record', ;
						datetime())
				index on deleted()        tag Deleted
				index on upper(cProdName) tag cProdName candidate
				use (lcFile) shared
		
		* Register the core manager.
		
				llSuccess = .RegisterCoreMgr()
			else
				.Warning(strtran(ccERR_CANT_CREATE_FILE, ccMSG_INSERT1, lcFile))
			endif llSuccess
		endwith
		return llSuccess
		
	ENDPROC

	PROCEDURE createpropcursor		&& Creates and populates the DBCX properties cursor
		*==============================================================================
		* Method:			CreatePropCursor
		* Status:			Public
		* Purpose:			Creates and populates the DBCX properties cursor
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		*					Mike Feltman, F1 Technologies
		* Last revision:	05/25/2001
		* Parameters:		none
		* Returns:			.T. if the properties cursor is open
		* Environment in:	This.cPropCursorName contains the name of the properties
		*						cursor
		*					This.aManagers is an array containing the names of all
		*						instantiated managers
		*					This.lPersistPropCursor is .T. if the proeprties cursor
		*						should be persisted as a table
		* Environment out:	if this method returns .T., the DBCX properties cursor is
		*						open
		*==============================================================================
		
		local lnSelect, ;
			lcTable, ;
			lcCollate, ;
			lnCounter, ;
			lcObjName
		with This
		
		* If it isn't already open, create the cursor that will hold all of the DBCX
		* properties.
		
			if not used(.cPropCursorName)
				lnSelect = select()
				lcTable  = addbs(justpath(dbf(.cRegistryName))) + ;
					alltrim(.cPropCursorName) + '.dbf'
		
		* If we're creating a cursor or the properties table doesn't exist, create it.
		
				if not .lPersistPropCursor or not file(lcTable)
					if .lPersistPropCursor
						create table (lcTable) free ;
							(cProperty C(30), ;
							cObject C(30), ;
							cLongName C(128), ;
							cProdName C(30), ;
							cReference C(10))
						use in (.cPropCursorName)
						use (.cPropCursorName) in 0 shared
					else
						create cursor (.cPropCursorName) ;
							(cProperty C(30), ;
							cObject C(30), ;
							cLongName C(128), ;
							cProdName C(30), ;
							cReference C(10))
					endif .lPersistPropCursor
					if used(.cPropCursorName)
						lcCollate = set('COLLATE')
						set collate to 'MACHINE'
						index on upper(cProperty)  tag cProperty  for not deleted()
						index on upper(cObject)    tag cObject    for not deleted()
						index on upper(cLongName)  tag cLongName  for not deleted()
						index on upper(cProdName)  tag cProdName  for not deleted()
						index on upper(cReference) tag cReference for not deleted()
						set order to
						if not empty(lcCollate)
							set collate to lcCollate
						endif not empty(lcCollate)
		
		* Populate the cursor by calling all instantiated managers' DBCXGetPropList.
		
						for lnCounter = 1 to alen(.aManagers, 1)
							if not empty(.aManagers[lnCounter, 1])
								lcObjName = '.' + alltrim(.aManagers[lnCounter, 1])
								if type(lcObjName) = 'O' and ;
									not isnull(evaluate(lcObjName))
									= evaluate(lcObjName + ;
										'.DBCXGetPropList(.cPropCursorName)')
								endif type(lcObjName) = 'O' ...
							endif not empty(.aManagers[lnCounter, 1])
						next lnCounter
					else
						.Warning(ccERR_CANT_CREATE_PROPCURSOR)
					endif used(.cPropCursorName)
					select (lnSelect)
		
		* We're using a table and it exists, so open it.
		
				else
					use (lcTable) alias (.cPropCursorName) again in 0 shared
				endif not .lPersistPropCursor ...
			endif not used(.cPropCursorName)
		endwith
		return used(This.cPropCursorName)
		
	ENDPROC

	PROCEDURE createxmlmergefile		&& Creates an XML document that can be used to merge different versions of the metadata. The data in the XML document will be for a single DBC.
		*==============================================================================
		* Method:			CreateXMLMergeFile
		* Purpose:			Creates an XML document that can be used to merge different 
		*					versions of the metadata. The data in the XML document will 
		*					be for a single DBC.
		* Author:			Toni M. Feltman, F1 Technologies
		* Parameters:		tcObjectName, The name of the DBC or a reference to a free 
		*						table as !<tablename>.  
		*					tcXMLFile, The name and path to the XML file that should
		*						be created.
		* Returns:			Logical, True if the file was created. Otherwise false.
		* Added:			08/18/2004
		*==============================================================================
		LPARAMETERS ;
			tcObjectName, ;
			tcXMLFile
			
		LOCAL ;
			llReturn AS Logical, ;
			llContinue AS Logical, ;
			loAdapter AS XMLAdapter, ;
			lnI AS Integer, ;
			lcManager AS Character
		
		llReturn  = .F.
		llContinue  = .T.
		
		WITH This
			* Validate the parameters.
			DO CASE
			CASE VARTYPE(tcObjectName) <> 'C' OR EMPTY(tcObjectName)
				.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				llContinue = .F.
			CASE VARTYPE(tcXMLFile) <> 'C' OR EMPTY(tcXMLFile)
				.Warning(ccERR_NO_FILENAME_SPECIFIED)
				llContinue = .F.		
			CASE NOT .FindObject(tcObjectName, [DATABASE], .T.)	
				.Warning(STRTRAN(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, ALLTRIM(tcObjectName)))
				llContinue = .F.		
			ENDCASE
			
			IF llContinue
				loAdapter = CREATEOBJECT([XMLAdapter])
				llReturn = .T.
				
				IF VARTYPE(loAdapter) = [O]
					FOR lnI = 1 TO ALEN(.aManagers, 1)
						lcManager = '.' + .aManagers[lnI, 1]
			
						if type(lcManager) = 'O'
							llReturn = llReturn and evaluate(lcManager + '.GetMergeData(tcObjectName, loAdapter)')
						endif type(lcManager) = 'O'
						
						IF NOT llReturn
							EXIT
						ENDIF
						
					NEXT lnI
					
					IF llReturn
						* Create the XML File
						loAdapter.ToXML(tcXMLFile, [], .T.)				
					ENDIF
					
					* Close the Merge Cursors
					FOR lnI = 1 TO ALEN(.aManagers, 1)
						lcManager = '.' + .aManagers[lnI, 1]
			
						if type(lcManager) = 'O'
							evaluate(lcManager + '.CloseMergeCursors()')
						endif type(lcManager) = 'O'
						
					NEXT lnI
					
					* Release the XMLAdapter.
					loAdapter = .NULL.
				ELSE
					.Warning(ccERR_CANT_CREATE_XMLADAPTER)
				ENDIF
			
			ENDIF
			
		ENDWITH
			
		RETURN llReturn	
	ENDPROC

	PROCEDURE dbcxcreateprop		&& Calls an extension's DBCXCreateProp method to create a property
		*==============================================================================
		* Method:			DBCXCreateProp
		* Status:			Public
		* Purpose:			Calls an extension's DBCXCreateProp method
		* Author:			Toni M. Feltman, F1 Technologies
		*					Y. Alan Griver, Flash Creative Management
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcPropName - the name of the property to create
		*					tcDBCX     - the name of the extension where the property
		*						should be added
		*					tcLongName - the long name of the property (optional: if it
		*						isn't specified, the long name is the same as the
		*						property name)
		*					tcDataType - the data type for the new property (optional:
		*						see BaseMgr.DBCXCreateProp for default used if it isn't
		*						specified)
		*					tnLength   - the size of the new property (optional: see
		*						BaseMgr.DBCXCreateProp for default used if it isn't
		*						specified)
		*					tnDecimals - the number of decimal places in the new
		*						property (optional: see BaseMgr.DBCXCreateProp for
		*						default used if it isn't specified)
		* Returns:			.T. if the property was created
		* Environment in:	the managers defined in DBCXREG must be instantiated
		* Environment out:	see BaseMgr.DBCXCreateProp()
		*==============================================================================
		
		lparameters tcPropName, ;
			tcDBCX, ;
			tcLongName, ;
			tcDataType, ;
			tnLength, ;
			tnDecimals
		local llReturn, ;
			lcExtension, ;
			lcLongName, ;
			lcCreateCommand
		with This
		
		* Ensure at least two parameters were passed.
		
			if pcount() < 2
				.Warning(ccERR_INVALID_PARAMETERS)
				return llReturn
			endif pcount() < 2
		
		* Ensure the property name is not empty and is of type Character.
		
			if vartype(tcPropName) <> 'C' or empty(tcPropName)
				.Warning(ccERR_NO_PROPERTY_SPECIFIED)
				return llReturn
			endif vartype(tcPropName) <> 'C' ...
		
		* Ensure the DBCX manager name is not empty, is of type Character, and
		* references an object.
		
			if vartype(tcDBCX) = 'C' and not empty(tcDBCX)
				lcExtension = 'This.' + tcDBCX
			else
				lcExtension = ''
			endif vartype(tcDBCX) = 'C' ...
			if type(lcExtension) <> 'O' or isnull(lcExtension)
				.Warning(strtran(ccERR_INVALID_MANAGER, ccMSG_INSERT1, lcExtension))
				return llReturn
			endif type(lcExtension) <> 'O' ...
		
		* If the long name wasn't passed, set it to the property name.
		
			lcLongName = iif(vartype(tcLongName) = 'C' and not empty(tcLongName), ;
				tcLongName, tcPropName)
		
		* Ensure the property doesn't already exist.
		
			if .FindProperty(lcLongName)
				.Warning(strtran(ccERR_PROPERTY_EXISTS, ccMSG_INSERT1, ;
					alltrim(tcPropName)))
		
		* Call the proper extension manager's DBCXCreateProp.
		
			else
				lcCreateCommand = 'This.' + alltrim(tcDBCX) + ;
					'.DBCXCreateProp(tcPropName, lcLongName'
				do case
					case pcount() = 4
						lcCreateCommand = lcCreateCommand + ', tcDataType'
					case pcount() = 5
						lcCreateCommand = lcCreateCommand + ', tcDataType, tnLength'
					case pcount() = 6
						lcCreateCommand = lcCreateCommand + ', tcDataType, ' + ;
							'tnLength, tnDecimals'
				endcase
				lcCreateCommand = lcCreateCommand + ')'
				llReturn = evaluate(lcCreateCommand)
			endif .FindProperty(lcLongName)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxdeleteprop		&& Calls an extension's DBCXDeleteProp method to remove a property
		*==============================================================================
		* Method:			DBCXDeleteProp
		* Status:			Public
		* Purpose:			Calls an extension's DBCXDeleteProp Method to remove a
		*						property from the extension
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcProperty - the name of the property to delete
		*					tcDBCX     - the name of the extension where the property
		*						should be removed
		* Returns:			.T. if the property was deleted
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		* Environment out:	the specified property has been deleted from the specified
		*						manager's meta data table
		*==============================================================================
		
		lparameters tcProperty, ;
			tcDBCX
		local llReturn, ;
			lcManager, ;
			lcDeleteCommand
		with This
		
		* Get the name of extension manager to call.
		
			lcManager = iif(vartype(tcDBCX) = 'C' and not empty(tcDBCX), ;
				'.' + alltrim(tcDBCX), '')
			do case
		
		* Ensure both parameters were passed.
		
				case pcount() <> 2
					.Warning(ccERR_INVALID_PARAMETERS)
		
		* Ensure the property name is not empty and is of type Character.
		
				case vartype(tcProperty) <> 'C' or empty(tcProperty)
					.Warning(ccERR_INVALID_PARAMETERS)
		
		* Ensure the specified manager exists.
		
				case empty(lcManager) or type(lcManager) <> 'O' or isnull(lcManager)
					.Warning(strtran(ccERR_INVALID_MANAGER, ccMSG_INSERT, lcManager))
		
		* Ensure the property exists.
		
				case not .FindProperty(tcProperty)
					.Warning(strtran(ccERR_INVALID_PROPERTY_NAME, ccMSG_INSERT1, ;
						alltrim(tcProperty)))
		
		* Call the proper extension manager's DBCXDeleteProp.
		
				otherwise
					lcProperty = alltrim(evaluate(.cPropCursorName + '.cProperty'))
					lcDeleteCommand = lcManager + '.DBCXDeleteProp(lcProperty, tcDBCX)'
					llReturn = evaluate(lcDeleteCommand)
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxdeleterow		&& Deletes an object from the meta data
		*==============================================================================
		* Method:			DBCXDeleteRow
		* Status:			Public
		* Purpose:			Calls each extension manager's DBCXDeleteRow() method to
		*						delete an object from the meta data
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	03/05/2003
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T. if no errors occurred
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		* Environment out:	This.cObjectName and This.cObjectType contain tcObjectName
		*						and tcObjectType if they were specified
		*					see BaseMgr.DBCXDeleteRow() for other environment out
		*						notes
		* Notes:			tcObjectName and tcObjectType are optional: if they aren't
		*						specified, This.cObjectName and This.cObjectType are
		*						used
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType
		local llReturn, ;
			lcObjectName, ;
			lcObjectType, ;
			lnManagers, ;
			lnCounter, ;
			lcExtension, ;
			lcManager, ;
			liID
		with This
		
		* If no parameters were passed, use cObjectName and cObjectType as the
		* object name and type.
		
			if pcount() = 0
				lcObjectName = .cObjectName
				lcObjectType = .cObjectType
			else
				lcObjectName = alltrim(tcObjectName)
				lcObjectType = alltrim(tcObjectType)
			endif pcount() = 0
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(lcObjectName) <> 'C' or empty(lcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(lcObjectType) <> 'C' or empty(lcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
		
		* Call each extension manager's DBCXDeleteRow method.
		
				otherwise
					llReturn  = .T.
					lnManagers = alen(.aManagers, 1)
					if upper(left(lcObjectType, 1)) = 'D'
						lcObjectName = juststem(lcObjectName)
					endif upper(left(lcObjectType, 1)) = 'D'
					for lnCounter = 1 to lnManagers
						lcExtension = alltrim(.aManagers[lnCounter, 1])
						lcManager   = '.' + lcExtension
						do case
							case empty(lcExtension) or type(lcManager) <> 'O' or ;
								isnull(evaluate(lcManager))
							case .aManagers[lnCounter, 3]
								llReturn = llReturn and evaluate(lcManager + ;
									'.DBCXDeleteRow(lcObjectName, lcObjectType)')
							otherwise
								liID     = .GetCoreMgrID(lcObjectName, lcObjectType)
								llReturn = llReturn and evaluate(lcManager + ;
									'.DBCXDeleteRow(liID)')
						endcase
					next lnCounter
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxgetallobjects		&& Find all data objects having a certain property set a certain way
		*==============================================================================
		* Function:			DBCXGetAllObjects
		* Status:			Public
		* Purpose:			Create an array of all objects having a certain property
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last Revision:	10/15/2004
		* Parameters:		tcType     - the type of object. Valid types are "Field",
		*						"Index", "Relation", "User", "Table", "Database",
		*						"View", and "Connection"
		*					NOTE: if tcType is "Field", "Index", "Relation", or "User",
		*						include the alias the objects are in as a second word
		*						in this parameter (eg. "Field Contacts").
		*					NOTE: the type can include a database by specifying
		*						<database>!<tcType>, such as MyDBC!Field MyTable to
		*						retrieve all fields for MyDBC!MyTable.
		*					NOTE: separate multiple types with commas and no spaces
		*						(eg. "Field,User Contacts"). NOTE: use "ALL" for the
		*						database (eg. "ALL!Table") to get all tables in all
		*						databases and all free tables
		*					NOTE: the database must be open
		*					taArray    - an array to contain the objects found. The
		*						array will be redimensioned to the number of rows
		*						based on the number of objects found, and the following
		*						number of columns:
		*
		*						Number of				Number
		*						Types		tcReturn	 of
		*						Specified	Specified	Columns	Col 1	 Col 2	Col 3
		*						---------	---------	-------	-------- ------	-----
		*						   1		   No		  1		object	 -		-
		*						   1		   Yes		  2		tcReturn object	-
		*						  > 1		   No		  2		object	 type	-
		*						  > 1		   Yes		  3		tcReturn object	type
		*
		*						"object" is the aliased object name, "tcReturn" is the
		*						value of the property specified in tcReturn for the
		*						object, and "type" is the first letter of the object
		*						type (eg. "F" for field, "I" for index, etc.). NOTE:
		*						this should be passed with an "@" prefix to force
		*						FoxPro to pass the entire array to this routine. NOTE:
		*						the object name will include the database (that is,
		*						"database!object") if "ALL" is specified in the
		*						tcType parameter
		*					tcReturn   - what to put into the first column of the
		*						array (optional). "Caption" will return the caption
		*						property from the database for fields. Otherwise, this
		*						must contain a DBCX property name, such as CBnCodePage
		*					tcProperty - the property to check
		*					tuValue    - the value to compare the property against;
		*						it can be an actual value or a string containing an
		*						expression to be evaluated with "VALUE" as a
		*						placeholder for the property. eg. "VALUE > 10"
		* Returns:			the number of elements found, or -1 if an error
		*						occurred
		*==============================================================================
		
		lparameters tcType, ;
			taArray, ;
			tcReturn, ;
			tcProperty, ;
			tuValue
		local lcType, ;
			lcProperty, ;
			lcDBC, ;
			lnPos, ;
			lcAlias, ;
			lcReturn, ;
			llAll, ;
			lnTypes, ;
			laObjects[1], ;
			laTypes[1], ;
			lcTypes, ;
			lcSelect, ;
			lnI, ;
			lcType1, ;
			lnObjects, ;
			lnLength, ;
			llEval, ;
			lcName, ;
			lcObjType, ;
			lcStoreName, ;
			llFound, ;
			luValue, ;
			lcField, ;
			luStoreValue
		
		* Process parameters.
		
		with This
			if vartype(tcType) <> 'C' or empty(tcType)
				.Warning(ccERR_INVALID_PARAMETERS)
				return -1
			endif vartype(tcType) <> 'C' ..
			lcType = alltrim(proper(tcType))
		
		* If the property was passed, ensure it's a valid DBCX property.
		
			if vartype(tcProperty) = 'C' and not empty(tcProperty)
				lcProperty = tcProperty
				if not .FindProperty(lcProperty)
					.Warning(strtran(ccERR_INVALID_PROPERTY_NAME, ccMSG_INSERT1, ;
						lcProperty))
					return -1
				endif not .FindProperty(lcProperty)
			else
				lcProperty = ''
			endif vartype(tcProperty) = 'C' ...
		
		* Get the database.
		
			lcDBC = .GetDatabase()
			if '!' $ lcType
				lcDBC  = .GetDatabase(lcType)
				lcType = proper(.StripDatabase(lcType))
			endif '!' $ lcType
		
		* Ensure the table or view name was specified for fields, indexes, and
		* relations.
		
			lnPos = at(' ', lcType)
			do case
				case not left(lcType, 4) $ 'Fiel,Rela,Inde,User'
					lcAlias = ''
				case lnPos = 0
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
					return -1
				otherwise
					lcAlias = upper(alltrim(substr(lcType, lnPos)))
					lcType  = left(lcType, lnPos - 1)
			endcase
		
		* If the return value is specified, ensure it's a valid property.
		
			if empty(tcReturn)
				lcReturn = ''
			else
				lcReturn = upper(tcReturn)
				if lcReturn <> 'CAPTION' and not .FindProperty(lcReturn)
					.Warning(strtran(ccERR_INVALID_PROPERTY_NAME, ccMSG_INSERT1, ;
						lcReturn))
					return -1
				endif lcReturn <> 'CAPTION' ...
			endif empty(tcReturn)
		
		* Get all objects from the CoreMgr that match the first cut of conditions.
		
			lcDBC   = upper(padr(juststem(lcDBC), len(CoreMeta.cDBCName)))
			llAll   = alltrim(lcDBC) == 'ALL'
			lnTypes = occurs(',', lcType) + 1
			do case
				case lcType = 'Database'
					select cDBCName, ;
							cObjectNam, ;
							cRecType ;
						from CoreMeta ;
						where cRecType = left(lcType, 1) and ;
							not deleted() ;
						into array laObjects ;
						order by nField
				case empty(lcAlias) and llAll
					select cDBCName, ;
							cObjectNam, ;
							cRecType ;
						from CoreMeta ;
						where cRecType = left(lcType, 1) and ;
							not deleted() ;
						into array laObjects ;
						order by nField
				case empty(lcAlias)
					select cDBCName, ;
							cObjectNam, ;
							cRecType ;
						from CoreMeta ;
						where upper(cDBCName + cRecType + cObjectNam) = lcDBC + ;
							left(lcType, 1) and ;
							not deleted() ;
						into array laObjects ;
						order by nField
				case lcType = 'Relation'
					select cDBCName, ;
							cObjectNam, ;
							cRecType ;
						from CoreMeta ;
						where (upper(cDBCName + cRecType + cObjectNam) = lcDBC + ;
							left(lcType, 1) + lcAlias + '.' or ;
							(upper(cDBCName + cRecType + cObjectNam) = lcDBC + ;
							left(lcType, 1) and lower(lcAlias) + '.' $ cObjectNam)) and ;
							not deleted() ;
						into array laObjects ;
						order by nField
				otherwise
					if lnTypes > 1
						dimension laTypes[lnTypes]
						lcTypes  = lcType
						lcSelect = ''
						for lnI = 1 to lnTypes
							lcType1  = upper(left(lcTypes, 1))
							lcTypes  = substr(lcTypes, at(',', lcTypes) + 1)
							lcSelect = iif(empty(lcSelect), '', lcSelect + ' or ') + ;
								'upper(cDBCName + cRecType + cObjectNam) = ' + ;
								'lcDBC + "' + lcType1 + '" + lcAlias + "."'
						next lnI
						lcSelect = '(' + lcSelect + ')'
					else
						lcSelect = 'upper(cDBCName + cRecType + cObjectNam) = ' + ;
							'lcDBC + "' + left(lcType, 1) + '" + lcAlias + "."'
					endif lnTypes > 1
					select cDBCName, ;
							cObjectNam, ;
							cRecType ;
						from CoreMeta ;
						where &lcSelect and not deleted() ;
						into array laObjects ;
						order by nField
			endcase
			lnObjects = iif(alen(laObjects, 2) = 0, 0, alen(laObjects, 1))
		
		* Now see which ones meet the property conditions.
		
			dimension taArray[1]
			taArray  = ''
			lnLength = 0
			llEval   = vartype(tuValue) = 'C' and 'VALUE' $ upper(tuValue)
			for lnI = 1 to lnObjects
				lcDBC       = alltrim(laObjects[lnI, 1])
				lcName      = alltrim(laObjects[lnI, 2])
				lcObjType   = laObjects[lnI, 3]
				lcStoreName = iif(llAll and left(lcType, 1) <> 'D', lcDBC + '!', ;
					'') + lcName
		
		* If we're not checking property values, we're OK.
		
				if empty(lcProperty)
					llFound = .T.
		
		* Get the value of the property and see if it matches the specified conditions.
		
				else
					llFound = .F.
					luValue = .DBCXGetProp(lcDBC + '!' + lcName, lcObjType, lcProperty)
					do case
						case isnull(luValue) and (not llEval or not ;
							'ISNULL(VALUE)' $ upper(tuValue))
						case llEval
							llFound = evaluate(strtran(upper(tuValue), 'VALUE', ;
								'luValue'))
						case vartype(tuValue) <> vartype(luValue)
							llFound = .F.
						otherwise
							llFound = luValue == tuValue
					endcase
				endif empty(lcProperty)
		
		* If this object matches, add the specified return value to the array.
		
				if llFound
					lnLength = lnLength + 1
					do case
						case empty(lcReturn) and lnTypes = 1
							dimension taArray[lnLength]
							taArray[lnLength] = lcStoreName
						case empty(lcReturn)
							dimension taArray[lnLength, 2]
							taArray[lnLength, 1] = lcStoreName
							taArray[lnLength, 2] = lcObjType
						otherwise
							dimension taArray[lnLength, iif(lnTypes = 1, 2, 3)]
		
		* If we want the caption for a field of a table in a database, ensure the
		* database is open, select it, and use DBGETPROP() to get the caption.
		
							if lcObjType = 'F' and lcReturn == 'CAPTION' and ;
								not empty(lcDBC)
								do case
									case empty(lcDBC)
									case dbused(lcDBC)
										set database to (lcDBC)
									otherwise
										.Warning(strtran(ccERR_DB_NOT_OPEN, ;
											ccMSG_INSERT1, lcDBC))
										return -1
								endcase
								lcField      = substr(lcName, at('.', lcName) + 1)
								luStoreValue = dbgetprop(lcName, 'Field', lcReturn)
								luStoreValue = iif(empty(luStoreValue), ;
									proper(strtran(lcField, '_', ' ')), luStoreValue)
							else
								luStoreValue = .DBCXGetProp(lcDBC + '!' + lcName, ;
									lcObjType, lcReturn)
							endif lcType = 'Field' ...
							taArray[lnLength, 1] = luStoreValue
							taArray[lnLength, 2] = lcStoreName
							if lnTypes > 1
								taArray[lnLength, 3] = lcObjType
							endif lnTypes > 1
					endcase
				endif llFound
			next lnI
		endwith
		return lnLength
		
	ENDPROC

	PROCEDURE dbcxgetprop		&& Retrieves a property from a DBCX table
		*==============================================================================
		* Method:			DBCXGetProp
		* Status:			Public
		* Purpose:			Get the specified property for the specified object
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcProperty   - the desired DBCX property to return
		* Returns:			the value of the specified property if the object and
		*						property exist or .NULL. if not
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		*					a manager based on DBCX 2 has a cVersion property
		* Environment out:	This.cObjectName and This.cObjectType contain tcObjectName
		*						and tcObjectType if they were specified
		*					see BaseMgr.DBCXGetProp() for other environment out notes
		* Notes:			tcObjectName and tcObjectType are optional: if they aren't
		*						specified, This.cObjectName and This.cObjectType are
		*						used
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcProperty
		local lcProperty, ;
			lcObjectName, ;
			lcObjectType, ;
			luReturn, ;
			lcManager, ;
			llNewSyntax, ;
			liID
		with This
		
		* If only one parameter was passed, it must be tcProperty, so use cObjectName
		* and cObjectType as the object name and type.
		
			if pcount() = 1
				lcProperty   = tcObjectName
				lcObjectName = .cObjectName
				lcObjectType = .cObjectType
			else
				lcProperty   = tcProperty
				lcObjectName = alltrim(tcObjectName)
				lcObjectType = alltrim(tcObjectType)
			endif pcount() = 1
			luReturn = .NULL.
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(lcObjectName) <> 'C' or empty(lcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(lcObjectType) <> 'C' or empty(lcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
				case vartype(lcProperty) <> 'C' or empty(lcProperty)
					.Warning(ccERR_NO_PROPERTY_SPECIFIED)
		
		* See if we have a valid property. If so, get its value for the specified
		* object (we may need to add the database to the object name first) by calling
		* the appropriate manager. Note: we may need to call the manager using DBCX 1
		* syntax.
		
				case .FindProperty(lcProperty)
					lcObjectName = .AddDatabaseToObjectName(lcObjectName, lcObjectType)
					lcManager    = 'This.' + ;
						alltrim(evaluate(.cPropCursorName + '.cObject'))
					lcProperty   = alltrim(evaluate(.cPropCursorName + '.cProperty'))
					llNewSyntax  = type(lcManager + '.cVersion') <> 'U'
					if llNewSyntax
						luReturn = evaluate(lcManager + ;
							'.DBCXGetProp(lcObjectName, lcObjectType, lcProperty)')
					else
						liID     = .GetCoreMgrID(lcObjectName, lcObjectType)
						luReturn = evaluate(lcManager + ;
							'.DBCXGetProp(lcProperty, liID)')
					endif llNewSyntax
		
		* Evaluate the contents of the property if necessary (it starts with "=").
		
					do case
						case vartype(luReturn) <> 'C'
						case left(luReturn, 1) = '=' and .lEvaluate
							luReturn = evaluate(substr(luReturn, 2))
					endcase
		
		* If the return value isn't NULL, save the specified object and type in
		* cObjectName and cObjectType.
		
					if not isnull(luReturn)
						.cObjectName = lcObjectName
						.cObjectType = lcObjectType
					endif not isnull(luReturn)
		
		* The specified property doesn't exist.
		
				otherwise
					.Warning(strtran(ccERR_INVALID_PROPERTY_NAME, ccMSG_INSERT1, ;
						alltrim(lcProperty)))
			endcase
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE dbcxgetpropertyobject		&& Returns an object that holds all of the properties for the specified object
		*==============================================================================
		* Method:			DBCXGetPropertyObject
		* Status:			Public
		* Purpose:			Returns an object that holds all of the properties for the
		*						specified object
		* Author:			Mike Feltman, F1 Technologies
		* Last revision:	05/27/2005
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			An object that has a property for each property defined
		*					in DBCX. The values of the properties of the object
		*					correspond to the values of the properties in DBCX.
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		*					a manager based on DBCX 2 has a cVersion property
		* Environment out:	This.cObjectName and This.cObjectType contain tcObjectName
		*						and tcObjectType if they were specified
		* Notes:			tcObjectName and tcObjectType are optional: if they aren't
		*						specified, This.cObjectName and This.cObjectType are
		*						used
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType
		local loProperties, ;
			lcObjectName, ;
			lcObjectType, ;
			lcPropertyString, ;
			lnSelect
		loProperties = .NULL.
		with This
		
		* Set lcObjectname and lcObjectType to the parameters or the current object if
		* not passed.
		
			lcObjectName = iif(pcount() >= 1, tcObjectName, .cObjectName)
			lcObjectType = iif(pcount() = 2,  tcObjectType, .cObjectType)
		
		* Get a string of property names. cPropertyString is set by an access method,
		* so we need to ensure it works in under VFP 5.0.
		
			lcPropertyString = .cPropertyString
			if empty(lcPropertyString)
				lcPropertyString = .cPropertyString_Access()
			endif empty(lcPropertyString)
		
		* If we've got a valid object and a property string, perform a SCATTER NAME to
		* create the object. We made need to select a valid workarea first.
		
			if not empty(lcPropertyString) and .FindObject(lcObjectName, ;
				lcObjectType, .T.)
				lnSelect = select()
				if empty(alias())
					select (.cRegistryName)
				endif empty(alias())
				scatter fields &lcPropertyString name loProperties memo
				select (lnSelect)
		
		* Save the specified object and type in cObjectName and cObjectType.
		
				.cObjectName = lcObjectName
				.cObjectType = lcObjectType
			endif not empty(lcPropertyString) ...
		endwith		
		return loProperties
		
	ENDPROC

	PROCEDURE dbcxgetrowprop		&& Retrieves all property names and values into an array
		*==============================================================================
		* Method:			DBCXGetRowProp
		* Status:			Public
		* Purpose:			Calls each extension manager's DBCXGetRowProp() method to
		*						create an array of every property for a specific object
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		taArray      - the array to populate (must be passed by
		*						reference)
		*					tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcDBCX       - the name of the extension manager to call
		*						(optional: if it isn't specified, all managers are
		*						called)
		* Returns:			.T. if no errors occurred
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		* Environment out:	This.cObjectName and This.cObjectType contain tcObjectName
		*						and tcObjectType if they were specified
		*					see BaseMgr.DBCXGetRowProp() for other environment out
		*						notes
		* Notes:			tcObjectName and tcObjectType are optional: if they aren't
		*						specified, This.cObjectName and This.cObjectType are
		*						used
		*==============================================================================
		
		lparameters taArray, ;
			tcObjectName, ;
			tcObjectType, ;
			tcDBCX
		local llReturn, ;
			lcObjectName, ;
			lcObjectType, ;
			lcManager, ;
			lnManagers, ;
			lnCounter, ;
			lcExtension, ;
			liID
		with This
		
		* Ensure taArray is an array.
		
			if type('taArray[1]') = 'U'
				.Warning(ccERR_INVALID_PARAMETERS)
				return llReturn
			endif type('taArray[1]') = 'U'
		
		* If the array isn't the correct size, redimensioned it.
		
			if alen(taArray, 2) < 3
				dimension taArray[alen(taArray, 1), 3]
			endif alen(taArray, 2) < 3
		
		* If only one or two parameters were passed, use cObjectName and cObjectType as the
		* object name and type.
		
			if pcount() < 3
				lcObjectName = .cObjectName
				lcObjectType = .cObjectType
				lcManager    = tcObjectName
			else
				lcObjectName = alltrim(tcObjectName)
				lcObjectType = alltrim(tcObjectType)
				lcManager    = tcDBCX
			endif pcount() < 3
		
		* Get the name of extension manager to call.
		
			lcManager = iif(vartype(lcManager) = 'C' and not empty(lcManager), ;
				'.' + alltrim(lcManager), '')
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(lcObjectName) <> 'C' or empty(lcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(lcObjectType) <> 'C' or empty(lcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
		
		* If no manager name was passed, scan through all registered extensions and
		* call the DBCXGetRowProp method. Note: we may need to call the manager using
		* DBCX 1 syntax.
		
				case empty(lcManager)
					llReturn  = .T.
					lnManagers = alen(.aManagers, 1)
					for lnCounter = 1 to lnManagers
						lcExtension = alltrim(.aManagers[lnCounter, 1])
						lcManager   = '.' + lcExtension
						do case
							case empty(lcExtension) or type(lcManager) <> 'O' or ;
								isnull(evaluate(lcManager))
							case .aManagers[lnCounter, 3]
								llReturn = llReturn and evaluate(lcManager + ;
									'.DBCXGetRowProp(@taArray, lcObjectName, lcObjectType)')
							otherwise
								liID     = .GetCoreMgrID(lcObjectName, lcObjectType)
								llReturn = llReturn and evaluate(lcManager + ;
									'.DBCXGetRowProp(@taArray, liID)')
						endcase
					next lnCounter
		
		* An invalid extension manager was specified.
		
				case type(lcManager) <> 'O' or isnull(evaluate(lcManager))
					.Warning(ccERR_INVALID_MANAGER)
		
		* Call the specified manager using DBCX 2 syntax.
		
				case type(lcManager + '.cVersion') <> 'U'
					llReturn = evaluate(lcManager + ;
						'.DBCXGetRowProp(@taArray, lcObjectName, lcObjectType)')
		
		* Call the specified manager using DBCX 1 syntax.
		
				otherwise
					liID     = .GetCoreMgrID(lcObjectName, lcObjectType)
					llReturn = evaluate(lcManager + ;
						'.DBCXGetRowProp(@taArray, liID)')
			endcase
		
		* If everything went OK, save the specified object and type in cObjectName and
		* cObjectType.
		
			if llReturn
				.cObjectName = .AddDatabaseToObjectName(lcObjectName, lcObjectType)
				.cObjectType = lcObjectType
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE dbcxnotify		&& Notifies all extensions of a change in another extension
		*==============================================================================
		* Method:			DBCXNotify
		* Status:			Public
		* Purpose:			Notifies all extensions when a successful DBCXSetProp or
		*						DBCXSetRowProp has been executed
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/06/98
		* Parameters:		tcFromWhere  - where we're being called from: DBCXSetProp or
		*						DBCXSetRowProp
		*					tcObjectName - the name of the object without the database
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tuValue      - the new value for the property if we're
		*						called from DBCXSetProp or the array if it's called
		*						from DBCXSetRowProp
		*					tcManager    - the manager whose property was changed
		*					tcProperty   - the property that was changed
		* Returns:			.T.
		* Environment in:	the CoreMgr must be instantiated
		* Environment out:	all managers have been notified of all changes
		*==============================================================================
		
		lparameters tcFromWhere, ;
			tcObjectName, ;
			tcObjectType, ;
			tuValue, ;
			tcManager, ;
			tcProperty
		local liID, ;
			lnProperties, ;
			lnI
		external array tuValue
		with This
		
		* Get the DBCX ID value for the specified object in case a manager we'll call
		* is based on DBCX 1.
		
			liID = .GetCoreMgrID(tcObjectName, tcObjectType)
		
		* Put us into "notify" mode.
		
			.lNotify = .T.
		
		* If we were called from DBCXSetRowProp, we've been passed an array of
		* properties to change, so pass each property in the array to all manager's
		* DBCXNotify methods using DBCXNotifyOneProperty.
		
			if upper(tcFromWhere) = 'DBCXSETROWPROP'
				lnProperties = alen(tuValue, 1)
				for lnI = 1 to lnProperties
					.DBCXNotifyOneProperty(tcObjectName, tcObjectType, ;
						upper(alltrim(tuValue[lnI, 1])), ;
						upper(alltrim(tuValue[lnI, 2])), tuValue[lnI, 3], liID)
				next lnI
		
		* We were called from DBCXSetProp, so pass the single property information to
		* to all manager's DBCXNotify methods using DBCXNotifyOneProperty.
		
			else
				.DBCXNotifyOneProperty(tcObjectName, tcObjectType, ;
					upper(tcManager), upper(tcProperty), tuValue, liID)
			endif upper(tcFromWhere) = 'DBCXSETROWPROP'
		
		* Turn off "notify" mode.
		
			.lNotify = .F.
		endwith
		return
		
	ENDPROC

	PROTECTED PROCEDURE dbcxnotifyoneproperty		&& Notify all extension managers of a property change
		*==============================================================================
		* Method:			DBCXNotifyOneProperty
		* Status:			Protected
		* Purpose:			Calls each extension manager's DBCXNotify() method to
		*						change the value of a specified property for a specific
		*						object
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/06/98
		* Parameters:		tcObjectName - the name of the object without the database
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcManager    - the name of the manager that controls the
		*						changed property
		*					tcProperty   - the name of the changed property
		*					tuValue      - the value it was changed to
		*					tiRow        - the DBCX ID for the object (in case a
		*						manager is based on DBCX 1)
		* Returns:			.T.
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		* Environment out:	see each manager's DBCXNotify() for other environment out
		*						notes
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcManager, ;
			tcProperty, ;
			tuValue, ;
			tiRow
		local lnManagers, ;
			lnCounter, ;
			lcExtension, ;
			lcManager
		
		* Call the DBCXNotify method in each of the managers, except skip the specified
		* manager since it was already done.
		
		with This
			lnManagers = alen(.aManagers, 1)
			for lnCounter = 1 to lnManagers
				lcExtension = alltrim(.aManagers[lnCounter, 1])
				lcManager   = '.' + lcExtension
				do case
					case empty(lcExtension) or type(lcManager) <> 'O' or ;
						isnull(evaluate(lcManager)) or tcManager = upper(lcExtension)
					case .aManagers[lnCounter, 3]
						= evaluate(lcManager + '.DBCXNotify(tcObjectName, ' + ;
							'tcObjectType, tcManager, tcProperty, tuValue)')
					otherwise
						= evaluate(lcManager + '.DBCXNotify("DBCXSetProp", ' + ;
							'tcManager, tcProperty, tuValue, tiRow)')
				endcase
			next lnCounter
		endwith
		return
		
	ENDPROC

	PROCEDURE dbcxpackmeta		&& Pack the meta data tables for each extension manager
		*==============================================================================
		* Method:			DBCXPackMeta
		* Status:			Public
		* Purpose:			Pack the meta data tables for each extension manager
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	02/03/99
		* Parameters:		none
		* Returns:			.T. if all meta data tables were packed
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		* Environment out:	see BaseMgr.DBCXPackMeta()
		*==============================================================================
		
		local lnManagers, ;
			lnManager
		with This
			lnManagers = alen(.aManagers, 1)
			llReturn   = .T.
			for lnManager = 1 to lnManagers
				lcManager = '.' + .aManagers[lnManager, 1]
				llReturn  = llReturn and evaluate(lcManager + '.DBCXPackMeta()')
			next lnManager
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxrenameobject		&& Renames a object in the meta data
		*==============================================================================
		* Method:			DBCXRenameObject
		* Status:			Public
		* Purpose:			Calls each extension manager's DBCXRenameObject() method to
		*						rename an object from the meta data
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	08/01/2001
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcNewName    - the new name of the object in VFP DBC syntax
		* Returns:			.T. if no errors occurred
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		* Environment out:	This.cObjectName and This.cObjectType contain tcNewName and
		*						tcObjectType if they were specified
		*					see BaseMgr.DBCXRenameObject() for other environment out
		*						notes
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcNewName
		local llReturn, ;
			lcObjectName, ;
			lcNewName, ;
			lnManagers, ;
			lnCounter, ;
			lcExtension, ;
			lcManager
		with This
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(tcObjectName) <> 'C' or empty(tcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(tcObjectType) <> 'C' or empty(tcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
				case vartype(tcNewName) <> 'C' or empty(tcNewName)
					.Warning(ccERR_NO_NEW_NAME_SPECIFIED)
		
		* Call each extension manager's DBCXRenameObject method.
		
				otherwise
					llReturn     = .T.
					lcObjectName = .AddDatabaseToObjectName(tcObjectName, tcObjectType)
					lcNewName    = .AddDatabaseToObjectName(tcNewName,    tcObjectType)
					lnManagers   = alen(.aManagers, 1)
					for lnCounter = 1 to lnManagers
						lcExtension = alltrim(.aManagers[lnCounter, 1])
						lcManager   = '.' + lcExtension
						do case
							case empty(lcExtension) or type(lcManager) <> 'O' or ;
								isnull(evaluate(lcManager))
							case .aManagers[lnCounter, 3]
								llReturn = llReturn and evaluate(lcManager + ;
									'.DBCXRenameObject(lcObjectName, ' + ;
									'tcObjectType, lcNewName)')
						endcase
					next lnCounter
		
		* If everything worked, save the new object name and type in cObjectName and
		* cObjectType.
		
					if llReturn
						.cObjectName = lcNewName
						.cObjectType = tcObjectType
					endif llReturn
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxsetprop		&& Sets a property in a DBCX table
		*==============================================================================
		* Method:			DBCXSetProp
		* Status:			Public
		* Purpose:			Set the specified property for the specified object
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcProperty   - the desired DBCX property to set
		*					tuValue      - the value to assign to the property
		* Returns:			.T. if the object and property exist and the data type of
		*						tuValue is proper or .F. if not
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		*					a manager based on DBCX 2 has a cVersion property
		*					This.lNotify is .T. if we're in "notify" mode
		* Environment out:	This.cObjectName and This.cObjectType contain tcObjectName
		*						and tcObjectType if they were specified
		*					if .F. is returned, This.aErrorInfo contains information
		*						about what went wrong
		*					see BaseMgr.DBCXSetProp() for other environment out notes
		* Notes:			tcObjectName and tcObjectType are optional: if they aren't
		*						specified, This.cObjectName and This.cObjectType are
		*						used
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcProperty, ;
			tuValue
		local lcProperty, ;
			luValue, ;
			lcObjectName, ;
			lcObjectType, ;
			llReturn, ;
			lcExtension, ;
			lcManager, ;
			llNewSyntax, ;
			liID
		with This
		
		* If only two parameters were passed, they must be tcProperty and tuValue, so
		* use cObjectName and cObjectType as the object name and type.
		
			if pcount() = 2
				lcProperty   = tcObjectName
				luValue      = tcObjectType
				lcObjectName = .cObjectName
				lcObjectType = .cObjectType
			else
				lcProperty   = tcProperty
				luValue      = tuValue
				lcObjectName = alltrim(tcObjectName)
				lcObjectType = alltrim(tcObjectType)
			endif pcount() = 2
			llReturn = .F.
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(lcObjectName) <> 'C' or empty(lcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(lcObjectType) <> 'C' or empty(lcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
				case vartype(lcProperty) <> 'C' or empty(lcProperty)
					.Warning(ccERR_NO_PROPERTY_SPECIFIED)
				case pcount() <> 2 and pcount() <> 4
					.Warning(ccERR_INVALID_PARAMETERS)
		
		* We have a valid property, so set its value for the specified object by
		* calling the appropriate manager. If llReturn is .T., save the specified
		* object and type in This.cObjectName and This.cObjectType.
		
				case .FindProperty(lcProperty)
					lcObjectName = .AddDatabaseToObjectName(lcObjectName, lcObjectType)
					lcExtension  = alltrim(evaluate(.cPropCursorName + '.cObject'))
					lcManager    = 'This.' + lcExtension
					lcProperty   = alltrim(evaluate(.cPropCursorName + '.cProperty'))
					llNewSyntax  = type(lcManager + '.cVersion') <> 'U'
					if llNewSyntax
						llReturn = evaluate(lcManager + ;
							'.DBCXSetProp(lcObjectName, lcObjectType, lcProperty, ' + ;
							'luValue)')
					else
						liID     = .GetCoreMgrID(lcObjectName, lcObjectType)
						llReturn = evaluate(lcManager + ;
							'.DBCXSetProp(lcProperty, luValue, liID)')
					endif llNewSyntax
		
		* If the value was properly set, save the specified object and type in
		* cObjectName and cObjectType and call DBCXNotify to notify other managers
		* of the change if we're not already in "notify" mode.
		
					if llReturn
						.cObjectName = lcObjectName
						.cObjectType = lcObjectType
						if not .lNotify
							.DBCXNotify('DBCXSetProp', lcObjectName, lcObjectType, ;
								tuValue, lcExtension, lcProperty)
						endif not .lNotify
					endif llReturn
		
		* The specified property doesn't exist.
		
				otherwise
					.Warning(strtran(ccERR_INVALID_PROPERTY_NAME, ccMSG_INSERT1, ;
						alltrim(lcProperty)))
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxsetpropertyobject		&& Saves the properties for the specified object from a passed object
		*==============================================================================
		* Method:			DBCXSetPropertyObject
		* Status:			Public
		* Purpose:			Returns an object that holds all of the properties for the
		*						specified object
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		toObject     - the object containing the properties for the
		*						data object
		*					tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T. if no errors occurred
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		* Environment out:	This.cObjectName and This.cObjectType contain tcObjectName
		*						and tcObjectType if they were specified
		*					see BaseMgr.DBCXSetRowProp() for other environment out
		*						notes
		* Notes:			tcObjectName and tcObjectType are optional: if they aren't
		*						specified, This.cObjectName and This.cObjectType are
		*						used
		*==============================================================================
		
		lparameters toObject, ;
			tcObjectName, ;
			tcObjectType
		local llReturn, ;
			lcObjectName, ;
			lcObjectType, ;
			lcManager, ;
			lnManagers, ;
			lnCounter, ;
			lcExtension, ;
			liID
		with This
		
		* Ensure toObject is an object.
		
			if vartype(toObject) <> 'O' or isnull(toObject)
				.Warning(ccERR_INVALID_PARAMETERS)
				return llReturn
			endif vartype(toObject) <> 'O' ...
		
		* If only one or two parameters were passed, use cObjectName and cObjectType as
		* the object name and type.
		
			if pcount() < 3
				lcObjectName = .cObjectName
				lcObjectType = .cObjectType
			else
				lcObjectName = alltrim(tcObjectName)
				lcObjectType = alltrim(tcObjectType)
			endif pcount() < 3
		
		* Get the name of extension manager to call.
		
			lcManager = iif(vartype(lcManager) = 'C' and not empty(lcManager), ;
				'.' + alltrim(lcManager), '')
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(lcObjectName) <> 'C' or empty(lcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(lcObjectType) <> 'C' or empty(lcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
		
		* If no manager name was passed, scan through all registered extensions and
		* call the DBCXSetRowProp method.
		
				otherwise
					llReturn   = .T.
					lnManagers = alen(.aManagers, 1)
					for lnCounter = 1 to lnManagers
						lcExtension = alltrim(.aManagers[lnCounter, 1])
						lcManager   = '.' + lcExtension
						if not empty(lcExtension) and type(lcManager + '.Name') = 'C'
							llReturn = llReturn and evaluate(lcManager + ;
								'.DBCXSetPropertyObject(toObject, ' + ;
								'lcObjectName, lcObjectType)')
						endif not empty(lcExtension) ...
					next lnCounter
					lcManager = ''
			endcase
		
		* If everything went OK, save the specified object and type in cObjectName and
		* cObjectType.
		
			if llReturn
				.cObjectName = .AddDatabaseToObjectName(lcObjectName, lcObjectType)
				.cObjectType = lcObjectType
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxsetrowprop		&& Sets all properties using the values from an array
		*==============================================================================
		* Method:			DBCXSetRowProp
		* Status:			Public
		* Purpose:			Calls each extension manager's DBCXSetRowProp() method to
		*						updates multiple properties for an object from an array
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		taArray      - the array containing the property names and
		*						values (must be passed by reference)
		*					tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcDBCX       - the name of the extension manager to call
		*						(optional: if it isn't specified, all managers are
		*						called)
		* Returns:			.T. if no errors occurred
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		*					This.lNotify is .T. if we're in "notify" mode
		* Environment out:	This.cObjectName and This.cObjectType contain tcObjectName
		*						and tcObjectType if they were specified
		*					see BaseMgr.DBCXSetRowProp() for other environment out
		*						notes
		* Notes:			tcObjectName and tcObjectType are optional: if they aren't
		*						specified, This.cObjectName and This.cObjectType are
		*						used
		*==============================================================================
		
		lparameters taArray, ;
			tcObjectName, ;
			tcObjectType, ;
			tcDBCX
		local llReturn, ;
			lcObjectName, ;
			lcObjectType, ;
			lcManager, ;
			lnManagers, ;
			lnCounter, ;
			lcExtension, ;
			liID
		with This
		
		* Ensure taArray is an array and the proper dimensions.
		
			if type('taArray[1]') = 'U' or alen(taArray, 2) < 3
				.Warning(ccERR_INVALID_PARAMETERS)
				return llReturn
			endif type('taArray[1]') = 'U'
		
		* If only one or two parameters were passed, use cObjectName and cObjectType as
		* the object name and type.
		
			if pcount() < 3
				lcObjectName = .cObjectName
				lcObjectType = .cObjectType
				lcManager    = tcObjectName
			else
				lcObjectName = alltrim(tcObjectName)
				lcObjectType = alltrim(tcObjectType)
				lcManager    = tcDBCX
			endif pcount() < 3
		
		* Get the name of extension manager to call.
		
			lcManager = iif(vartype(lcManager) = 'C' and not empty(lcManager), ;
				'.' + alltrim(lcManager), '')
		
		* If the second parameter is numeric, we've been called from a DBCX 1 extension
		* manager, so adjust the properties accordingly.
		
			if vartype(tcObjectName) = 'N'
				lcManager = '.' + tcObjectType
				if seek(tcObjectName, 'COREMETA', 'iID')
					lcObjectName = COREMETA.cObjectNam
					lcObjectType = COREMETA.cRecType
				endif seek(tcObjectName, 'COREMETA', 'iID')
			endif vartype(tcObjectName) = 'N'
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(lcObjectName) <> 'C' or empty(lcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(lcObjectType) <> 'C' or empty(lcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
		
		* If no manager name was passed, scan through all registered extensions and
		* call the DBCXSetRowProp method. Note: we may need to call the manager using
		* DBCX 1 syntax.
		
				case empty(lcManager)
					llReturn   = .T.
					lnManagers = alen(.aManagers, 1)
					for lnCounter = 1 to lnManagers
						lcExtension = alltrim(.aManagers[lnCounter, 1])
						lcManager   = '.' + lcExtension
						if not empty(lcExtension) and type(lcManager) = 'O' and ;
							not isnull(evaluate(lcManager))
							if .aManagers[lnCounter, 3]
								llReturn = llReturn and evaluate(lcManager + ;
									'.DBCXSetRowProp(@taArray, lcObjectName, ' + ;
									'lcObjectType)')
							else
								liID     = .GetCoreMgrID(lcObjectName, lcObjectType)
								llReturn = llReturn and evaluate(lcManager + ;
									'.DBCXSetRowProp(@taArray, liID)')
							endif .aManagers[lnCounter, 3]
						endif not empty(lcExtension) ...
					next lnCounter
					lcManager = ''
		
		* An invalid extension manager was specified.
		
				case type(lcManager) <> 'O' or isnull(evaluate(lcManager))
					.Warning(ccERR_INVALID_MANAGER)
		
		* Call the specified manager using DBCX 2 syntax.
		
				case type(lcManager + '.cVersion') <> 'U'
					llReturn = evaluate(lcManager + ;
						'.DBCXSetRowProp(@taArray, lcObjectName, lcObjectType)')
		
		* Call the specified manager using DBCX 1 syntax.
		
				otherwise
					liID     = .GetCoreMgrID(lcObjectName, lcObjectType)
					llReturn = evaluate(lcManager + ;
						'.DBCXSetRowProp(@taArray, liID)')
			endcase
		
		* If everything went OK, save the specified object and type in cObjectName and
		* cObjectType and call DBCXNotify to notify other managers of the changes if
		* we're not already in "notify" mode.
		
			if llReturn
				.cObjectName = .AddDatabaseToObjectName(lcObjectName, lcObjectType)
				.cObjectType = lcObjectType
				if not .lNotify
					.DBCXNotify('DBCXSetRowProp', lcObjectName, lcObjectType, ;
						@taArray, lcExtension, '')
				endif not .lNotify
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE Destroy
		*==============================================================================
		* Method:			Destroy
		* Status:			Public
		* Purpose:			Releases each extension's class library and close the DBCX
		*						Registry table and properties cursor in case this is in
		*						the default datasession
		* Author:			Marie Hooper, Micromega Systems, Inc.
		*					Toni M. Feltman, F1 Technologies
		*					Y. Alan Griver, Flash Creative Management
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/06/2001
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	the second column of This.aManagers contains the class
		*						library for each instantiated manager, and the fourth
		*						column is .T. if we opened the library
		*					This.cRegistryName contains the alias of the DBCX Registry
		*						table and This.cPropCursorName contains the alias of
		*						the properties cursor
		* Environment out:	all class libraries listed in This.aManagers are closed if
		*						we opened them
		*					the DBCX Registry table and properties cursor are closed
		*					This.oError is .NULL.
		*==============================================================================
		
		local lcFullPath, ;
			lnManagers, ;
			lnCounter, ;
			lcLibrary, ;
			llFound
		with This
			lcFullPath = set('FULLPATH')
			set fullpath on
		
		* Release all the class libraries we opened.
		
			lnManagers = alen(.aManagers, 1)
			lnCounter  = 0
			for lnCounter = 1 to lnManagers
				if vartype(.aManagers[lnCounter, 2]) = 'C'
					lcLibrary = juststem(alltrim(.aManagers[lnCounter, 2]))
					if .aManagers[lnCounter, 4] and ;
						('\' + lcLibrary + '.' $ set('CLASSLIB') or ;
						'\' + lcLibrary + '.' $ set('PROCEDURE'))
						release classlib alias (lcLibrary)
					endif .aManagers[lnCounter, 4] ...
				endif vartype(.aManagers[lnCounter, 2]) = 'C'
			next lnCounter
		
		* Close the tables we opened.
		
			if used(.cRegistryName)
				use in (.cRegistryName)
			endif used(.cRegistryName)
			if used(.cPropCursorName)
				use in (.cPropCursorName)
			endif used(.cPropCursorName)
		
		* Clean up.
		
			.oError = .NULL.
			if lcFullPath = 'OFF'
				set fullpath off
			endif lcFullPath = 'OFF'
		endwith
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handle an error
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	05/19/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method the error occurred in
		*					tnLine   - the line number the error occurred on
		* Returns:			.T.
		* Environment In:	none
		* Environment Out:	the warning has been logged to This.aErrorInfo
		*					This.lErrorOccurred is .T.
		*					if This.lSuppressErrors is .T., no error message is
		*						displayed
		*					if a global error handler is in effect, it is called; if
		*						not, a message is displayed to the user
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lnI, ;
			lcMethod, ;
			lcReturn, ;
			lnErrors, ;
			lcError
		with This
		
		* If we were started as an application object or in-process server, allow a
		* certain number of retries before returning an error.
		
		#if not ' 05.' $ version()
			if between(_vfp.StartMode, 1, 3)
				if .nRetries < .nMaxRetries
					.nRetries = .nRetries + 1
					if '.' $ tcMethod
						return ccMSG_RETRY
					else
						retry
					endif '.' $ tcMethod
				else
					.nRetries = 0
					comreturnerror('Program: ' + tcMethod + ' Source: ' + message(1), ;
						message())
				endif .nRetries < .nMaxRetries
			endif between(_vfp.StartMode, 1, 3)
		#endif
		
		* Figure out who called us if it wasn't specified.
		
			aerror(laError)
			lnI = 1
			do while not empty(program(lnI)) and not '.ERROR' $ program(lnI)
				lcMethod = program(lnI)
				lnI      = lnI + 1
			enddo while not empty(program(lnI)) ...
		
		* Log the error to the aErrorInfo array and set lErrorOccurred to .T.
		
			.LogError(tnError, lcMethod, tnLine, @laError)
			.lErrorOccurred = .T.
		
		* If we have an error handler object, let's call it.
		
			if vartype(.oError) = 'O'
				lcReturn = .oError.Error(tnError, .Name + '.' + tcMethod, tnLine)
			endif vartype(.oError) = 'O'
			do case
		
		* If the error handler already handled the error, do nothing else.
		
				case not empty(lcReturn)
		
		* We're not supposed to display an error message.
		
				case .lSuppressErrors
		
		* If we're in debug mode, bring up the debugger.
		
				case .lDebugMode and version(2) = 2
					debug
					suspend
					lcReturn = ccMSG_CONTINUE
		
		* If no global error handler is in place, display an error message.
		
				case empty(on('ERROR'))
					lnErrors = alen(.aErrorInfo, 1)
					lcReturn = iif(messagebox(ccMSG_ERROR_NUM + chr(9) + ;
						ltrim(str(tnError)) + chr(13) + ccMSG_MESSAGE + ;
						chr(9) + .aErrorInfo[lnErrors, 2] + chr(13) + ;
						ccMSG_LINE_NUM + chr(9) + ltrim(str(tnLine)) + chr(13) + ;
						ccMSG_METHOD + chr(9) + lcMethod, MB_OKCANCEL + MB_ICONSTOP, ;
						.cCaption) = IDOK, ccMSG_CONTINUE, ccMSG_CANCEL)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, and the line number) with the appropriate values.
		
				otherwise
					lcError = upper(on('ERROR'))
					lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
					lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
					lcError = strtran(lcError, ',ERROR()',  ',tnError')
					lcError = strtran(lcError, ' ERROR()',  ' tnError')
					lcError = strtran(lcError, 'ERROR(),',  'tnError,')
					lcError = strtran(lcError, 'LINENO()',  'tnLine')
					lcError = strtran(lcError, 'LINENO(1)', 'tnLine')
					lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
					lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE".
		
					if left(lcError, 3) = 'DO ' or '=' $ lcError
						&lcError
						lcReturn = ccMSG_CONTINUE
		
		* If the error handler is called as a function (such as an object method), call
		* it and ensure the return value is one of the values we'll accept (CONTINUE,
		* RETRY, or CANCEL).
		
					else
						lcReturn = &lcError
					endif left(lcError, 3) = 'DO ' ...
			endcase
		
		* Decide how to dispatch the error based on lcReturn.
		
			lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
				not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ;
				ccMSG_CLOSEFORM + ccMSG_DEBUG, ccMSG_CONTINUE, lcReturn)
			do case
				case '.' $ tcMethod
					return lcReturn
				case lcReturn = ccMSG_DEBUG
					debug
					suspend
				case lcReturn = ccMSG_CONTINUE
					return
				case lcReturn = ccMSG_RETRY
					retry
				otherwise
					cancel
			endcase
		endwith
		
	ENDPROC

	PROCEDURE execute		&& Executes a VFP command
		*==============================================================================
		* Method:			Execute
		* Status:			Public
		* Purpose:			Executes a VFP command
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcCommand - the command to execute
		* Returns:			.T. if no errors occurred
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		* Environment out:	the meta data tables used by each manager are open
		*					other changes vary depending on what command was executed
		*==============================================================================
		
		lparameters tcCommand
		local llReturn, ;
			lnI, ;
			lcManager
		with This
		
		* Ensure a command was passed.
		
			if vartype(tcCommand) <> 'C' or empty(tcCommand)
				llReturn = .F.
				.Warning(ccERR_INVALID_PARAMETERS)
		
		* Ensure all meta data tables are open.
		
			else
				llReturn = .T.
				for lnI = 1 to alen(.aManagers, 1)
					lcManager = '.' + .aManagers[lnI, 1]
					if type(lcManager) = 'O'
						llReturn = llReturn and evaluate(lcManager + '.OpenDBCXMeta()')
					endif type(lcManager) = 'O'
				next lnI
		
		* Clear any previous errors and execute the command, then set the return flag
		* based on whether an error occurred.
		
				.ResetError()
				&tcCommand
				llReturn = not .lErrorOccurred
			endif vartype(tcCommand) <> 'C' ...
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE findobject		&& Locates the specified object in the CoreMgr meta data table
		*==============================================================================
		* Method:			FindObject
		* Status:			Public
		* Purpose:			Locate the specified object in the all manager meta data
		*						tables
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		*					Mike Feltman, F1 Technologies
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName   - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType   - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tlAnyExtension - indicates .T. should be returned if the
		*						object is found in any extension. This allows
		*						FindObject to be used for items not supported by
		*						CoreMgr
		* Returns:			.T. if the object was found in the meta data table
		* Environment in:	see BaseMgr.FindObject()
		* Environment out:	the meta data table for each extension manager is
		*						positioned to the record for the object if the object
		*						was found or EOF if not
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tlAnyExtension
		local llFound, ;
			llReturn, ;
			lcDBC, ;
			lcObjectName, ;
			lnManagers, ;
			lnI, ;
			lcManager
		with This
			llFound  = .F.
			llReturn = .F.
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(tcObjectName) <> 'C' or empty(tcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(tcObjectType) <> 'C' or empty(tcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
		
		* Convert the parameters to the form BaseMgr's FindObject needs and call each
		* manager's FindObject method.
		
				otherwise
					lcDBC        = .GetDatabase(tcObjectName)
					lcObjectName = .StripDatabase(tcObjectName)
					lcDBC        = iif(upper(tcObjectType) = 'DATABASE', ;
						lcObjectName, lcDBC)
					lnManagers   = alen(.aManagers, 1)
					for lnI = 1 to lnManagers
						lcManager = 'This.' + alltrim(.aManagers[lnI, 1])
						do case
							case type(lcManager) <> 'O'
							case upper(lcManager) = 'THIS.OCOREMGR'
								llFound = evaluate(lcManager + ;
									'.FindObject(lcObjectName, tcObjectType, lcDBC)')
								if not tlAnyExtension
									llReturn = llFound
								endif not tlAnyExtension
							otherwise
								llFound = evaluate(lcManager + ;
									'.FindObject(lcObjectName, tcObjectType, lcDBC)')
						endcase
						if llFound and tlAnyExtension
							llReturn = .T.
						endif llFound ...
					next lnI
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE findproperty		&& Finds a property in the properties cursor
		*==============================================================================
		* Method:			FindProperty
		* Status:			Public
		* Purpose:			Finds a property in the properties cursor
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	10/11/2000
		* Parameters:		tcProperty - the name of the property to look for
		* Returns:			.T. if the property is found
		* Environment in:	the properties cursor is either open or can be created
		* Environment out:	if the property was found, the properties cursor is
		*						positioned to the record for it
		*==============================================================================
		
		lparameters tcProperty
		local llReturn, ;
			lcLongName, ;
			lcProperty
		with This
		
		* Ensure the properties cursor is open (if not, we don't need to give an error
		* since one was already given). Then try to find the specified property in the
		* cLongName field of the cursor, If it wasn't there, try the cProperty field.
		* Set llReturn to .T. if it was found in either field.
		
			if .CreatePropCursor()
				lcLongName = padr(upper(alltrim(tcProperty)), ;
					fsize('cLongName', .cPropCursorName))
				lcProperty = padr(upper(alltrim(tcProperty)), ;
					fsize('cProperty', .cPropCursorName))
				llReturn   = seek(lcLongName, .cPropCursorName, 'cLongName') or ;
					seek(lcProperty, .cPropCursorName, 'cProperty')
			endif .CreatePropCursor()
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE getcoremgrid		&& Returns the CoreMgr iID property for the specified object
		*==============================================================================
		* Method:			GetCoreMgrID
		* Status:			Protected
		* Purpose:			Returns the CoreMgr iID property for the specified object
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	03/18/98
		* Parameters:		tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcObjectName - the name of the object:
		*						<alias> for tables, views, and connections
		*						<alias>.<name> for fields and indexes
		*						<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		* Returns:			the CoreMgr iID if the object was found or .NULL. if not
		* Environment in:	the CoreMgr must be instantiated
		* Environment out:	if .NULL. is returned, This.aErrorInfo contains information
		*						about what went wrong
		*					see This.DBCXGetProp() for other environment out notes
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType
		local lcObjectName, ;
			liID
		with This.oCoreMgr
			lcObjectName = This.AddDatabaseToObjectName(tcObjectName, tcObjectType)
			liID = .DBCXGetProp(lcObjectName, tcObjectType, .cPrefix + 'iID')
		endwith
		return liID
		
	ENDPROC

	PROCEDURE getdatabase		&& Returns the database name for a specified object
		*==============================================================================
		* Method:			GetDatabase
		* Status:			Public
		* Purpose:			Returns the database name for a specified object
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName - the object name (optional: if it isn't
		*						specified, a default database is used; see below)
		* Returns:			the database for the object using the following algorithm:
		*						- <database> if it's specified using the VFP syntax
		*							<database>!<objectname>
		*						- dbc() if it isn't empty
		*						- This.cCurrentDBC if neither of the above succeed
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcObjectName
		local lnPos, ;
			lcDBC
		lnPos = iif(vartype(tcObjectName) = 'C', at('!', tcObjectName), 0)
		do case
			case lnPos > 0
				lcDBC = left(tcObjectName, lnPos - 1)
			case not empty(dbc())
				lcDBC = dbc()
			otherwise
				lcDBC = This.cCurrentDBC
		endcase
		lcDBC = lower(juststem(lcDBC))
		return lcDBC
		
	ENDPROC

	PROCEDURE Hide
		*==============================================================================
		* Method:			Hide
		* Status:			Public
		* Purpose:			Hide the DBCXMgr form
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	11/23/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the form caption is blanked
		*==============================================================================
		
		This.Caption = ''
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Instantiates the custom DBCX managers found in the DBCX
		*						registry table
		* Author:			Marie Hooper, Micromega Systems, Inc.
		*					Toni M. Feltman, F1 Technologies
		*					W. Michael Feltman, F1 Technologies
		*					Y. Alan Griver, Flash Creative Management
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	03/22/2004
		* Parameters:		tlDebugMode  - value used to initialize This.lDebugMode
		*					tcRegPath    - the path to the registry table (optional: if
		*						it isn't specified, MetaMgr will look in the current
		*						directory and VFP path)
		*					tlAutoCreate - if .T. and the registry table doesn't exist,
		*						it's created
		* Returns:			.T. if everything worked
		* Environment in:	the DBCX registry table must either be available to be
		*						opened in the current directory, VFP path, or specified
		*						directory, or can be created in the current or
		*						specified directory
		* Environment out:	all managers listed in the DBCX registry table are
		*						instantiated as members of this object
		*					This.aManagers contains the name and class library of all
		*						extension managers
		*==============================================================================
		
		lparameters tlDebugMode, ;
			tcRegPath, ;
			tlAutoCreate
		local lcRegTableName, ;
			lcDBF, ;
			laTemp[1], ;
			llDifObjName, ;
			llAPP, ;
			laLibList[1], ;
			lnNumMgrs, ;
			lnCounter, ;
			llConvert, ;
			lcManager, ;
			llStatus
		with This
		
		* Setup the environment the way we want.
		
			set talk off
			set deleted on
			set safety off
			set exact off
			set null off
			set unique off
			set multilocks on
			set compatible off
		
		* Reset the error array.
		
			dimension .aErrorInfo[1, 9]
			.aErrorInfo = ''
		
		* Set the cCaption and Caption properties: Caption is blanked so it doesn't
		* show in a Window menu.
		
			.cCaption = ccCAPTION_DBCXMGR
			.Caption  = ''
		
		* Set lDebugMode to the passed value.
		
			if vartype(tlDebugMode) = 'L' and tlDebugMode
				.lDebugMode = .T.
			endif vartype(tlDebugMode) = 'L' ...
		
		* Set cRegistryPath to the passed value and determine the complete path and
		* name for the DBCX registry table.
		
			if vartype(tcRegPath) = 'C' and not isnull(tcRegPath) and ;
				not empty(tcRegPath)
				.cRegistryPath = alltrim(tcRegPath)
				.cRegistryPath = .cRegistryPath + iif(right(.cRegistryPath, 1) = '\', ;
					'', '\')
			else
				.cRegistryPath = ''
			endif vartype(tcRegPath) = 'C' ...
			lcRegTableName = upper(.cRegistryPath + .cRegistryName + ;
				iif(right(alltrim(.cRegistryName), 4) <> '.DBF', '.DBF', ''))
		
		* Dimension the aManagers array.
		
			dimension .aManagers[1, 4]
			do case
		
		* If the registry table exists, try to open it. If we can't, exit (we don't
		* need to give an error message since one was already given).
		
				case file(lcRegTableName) and not .OpenDBCXMeta()
					return .F.
				case file(lcRegTableName)
		
		* If it doesn't exist and we weren't told to create it, give an error and exit.
		
				case not tlAutoCreate
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, ;
						lcRegTableName))
					return .F.
		
		* Try to create the registry table. If we can't, exit (we don't need to give an
		* error message since one was already given).
		
				case not .CreateDBCXMeta()
					return .F.
			endcase
		
		* Set cRegistryPath to the actual directory where we found DBCXREG.
		
			lcDBF = dbf(.cRegistryName)
			if empty(.cRegistryPath) and adir(laTemp, lcDBF) > 0
				.cRegistryPath = left(lcDBF, rat('\', lcDBF))
			endif empty(.cRegistryPath) ...
		
		* If the CoreMgr isn't listed, add it.
		
			do case
				case seek('CORE MANAGER', .cRegistryName, .cRegistryTag)
				case .RegisterCoreMgr()
					use in (.cPropCursorName)
				otherwise
					return .F.
			endcase
		
		* Get an array of the extension managers to instantiate. If a field in the
		* registry table called cObjName exists, it'll be used as the object name when
		* instantiating an extension manager.
		
			llDifObjName = type(alltrim(.cRegistryName) + '.cObjName') = 'C'
			select padr(alltrim(mLibPath) + alltrim(cLibName), 254) as LibName, ;
					cClassName, ;
					iif(llDifObjName, cObjName, space(30)), ;
					iif(upper(cClassName) = 'COREMGR', 0, 1) as Order ;
				from (.cRegistryName) ;
				where upper(cProdName) <> 'SYSTEM RECORD' and ;
					upper(cProdName) <> 'CODEBOOK' and ;
					not deleted() ;
				order by 4 ;
				into array laLibList
			lnNumMgrs = iif(empty(laLibList[1]), 0, alen(laLibList, 1))
		
		* Instantiate all defined managers.
		
			for lnCounter = 1 to lnNumMgrs
				.InstantiateManager(laLibList[lnCounter, 1], laLibList[lnCounter, 2], ;
					laLibList[lnCounter, 3])
			next lnCounter
		
		* Ensure we have some managers. If not, bug out now.
		
			lnNumMgrs = iif(empty(.aManagers[1]), 0, alen(.aManagers, 1))
			if lnNumMgrs = 0
				return .F.
			endif lnNumMgrs = 0
		
		* See if any managers need to convert their data from a previous format.
		
			llConvert = .F.
			for lnCounter = 1 to lnNumMgrs
				lcManager = '.' + .aManagers[lnCounter, 1]
				if .aManagers[lnCounter, 3] and type(lcManager) = 'O'
					llConvert = evaluate(lcManager + '.CheckDBCXMeta()')
					if llConvert
						exit
					endif llConvert
				endif .aManagers[lnCounter, 3] ...
			next lnCounter
		
		* If we need to convert, ask if we want to do the conversion. If so, call the
		* ConvertDBCXMeta method of each manager.
		
			do case
				case not llConvert
				case messagebox(ccMSG_CONVERT_DBCXMETA, MB_YESNO + MB_ICONQUESTION, ;
					.cCaption) = IDYES
					for lnCounter = 1 to lnNumMgrs
						lcManager = '.' + .aManagers[lnCounter, 1]
						if .aManagers[lnCounter, 3] and type(lcManager) = 'O' and ;
							pemstatus(&lcManager, 'ConvertDBCXMeta', 5)
							= evaluate(lcManager + '.ConvertDBCXMeta()')
						endif .aManagers[lnCounter, 3] ...
					next lnCounter
					if messagebox(ccMSG_VALIDATE_AFTER_CONVERT, MB_YESNO + ;
						MB_ICONQUESTION, .cCaption) = IDYES
						llStatus     = .lShowStatus
						.lShowStatus = .T.
						.ValidateAll()
						.lShowStatus = llStatus
					endif messagebox ...
				otherwise
					return .F.
			endcase
		
		* Create and populate the properties cursor.
		
			.CreatePropCursor()
		
		* Save the DataSessionID.
		
			.nDataSessionID = .DataSessionID
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE instantiatemanager		&& Instantiates a single extension manager
		*==============================================================================
		* Method:			InstantiateManager
		* Status:			Protected
		* Purpose:			Instantiates a single extension manager
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/05/2001
		* Parameters:		tcLibPath    - the path and name of the class library
		*						containing the extension manager class
		*					tcClassName  - the name of the extension manager class
		*					tcObjectName - the name to give the instantiated manager
		*						(optional: if it isn't specified, the manager will be
		*						called "O" plus the class name)
		* Returns:			.T. if the manager was successfully instantiated
		* Environment in:	none
		* Environment out:	if this method returns .T., the manager class was
		*						instantiated and an entry for it was added to
		*						This.aManagers
		*==============================================================================
		
		lparameters tcLibPath, ;
			tcClassName, ;
			tcObjectName
		local llSuccess, ;
			lcObjectName, ;
			lcFullPath, ;
			lcLibPath, ;
			lcLibrary, ;
			llFound, ;
			lcClassAlias, ;
			llOpened, ;
			lnManagers
		with This
		
		* If the object name wasn't passed, use "O" plus the class name.
		
			llSuccess    = .T.
			lcObjectName = alltrim(iif(empty(tcObjectName), 'o' + tcClassName, ;
				tcObjectName))
		
		* Ensure FULLPATH is on.
		
			lcFullPath = set('FULLPATH')
			set fullpath on
		
		* Only instantiate the class if we haven't already done so.
		
			if type('.' + lcObjectName) <> 'O'
		
		* Get the full path of the class library name relative to the DBCX registry
		* table. Ensure the library exists: try to find it in the relative path, then
		* try to find it in the specified path, then try to find just the VCX without
		* a path.
		
				lcLibPath = alltrim(tcLibPath)
				lcLibrary = fullpath(lcLibPath, dbf(.cRegistryName))
				llFound   = file(lcLibrary)
				if not llFound
					lcLibrary = lcLibPath
					llFound   = file(lcLibrary)
					if not llFound
						lcLibrary = justfname(lcLibrary)
						llFound   = file(lcLibrary)
					endif not file(lcLibrary)
				endif not file(lcLibrary)
		
		* If we found it, open the class library.
		
				if llFound
					lcClassAlias = justfname(upper(lcLibPath))
					llOpened     = .F.
					do case
						case '.PRG' $ lcClassAlias and ;
							not '\' + lcClassAlias $ set('PROCEDURE')
							set procedure to (lcLibrary) additive
							llOpened = .T.
						case not '\' + lcClassAlias $ set('CLASSLIB')
							set classlib to (lcLibrary) additive
							llOpened = .T.
					endcase
		
		* Instantiate the class as a member object.
		
					= evaluate(".AddObject('" + lcObjectName + "', '" + ;
						alltrim(tcClassName) + "')")
		
		* If we successfully instantiated the class, add the new manager to the
		* aManagers array.
		
					llSuccess = type('.' + lcObjectName) = 'O'
					if llSuccess
						lnManagers = iif(empty(.aManagers[1]), 1, ;
							alen(.aManagers, 1) + 1)
						dimension .aManagers[lnManagers, alen(.aManagers, 2)]
						.aManagers[lnManagers, 1] = upper(lcObjectName)
						.aManagers[lnManagers, 2] = lcLibrary
						.aManagers[lnManagers, 3] = type('.' + lcObjectName + ;
							'.cVersion') <> 'U'
						.aManagers[lnManagers, 4] = llOpened
					else
						.Warning(strtran(ccERR_CANT_INSTANTIATE_MGR, ccMSG_INSERT1, ;
							alltrim(tcClassName)))
					endif llSuccess
				else
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, ;
						alltrim(lcLibrary)))
					llSuccess = .F.
				endif llFound
			endif type('.' + lcObjectName) <> 'O'
		
		* Clean up and return.
		
			if lcFullPath = 'OFF'
				set fullpath off
			endif lcFullPath = 'OFF'
		endwith
		return llSuccess
		
	ENDPROC

	PROCEDURE ismanagerregistered		&& Determine if the specified extension manager is registered
		*==============================================================================
		* Method:			IsManagerRegistered
		* Status:			Public
		* Purpose:			Determine if the specified extension manager is registered
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcManager - the object name of the manager (eg. oCoreMgr)
		*					tlRow     - .T. to return the row number (otherwise, it
		*						returns .T. if the manager was found)
		* Returns:			if tlRow is .F., .T. if the manager was found; otherwise,
		*						the row in aManagers if the manager is registered or 0
		*						if not
		* Environment in:	the aManagers array contains an array of managers
		* Environment out:	none
		*==============================================================================
		
		lparameters tcManager, ;
			tlRow
		local lcManager, ;
			lnRow
		with This
			if vartype(tcManager) <> 'C' or empty(tcManager)
				.Warning(ccERR_INVALID_PARAMETERS)
				lnRow = 0
			else
				lnRow = ascan(.aManagers, upper(tcManager))
				if lnRow > 0
					lnRow = asubscript(.aManagers, lnRow, 1)
				endif lnRow > 0
			endif vartype(tcManager) <> 'C' ...
		endwith
		return iif(tlRow, lnRow, lnRow > 0)
		
	ENDPROC

	PROCEDURE justfname		&& For backward compatibility only
		lparameters tcPath
		return justfname(tcPath)
		
	ENDPROC

	PROCEDURE justpath		&& For backward compatibility only
		lparameters tcPath
		return justpath(tcPath)
		
	ENDPROC

	PROCEDURE juststem		&& For backward compatibility only
		lparameters tcPath
		return juststem(tcPath)
		
	ENDPROC

	PROCEDURE loadxmlmergefile		&& Takes the contents of an XML document and updates metadata tables from it.
		*==============================================================================
		* Method:			LoadXMLMergeFile
		* Purpose:			Takes the contents of an XML document and updates metadata 
		*					tables from it. 
		* Author:			Toni M. Feltman, F1 Technologies
		* Parameters:		tcXML, The name and path to the XML file to load.
		* Returns:			None
		* Added:			08/18/2004
		*==============================================================================
		LPARAMETERS ;
			tcXML
			
		LOCAL ;
			llContinue AS Logical, ;
			loAdapter AS XMLAdapter, ;
			lnI AS Integer
		
		llContinue = .T.
			
		WITH This
			* Validate the parameters.
			DO CASE
			CASE VARTYPE(tcXML) <> 'C' OR EMPTY(tcXML)
				.Warning(ccERR_NO_FILENAME_SPECIFIED)
				llContinue = .F.
			CASE NOT FILE(tcXML)
				.Warning(STRTRAN(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, ALLTRIM(tcXML)))
				llContinue = .F.		
			ENDCASE	
		
			IF llContinue
				loAdapter = CREATEOBJECT([XMLAdapter])
				
				IF VARTYPE(loAdapter) = [O]
					
					IF loAdapter.LoadXML(tcXML, .T.)
						* Call the LoadMetaDataFromObject
						FOR lnI = 1 TO ALEN(.aManagers, 1)
							lcManager = '.' + .aManagers[lnI, 1]
				
							if type(lcManager) = 'O'
								llContinue = evaluate(lcManager + '.LoadMetaDataFromObject(loAdapter)')
								
								IF NOT llContinue
									EXIT
								ENDIF
								
							endif type(lcManager) = 'O'
							
						NEXT lnI
						
					ELSE
						.Warning(STRTRAN(ccERR_CANT_LOAD_XMLFILE, ccMSG_INSERT1, ALLTRIM(tcXML)))
					ENDIF
					
				ELSE
					.Warning(ccERR_CANT_CREATE_XMLADAPTER)
				ENDIF
				
			ENDIF
			
		ENDWITH	
	ENDPROC

	PROTECTED PROCEDURE logerror		&& Logs an error in aErrorInfo
		*==============================================================================
		* Method:			LogError
		* Status:			Protected
		* Purpose:			Logs an error in aErrorInfo
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/19/2002
		* Parameters:		tnError  - the error number
		*					tcMethod - the method the error occurred in
		*					tnLine   - the line number the error occurred on
		*					taError  - an array of error information
		* Returns:			.T.
		* Environment In:	none
		* Environment Out:	the error has been logged to This.aErrorInfo
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine, ;
			taError
		local lnErrors
		external array taError
		with This
			lnErrors = iif(vartype(.aErrorInfo[1]) <> 'N', 1, alen(.aErrorInfo, 1) + 1)
			dimension .aErrorInfo[lnErrors, alen(.aErrorInfo, 2)]
			.aErrorInfo[lnErrors, 1] = tnError
			.aErrorInfo[lnErrors, 2] = taError[2]
			.aErrorInfo[lnErrors, 3] = taError[3]
			.aErrorInfo[lnErrors, 4] = taError[4]
			.aErrorInfo[lnErrors, 5] = taError[5]
			.aErrorInfo[lnErrors, 6] = taError[6]
			.aErrorInfo[lnErrors, 7] = taError[7]
			.aErrorInfo[lnErrors, 8] = tcMethod
			.aErrorInfo[lnErrors, 9] = tnLine
		endwith
		return
		
	ENDPROC

	PROCEDURE newid		&& Generates the next DBCX ID
		*==============================================================================
		* Method:			NewID
		* Status:			Public
		* Purpose:			Generates the next DBCX ID
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	11/26/97
		* Parameters:		none
		* Returns:			the next DBCX ID or 0 if an error occurred
		* Environment in:	the DBCX registry table must be open or available to be
		*						opened, must have a SYSTEM RECORD, and that record must
		*						not be locked
		* Environment out:	if 0 is returned, This.aErrorInfo contains information
		*						about what went wrong
		*					the iLastID field in the SYSTEM RECORD in the registry
		*						table is incremented, and the tLastUpdt field contains
		*						the current datetime
		*==============================================================================
		
		local liNewID
		liNewID = 0
		with This
			do case
		
		* If we can't open the DBCX registry table, we don't need to issue a warning
		* since one was already issued.
		
				case not .OpenDBCXMeta()
		
		* Ensure we can find and lock the SYSTEM RECORD record in the registry table.
		
				case not seek('SYSTEM RECORD', .cRegistryName, ;
					.cRegistryTag)
					.Warning(ccERR_NO_SYSTEM_RECORD)
				case not rlock(.cRegistryName)
					.Warning(ccERR_CANT_LOCK_REGISTRY)
		
		* Generate the next ID by incrementing the iLastID field. Also, update the
		* tlastUpdt field.
		
				otherwise
					liNewID = evaluate(.cRegistryName + '.iLastID') + 1
					replace iLastID with liNewID, ;
						tLastUpdt with datetime() ;
						in (.cRegistryName)
					unlock in (.cRegistryName)
			endcase
		endwith
		return liNewID
		
	ENDPROC

	PROCEDURE opendbcxmeta		&& Open the DBCX Registry table
		*==============================================================================
		* Method:			OpenDBCXMeta
		* Status:			Public
		* Purpose:			Open the DBCX Registry table
		* Author:			Toni M. Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	10/09/98
		* Parameters:		tlExclusive - .T. to open the table exclusively
		* Returns:			.T. if the registry table was open or opened
		* Environment in:	This.cRegistryPath contains the path to the registry table
		*					This.cRegistryName contains the name of the registry table
		* Environment out:	if OpenDBCXMeta() returns .T., the DBCX Registry table is
		*						open
		*==============================================================================
		
		lparameters tlExclusive
		local llUsed, ;
			lcRegTableName, ;
			lcMode
		with This
			llUsed = used(.cRegistryName)
			if not llUsed
				lcRegTableName = .cRegistryPath + .cRegistryName + ;
					iif(right(alltrim(.cRegistryName), 4) <> '.DBF', '.DBF', '')
				lcMode = iif(tlExclusive, 'exclusive', 'shared')
				if file(lcRegTableName)
					use (lcRegTableName) alias (.cRegistryName) again in 0 &lcMode
					llUsed = used(.cRegistryName)
				else
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, ;
						lcRegTableName))
				endif file(lcRegTableName)
			endif
		endwith
		return llUsed
		
	ENDPROC

	PROCEDURE postvalidate		&& Hook method called after an object is validated
		*==============================================================================
		* Method:			PostValidate
		* Status:			Public
		* Purpose:			Executes any post-valdiation code desired
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	07/16/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.cCurrentDBC points to the current database
		*					This.cRegistryPath points to the meta data currently open
		*					This.cValidateObjectName and This.cValidateObjectType
		* Environment out:	if a program called POSTVALIDATE.PRG exists in the same
		*						directory as the meta data, as the DBC, or in the VFP
		*						path, it was called
		*==============================================================================
		
		local lcPath
		with This
			lcPath = addbs(justpath(.cCurrentDBC))
			do case
				case file(.cRegistryPath + 'POSTVALIDATE.PRG') or ;
					file(.cRegistryPath + 'POSTVALIDATE.FXP')
					do (.cRegistryPath + 'POSTVALIDATE') with .cValidateObjectName, ;
						.cValidateObjectType
				case file(lcPath + 'POSTVALIDATE.PRG') or ;
					file(lcPath + 'POSTVALIDATE.FXP')
					do (lcPath + 'POSTVALIDATE') with .cValidateObjectName, ;
						.cValidateObjectType
				case file('POSTVALIDATE.PRG') or file('POSTVALIDATE.FXP')
					do ('POSTVALIDATE') with .cValidateObjectName, .cValidateObjectType
			endcase
		endwith
		
	ENDPROC

	PROCEDURE prevalidate		&& Hook method called before an object is validated
		*==============================================================================
		* Method:			PreValidate
		* Status:			Public
		* Purpose:			Executes any pre-valdiation code desired
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	07/16/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.cCurrentDBC points to the current database
		*					This.cRegistryPath points to the meta data currently open
		*					This.cValidateObjectName and This.cValidateObjectType
		* Environment out:	if a program called PREVALIDATE.PRG exists in the same
		*						directory as the meta data, as the DBC, or in the VFP
		*						path, it was called
		*==============================================================================
		
		local lcPath
		with This
			lcPath = addbs(justpath(.cCurrentDBC))
			do case
				case file(.cRegistryPath + 'PREVALIDATE.PRG') or ;
					file(.cRegistryPath + 'PREVALIDATE.FXP')
					do (.cRegistryPath + 'PREVALIDATE') with .cValidateObjectName, ;
						.cValidateObjectType
				case file(lcPath + 'PREVALIDATE.PRG') or ;
					file(lcPath + 'PREVALIDATE.FXP')
					do (lcPath + 'PREVALIDATE') with .cValidateObjectName, ;
						.cValidateObjectType
				case file('PREVALIDATE.PRG') or file('PREVALIDATE.FXP')
					do ('PREVALIDATE') with .cValidateObjectName, .cValidateObjectType
			endcase
		endwith
		
	ENDPROC

	PROCEDURE QueryUnload
		*==============================================================================
		* Method:			QueryUnload
		* Status:			Public
		* Purpose:			Hides the form when the Close box is clicked
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	01/11/99
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the form is hidden and output directed to _screen if it's
		*						visible
		*==============================================================================
		
		if This.Visible
			This.Hide()
			if _screen.Visible
				activate screen
			endif _screen.Visible
			nodefault
		endif This.Visible
		
	ENDPROC

	PROTECTED PROCEDURE registercoremgr		&& Registers the CoreMgr in the DBCX registry table
		*==============================================================================
		* Method:			RegisterCoreMgr
		* Status:			Protected
		* Purpose:			Registers the CoreMgr in the DBCX registry table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	11/13/98
		* Parameters:		none
		* Returns:			.T. if the CoreMgr was successfully registered
		* Environment in:	This.cRegistryPath contains the path to the registry table
		* Environment out:	if this method returns .T., the CoreMgr manager is
		*						registered in the registry table and instantiated
		*					if cObjName doesn't exist in DBCXReg, it's added
		*==============================================================================
		
		local llSuccess, ;
			lcPath
		with This
		
		* Ensure DBCXReg has the correct structure.
		
			llSuccess = .T.
			if type(.cRegistryName + '.cObjName') = 'U'
				llSuccess = .ConvertDBCXMeta()
			endif type(.cRegistryName + '.cObjName') = 'U'
		
		* Register CoreMgr.
		
			if llSuccess
				lcPath    = left(.ClassLibrary, rat('\', .ClassLibrary))
				llSuccess = .RegisterManager('Core Manager', lcPath, 'DBCXMGR.VCX', ;
					'CoreMgr', '')
				if not llSuccess
					.Warning(ccERR_CANT_REGISTER_COREMGR)
				endif not llSuccess
			endif llSuccess
		endwith
		return llSuccess
		
	ENDPROC

	PROCEDURE registermanager		&& Registers a DBCX extension manager
		*==============================================================================
		* Method:			RegisterManager
		* Status:			Public
		* Purpose:			Registers a DBCX extension manager
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcProdName   - the full name of the extension manager
		*					tcLibPath    - the path to the class library containing the
		*						extension manager class
		*					tcLibName    - the name of the class library containing the
		*						extension manager class
		*					tcClassName  - the name of the extension manager class
		*					tcObjectName - the name to give the instantiated manager
		*						(optional: if it isn't specified, the manager will be
		*						called "O" plus the class name)
		* Returns:			.T. if the manager was successfully registered and
		*						instantiated
		* Environment in:	This.cRegistryName contains the name of the registry table
		* Environment out:	if this method returns .T., a record for the manager was
		*						added to the registry table and the manager class was
		*						instantiated
		*==============================================================================
		
		lparameters tcProdName, ;
			tcLibPath, ;
			tcLibName, ;
			tcClassName, ;
			tcObjectName
		local lcObjectName, ;
			lcLibPath, ;
			llReturn
		with This
		
		* Proces the parameters and make the specified path relative to the location of
		* the Registry table.
		
			lcObjectName = iif(vartype(tcObjectName) <> 'C' or ;
				empty(tcObjectName), '', tcObjectName)
			lcLibPath    = tcLibPath + iif(empty(tcLibPath) or ;
				right(tcLibPath, 1) = '\', '', '\')
			lcLibPath    = sys(2014, lcLibPath, .cRegistryPath)
		
		* Make sure we don't already have a record for this manager.
		
			set deleted off
			if seek(upper(tcProdName), .cRegistryName, .cRegistryTag)
				lnSelect = select()
				select (.cRegistryName)
				recall
				select (lnSelect)
				replace cProdName with tcProdName, ;
					mLibPath with lcLibPath, ;
					cLibName with tcLibName, ;
					cClassName with tcClassName, ;
					cObjName with lcObjectName, ;
					tLastUpdt with datetime() ;
					in (.cRegistryName)
			else
				insert into (.cRegistryName) ;
						(cProdName, ;
						mLibPath, ;
						cLibName, ;
						cClassName, ;
						cObjName, ;
						tLastUpdt) ;
					values ;
						(tcProdName, ;
						lcLibPath, ;
						tcLibName, ;
						tcClassName, ;
						lcObjectName, ;
						datetime())
			endif seek(upper(tcProdName), ...
			set deleted on
			llReturn = .InstantiateManager(lcLibPath + tcLibName, tcClassName, ;
				tcObjectName)
			if llReturn
				lcObjectName = iif(empty(lcObjectName), 'o' + tcClassName, ;
					lcObjectName)
				if type('.' + lcObjectName + '.cVersion') <> 'U'
					llReturn = evaluate('.' + lcObjectName + '.CreateDBCXMeta()')
				endif type('.' + lcObjectName + '.cVersion') <> 'U'
				if .CreatePropCursor()
					= evaluate('.' + lcObjectName + '.DBCXGetPropList(.cPropCursorName)')
				endif .CreatePropCursor()
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE reseterror		&& Resets error information
		*==============================================================================
		* Method:			ResetError
		* Status:			Public
		* Purpose:			Resets This.lErrorOccurred and This.nTries and optionally
		*						This.aErrorInfo
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/19/2002
		* Parameters:		tlClearArray - .T. to clear This.aErrorInfo too
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.lErrorOccurred = .F. and This.nRetries = 0 and if
		*						tlClearArray is .T., This.aErrorInfo has a single row
		*==============================================================================
		
		lparameters tlClearArray
		with This
			.lErrorOccurred = .F.
			.nRetries       = 0
			if tlClearArray
				dimension .aErrorInfo[1, alen(.aErrorInfo, 2)]
				.aErrorInfo = .F.
			endif tlClearArray
		endwith
		
	ENDPROC

	PROCEDURE setdatabase		&& Sets the cCurrentDBC property and selects the database
		*==============================================================================
		* Method:			SetDatabase
		* Status:			Public
		* Purpose:			Sets the cCurrentDBC property and selects the database
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	09/24/2003
		* Parameters:		tcDatabase - the name of the database or blank
		* Returns:			.T. if the database was selected
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcDatabase
		local llReturn
		llReturn = .T.
		do case
		
		* If a blank name was specified, close the current database and set
		* cCurrentDBC.
		
			case pcount() = 0 or empty(tcDatabase)
				if not empty(dbc())
					close database
				endif not empty(dbc())
				set database to
				This.cCurrentDBC = ''
		
		* Ensure we were passed a proper parameter and that the specified database is
		* open.
		
			case vartype(tcDatabase) <> 'C'
				This.Warning(ccERR_NO_DBC_SPECIFIED)
				llReturn = .F.
			case not dbused(tcDatabase)
				This.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, tcDatabase))
				llReturn = .F.
		
		* If a database name was specified, select it and set cCurrentDBC.
		
			otherwise
				set database to (tcDatabase)
				This.cCurrentDBC = dbc()
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE Show
		*==============================================================================
		* Method:			Show
		* Status:			Public
		* Purpose:			Display the DBCXMgr form
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	11/23/98
		* Parameters:		tnStyle - 1 to display a modal form
		* Returns:			.T.
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		*					This.cCaption contains the caption for the form
		* Environment out:	the ShowUI method of each manager was called
		*==============================================================================
		
		lparameters tnStyle
		local lnManagers, ;
			lnCounter, ;
			lcExtension, ;
			lcManager
		with This
			.Caption = .cCaption
			lnManagers = alen(.aManagers, 1)
			for lnCounter = 1 to lnManagers
				lcExtension = alltrim(.aManagers[lnCounter, 1])
				lcManager   = '.' + lcExtension
				if not empty(lcExtension) and type(lcManager) = 'O' and ;
					not isnull(evaluate(lcManager)) and .aManagers[lnCounter, 3]
					evaluate(lcManager + '.ShowUI()')
				endif not empty(lcExtension) ...
			next lnCounter
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE showstatus		&& Display a message indicating a process is taking place
		*==============================================================================
		* Method:			ShowStatus
		* Status:			Protected
		* Purpose:			Display a message indicating a process is taking place
		* Author:			W. Michael Feltman, F1 Technologies
		*					Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcMessage - the message to display (optional: if it isn't
		*						specified, "Please wait" is displayed
		*					tnNumber  - the item number of the total being processed
		*						(optional: if it isn't specified, no number is
		*						displayed)
		*					tnTotal   - the total number items being processed
		*						(optional, although required if tnNumber is passed)
		* Returns:			.T.
		* Environment in:	This.lShowStatus is .T. if the message should be displayed
		* Environment out:	a WAIT WINDOW is displayed if This.lShowStatus is .T.
		*==============================================================================
		
		lparameters tcMessage, ;
			tnNumber, ;
			tnTotal
		local lcMessage
		
		* Only do something if lShowStatus is .T.
		
		if This.lShowStatus
		
		* Figure out what to display based on the parameters.
		
			lcMessage = ''
			do case
				case pcount() = 0 or vartype(tcMessage) <> 'C' or empty(tcMessage)
					lcMessage = 'Please wait...'
				case pcount() = 1
					lcMessage = alltrim(tcMessage)
				case pcount() = 2
					lcMessage = alltrim(tcMessage) + ' ' + ltrim(str(tnNumber))
				case pcount() = 3
					lcMessage = alltrim(tcMessage) + ' ' + ltrim(str(tnNumber)) + ;
						' of ' + ltrim(str(tnTotal))
			endcase
			if not '...' $ lcMessage and right(lcMessage,1) <> '.'
				lcMessage = lcMessage + '...'
			endif not '...' $ lcMessage ...
		
		* Use WAIT WINDOW to display the message.
		
			wait window lcMessage nowait
		endif This.lShowStatus
		
	ENDPROC

	PROCEDURE stripdatabase		&& Removes the database from an object name
		*==============================================================================
		* Method:			StripDatabase
		* Status:			Public
		* Purpose:			Removes the database from an object name
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	12/03/97
		* Parameters:		tcObjectName - the object name
		* Returns:			the object name with any specified database stripped off
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcObjectName
		local lnPos, ;
			lcObjectName
		lnPos = at('!', tcObjectName)
		lcObjectName = iif(lnPos = 0, tcObjectName, substr(tcObjectName, lnPos + 1))
		return lcObjectName
		
	ENDPROC

	PROCEDURE unregistermanager		&& Removes a manager from the Registry table
		*==============================================================================
		* Method:			UnRegisterManager
		* Status:			Public
		* Purpose:			Removes an extension manager from DBCX
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcProduct - the product name of the manager
		* Returns:			.T. if the manager was found and removed
		* Environment in:	the Registry table is open
		* Environment out:	the manager is deleted from the Registry table and
		*						aManagers array, removed as a member of this object,
		*						and all properties deleted from the properties cursor
		*==============================================================================
		
		lparameters tcProduct
		local llReturn, ;
			lcProduct, ;
			lcManager, ;
			lcObject, ;
			lnRow, ;
			lnManagers
		with This
			if vartype(tcProduct) <> 'C' or empty(tcProduct)
				.Warning(ccERR_INVALID_PARAMETERS)
				llReturn = .F.
			else
				lcProduct = upper(tcProduct)
				llReturn  = seek(lcProduct, .cRegistryName, .cRegistryTag)
				if llReturn
					lcManager = evaluate(.cRegistryName + '.cObjName')
					lcManager = trim(upper(iif(empty(lcManager), ;
						'o' + evaluate(.cRegistryName + '.cClassName'), lcManager)))
					lcObject  = '.' + lcManager
					delete in (.cRegistryName)
					if type(lcObject) = 'O' and not isnull(evaluate(lcObject))
						.RemoveObject(lcManager)
					endif type(lcObject) = 'O' ...
					lnRow = .IsManagerRegistered(lcManager, .T.)
					if lnRow > 0
						lnManagers = alen(.aManagers, 1) - 1
						adel(.aManagers, lnRow)
						dimension .aManagers[lnManagers, alen(.aManagers, 2)]
					endif lnRow > 0
					if used(.cPropCursorName)
						delete for cObject = lcManager in (.cPropCursorName)
					endif used(.cPropCursorName)
				endif llReturn
			endif vartype(tcProduct) <> 'C' ...
		endwith
		
	ENDPROC

	PROCEDURE validate		&& Validates the information in the extension manager
		*==============================================================================
		* Method:			Validate
		* Status:			Public
		* Purpose:			Ensures all objects belonging to the specified object have
		*						records in all extension manager's meta data tables
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	10/20/2004
		* Parameters:		tcObjectName - the name of the object (optional: if it
		*						isn't specified, This.cCurrentDBC is used)
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database" (optional: if it isn't specified, "database"
		*						is used
		* Returns:			.T. if all validations went OK
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		* Environment out:	all objects belonging to the specified object have records
		*						in all extension manager's meta data tables. Note: only
		*						DBCX 2 based managers can validate anything other than
		*						the entire database
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType
		local llReturn, ;
			lcObjectName, ;
			lcObjectType, ;
			lcFullpath, ;
			laUsed[1], ;
			lcDBC, ;
			lnManagers, ;
			lcDatabase, ;
			llValid, ;
			lnManager, ;
			lcManager, ;
			llAllValid, ;
			laObjects[1], ;
			lnObjects, ;
			lnI, ;
			lcObject, ;
			lnEngineBehavior, ;
			lcCommand, ;
			lcView, ;
			llViewIndex
		with This
		
		* If no parameters were specified, assume we're validating the database.
		
			lcDBC = .GetDatabase()
			do case
				case pcount() = 0
					lcObjectName = lcDBC
					lcObjectType = 'Database'
				case pcount() = 1
					lcObjectName = tcObjectName
					lcObjectType = 'Database'
				otherwise
					lcObjectName = tcObjectName
					lcObjectType = tcObjectType
					lcObjectType = iif(vartype(lcObjectType) = 'C', ;
						proper(lcObjectType), lcObjectType)
			endcase
		
		* Ensure FULLPATH is on.
		
			lcFullPath = set('FULLPATH')
			set fullpath on
		
		* Get a snapshot of open cursors.
		
			= aused(laUsed)
		
		* Strip the database name off the object name if it's specified. Otherwise, use
		* the current database name. Select that database.
		
			do case
				case vartype(lcObjectType) = 'C' and lcObjectType = 'Database'
					lcDBC = lcObjectName
				case '!' $ lcObjectName
					lcDBC        = .GetDatabase(lcObjectName)
					lcObjectName = .StripDatabase(lcObjectName)
			endcase
			lnManagers = alen(.aManagers, 1)
			lcDatabase = iif(empty(dbc()), '', '"' + dbc() + '"')
			.SetDatabase(lcDBC)
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(lcObjectName) <> 'C' or empty(lcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
				case vartype(lcObjectType) <> 'C' or empty(lcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
				case not inlist(lcObjectType, 'Database', 'Table', 'View', 'Field', ;
					'Index', 'Relation', 'Connection')
					.Warning(strtran(ccERR_INVALID_OBJECT_TYPE, ccMSG_INSERT1, ;
						lcObjectType))
		
		* Ensure the specified database is open.
		
				case not empty(lcDBC) and not dbused(lcDBC)
					.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
				case empty(lcDBC) and inlist(lcObjectType, 'Database', 'Relation', ;
					'Connection')
					.Warning(ccERR_NO_DBC_SPECIFIED)
		
		* Handle the database by letting each manager validate the database itself,
		* then the tables, views, relations, and connections in it.
		
				case lcObjectType = 'Database'
					llReturn = .T.
					set database to (lcDBC)
		
		* Do the database.
		
					.ShowStatus(ccMSG_VALIDATING_DATABASE)
					.cValidateObjectName = lcObjectName
					.cValidateObjectType = 'Database'
					llValid = .T.
					.PreValidate()
					for lnManager = 1 to lnManagers
						lcManager = '.' + .aManagers[lnManager, 1]
						do case
							case not llValid
							case .aManagers[lnManager, 3]
								llReturn = llReturn and evaluate(lcManager + ;
									'.Validate(lcObjectName, "Database", lcDBC)')
								llValid  = evaluate(lcManager + '.lValidateObject')
							otherwise
								llReturn = llReturn and ;
									evaluate(lcManager + '.Validate()')
						endcase
					next lnManager
					.PostValidate()
					llAllValid = llValid
		
		* Do tables.
		
					if llReturn
						lnObjects = adbobjects(laObjects, 'Table')
						.cValidateObjectType = 'Table'
						for lnI = 1 to lnObjects
							lcObject = laObjects[lnI]
							.ShowStatus(strtran(ccMSG_VALIDATING_TABLE, ;
								ccMSG_INSERT1, lcObject))
							.cValidateObjectName = lcObject
							llValid = .T.
							.PreValidate()
							for lnManager = 1 to lnManagers
								lcManager = '.' + .aManagers[lnManager, 1]
								if .aManagers[lnManager, 3] and llValid
									llReturn = llReturn and evaluate(lcManager + ;
										'.Validate(lcObject, "Table", lcDBC)')
									llValid  = evaluate(lcManager + '.lValidateObject')
								endif .aManagers[lnManager, 3] ...
							next lnManager
							.PostValidate()
							llAllValid = llAllValid and llValid
							if not llReturn
								exit
							endif not llReturn
						next lnI
					endif llReturn
		
		* Do views.
		
					if llReturn
						lnObjects = adbobjects(laObjects, 'View')
						.cValidateObjectType = 'View'
						if version(5) >= 800
							lnEngineBehavior = set('EngineBehavior')
							lcCommand        = 'set enginebehavior 70'
							&lcCommand
						endif version(5) >= 800
						for lnI = 1 to lnObjects
							lcObject = laObjects[lnI]
							.ShowStatus(strtran(ccMSG_VALIDATING_VIEW, ccMSG_INSERT1, ;
								lcObject))
							.cValidateObjectName = lcObject
							llValid = .T.
							.PreValidate()
							for lnManager = 1 to lnManagers
								lcManager = '.' + .aManagers[lnManager, 1]
								if .aManagers[lnManager, 3] and llValid
									llReturn = llReturn and evaluate(lcManager + ;
										'.Validate(lcObject, "View", lcDBC)')
									llValid  = evaluate(lcManager + '.lValidateObject')
								endif .aManagers[lnManager, 3] ...
							next lnManager
							.PostValidate()
							llAllValid = llAllValid and llValid
							if not llReturn
								exit
							endif not llReturn
						next lnI
						if version(5) >= 800
							lcCommand = 'set enginebehavior lnEngineBehavior'
							&lcCommand
						endif version(5) >= 800
					endif llReturn
		
		* Do relations.
		
					if llReturn
						lnObjects = adbobjects(laObjects, 'Relation')
						.cValidateObjectType = 'Relation'
						for lnI = 1 to lnObjects
							lcObject = laObjects[lnI, 2] + '.' + laObjects[lnI, 4] + ;
								',' + laObjects[lnI, 1] + '.' + laObjects[lnI, 3]
							.ShowStatus(strtran(ccMSG_VALIDATING_RELATION, ;
								ccMSG_INSERT1, lcObject))
							.cValidateObjectName = lcObject
							llValid = .T.
							.PreValidate()
							for lnManager = 1 to lnManagers
								lcManager = '.' + .aManagers[lnManager, 1]
								if .aManagers[lnManager, 3] and llValid
									llReturn = llReturn and evaluate(lcManager + ;
										'.Validate(lcObject, "Relation", lcDBC)')
									llValid  = evaluate(lcManager + '.lValidateObject')
								endif .aManagers[lnManager, 3] ...
							next lnManager
							.PostValidate()
							llAllValid = llAllValid and llValid
							if not llReturn
								exit
							endif not llReturn
						next lnI
					endif llReturn
		
		* Do connections.
		
					if llReturn
						lnObjects = adbobjects(laObjects, 'Connection')
						.cValidateObjectType = 'Connection'
						for lnI = 1 to lnObjects
							lcObject = laObjects[lnI]
							.ShowStatus(strtran(ccMSG_VALIDATING_CONNECTION, ;
								ccMSG_INSERT1, lcObject))
							.cValidateObjectName = lcObject
							llValid = .T.
							.PreValidate()
							for lnManager = 1 to lnManagers
								lcManager = '.' + .aManagers[lnManager, 1]
								if .aManagers[lnManager, 3] and llValid
									llReturn = llReturn and evaluate(lcManager + ;
										'.Validate(lcObject, "Connection", lcDBC)')
									llValid  = evaluate(lcManager + '.lValidateObject')
								endif .aManagers[lnManager, 3] ...
							next lnManager
							.PostValidate()
							llAllValid = llAllValid and llValid
							if not llReturn
								exit
							endif not llReturn
						next lnI
					endif llReturn
		
		* For a relation, ensure the name was specified properly and then call the
		* appropriate method for each manager.
		
				case lcObjectType = 'Relation'
					set database to (lcDBC)
					lnObjects  = adbobjects(laObjects, 'Relation')
					lnRelation = 0
					for lnI = 1 to lnObjects
						if lower(laObjects[lnI, 2] + '.' + laObjects[lnI, 4] + ',' + ;
							laObjects[lnI, 1] + '.' + ;
							laObjects[lnI, 3]) == lcObjectName
							lnRelation = lnI
							exit
						endif lower(laObjects[lnI, 2] ...
					next lnI
					if lnRelation = 0
						.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
							lcObjectName))
					else
						llReturn = .T.
						.ShowStatus(strtran(ccMSG_VALIDATING_RELATION, ccMSG_INSERT1, ;
							lcObjectName))
						.cValidateObjectType = 'Relation'
						.cValidateObjectName = lcObjectName
						llValid = .T.
						.PreValidate()
						for lnManager = 1 to lnManagers
							lcManager = '.' + .aManagers[lnManager, 1]
							if .aManagers[lnManager, 3] and llValid
								llReturn = llReturn and evaluate(lcManager + ;
									'.Validate(lcObjectName, "Relation", lcDBC)')
								llValid  = evaluate(lcManager + '.lValidateObject')
							endif .aManagers[lnManager, 3] ...
						next lnManager
						.PostValidate()
						llAllValid = llValid
					endif lnRelation = 0
		
		* Handle other objects by ensuring the specified object exists in the database
		* and then calling the appropriate method for each manager.
		
				case not empty(lcDBC)
					llReturn = .T.
					set database to (lcDBC)
					if lcObjectType = 'Index'
						lcView      = left(lcObjectName, at('.', lcObjectName) - 1)
						llViewIndex = indbc(lcView, 'View')
					else
						llViewIndex = .F.
					endif lcObjectType = 'Index'
					if indbc(lcObjectName, lcObjectType) or llViewIndex
						.ShowStatus(strtran(strtran(ccMSG_VALIDATING_OBJECT, ;
							ccMSG_INSERT1, lower(lcObjectType)), ccMSG_INSERT2, ;
							lcObjectName))
						.cValidateObjectType = lcObjectType
						.cValidateObjectName = lcObjectName
						llValid = .T.
						if version(5) >= 800
							lnEngineBehavior = set('EngineBehavior')
							lcCommand        = 'set enginebehavior 70'
							&lcCommand
						endif version(5) >= 800
						.PreValidate()
						for lnManager = 1 to lnManagers
							lcManager = '.' + .aManagers[lnManager, 1]
							if .aManagers[lnManager, 3] and llValid
								llReturn = llReturn and evaluate(lcManager + ;
									'.Validate(lcObjectName, lcObjectType, lcDBC)')
								llValid  = evaluate(lcManager + '.lValidateObject')
							endif .aManagers[lnManager, 3] ...
						next lnManager
						.PostValidate()
						if version(5) >= 800
							lcCommand = 'set enginebehavior lnEngineBehavior'
							&lcCommand
						endif version(5) >= 800
						llAllValid = llValid
					else
						.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
							lcObjectName))
					endif indbc(lcObjectName, lcObjectType) ...
		
		* Handle non-database objects.
		
				case inlist(lcObjectType, 'Table', 'Field', 'Index')
					llReturn = .T.
					.ShowStatus(strtran(strtran(ccMSG_VALIDATING_OBJECT, ;
						ccMSG_INSERT1, lower(lcObjectType)), ccMSG_INSERT2, ;
						lcObjectName))
					.cValidateObjectType = lcObjectType
					.cValidateObjectName = lcObjectName
					llValid = .T.
					.PreValidate()
					for lnManager = 1 to lnManagers
						lcManager = '.' + .aManagers[lnManager, 1]
						if .aManagers[lnManager, 3] and llValid
							llReturn = llReturn and evaluate(lcManager + ;
								'.Validate(lcObjectName, lcObjectType, lcDBC)')
							llValid  = evaluate(lcManager + '.lValidateObject')
						endif .aManagers[lnManager, 3] ...
					next lnManager
					.PostValidate()
					llAllValid = llValid
				otherwise
					.Warning(strtran(ccERR_INVALID_OBJECT_TYPE, ccMSG_INSERT1, ;
						lcObjectType))
			endcase
		
		* If everything worked, call each manager's DBCXRemoveOrphan and PackMeta
		* methods to remove orphan records.
		
			if llAllValid
				for lnManager = 1 to lnManagers
					lcManager = '.' + .aManagers[lnManager, 1]
					= evaluate(lcManager + '.DBCXRemoveOrphan()')
					= evaluate(lcManager + '.DBCXPackMeta()')
				next lnManager
			endif llAllValid
		
		* Close any cursors we opened.
		
			.CloseOpenedCursors(@laUsed)
		
		* Clean up and exit.
		
			if .lShowStatus
				wait clear
			endif .lShowStatus
			.SetDatabase(lcDatabase)
			if lcFullPath = 'OFF'
				set fullpath off
			endif lcFullPath = 'OFF'
			store '' to .cValidateObjectType, .cValidateObjectName
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE validateall		&& Validates the entire meta data
		*==============================================================================
		* Method:			ValidateAll
		* Status:			Public
		* Purpose:			Validates the entire meta data
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	11/05/2002
		* Parameters:		none
		* Returns:			.T. if all validations went OK
		* Environment in:	the managers defined in the DBCX registry table must be
		*						instantiated
		* Environment out:	all objects in the meta data have been validated
		*==============================================================================
		
		local llReturn, ;
			laObjects[1], ;
			lnObjects, ;
			lnI, ;
			lcObject
		with This
		
		* First do all databases.
		
			llReturn  = .T.
			lnObjects = .DBCXGetAllObjects('Database', @laObjects)
			for lnI = 1 to lnObjects
				lcObject = laObjects[lnI]
				lcDBC    = forceext(lcObject, 'dbc')
				do case
					case dbused(lcObject)
					case file(lcDBC)
						open database (lcDBC)
					case file(fullpath(lcDBC, .cRegistryPath))
						open database (fullpath(lcDBC, .cRegistryPath))
					otherwise
						open database (locfile(lcDBC, 'DBC'))
				endcase
				if dbused(lcObject)
					llReturn = .Validate(lcObject)
				else
					llReturn = .F.
				endif dbused(lcObject)
				if not llReturn
					exit
				endif not llReturn
			next lnI
		
		* Now do all free tables.
		
			if llReturn
				lnObjects = .DBCXGetAllObjects('!Table', @laObjects, 'CBmPath')
				for lnI = 1 to lnObjects
					lcObject = laObjects[lnI, 1]
					lcObject = iif(left(lcObject, 1) = '=', ;
						fullpath(evaluate(substr(lcObject, 2))), ;
						fullpath(lcObject, .cRegistryPath))
					llReturn = .Validate('!' + lcObject, 'Table')
					if not llReturn
						exit
					endif not llReturn
				next lnI
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE warning		&& Handles an warning condition
		*==============================================================================
		* Method:			Warning
		* Status:			Public
		* Purpose:			Handle a warning condition
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	04/19/2002
		* Parameters:		tcMessage   - the message to display
		*					tcMethod    - the method in which the warning occurred
		*						(optional: if it isn't specified, the calling stack is
		*						examined to find the name of the calling routine)
		*					tcOtherInfo - additional information for the error array
		*						(optional)
		* Returns:			.T.
		* Environment in:	This.aErrorInfo is an array containing warning and error
		*						messages
		* Environment out:	the warning has been logged to This.aErrorInfo and
		*						This.lErrorOccurred is .T.
		*					if This.lDebugMode is .T., a message is displayed to the
		*						user
		*					if the user chose Cancel, CANCEL is issued
		*==============================================================================
		
		lparameters tcMessage, ;
			tcMethod, ;
			tcOtherInfo
		local lnI, ;
			lcMethod, ;
			laError[7]
		with This
		
		* Figure out who called us if it wasn't specified.
		
			if empty(tcMethod)
				lnI = 1
				do while not empty(program(lnI)) and not '.WARNING' $ program(lnI)
					lcMethod = program(lnI)
					lnI      = lnI + 1
				enddo while not empty(program(lnI)) ...
			else
				lcMethod = tcMethod
			endif empty(tcMethod)
		
		* Log the error to the aErrorInfo array.
		
			laError    = .NULL.
			laError[2] = tcMessage
			laError[3] = tcOtherInfo
			.LogError(0, lcMethod, 0, @laError)
			.lErrorOccurred = .T.
		
		* Display a message to the user if we're in debug mode.
		
			do case
				case not .lDebugMode
				case messagebox(tcMessage + chr(13) + ccMSG_METHOD + chr(9) + lcMethod, ;
					MB_OKCANCEL + MB_ICONSTOP, .cCaption) = IDCANCEL
					wait clear
					cancel
			endcase
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS metamgr AS dbcxmgr OF "dbcxmgr.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "dbcxmgr.h"
	*<DefinedPropArrayMethod>
		*m: dbgetdbckey		&& Gets the DBCX ID for the specified object
		*m: getobjectfromid		&& Gets the object name and type from the specified DBCX ID
	*</DefinedPropArrayMethod>

	cversion = 2004.07.09
	DataSession = 1
	DoCreate = .T.
	Name = "metamgr"
	
	PROCEDURE dbcxdeleterow
		*==============================================================================
		* Method:			DBCXDeleteRow
		* Status:			Public
		* Purpose:			Convert parameters from MetaMgr DBCXDeleteRow() to DBCXMgr
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tiKey   - the DBCX ID for the object
		*					tuOther - only passed for a DBCX 2 call
		* Returns:			see DBCXMgr.DBCXDeleteRow()
		* Environment in:	see DBCXMgr.DBCXDeleteRow()
		* Environment out:	see DBCXMgr.DBCXDeleteRow()
		*==============================================================================
		
		lparameters tiKey, ;
			tuOther
		local llReturn
		with This
			llReturn = .F.
			do case
		
		* If we weren't passed any parameters, or we were passed both and they're
		* character, this must be a DBCX 2 call, so pass it on to DBCXMgr.
		
				case pcount() = 0
					luReturn = dodefault(tiKey)
				case pcount() = 2 and vartype(tiKey) = 'C' and vartype(tuOther) = 'C'
					luReturn = dodefault(tiKey, tuOther)
		
		* Find the specified DBCX ID in CoreMeta.
		
				case not vartype(tiKey) $ 'NFIBY' or tiKey < 1 or ;
					not .GetObjectFromID(tiKey)
					.Warning(ccERR_INVALID_KEY)
		
		* If we found an object with the specified DBCX ID, call the "normal" method
		* (This.cObjectName and This.cObjectType will contain the name and type of the
		* found object).
		
				otherwise
					llReturn = dodefault()
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxgetprop
		*==============================================================================
		* Method:			DBCXGetProp
		* Status:			Public
		* Purpose:			Convert parameters from MetaMgr DBCXGetProp() to DBCXMgr
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcProperty   - the property to return
		*					tiKey        - the DBCX ID for the object
		*					tlReturnExpr - .T. to return an evaluated expression
		* Returns:			see DBCXMgr.DBCXGetProp()
		* Environment in:	see DBCXMgr.DBCXGetProp()
		* Environment out:	see DBCXMgr.DBCXGetProp()
		*==============================================================================
		
		lparameters tcProperty, ;
			tiKey, ;
			tlReturnExpr
		local luReturn
		with This
			luReturn = .NULL.
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(tcProperty) <> 'C' or empty(tcProperty)
					.Warning(ccERR_NO_PROPERTY_SPECIFIED)
		
		* If we were only passed one parameter, or we were passed all three and they're
		* all character, this must be a DBCX 2 call, so pass it on to DBCXMgr.
		
				case pcount() = 1
					luReturn = dodefault(tcProperty)
				case pcount() = 3 and vartype(tiKey) = 'C' and ;
					vartype(tlReturnExpr) = 'C'
					luReturn = dodefault(tcProperty, tiKey, tlReturnExpr)
		
		* Find the specified DBCX ID in CoreMeta.
		
				case not vartype(tiKey) $ 'NFIBY' or tiKey < 1 or ;
					not .GetObjectFromID(tiKey)
					.Warning(ccERR_INVALID_KEY)
		
		* If we found an object with the specified DBCX ID, call the "normal" method
		* with the property (This.cObjectName and This.cObjectType will contain the
		* name and type of the found object).
		
				otherwise
					luReturn = dodefault(tcProperty)
			endcase
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE dbcxgetrowprop
		*==============================================================================
		* Method:			DBCXGetRowProp
		* Status:			Public
		* Purpose:			Convert parameters from MetaMgr DBCXGetRowProp() to DBCXMgr
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		taArray      - the array of properties to get values for
		*					tiKey        - the DBCX ID for the object
		*					tlReturnExpr - .T. to return an evaluated expression
		*					tcDBCX       - the manager to get values from
		* Returns:			see DBCXMgr.DBCXGetRowProp()
		* Environment in:	see DBCXMgr.DBCXGetRowProp()
		* Environment out:	see DBCXMgr.DBCXGetRowProp()
		*==============================================================================
		
		lparameters taArray, ;
			tiKey, ;
			tlReturnExpr, ;
			tcDBCX
		local llReturn
		with This
			llReturn = .F.
			do case
		
		* If we were only passed one parameter, or we were passed at least three and
		* they're character, this must be a DBCX 2 call, so pass it on to DBCXMgr.
		
				case pcount() = 1
					luReturn = dodefault(@taArray)
				case pcount() >= 3 and vartype(tiKey) = 'C' and ;
					vartype(tlReturnExpr) = 'C'
					luReturn = dodefault(@taArray, tiKey, tlReturnExpr, tcDBCX)
		
		* Find the specified DBCX ID in CoreMeta.
		
				case not vartype(tiKey) $ 'NFIBY' or tiKey < 1 or ;
					not .GetObjectFromID(tiKey)
					.Warning(ccERR_INVALID_KEY)
		
		* If we found an object with the specified DBCX ID, call the "normal" method
		* with the array and manager (This.cObjectName and This.cObjectType will
		* contain the name and type of the found object).
		
				otherwise
					llReturn = dodefault(@taArray, tcDBCX)
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxsetprop
		*==============================================================================
		* Method:			DBCXSetProp
		* Status:			Public
		* Purpose:			Convert parameters from MetaMgr DBCXSetProp() to DBCXMgr
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcProperty - the property to update
		*					tuValue    - the value to store
		*					tiKey      - the DBCX ID for the object
		*					tuOther    - only passed for a DBCX 2 call
		* Returns:			see DBCXMgr.DBCXSetProp()
		* Environment in:	see DBCXMgr.DBCXSetProp()
		* Environment out:	see DBCXMgr.DBCXSetProp()
		*==============================================================================
		
		lparameters tcProperty, ;
			tuValue, ;
			tiKey, ;
			tuOther
		local llReturn
		with This
			llReturn = .F.
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(tcProperty) <> 'C' or empty(tcProperty)
					.Warning(ccERR_NO_PROPERTY_SPECIFIED)
		
		* If we were only passed one parameter, or we were passed all four and the
		* first three are character, this must be a DBCX 2 call, so pass it on to
		* DBCXMgr.
		
				case pcount() = 1
					llReturn = dodefault(tcProperty)
				case pcount() = 4 and vartype(tuValue) = 'C' and vartype(tiKey) = 'C'
					llReturn = dodefault(tcProperty, tuValue, tiKey, tuOther)
		
		* Find the specified DBCX ID in CoreMeta.
		
				case not vartype(tiKey) $ 'NFIBY' or tiKey < 1 or ;
					not .GetObjectFromID(tiKey)
					.Warning(ccERR_INVALID_KEY)
		
		* If we found an object with the specified DBCX ID, call the "normal" method
		* with the property and value (This.cObjectName and This.cObjectType will
		* contain the name and type of the found object).
		
				otherwise
					llReturn = dodefault(tcProperty, tuValue)
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxsetrowprop
		*==============================================================================
		* Method:			DBCXSetRowProp
		* Status:			Public
		* Purpose:			Convert parameters from MetaMgr DBCXSetRowProp() to DBCXMgr
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		taArray - the array of properties to get values for
		*					tiKey   - the DBCX ID for the object
		*					tcDBCX  - the manager to get values from
		*					tuOther - only passed for a DBCX 2 call
		* Returns:			see DBCXMgr.DBCXSetRowProp()
		* Environment in:	see DBCXMgr.DBCXSetRowProp()
		* Environment out:	see DBCXMgr.DBCXSetRowProp()
		*==============================================================================
		
		lparameters taArray, ;
			tiKey, ;
			tcDBCX, ;
			tuOther
		local llReturn
		with This
			llReturn = .F.
			do case
		
		* If we were only passed one parameter, or we were passed at least three and
		* they're character, this must be a DBCX 2 call, so pass it on to DBCXMgr.
		
				case pcount() = 1
					llReturn = dodefault(@taArray)
				case pcount() >= 3 and vartype(tiKey) = 'C' and vartype(tcDBCX) = 'C'
					llReturn = dodefault(@taArray, tiKey, tcDBCX, tuOther)
		
		* Find the specified DBCX ID in CoreMeta.
		
				case not vartype(tiKey) $ 'NFIBY' or tiKey < 1 or ;
					not .GetObjectFromID(tiKey)
					.Warning(ccERR_INVALID_KEY)
		
		* If we found an object with the specified DBCX ID, call the "normal" method
		* with the array and manager (This.cObjectName and This.cObjectType will
		* contain the name and type of the found object).
		
				otherwise
					llReturn = dodefault(@taArray, tcDBCX)
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbgetdbckey		&& Gets the DBCX ID for the specified object
		*==============================================================================
		* Method:			DBGetDBCKey
		* Status:			Public
		* Purpose:			Get the DBCX ID for the specified object
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcDBC        - the database container
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcObjectName - the name of the object:
		*						<alias> for tables, views, and connections
		*						<alias>.<name> for fields and indexes
		*						<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		* Returns:			the CoreMgr iID if the object was found or 0 if not
		* Environment in:	the CoreMgr must be instantiated
		* Environment out:	if 0 is returned, This.aErrorInfo contains information
		*						about what went wrong
		*					see This.DBCXGetProp (which is called by GetCoreMgrID,
		*						which is called by this function) for other environment
		*						out notes
		*==============================================================================
		
		lparameters tcDBC, ;
			tcObjectType, ;
			tcObjectName
		local lcDBC, ;
			liID
		liID = 0
		with This
			do case
		
		* Ensure we have valid parameters.
		
				case vartype(tcDBC) <> 'C' or empty(tcDBC)
					.Warning(ccERR_NO_DBC_SPECIFIED)
				case vartype(tcObjectType) <> 'C' or empty(tcObjectType)
					.Warning(ccERR_NO_OBJ_TYPE_SPECIFIED)
				case vartype(tcObjectName) <> 'C' or empty(tcObjectName)
					.Warning(ccERR_NO_OBJ_NAME_SPECIFIED)
		
		* Use GetCoreMgrID to get the core manager's iID property.
		
				otherwise
					lcDBC = juststem(tcDBC)
					liID  = nvl(.GetCoreMgrID(lcDBC + '!' + tcObjectName, ;
						tcObjectType), 0)
			endcase
		endwith
		return liID
		
	ENDPROC

	PROTECTED PROCEDURE getobjectfromid		&& Gets the object name and type from the specified DBCX ID
		*==============================================================================
		* Method:			GetObjectFromID
		* Status:			Protected
		* Purpose:			Find an object in CoreMeta with the specified DBCX ID
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	03/18/98
		* Parameters:		tiKey - the DBCX ID
		* Returns:			.T. if an object with the specified DBCX ID was found in
		*						CoreMeta
		* Environment in:	CoreMeta must be open
		* Environment out:	if a record with the specified DBCX ID was found in
		*						CoreMeta, it's positioned to that record and
		*						This.cObjectName contains the object name (with the
		*						database added) and This.cObjectType contains the
		*						object type
		*==============================================================================
		
		lparameters tiKey
		with This
			llReturn = seek(tiKey, 'CoreMeta', 'iID')
			if llReturn
				.cObjectName = trim(CoreMeta.cDBCName - '!' - CoreMeta.cObjectNam)
				.cObjectType = CoreMeta.cRecType
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE validate
		*==============================================================================
		* Method:			Validate
		* Status:			Public
		* Purpose:			Convert parameters from MetaMgr Validate() to DBCXMgr
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		*					Toni Feltman, F1 Technologies
		* Last revision:	07/09/2004
		* Parameters:		tcDBCX    - the manager to validate
		*					tnOptions - validation options
		* Returns:			see DBCXMgr.Validate()
		* Environment in:	see DBCXMgr.Validate()
		* Environment out:	see DBCXMgr.Validate()
		*==============================================================================
		
		lparameters tcDBCX, ;
			tnOptions
		local llReturn
		if pcount() = 2 and vartype(tnOptions) = 'C'
			llReturn = dodefault(tcDBCX, tnOptions)
		else
			llReturn = dodefault()
		endif pcount() = 2 ...
		return llReturn
		
	ENDPROC

ENDDEFINE
