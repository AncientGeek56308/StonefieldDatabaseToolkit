*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sdtccontrol.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sdtcalcprops AS sdtpropspage OF "sdtccontrol.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDecimals" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtInputMask" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblInputMask" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtExpr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFormat" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblExpr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblFormat" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="spnWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="spnDecimals" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboType" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*p: lexpressionerror		&& .T. if the expression is in error
	*</DefinedPropArrayMethod>

	ctype = User
	lexpressionerror = .F.		&& .T. if the expression is in error
	Name = "sdtcalcprops"

	ADD OBJECT 'cboType' AS sdtcombobox WITH ;
		Height = 24, ;
		Left = 65, ;
		Name = "cboType", ;
		RowSource = "Thisform.aDataTypes", ;
		RowSourceType = 5, ;
		Style = 2, ;
		TabIndex = 4, ;
		Top = 25, ;
		Width = 110
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkFilter' AS sdtcheckbox WITH ;
		Caption = "Can Filter", ;
		Left = 65, ;
		Name = "chkFilter", ;
		TabIndex = 19, ;
		Top = 240
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'edtComments' AS sdteditbox WITH ;
		czoomformcaption = Comments, ;
		Height = 53, ;
		IntegralHeight = .F., ;
		Left = 65, ;
		MaxLength = 255, ;
		Name = "edtComments", ;
		TabIndex = 18, ;
		Top = 180, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'edtExpr' AS sdteditbox WITH ;
		czoomformcaption = Calculation, ;
		Height = 53, ;
		Left = 65, ;
		MaxLength = 255, ;
		Name = "edtExpr", ;
		TabIndex = 16, ;
		Top = 125, ;
		Width = 270, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'lblCaption' AS sdtlabel WITH ;
		Caption = "Caption", ;
		Height = 17, ;
		Left = 0, ;
		Name = "lblCaption", ;
		TabIndex = 13, ;
		Top = 103, ;
		Width = 45
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblComments' AS sdtlabel WITH ;
		Caption = "Comments", ;
		Left = 0, ;
		Name = "lblComments", ;
		TabIndex = 17, ;
		Top = 180
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblDecimals' AS sdtlabel WITH ;
		Caption = "Dec", ;
		Left = 265, ;
		Name = "lblDecimals", ;
		TabIndex = 7, ;
		Top = 29, ;
		Width = 24
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblExpr' AS sdtlabel WITH ;
		Caption = "Calculation", ;
		Name = "lblExpr", ;
		TabIndex = 15, ;
		Top = 125, ;
		Width = 64, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblFormat' AS sdtlabel WITH ;
		Caption = "Format", ;
		Height = 17, ;
		Left = 0, ;
		Name = "lblFormat", ;
		TabIndex = 9, ;
		Top = 53, ;
		Width = 41
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblInputMask' AS sdtlabel WITH ;
		Caption = "Input Mask", ;
		Height = 17, ;
		Left = 0, ;
		Name = "lblInputMask", ;
		TabIndex = 11, ;
		Top = 78, ;
		Width = 61
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblName' AS sdtlabel WITH ;
		Caption = "Name", ;
		Left = 0, ;
		Name = "lblName", ;
		TabIndex = 1, ;
		Top = 3
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblType' AS sdtlabel WITH ;
		Caption = "Type", ;
		Left = 0, ;
		Name = "lblType", ;
		TabIndex = 3, ;
		Top = 29
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblWidth' AS sdtlabel WITH ;
		Caption = "Width", ;
		Left = 180, ;
		Name = "lblWidth", ;
		TabIndex = 5, ;
		Top = 29, ;
		Width = 33
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'spnDecimals' AS sdtspinner WITH ;
		InputMask = "999", ;
		KeyboardHighValue = 1, ;
		KeyboardLowValue = 0, ;
		Left = 290, ;
		Name = "spnDecimals", ;
		SelectOnEntry = .T., ;
		SpinnerLowValue = 0.00, ;
		TabIndex = 8, ;
		Top = 25, ;
		Width = 49
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="spinner" />

	ADD OBJECT 'spnWidth' AS sdtspinner WITH ;
		InputMask = "999", ;
		KeyboardLowValue = 1, ;
		Left = 214, ;
		Name = "spnWidth", ;
		SelectOnEntry = .T., ;
		SpinnerLowValue = 1.00, ;
		TabIndex = 6, ;
		Top = 25, ;
		Width = 49
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="spinner" />

	ADD OBJECT 'txtCaption' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtCaption", ;
		TabIndex = 14, ;
		Top = 100, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtFormat' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtFormat", ;
		TabIndex = 10, ;
		Top = 50, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtInputMask' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtInputMask", ;
		TabIndex = 12, ;
		Top = 75, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtName' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtName", ;
		TabIndex = 2, ;
		Top = 0, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE requery
		local laDataTypes[1], ;
			lnType, ;
			lcField
		with This
		
		* No object was selected.
		
			if empty(Thisform.cCurrParent)
				.txtName.Value        = ''
				.cboType.DisplayValue = ''
				.spnWidth.Value       = 0
				.spnDecimals.Value    = 0
				.txtCaption.Value     = ''
				.txtInputMask.Value   = ''
				.txtFormat.Value      = ''
				.edtExpr.Value        = ''
				.edtComments.Value    = ''
				.chkFilter.Value      = .F.
				select _PROPERTY
				zap
		
		* An object was selected, so read properties from the database and the meta
		* data and put them into the appropriate controls.
		
			else
				acopy(Thisform.aDataTypes, laDataTypes)
				lnType  = Thisform.oUtility.ArrayScan(@laDataTypes, ;
					iif(Thisform.cCurrParentType = ccLIBRARY_TABLE, ;
					LIBCOREMETA.CTYPE, COREMETA.CTYPE), 2)
				lnType  = iif(lnType = 0, 1, lnType)
				.cboType.Requery()
				.cboType.ListIndex = lnType
				lcField = Thisform.cCurrObject
				.txtName.Value = substr(Thisform.cCurrObject, ;
					rat('.', Thisform.cCurrObject) + 1)
				if Thisform.cCurrParentType = ccLIBRARY_TABLE
					.spnWidth.Value     = LIBCOREMETA.NSIZE
					.spnDecimals.Value  = LIBCOREMETA.NDECIMALS
					.txtCaption.Value   = LIBCOREMETA.CCAPTION
					.txtInputMask.Value = LIBCOREMETA.MINPUTMASK
					.txtFormat.Value    = LIBCOREMETA.MFORMAT
					.edtExpr.Value      = LIBCOREMETA.MEXPR
					.edtComments.Value  = LIBCOREMETA.MCOMMENT
					.chkFilter.Value    = LIBSDTMETA.FILTER
				else
					.spnWidth.Value     = COREMETA.NSIZE
					.spnDecimals.Value  = COREMETA.NDECIMALS
					.chkFilter.Value    = SDTMETA.FILTER
					.txtCaption.Value   = COREMETA.CCAPTION
					.txtInputMask.Value = COREMETA.MINPUTMASK
					.txtFormat.Value    = COREMETA.MFORMAT
					.edtExpr.Value      = COREMETA.MEXPR
					.edtComments.Value  = COREMETA.MCOMMENT
				endif Thisform.cCurrParentType = ccLIBRARY_TABLE
			endif empty(Thisform.cCurrParent)
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE saveprops
		* Save the extended and DBC properties.
		
		local lcSDTAlias, ;
			lcCoreAlias, ;
			lnType, ;
			lcType, ;
			lcNewName, ;
			loNode
		with This
			lcSDTAlias  = iif(Thisform.cCurrParentType = ccLIBRARY_TABLE, ;
				'LIBSDTMETA', 'SDTMETA')
			lcCoreAlias = iif(Thisform.cCurrParentType = ccLIBRARY_TABLE, ;
				'LIBCOREMETA', 'COREMETA')
			replace FILTER with .chkFilter.Value ;
				in (lcSDTAlias)
			lnType = .cboType.ListIndex
			lcType = Thisform.aDataTypes[lnType, 2]
			replace MINPUTMASK with alltrim(.txtInputMask.Value), ;
				MFORMAT with alltrim(.txtFormat.Value), ;
				CCAPTION with alltrim(.txtCaption.Value), ;
				MCOMMENT with alltrim(.edtComments.Value), ;
				MEXPR with alltrim(.edtExpr.Value), ;
				CTYPE with lcType, ;
				NSIZE with .spnWidth.Value, ;
				NDECIMALS with .spnDecimals.Value ;
				in (lcCoreAlias)
		
		* Handle the user renaming the calculated field.
		
			lcNewName = Thisform.cCurrParent + '.' + .txtName.Value
			if not evaluate(lcSDTAlias + '.OBJECTNAME') == padr(lcNewName, ;
				len(SDTMETA.OBJECTNAME))
				replace OBJECTNAME with lcNewName ;
					in (lcSDTAlias)
				replace COBJECTNAM with lcNewName ;
					in (lcCoreAlias)
				loNode      = Thisform.oTree.SelectedItem
				loNode.Text = alltrim(.txtName.Value)
				loNode.Key  = Thisform.cDatabase + '!U' + lower(lcNewName)
			endif not evaluate(lcSDTAlias + '.OBJECTNAME') ...
		
		* Set the saved values to the same as the current values.
		
			.SetSavedValues()
		endwith
		
	ENDPROC

	PROCEDURE cboType.InteractiveChange
		local lcValue, ;
			lcType
		lcValue = This.DisplayValue
		with This.Parent
			do case
				case lcValue = 'Character'
					.spnDecimals.Value = 0
				case lcValue = 'Currency'
					.spnWidth.Value    = 8
					.spnDecimals.Value = 4
				case lcValue = 'Date' or lcValue = 'DateTime'
					.spnWidth.Value    = 8
					.spnDecimals.Value = 0
				case lcValue = 'Double'
					.spnWidth.Value    = 8
				case lcValue = 'Integer' or lcValue = 'Memo' or lcValue = 'General'
					.spnWidth.Value    = 4
					.spnDecimals.Value = 0
				case lcValue = 'Logical'
					.spnWidth.Value    = 1
					.spnDecimals.Value = 0
			endcase
			.spnWidth.Refresh()
			.spnDecimals.Refresh()
			.PropsChanged()
		endwith
		
	ENDPROC

	PROCEDURE chkFilter.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkFilter.Refresh
		with Thisform
			This.Enabled = .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject))
		endwith
		
	ENDPROC

	PROCEDURE edtComments.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE edtComments.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Enabled, ;
				This.Parent.lblComments.Enabled
		endwith
		
	ENDPROC

	PROCEDURE edtExpr.Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		This.Parent.lExpressionError = .T.
		return
		
	ENDPROC

	PROCEDURE edtExpr.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE edtExpr.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Enabled, ;
				This.Parent.lblExpr.Enabled
		endwith
		
	ENDPROC

	PROCEDURE edtExpr.validation
		* If we can evaluate the expression, store its type and size.
		
		local lcAlias, ;
			llUsed, ;
			lcType, ;
			luValue, ;
			laDataTypes[1], ;
			lnType
		with This
			lcAlias = strtran(Thisform.cCurrParent, ' ', '_')
			llUsed  = used(lcAlias)
			if not llUsed
				use (Thisform.cCurrParent) in 0 again nodata shared
			endif not llUsed
			.Parent.lExpressionError = .F.
			luValue = evaluate(.Value)
			if not .Parent.lExpressionError
				acopy(Thisform.aDataTypes, laDataTypes)
				lcType = vartype(luValue)
				lnType = Thisform.oUtility.ArrayScan(@laDataTypes, lcType, 2)
				lnType = iif(lnType = 0, 1, lnType)
				.Parent.cboType.ListIndex = lnType
				if lcType = 'C'
					.Parent.spnWidth.Value = len(luValue)
				endif lcType = 'C'
			endif not .Parent.lExpressionError
			if not llUsed and used(lcAlias)
				use in (lcAlias)
			endif not llUsed ...
		endwith
		
	ENDPROC

	PROCEDURE spnDecimals.Refresh
		This.Enabled = inlist(This.Parent.cboType.DisplayValue, 'Numeric', 'Float', ;
			'Double')
		
	ENDPROC

	PROCEDURE spnDecimals.When
		store max(This.Parent.spnWidth.Value - 2, 0) to This.KeyboardHighValue, ;
			This.SpinnerHighValue
		
	ENDPROC

	PROCEDURE spnWidth.InteractiveChange
		if This.Parent.spnDecimals.Value > 0
			This.Parent.spnDecimals.Value = min(This.Value - 2, ;
				This.Parent.spnDecimals.Value)
		endif This.Parent.spnDecimals.Value > 0
		dodefault()
		
	ENDPROC

	PROCEDURE spnWidth.Refresh
		This.Enabled = inlist(This.Parent.cboType.DisplayValue, 'Character', ;
			'Numeric', 'Float', 'Character (Binary)')
		
	ENDPROC

	PROCEDURE spnWidth.When
		local lcType
		lcType = This.Parent.cboType.DisplayValue
		with This
			do case
				case lcType = 'Character'
					store 254 to .KeyboardHighValue, .SpinnerHighValue
				case lcType = 'Numeric' or lcType = 'Float'
					store 20 to .KeyboardHighValue, .SpinnerHighValue
			endcase
		endwith
		
	ENDPROC

	PROCEDURE txtCaption.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtCaption.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Enabled, ;
				This.Parent.lblCaption.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtFormat.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtFormat.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Enabled, ;
				This.Parent.lblCaption.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtInputMask.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtInputMask.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Enabled, ;
				This.Parent.lblCaption.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtName.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtName.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Enabled, This.Parent.lblName.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtName.validation
		* Ensure the field name hasn't already been used.
		
		local lnRecno, ;
			llFound, ;
			llError
		with Thisform
			lnRecno = recno('COREMETA')
			llFound = seek(upper(padr(.cDatabase, len(cDBCName)) + 'F' + ;
				padr(.cCurrParent + '.' + This.Value, len(cObjectNam))), 'COREMETA', ;
				'OBJECTNAME')
			llError = llFound and recno('COREMETA') <> lnRecno
			go lnRecno in COREMETA
			if llError
				wait window ccERR_FIELD_EXISTS nowait
			endif llError
		endwith
		return iif(llError, 0, .T.)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtdatabaseprops AS sdtpropspage OF "sdtccontrol.vcx" 		&& A control to display database properties
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cntDBCEvents" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntStatistics" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTables" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblViews" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDBCEvents" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGetPath" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtEventFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblEventFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTableCount" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblViewCount" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdInstallSDT" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*m: relativepath		&& Sets a relative path from the DBC event file to the DBC
	*</DefinedPropArrayMethod>

	ctype = Database
	Name = "sdtdatabaseprops"

	ADD OBJECT 'chkDBCEvents' AS sdtcheckbox WITH ;
		Caption = "Handle DBC events", ;
		Left = 10, ;
		Name = "chkDBCEvents", ;
		TabIndex = 3, ;
		Top = 100, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdGetPath' AS sfputfile WITH ;
		cafterdone = This.Parent.RelativePath(), ;
		ccaption = DBC Event File, ;
		cdefault = This.Parent.txtEventFile.Value, ;
		cextensions = 'Program file (*.prg),*.PRG', ;
		cresult = This.Parent.txtEventFile.Value, ;
		Left = 305, ;
		lusecommondialog = .T., ;
		Name = "cmdGetPath", ;
		TabIndex = 6, ;
		Top = 120, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdInstallSDT' AS sdtcommandbutton WITH ;
		Caption = "Install SDT Events", ;
		Height = 27, ;
		Left = 10, ;
		Name = "cmdInstallSDT", ;
		Top = 150, ;
		Width = 115, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntDBCEvents' AS sdtlabelledbox WITH ;
		Height = 110, ;
		Left = 0, ;
		Name = "cntDBCEvents", ;
		Top = 80, ;
		Width = 335, ;
		ZOrderSet = 1, ;
		LBLLABEL.Caption = " DBC Events ", ;
		LBLLABEL.Name = "LBLLABEL", ;
		SHPBOX.Height = 104, ;
		SHPBOX.Name = "SHPBOX", ;
		SHPBOX.Width = 335
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cntStatistics' AS sdtlabelledbox WITH ;
		Height = 75, ;
		Name = "cntStatistics", ;
		Top = 200, ;
		Width = 335, ;
		ZOrderSet = 1, ;
		lblLabel.Caption = " Statistics ", ;
		lblLabel.Name = "lblLabel", ;
		shpBox.Height = 69, ;
		shpBox.Name = "shpBox", ;
		shpBox.Width = 335
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'edtComments' AS sdteditbox WITH ;
		czoomformcaption = Comments, ;
		Height = 53, ;
		IntegralHeight = .F., ;
		Left = 0, ;
		MaxLength = 255, ;
		Name = "edtComments", ;
		TabIndex = 2, ;
		Top = 20, ;
		Width = 335, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'lblComments' AS sdtlabel WITH ;
		Caption = "Database Comments", ;
		Left = 0, ;
		Name = "lblComments", ;
		TabIndex = 1, ;
		Top = 0, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblEventFile' AS sdtlabel WITH ;
		Caption = "DBC event file", ;
		Left = 10, ;
		Name = "lblEventFile", ;
		TabIndex = 4, ;
		Top = 123, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblTableCount' AS sdtlabel WITH ;
		Caption = "0", ;
		Left = 60, ;
		Name = "lblTableCount", ;
		TabIndex = 8, ;
		Top = 225, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblTables' AS sdtlabel WITH ;
		Caption = "Tables:", ;
		Left = 10, ;
		Name = "lblTables", ;
		TabIndex = 8, ;
		Top = 225, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblViewCount' AS sdtlabel WITH ;
		Caption = "0", ;
		Left = 60, ;
		Name = "lblViewCount", ;
		TabIndex = 8, ;
		Top = 240, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblViews' AS sdtlabel WITH ;
		Caption = "Views:", ;
		Left = 10, ;
		Name = "lblViews", ;
		TabIndex = 9, ;
		Top = 240, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'txtEventFile' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 95, ;
		MaxLength = 255, ;
		Name = "txtEventFile", ;
		TabIndex = 5, ;
		Top = 120, ;
		Width = 210, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE relativepath		&& Sets a relative path from the DBC event file to the DBC
		with This
			.txtEventFile.Value = lower(fullpath(.txtEventFile.Value, Thisform.cDBC))
		endwith
		
	ENDPROC

	PROCEDURE requery
		* So read properties from the database and the meta data and put them into the
		* appropriate controls.
		
		local lcEventFile, ;
			laCursors[1]
		with This
			.edtComments.Value = dbgetprop('Database', 'Database', 'Comment')
			if clVFP7ORLATER
				.chkDBCEvents.Value = dbgetprop('Database', 'Database', ;
					'DBCEvents')
				lcEventFile = dbgetprop('Database', 'Database', 'DBCEventFileName')
				.txtEventFile.Value = iif(empty(lcEventFile), '', ;
					lower(fullpath(lcEventFile, Thisform.cDBC)))
			endif clVFP7ORLATER
			.lblTableCount.Caption = transform(adbobjects(laCursors, 'Table'))
			.lblViewCount.Caption  = transform(adbobjects(laCursors, 'View'))
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE saveprops
		with This
			dbsetprop('Database', 'Database', 'Comment', .edtComments.Value)
			if clVFP7ORLATER
				dbsetprop('Database', 'Database', 'DBCEvents', .chkDBCEvents.Value)
				if .chkDBCEvents.Value
					dbsetprop('Database', 'Database', 'DBCEventFileName', ;
						alltrim(.txtEventFile.Value))
				endif .chkDBCEvents.Value
			endif clVFP7ORLATER
			.SetSavedValues()
		endwith
		
	ENDPROC

	PROCEDURE chkDBCEvents.anychange
		This.Parent.Refresh()
		
	ENDPROC

	PROCEDURE chkDBCEvents.Init
		This.Enabled = clVFP7ORLATER
		
	ENDPROC

	PROCEDURE chkDBCEvents.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE cmdGetPath.Click
		dodefault()
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE cmdGetPath.Refresh
		This.Enabled = This.Parent.chkDBCEvents.Value
		
	ENDPROC

	PROCEDURE cmdInstallSDT.Click
		local lcTempFile, ;
			lcProc, ;
			lnStart, ;
			lnEnd, ;
			lcDirectory, ;
			lcCode
		with Thisform
		
		* Remove any existing SDT event code from the current stored procedures.
		
			lcTempFile = .oUtility.TempFile('PRG')
			copy procedures to (lcTempFile)
			lcProc  = filetostr(lcTempFile)
			lnStart = atc(ccSTART_SDT_EVENT_CODE, lcProc)
			lnEnd   = atc(ccEND_SDT_EVENT_CODE,   lcProc)
			if lnStart > 0 and lnEnd > 0
				lcProc = left(lcProc, lnStart - 1) + ;
					substr(lcProc, lnEnd + len(ccEND_SDT_EVENT_CODE))
				strtofile(lcProc, lcTempFile)
				append procedures from (lcTempFile) overwrite
			endif lnStart > 0 ...
		
		* Create new event code from the template file.
		
			lcDirectory = .oUtility.GetAppDirectory(sys(16))
			if not file(lcDirectory + 'dbcevents.prg')
				lcDirectory = lcDirectory + 'SOURCE\'
			endif not file(lcDirectory + 'dbcevents.prg')
			lcCode = filetostr(lcDirectory + 'dbcevents.prg')
			lcCode = strtran(lcCode, '<METADATA_PATH>',    .oMeta.cRegistryPath)
			lcCode = strtran(lcCode, '<DBCXMGR_PATH>',     lcDirectory + ;
				'DBCXMgr.vcx')
			lcCode = strtran(lcCode, '<SDTDBUTILS_PATH>',  lcDirectory + ;
				'SDTManagers.vcx')
			strtofile(lcCode, lcTempFile)
			append procedures from (lcTempFile)
			erase (lcTempFile)
			messagebox('SDT DBC events have been installed in the stored ' + ;
				'procedures of the database. When any structural changes are made ' + ;
				'to any member of the database, the meta data will be ' + ;
				'automatically updated.', 64, .Caption)
		endwith
		
	ENDPROC

	PROCEDURE cmdInstallSDT.Refresh
		This.Enabled = This.Parent.chkDBCEvents.Value
		
	ENDPROC

	PROCEDURE edtComments.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtEventFile.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtEventFile.Refresh
		with This
			store .Parent.chkDBCEvents.Value to .Enabled, .Parent.lblEventFile.Enabled
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtdatabasespage AS sdtpropspage OF "sdtccontrol.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblDatabases" UniqueID="" Timestamp="" />

	ctype = Databases
	Name = "sdtdatabasespage"

	ADD OBJECT 'lblDatabases' AS sdtlabel WITH ;
		Caption = "0 databases in meta data", ;
		Name = "lblDatabases"
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />
	
	PROCEDURE Refresh
		with This
			.Visible = Thisform.cCurrObjectType == .cType or .lForce
			.lForce  = .F.
			if not .Visible
				nodefault
			endif not .Visible
		endwith
		
	ENDPROC

	PROCEDURE requery
		This.lblDatabases.Caption = transform(Thisform.nDBCs) + ;
			' database' + iif(Thisform.nDBCs = 1, '', 's') + ' in meta data'
		dodefault()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtextendedprops AS sdtcontainer OF "sdtcontrols.vcx" 		&& A control to display extended properties for an object.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdProperty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdProperty.grcName.grhName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdProperty.grcName.txtName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdProperty.grcType.grhType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdProperty.grcType.txtType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdProperty.grcField.grhField" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdProperty.grcField.txtField" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntValues" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*m: getextprops
		*m: saveextprop		&& Saves an extended property.
		*p: ccurrobjecttype		&& The type of the selected object.
		*p: lgotobject		&& .T. if we have a valid object.
		*p: lrefresh
	*</DefinedPropArrayMethod>

	ccurrobjecttype = 		&& The type of the selected object.
	Height = 278
	lrefresh = .F.
	Name = "sdtextendedprops"
	Width = 342

	ADD OBJECT 'cntValues' AS sdtextpropvalues WITH ;
		Left = 0, ;
		Name = "cntValues", ;
		Top = 170, ;
		chkValue.Alignment = 0, ;
		chkValue.Name = "chkValue", ;
		cmdDelete.Name = "cmdDelete", ;
		cmdEdit.Name = "cmdEdit", ;
		cmdNew.Name = "cmdNew", ;
		edtValue.Name = "edtValue", ;
		lblValue.Name = "lblValue", ;
		spnValue.Name = "spnValue", ;
		txtDValue.Name = "txtDValue", ;
		txtTValue.Name = "txtTValue", ;
		txtValue.Name = "txtValue"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'grdProperty' AS sdtgrid WITH ;
		ColumnCount = 3, ;
		DeleteMark = .F., ;
		Height = 163, ;
		Name = "grdProperty", ;
		RecordSource = "_property", ;
		ScrollBars = 2, ;
		TabIndex = 1, ;
		Width = 342, ;
		Column1.ControlSource = "_property.property", ;
		Column1.FontSize = 9, ;
		Column1.Name = "grcName", ;
		Column1.Width = 145, ;
		Column2.ControlSource = "_property.type", ;
		Column2.FontSize = 9, ;
		Column2.Name = "grcType", ;
		Column2.Width = 78, ;
		Column3.ControlSource = "_property.field_name", ;
		Column3.Name = "grcField", ;
		Column3.Width = 88
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="grid" />

	ADD OBJECT 'grdProperty.grcField.grhField' AS header WITH ;
		Caption = "SDT Field", ;
		Name = "grhField"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdProperty.grcField.txtField' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "txtField"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdProperty.grcName.grhName' AS header WITH ;
		Caption = "Property", ;
		FontSize = 9, ;
		Name = "grhName"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdProperty.grcName.txtName' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ColorSource = 3, ;
		FontSize = 9, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "txtName"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdProperty.grcType.grhType' AS header WITH ;
		Caption = "Type", ;
		FontSize = 9, ;
		Name = "grhType"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdProperty.grcType.txtType' AS textbox WITH ;
		BorderStyle = 0, ;
		FontSize = 9, ;
		Name = "txtType"
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE getextprops
		* Populate the _PROPERTY cursor with the extended properties for the specified
		* object.
		
		lparameters tcObject, ;
			tcObjectType
		local lnCurrSelect, ;
			lcCurrField, ;
			laTypes[1], ;
			lcObject, ;
			lcMeta, ;
			lnRecno, ;
			lcObjectType, ;
			lcField, ;
			lcProperty, ;
			lnWidth, ;
			lnDecimals, ;
			luValue, ;
			lcType, ;
			lnType, ;
			lcFullType
		with Thisform
			lnCurrSelect = select()
			select _PROPERTY
			lcCurrField = FIELD_NAME
			delete all
			if This.lGotObject
				acopy(.aDataTypes, laTypes)
				lcObject     = upper(juststem(tcObject))
				lcMeta       = iif(lcObject = ccLIBRARY_TABLE, 'LIBSDTMETA', 'SDTMETA')
				lnRecno      = recno(lcMeta)
				lcObjectType = left(tcObjectType, 1)
				do case
					case lcObject = ccLIBRARY_TABLE
						= seek(space(len(LIBSDTMETA.DBCNAME)) + lcObjectType + ;
							padr(upper(tcObject), len(LIBSDTMETA.OBJECTNAME)), ;
							'LIBSDTMETA', 'OBJECTNAME') and ;
							seek(space(len(LIBCOREMETA.CDBCNAME)) + lcObjectType + ;
							padr(upper(tcObject), len(LIBCOREMETA.COBJECTNAM)), ;
							'LIBCOREMETA', 'OBJECTNAME')
					case .cCurrParentType = 'Free Tables'
						.oMeta.DBCXGetProp('!' + tcObject, tcObjectType, 'SDTUpdated')
					otherwise
						.oMeta.DBCXGetProp(tcObject, tcObjectType, 'SDTUpdated')
				endcase
				select iif(lcObject = ccLIBRARY_TABLE, 'LIBSDTUSER', 'SDTUSER')
				scan for lcObjectType $ OBJECTTYPE
					lcField = trim(FIELD_NAME)
					if type(lcMeta + '.' + lcField) <> 'U'
						lcProperty = PROPERTY
						lnWidth    = FIELD_LEN
						lnDecimals = FIELD_DEC
						luValue    = evaluate(lcMeta + '.' + lcField)
						lcType     = FIELD_TYPE
						lnType     = .oUtility.ArrayScan(@laTypes, lcType, 2)
						if lnType > 0
							lcFullType = laTypes[lnType, 1]
						else
							lcFullType = 'Character'
						endif lnType > 0
		
		* If we're adding this property to the cursor, update the appropriate field
		* based on the type of the property.
		
						insert into _PROPERTY (PROPERTY, FIELD_NAME, FIELD_TYPE, ;
							TYPE, FIELD_LEN, FIELD_DEC) values (lcProperty, lcField, ;
							lcType, lcFullType, lnWidth, lnDecimals)
						do case
							case isnull(luValue)
							case lcType $ 'CM'
								replace CVALUE  with luValue in _PROPERTY
							case lcType = 'D'
								replace DVALUE  with luValue in _PROPERTY
							case lcType = 'T'
								replace DTVALUE with luValue in _PROPERTY
							case lcType = 'L'
								replace LVALUE  with luValue in _PROPERTY
							case lcType $ 'NFIBY'
								replace NVALUE  with luValue in _PROPERTY
						endcase
					endif type(lcMeta + '.' + lcField) <> 'U'
				endscan
				if not seek(lcCurrField, '_PROPERTY', 'FIELD_NAME')
					go top in _PROPERTY
				endif not seek(lcCurrField, '_PROPERTY', 'FIELD_NAME')
				.oUtility.Reposition(lnRecno, lcMeta, .DataSessionID)
			endif This.lGotObject
			select (lnCurrSelect)
			This.grdProperty.Refresh()
		endwith
		
	ENDPROC

	PROCEDURE Refresh
		with This.cntValues.lblValue
			.Visible = reccount('_PROPERTY') > 0 and This.lGotObject
			if .Visible
				.Caption = trim(_PROPERTY.PROPERTY)
			endif .Visible
		endwith
		
		* This gets around a VFP bug that sometimes doesn't refresh controls when a
		* container is refreshed.
		
		This.cntValues.Refresh()
		
	ENDPROC

	PROCEDURE saveextprop		&& Saves an extended property.
		lparameters tuValue
		local lcMeta, ;
			lcDatabase
		with Thisform
			lcMeta     = iif(.cCurrParentType = ccLIBRARY_TABLE, 'LIBSDTMETA', ;
				'SDTMETA')
			lcDatabase = iif(.cCurrParentType = ccLIBRARY_TABLE or ;
				.cCurrParentType = 'Free Tables', '', .cDatabase)
			if seek(upper(padr(lcDatabase, len(SDTMETA.DBCNAME)) + ;
				left(.cCurrObjectType, 1) + ;
				padr(.cCurrObject, len(SDTMETA.OBJECTNAME))), lcMeta, 'OBJECTNAME')
				replace (trim(_PROPERTY.FIELD_NAME)) with tuValue in (lcMeta)
			endif seek(upper(padr(lcDatabase, ...
		endwith
		
	ENDPROC

	PROCEDURE grdProperty.AfterRowColChange
		LPARAMETERS nColIndex
		with Thisform
			.LockScreen = .T.
			This.Parent.Refresh()
			.LockScreen = .F.
			dodefault(nColIndex)
		endwith
		
	ENDPROC

	PROCEDURE grdProperty.grcField.grhField.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE grdProperty.grcField.txtField.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE grdProperty.grcField.txtField.When
		return .F.
		
	ENDPROC

	PROCEDURE grdProperty.grcName.grhName.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE grdProperty.grcName.txtName.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE grdProperty.grcName.txtName.When
		return .F.
		
	ENDPROC

	PROCEDURE grdProperty.grcType.grhType.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE grdProperty.grcType.txtType.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE grdProperty.grcType.txtType.When
		return .F.
		
	ENDPROC

	PROCEDURE grdProperty.Init
		* Highlight the current row in VFP 8 and later.
		
		if version(5) >= 800
			This.HighlightStyle     = 2
			This.AllowCellSelection = .F.
			This.RecordMark         = .F.
			This.Width              = This.Width - 10
		endif version(5) >= 800
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtextpropvalues AS sdtcontainer OF "sdtcontrols.vcx" 		&& A control showing the values for the selected extended property
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="edtValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="spnValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtTValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdNew" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdEdit" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*m: handlesdtmeta		&& Closes or reopen the calling SDT form's SDTMETA table.
		*m: opensdtmetaexcl		&& Ensure that SDTMETA can be open exclusively.
		*p: lerroroccurred		&& .T. if an error occurred.
		*p: ltd		&& .T. if this object is sitting on the TD form.
	*</DefinedPropArrayMethod>

	Height = 108
	lerroroccurred = .F.		&& .T. if an error occurred.
	ltd = .F.		&& .T. if this object is sitting on the TD form.
	Name = "sdtextpropvalues"
	Width = 342

	ADD OBJECT 'chkValue' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Check1", ;
		ControlSource = "_property.lvalue", ;
		Left = 0, ;
		Name = "chkValue", ;
		TabIndex = 3, ;
		Top = 0, ;
		Visible = .F., ;
		Width = 60
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdDelete' AS sdtcommandbutton WITH ;
		Caption = "Delete", ;
		Height = 23, ;
		Left = 140, ;
		Name = "cmdDelete", ;
		TabIndex = 9, ;
		Top = 85, ;
		Width = 60
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdEdit' AS sdtcommandbutton WITH ;
		Caption = "Edit", ;
		Height = 23, ;
		Left = 205, ;
		Name = "cmdEdit", ;
		TabIndex = 10, ;
		Top = 85, ;
		Width = 60
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdNew' AS sdtcommandbutton WITH ;
		Caption = "New", ;
		Height = 23, ;
		Left = 75, ;
		Name = "cmdNew", ;
		TabIndex = 8, ;
		Top = 85, ;
		Width = 60
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'edtValue' AS sdteditbox WITH ;
		ControlSource = "_property.cvalue", ;
		czoomformcaption = Value, ;
		Height = 53, ;
		Left = 0, ;
		Name = "edtValue", ;
		TabIndex = 1, ;
		Top = 20, ;
		Visible = .F., ;
		Width = 342
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'lblValue' AS sdtlabel WITH ;
		Caption = "Value", ;
		Left = 0, ;
		Name = "lblValue", ;
		TabIndex = 7, ;
		Top = 0
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'spnValue' AS sdtspinner WITH ;
		ControlSource = "_property.nvalue", ;
		Left = 0, ;
		Name = "spnValue", ;
		SelectOnEntry = .T., ;
		TabIndex = 2, ;
		Top = 20, ;
		Visible = .F., ;
		Width = 107
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="spinner" />

	ADD OBJECT 'txtDValue' AS sdttextbox WITH ;
		ControlSource = "_property.dvalue", ;
		Left = 0, ;
		Name = "txtDValue", ;
		TabIndex = 5, ;
		Top = 20, ;
		Width = 106
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtTValue' AS sdttextbox WITH ;
		ControlSource = "_property.dtvalue", ;
		Left = 0, ;
		Name = "txtTValue", ;
		TabIndex = 6, ;
		Top = 20, ;
		Width = 106
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtValue' AS sdteditbox WITH ;
		ControlSource = "_property.cvalue", ;
		Height = 23, ;
		Left = 0, ;
		Name = "txtValue", ;
		ScrollBars = 0, ;
		TabIndex = 4, ;
		Top = 20, ;
		Visible = .F., ;
		Width = 101
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />
	
	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		if tnError = cnERR_FILE_IN_USE or tnError = cnERR_ACCESS_DENIED
			This.lErrorOccurred = .T.
		else
			return dodefault(tnError, tcMethod, tnLine)
		endif tnError = cnERR_FILE_IN_USE ...
		
	ENDPROC

	PROCEDURE handlesdtmeta		&& Closes or reopen the calling SDT form's SDTMETA table.
		lparameters tcSDTMeta, ;
			tcMetaPath, ;
			tlOpen
		if This.lTD
			Thisform.oSDTForm.HandleSDTMeta(tcSDTMeta, tcMetaPath, tlOpen)
		endif This.lTD
		
	ENDPROC

	PROCEDURE opensdtmetaexcl		&& Ensure that SDTMETA can be open exclusively.
		* Ensure that SDTMETA can be open exclusively. Otherwise, we can't edit its
		* structure.
		
		lparameters tlNoShared
		local lnCurrSelect, ;
			lcSDTMeta, ;
			lcDBF, ;
			llReturn
		lnCurrSelect = select()
		with Thisform
			This.lErrorOccurred = .F.
			lcSDTMeta  = iif(Thisform.cCurrParentType == ccLIBRARY_TABLE, ;
				'LIBSDTMETA', 'SDTMETA')
			select (lcSDTMeta)
			if This.lTD and Thisform.cCurrParentType == ccLIBRARY_TABLE and ;
				used('SDTMETA')
				use in SDTMETA
			endif This.lTD ...
			lcDBF = dbf()
			use (lcDBF) alias (lcSDTMeta) exclusive
			llReturn = not This.lErrorOccurred
			do case
				case not llReturn
					use (lcDBF) alias (lcSDTMeta) again shared
					cursorsetprop('Buffering', 1)
					.oMessage.ErrorMessage(ccERR_CANT_EDIT_PROP)
				case not tlNoShared
					use (lcDBF) alias (lcSDTMeta) again shared
					cursorsetprop('Buffering', 1)
			endcase
			This.lErrorOccurred = .F.
		endwith
		select (lnCurrSelect)
		return llReturn
		
	ENDPROC

	PROCEDURE Refresh
		* This is a workaround for a VFP bug that sometimes doesn't refresh controls
		* when a container is refreshed.
		
		for each oControl in This.Controls
			if upper(oControl.BaseClass) <> 'LABEL'
				oControl.Refresh()
			endif upper(oControl.BaseClass) <> 'LABEL'
		next oControl
		
	ENDPROC

	PROCEDURE chkValue.LostFocus
		with This
			if .Visible
				.Parent.Parent.SaveExtProp(.Value)
			endif .Visible
		endwith
		
	ENDPROC

	PROCEDURE chkValue.Refresh
		local laCount[1]
		with This
			select count(*) from _PROPERTY where not deleted() into array laCount
			.Visible = _PROPERTY.FIELD_TYPE = 'L' and .Parent.Parent.lGotObject
			.Parent.lblValue.Visible = not .Visible and laCount[1] > 0
			if .Visible
				.Caption = _PROPERTY.PROPERTY
			endif .Visible
		endwith
		
	ENDPROC

	PROCEDURE cmdDelete.Click
		* Delete the selected extended property.
		
		local lcSDTMeta, ;
			lcMetaPath, ;
			lcSDTUser, ;
			lnCurrSelect, ;
			lcField, ;
			lcType, ;
			lcSDTType
		
		* If we're on the TD form, we need to close the calling SDT form's SDTMETA.
		
		with This.Parent
			lcSDTMeta  = iif(Thisform.cCurrParentType == ccLIBRARY_TABLE, ;
				'LIBSDTMETA', 'SDTMETA')
			lcMetaPath = dbf(lcSDTMeta)
			.HandleSDTMeta(lcSDTMeta, lcMetaPath)
		
		* If the SDTMETA table can be opened exclusively, see if the user wants to
		* delete the property and if so, do it.
		
			if .OpenSDTMetaExcl() and ;
				Thisform.oMessage.YesNo(ccQST_REMOVE_EXT_PROP)
				lcSDTUser    = iif(Thisform.cCurrParentType == ccLIBRARY_TABLE, ;
					'LIBSDTUSER', 'SDTUSER')
				lnCurrSelect = select()
				select _PROPERTY
				lcField = trim(FIELD_NAME)
				delete
				skip
				if eof()
					go bottom
				endif eof()
				= seek(padr(lcField, len(SDTUSER.FIELD_NAME)), lcSDTUser, 'FIELD')
		
		* If this is the last object type using this property, completely remove it.
		* Otherwise, just remove it for this object type.
		
				lcType    = left(.Parent.cCurrObjectType, 1)
				lcSDTType = alltrim(evaluate(lcSDTUser + '.OBJECTTYPE'))
				if lcSDTType == lcType
					delete in (lcSDTUser)
		
		* If we're deleting a property for the Field Repository, we must manually do
		* it.
		
					if Thisform.cCurrParentType == ccLIBRARY_TABLE
						if not .OpenSDTMetaExcl(.T.)
							return .F.
						endif not .OpenSDTMetaExcl(.T.)
						alter table (lcSDTMeta) ;
							drop column (lcField)
						select (lcSDTMeta)
						use (lcMetaPath) alias (lcSDTMeta) shared
						cursorsetprop('Buffering', 1)
						if This.Parent.lTD and ;
							Thisform.cCurrParentType == ccLIBRARY_TABLE
							use (lcMetaPath) alias SDTMETA shared again in 0
							cursorsetprop('Buffering', 1, 'SDTMETA')
						endif This.Parent.lTD ...
						if seek(padr('SDT' + lcField, ;
							fsize('cProperty', Thisform.oMeta.cPropCursorName)), ;
							Thisform.oMeta.cPropCursorName, 'cProperty')
							select (Thisform.oMeta.cPropCursorName)
							if rlock()
								delete
								unlock
							endif rlock()
						endif seek('SDT' + lcField, ...
		
		* If we're deleting a property for a "real" object, use DBCXDeleteProp to do
		* it.
		
					else
						Thisform.oMeta.DBCXDeleteProp('SDT' + lcField, 'oSDTMgr')
					endif Thisform.cCurrParentType == ccLIBRARY_TABLE
				else
					replace OBJECTTYPE with strtran(lcSDTType, lcType) in (lcSDTUser)
				endif lcSDTType == lcType
				.Parent.Refresh()
				select (lnCurrSelect)
			endif not .OpenSDTMetaExcl() ...
		
		* If we're on the TD form, we need to reopen the calling SDT form's SDTMETA.
		
			.HandleSDTMeta(lcSDTMeta, lcMetaPath, .T.)
		endwith
		
	ENDPROC

	PROCEDURE cmdDelete.Refresh
		local laCount[1]
		select count(*) from _PROPERTY where not deleted() into array laCount
		This.Enabled = This.Parent.Parent.lGotObject and laCount[1] > 0
		
	ENDPROC

	PROCEDURE cmdEdit.Click
		local lcSDTMeta, ;
			lcMetaPath, ;
			oProperty, ;
			lcType, ;
			lcSDTUser, ;
			oNewProp, ;
			lcAlter
		
		* If we're on the TD form, we need to close the calling SDT form's SDTMETA.
		
		with This.Parent
			lcSDTMeta  = iif(Thisform.cCurrParentType == ccLIBRARY_TABLE, ;
				'LIBSDTMETA', 'SDTMETA')
			lcMetaPath = dbf(lcSDTMeta)
			.HandleSDTMeta(lcSDTMeta, lcMetaPath)
		
		* Ensure the SDTMETA table can be opened exclusively.
		
			if .OpenSDTMetaExcl()
		
		* Create a PassParameters object so we can receive multiple values back, and
		* use the NEWPROP form to define the new property.
		
				oProperty  = MakeObject('SDTPassParameters', 'SDT.VCX')
				lcType     = left(.Parent.cCurrObjectType, 1)
				lcSDTUser  = iif(Thisform.cCurrParentType == ccLIBRARY_TABLE, ;
					'LIBSDTUSER', 'SDTUSER')
				dimension oProperty.aParameters[6]
				acopy(Thisform.aDataTypes, oProperty.aArray)
				do form NEWPROP with oProperty, lcSDTUser, lcType, Thisform, 'E' ;
					name oNewProp linked
		
		* If the structure was changed, update everything necessary.
		
				if not empty(oProperty.aParameters[1])
		
		* Open SDTMETA exclusively.
		
					if not .OpenSDTMetaExcl(.T.)
						return .F.
					endif not .OpenSDTMetaExcl(.T.)
		
		* If the structure was changed, figure out what was changed and use ALTER TABLE
		* to do it.
		
					lcAlter = ''
					if not alltrim(_PROPERTY.FIELD_NAME) == oProperty.aParameters[2]
						lcAlter = 'rename column ' + alltrim(_PROPERTY.FIELD_NAME) + ;
							' to ' + alltrim(oProperty.aParameters[2])
					endif not alltrim(_PROPERTY.FIELD_NAME) == oProperty.aParameters[2]
					if not _PROPERTY.FIELD_TYPE == oProperty.aParameters[5] or ;
						_PROPERTY.FIELD_LEN <> oProperty.aParameters[4] or ;
						_PROPERTY.FIELD_DEC <> oProperty.aParameters[6]
						lcAlter = lcAlter + ' alter column ' + ;
							alltrim(oProperty.aParameters[2]) + ' ' + ;
							oProperty.aParameters[5] + '(' + ;
							iif(oProperty.aParameters[5] = 'B', '', ;
							ltrim(str(oProperty.aParameters[4])) + ;
							iif(oProperty.aParameters[6] = 0, '', ',')) + ;
							iif(oProperty.aParameters[6] = 0, '', ;
							ltrim(str(oProperty.aParameters[6]))) + ')'
					endif not _PROPERTY.FIELD_TYPE == oProperty.aParameters[5]
					if not empty(lcAlter)
						alter table (lcSDTMeta) &lcAlter
					endif not empty(lcAlter)
		
		* Reopen SDTMETA in shared mode and position SDTUSER to the correct record.
		
					select (lcSDTMeta)
					use (lcMetaPath) alias (lcSDTMeta) shared
					cursorsetprop('Buffering', 1)
					if This.Parent.lTD and Thisform.cCurrParentType == ccLIBRARY_TABLE
						use (lcMetaPath) alias SDTMETA shared again in 0
						cursorsetprop('Buffering', 1, 'SDTMETA')
					endif This.Parent.lTD ...
					= seek(_PROPERTY.FIELD_NAME, lcSDTUser, 'FIELD')
		
		* Save the changes in the _PROPERTY cursor and SDTUSER as well.
		
					replace PROPERTY with oProperty.aParameters[1], ;
						TYPE with oProperty.aParameters[3], ;
						FIELD_TYPE with oProperty.aParameters[5], ;
						FIELD_LEN with oProperty.aParameters[4], ;
						FIELD_NAME with oProperty.aParameters[2], ;
						FIELD_DEC with oProperty.aParameters[6] ;
						in _PROPERTY
					replace PROPERTY with oProperty.aParameters[1], ;
						FIELD_TYPE with oProperty.aParameters[5], ;
						FIELD_LEN with oProperty.aParameters[4], ;
						FIELD_NAME with oProperty.aParameters[2], ;
						FIELD_DEC with oProperty.aParameters[6] ;
						in (lcSDTUser)
					.lblValue.Visible = .T.
					Thisform.RefreshForm()
		
		* Set the focus to the appropriate value control.
		
					select _PROPERTY
					do case
						case FIELD_TYPE = 'C'
							.txtValue.SetFocus()
						case FIELD_TYPE = 'D'
							.txtDValue.SetFocus()
						case FIELD_TYPE = 'T'
							.txtTValue.SetFocus()
						case FIELD_TYPE = 'M'
							.edtValue.SetFocus()
						case FIELD_TYPE $ 'NFIBY'
							.spnValue.SetFocus()
						case FIELD_TYPE = 'L'
							.chkValue.SetFocus()
					endcase
				endif not empty(oProperty.aParameters[1])
			endif not .OpenSDTMetaExcl()
		
		* If we're on the TD form, we need to reopen the calling SDT form's SDTMETA.
		
			.HandleSDTMeta(lcSDTMeta, lcMetaPath, .T.)
		endwith
		
	ENDPROC

	PROCEDURE cmdEdit.Refresh
		local laCount[1]
		select count(*) from _PROPERTY where not deleted() into array laCount
		This.Enabled = This.Parent.Parent.lGotObject and laCount[1] > 0
		
	ENDPROC

	PROCEDURE cmdNew.Click
		local lcSDTMeta, ;
			lcMetaPath, ;
			oProperty, ;
			lcType, ;
			lcSDTUser, ;
			oNewProp, ;
			lcAlter
		
		* If we're on the TD form, we need to close the calling SDT form's SDTMETA.
		
		with This.Parent
			lcSDTMeta  = iif(Thisform.cCurrParentType == ccLIBRARY_TABLE, ;
				'LIBSDTMETA', 'SDTMETA')
			lcMetaPath = dbf(lcSDTMeta)
			.HandleSDTMeta(lcSDTMeta, lcMetaPath)
		
		* Ensure the SDTMETA table can be opened exclusively.
		
			if .OpenSDTMetaExcl()
		
		* Create a PassParameters object so we can receive multiple values back, and
		* use the NEWPROP form to define the new property.
		
				oProperty  = MakeObject('SDTPassParameters', 'SDT.VCX')
				lcType     = left(.Parent.cCurrObjectType, 1)
				lcSDTUser  = iif(Thisform.cCurrParentType == ccLIBRARY_TABLE, ;
					'LIBSDTUSER', 'SDTUSER')
				dimension oProperty.aParameters[6]
				acopy(Thisform.aDataTypes, oProperty.aArray)
				do form NEWPROP with oProperty, lcSDTUser, lcType, Thisform, 'N' ;
					name oNewProp linked
		
		* If a new property was defined, add it to the cursor.
		
				if not empty(oProperty.aParameters[1])
					insert into _PROPERTY (PROPERTY, TYPE, FIELD_TYPE, FIELD_LEN, ;
						FIELD_NAME, FIELD_DEC) values (oProperty.aParameters[1], ;
						oProperty.aParameters[3], oProperty.aParameters[5], ;
						oProperty.aParameters[4], oProperty.aParameters[2], ;
						oProperty.aParameters[6])
					.lblValue.Visible = .T.
					Thisform.RefreshForm()
					do case
		
		* If any new properties have been defined don't already exist, we'll have to
		* add them to the Meta Registry table.
		
						case not seek(_PROPERTY.FIELD_NAME, lcSDTUser, 'FIELD')
							insert into (lcSDTUser) ;
									(PROPERTY, ;
									OBJECTTYPE, ;
									FIELD_NAME, ;
									FIELD_TYPE, ;
									FIELD_LEN, ;
									FIELD_DEC) ;
								values ;
									(_PROPERTY.PROPERTY, ;
									lcType, ;
									_PROPERTY.FIELD_NAME, ;
									_PROPERTY.FIELD_TYPE, ;
									_PROPERTY.FIELD_LEN, ;
									_PROPERTY.FIELD_DEC)
		
		* If we're adding properties to the Field Repository, we must manually do it.
		
							if Thisform.cCurrParentType == ccLIBRARY_TABLE
								if not .OpenSDTMetaExcl(.T.)
									return .F.
								endif not .OpenSDTMetaExcl(.T.)
								if _PROPERTY.FIELD_TYPE = 'B'
									lcAlter = 'B(' + ;
										ltrim(str(_PROPERTY.FIELD_DEC)) + ')'
								else
									lcAlter = _PROPERTY.FIELD_TYPE + '(' + ;
										ltrim(str(_PROPERTY.FIELD_LEN)) + ',' + ;
										ltrim(str(_PROPERTY.FIELD_DEC)) + ')'
								endif _PROPERTY.FIELD_TYPE = 'B'
								alter table (lcSDTMeta) ;
									add column (trim(_PROPERTY.FIELD_NAME)) &lcAlter ;
									not null
								insert into (Thisform.oMeta.cPropCursorName) ;
										(cProperty, ;
										cObject, ;
										cProdName) ;
									values ;
										('SDT' + trim(_PROPERTY.FIELD_NAME), ;
										'oSDTMgr', ;
										Thisform.oMeta.oSDTMgr.cProductName)
								select (lcSDTMeta)
								use (lcMetaPath) alias (lcSDTMeta) shared
								cursorsetprop('Buffering', 1)
								if This.Parent.lTD and ;
									Thisform.cCurrParentType == ccLIBRARY_TABLE
									use (lcMetaPath) alias SDTMETA shared again in 0
									cursorsetprop('Buffering', 1, 'SDTMETA')
								endif This.Parent.lTD ...
		
		* If we're adding properties to a "real" object, use DBCXCreateProp to do it.
		
							else
								Thisform.oMeta.DBCXCreateProp('SDT' + ;
									trim(_PROPERTY.FIELD_NAME), 'oSDTMgr', ;
									_PROPERTY.PROPERTY, _PROPERTY.FIELD_TYPE, ;
									_PROPERTY.FIELD_LEN, _PROPERTY.FIELD_DEC)
							endif Thisform.cCurrParentType == ccLIBRARY_TABLE
		
		* If any new properties have been defined for this object type that already
		* exist for another property type, we just need to add this object type to the
		* Meta Registry OBJECTTYPE field.
		
						case not lcType $ evaluate(lcSDTUser + '.OBJECTTYPE')
							replace OBJECTTYPE with trim(OBJECTTYPE) + lcType ;
								in (lcSDTUser)
					endcase
		
		* Set the focus to the grid so it refreshes properly, then to the appropriate
		* value control.
		
					.Parent.grdProperty.SetFocus()
					do case
						case _PROPERTY.FIELD_TYPE = 'C'
							.txtValue.SetFocus()
						case _PROPERTY.FIELD_TYPE = 'D'
							.txtDValue.SetFocus()
						case _PROPERTY.FIELD_TYPE = 'T'
							.txtTValue.SetFocus()
						case _PROPERTY.FIELD_TYPE = 'M'
							.edtValue.SetFocus()
						case _PROPERTY.FIELD_TYPE $ 'NFIBY'
							.spnValue.SetFocus()
						case _PROPERTY.FIELD_TYPE = 'L'
							.chkValue.SetFocus()
					endcase
				endif not empty(oProperty.aParameters[1])
			endif .OpenSDTMetaExcl()
		
		* If we're on the TD form, we need to reopen the calling SDT form's SDTMETA.
		
			.HandleSDTMeta(lcSDTMeta, lcMetaPath, .T.)
		endwith
		
	ENDPROC

	PROCEDURE cmdNew.Refresh
		This.Enabled = This.Parent.Parent.lGotObject or ;
			(Thisform.cCurrParentType == ccLIBRARY_TABLE and ;
			not empty(Thisform.cCurrObject))
		
	ENDPROC

	PROCEDURE edtValue.LostFocus
		with This
			if .Visible
				.Parent.Parent.SaveExtProp(.Value)
			endif .Visible
		endwith
		
	ENDPROC

	PROCEDURE edtValue.Refresh
		This.Visible = _PROPERTY.FIELD_TYPE = 'M' and This.Parent.Parent.lGotObject
		
	ENDPROC

	PROCEDURE spnValue.LostFocus
		with This
			if .Visible
				.Parent.Parent.SaveExtProp(.Value)
			endif .Visible
		endwith
		
	ENDPROC

	PROCEDURE spnValue.Refresh
		local lcStyle
		with This
			.Visible = _PROPERTY.FIELD_TYPE $ 'NFBYI' and .Parent.Parent.lGotObject
			if .Visible
				lcStyle = Thisform.oUtility.CalcObjectStyle(This)
				if _PROPERTY.FIELD_TYPE $ 'NF'
					.InputMask = replicate('9', _PROPERTY.FIELD_LEN - ;
						_PROPERTY.FIELD_DEC - iif(_PROPERTY.FIELD_DEC > 0, 1, 0)) + ;
						iif(_PROPERTY.FIELD_DEC > 0, '.' + ;
						replicate('9', _PROPERTY.FIELD_DEC), '')
					store min(val(.InputMask), 2^32/2 - 1) to .KeyboardHighValue, ;
						.SpinnerHighValue
				else
					.InputMask = '99999999999' + iif(_PROPERTY.FIELD_DEC > 0, '.' + ;
						replicate('9', _PROPERTY.FIELD_DEC), '')
					store 2^32/2 - 1 to .KeyboardHighValue, .SpinnerHighValue
				endif _PROPERTY.FIELD_TYPE $ 'NF'
				.Width = txtwidth(.InputMask, .FontName, .FontSize, lcStyle) * ;
					fontmetric(6, .FontName, .FontSize, lcStyle) + cnSPNWIDTH
			endif .Visible
		endwith
		
	ENDPROC

	PROCEDURE txtDValue.LostFocus
		with This
			if .Visible
				.Parent.Parent.SaveExtProp(.Value)
			endif .Visible
		endwith
		
	ENDPROC

	PROCEDURE txtDValue.Refresh
		local lcStyle
		with This
			.Visible = _PROPERTY.FIELD_TYPE = 'D' and .Parent.Parent.lGotObject
			if .Visible
				lcStyle = Thisform.oUtility.CalcObjectStyle(This)
				.Width  = Thisform.oUtility.CalcExprWidth(.ControlSource, ;
					.FontName, .FontSize, lcStyle) + .Margin * 2 + ;
					iif(.SpecialEffect = cn3DBORDER, cnBORDER, 0)
			endif .Visible
		endwith
		
	ENDPROC

	PROCEDURE txtTValue.LostFocus
		with This
			if .Visible
				.Parent.Parent.SaveExtProp(.Value)
			endif .Visible
		endwith
		
	ENDPROC

	PROCEDURE txtTValue.Refresh
		local lcStyle
		with This
			.Visible = _PROPERTY.FIELD_TYPE = 'T' and .Parent.Parent.lGotObject
			if .Visible
				lcStyle = Thisform.oUtility.CalcObjectStyle(This)
				.Width  = Thisform.oUtility.CalcExprWidth(.ControlSource, ;
					.FontName, .FontSize, lcStyle) + .Margin * 2 + ;
					iif(.SpecialEffect = cn3DBORDER, cnBORDER, 0)
			endif .Visible
		endwith
		
	ENDPROC

	PROCEDURE txtValue.LostFocus
		with This
			if .Visible
				.Parent.Parent.SaveExtProp(.Value)
			endif .Visible
		endwith
		
	ENDPROC

	PROCEDURE txtValue.Refresh
		local lcStyle
		with This
			lcStyle  = Thisform.oUtility.CalcObjectStyle(This)
			.Visible = _PROPERTY.FIELD_TYPE = 'C' and .Parent.Parent.lGotObject
			if .Visible
				.MaxLength = _PROPERTY.FIELD_LEN
				.Width     = min(txtwidth(replicate('W', _PROPERTY.FIELD_LEN), .FontName, ;
					.FontSize, lcStyle) * fontmetric(6, .FontName, .FontSize, ;
					lcStyle) + .Margin * 2 + iif(.SpecialEffect = cn3DBORDER, ;
					cnBORDER, 0), .Parent.Parent.Parent.Parent.Width - 2 * .Left)
			endif .Visible
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtfieldprops AS sdtpropspage OF "sdtccontrol.vcx" 		&& A control to display field properties
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDecimals" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtInputMask" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblInputMask" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFormat" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblFormat" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtRuleExpr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblRuleExpr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtRuleText" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblRuleText" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDecimals" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkKeyField" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUpdatable" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	ctype = Field,_LIBRARY
	Name = "sdtfieldprops"

	ADD OBJECT 'chkFilter' AS sdtcheckbox WITH ;
		Caption = "Can Filter", ;
		Left = 65, ;
		Name = "chkFilter", ;
		TabIndex = 23, ;
		Top = 260
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkKeyField' AS sdtcheckbox WITH ;
		Caption = "Key Field", ;
		Left = 145, ;
		Name = "chkKeyField", ;
		TabIndex = 24, ;
		Top = 260
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkUpdatable' AS sdtcheckbox WITH ;
		Caption = "Updateable", ;
		Left = 230, ;
		Name = "chkUpdatable", ;
		TabIndex = 25, ;
		Top = 260
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'edtComments' AS sdteditbox WITH ;
		czoomformcaption = Comments, ;
		Height = 53, ;
		IntegralHeight = .F., ;
		Left = 65, ;
		MaxLength = 255, ;
		Name = "edtComments", ;
		TabIndex = 22, ;
		Top = 200, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'lblCaption' AS sdtlabel WITH ;
		Caption = "Caption", ;
		Height = 17, ;
		Left = 0, ;
		Name = "lblCaption", ;
		TabIndex = 13, ;
		Top = 103, ;
		Width = 45
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblComments' AS sdtlabel WITH ;
		Caption = "Comments", ;
		Left = 0, ;
		Name = "lblComments", ;
		TabIndex = 21, ;
		Top = 200
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblDecimals' AS sdtlabel WITH ;
		Caption = "Dec", ;
		Left = 275, ;
		Name = "lblDecimals", ;
		TabIndex = 7, ;
		Top = 28, ;
		Width = 24
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblDefault' AS sdtlabel WITH ;
		Caption = "Default", ;
		Height = 17, ;
		Left = 0, ;
		Name = "lblDefault", ;
		TabIndex = 19, ;
		Top = 178, ;
		Width = 41
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblFormat' AS sdtlabel WITH ;
		Caption = "Format", ;
		Height = 17, ;
		Left = 0, ;
		Name = "lblFormat", ;
		TabIndex = 9, ;
		Top = 53, ;
		Width = 41
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblInputMask' AS sdtlabel WITH ;
		Caption = "Input Mask", ;
		Height = 17, ;
		Left = 0, ;
		Name = "lblInputMask", ;
		TabIndex = 11, ;
		Top = 78, ;
		Width = 61
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblName' AS sdtlabel WITH ;
		Caption = "Name", ;
		Left = 0, ;
		Name = "lblName", ;
		TabIndex = 1, ;
		Top = 3
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblRuleExpr' AS sdtlabel WITH ;
		Caption = "Rule", ;
		Height = 17, ;
		Left = 0, ;
		Name = "lblRuleExpr", ;
		TabIndex = 15, ;
		Top = 128, ;
		Width = 28
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblRuleText' AS sdtlabel WITH ;
		Caption = "Message", ;
		Height = 17, ;
		Left = 0, ;
		Name = "lblRuleText", ;
		TabIndex = 17, ;
		Top = 153, ;
		Width = 53
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblType' AS sdtlabel WITH ;
		Caption = "Type", ;
		Left = 0, ;
		Name = "lblType", ;
		TabIndex = 3, ;
		Top = 28
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblWidth' AS sdtlabel WITH ;
		Caption = "Width", ;
		Left = 195, ;
		Name = "lblWidth", ;
		TabIndex = 5, ;
		Top = 28, ;
		Width = 33
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'txtCaption' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtCaption", ;
		TabIndex = 14, ;
		Top = 100, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtDecimals' AS sdtreadonlytextbox WITH ;
		Height = 23, ;
		Left = 300, ;
		Name = "txtDecimals", ;
		TabIndex = 8, ;
		Top = 25, ;
		Width = 35
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtDefault' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtDefault", ;
		TabIndex = 20, ;
		Top = 175, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtFormat' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtFormat", ;
		TabIndex = 10, ;
		Top = 50, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtInputMask' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtInputMask", ;
		TabIndex = 12, ;
		Top = 75, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtName' AS sdtreadonlytextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtName", ;
		TabIndex = 2, ;
		Top = 0, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtRuleExpr' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtRuleExpr", ;
		TabIndex = 16, ;
		Top = 125, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtRuleText' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtRuleText", ;
		TabIndex = 18, ;
		Top = 150, ;
		Width = 270
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtType' AS sdtreadonlytextbox WITH ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtType", ;
		TabIndex = 4, ;
		Top = 25, ;
		Width = 120
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtWidth' AS sdtreadonlytextbox WITH ;
		Height = 23, ;
		Left = 230, ;
		Name = "txtWidth", ;
		TabIndex = 6, ;
		Top = 25, ;
		Width = 35
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE requery
		lparameters tlForce
		local lcType, ;
			llBinary, ;
			lnStep, ;
			laDataTypes[1], ;
			lnType, ;
			lcField
		with This
		
		* No object was selected.
		
			if empty(Thisform.cCurrParent)
				.txtName.Value      = ''
				.txtType.Value      = ''
				.txtWidth.Value     = 0
				.txtDecimals.Value  = 0
				.txtCaption.Value   = ''
				.txtInputMask.Value = ''
				.txtFormat.Value    = ''
				.txtRuleExpr.Value  = ''
				.txtRuleText.Value  = ''
				.txtDefault.Value   = ''
				.edtComments.Value  = ''
				.chkFilter.Value    = .F.
				select _PROPERTY
				zap
		
		* An object was selected, so read properties from the database and the meta
		* data and put them into the appropriate controls.
		
			else
				lcType   = iif(Thisform.cCurrParentType = ccLIBRARY_TABLE, ;
					LIBCOREMETA.CTYPE, COREMETA.CTYPE)
				llBinary = iif(Thisform.cCurrParentType = ccLIBRARY_TABLE, ;
					LIBCOREMETA.LBINARY, COREMETA.LBINARY)
				do case
					case type('COREMETA.NSTEPVALUE') = 'U'
						lnStep = 0
					case Thisform.cCurrParentType = ccLIBRARY_TABLE
						lnStep = LIBCOREMETA.NSTEPVALUE
					otherwise
						lnStep = COREMETA.NSTEPVALUE
				endcase
				do case
					case lcType = 'I' and lnStep > 0
						lcType = 'Integer (Auto-Inc)'
					case lcType = 'C' and llBinary
						lcType = 'Character (Binary)'
					case lcType = 'M' and llBinary
						lcType = 'Memo (Binary)'
					otherwise
						acopy(Thisform.aDataTypes, laDataTypes)
						lnType = Thisform.oUtility.ArrayScan(@laDataTypes, lcType, 2)
						lcType = Thisform.aDataTypes[max(lnType, 1), 1]
				endcase
				lcField = Thisform.cCurrObject
				.txtName.Value = substr(Thisform.cCurrObject, ;
					rat('.', Thisform.cCurrObject) + 1)
				.txtType.Value = lcType
				do case
					case Thisform.cCurrParentType = ccLIBRARY_TABLE
						.txtWidth.Value     = LIBCOREMETA.NSIZE
						.txtDecimals.Value  = LIBCOREMETA.NDECIMALS
						.txtCaption.Value   = LIBCOREMETA.CCAPTION
						.txtInputMask.Value = LIBCOREMETA.MINPUTMASK
						.txtFormat.Value    = LIBCOREMETA.MFORMAT
						.txtRuleExpr.Value  = LIBSDTMETA.VALID
						.txtRuleText.Value  = LIBSDTMETA.ERROR
						.txtDefault.Value   = LIBSDTMETA.DEFVALUE
						.edtComments.Value  = LIBCOREMETA.MCOMMENT
						.chkFilter.Value    = LIBSDTMETA.FILTER
						.chkKeyField.Value  = .F.
						.chkUpdatable.Value = .F.
					case Thisform.cCurrParentType = 'Free Tables'
						.txtWidth.Value     = COREMETA.NSIZE
						.txtDecimals.Value  = COREMETA.NDECIMALS
						.txtCaption.Value   = COREMETA.CCAPTION
						.txtInputMask.Value = COREMETA.MINPUTMASK
						.txtFormat.Value    = COREMETA.MFORMAT
						.txtRuleExpr.Value  = ''
						.txtRuleText.Value  = ''
						.txtDefault.Value   = ''
						.edtComments.Value  = COREMETA.MCOMMENT
						.chkFilter.Value    = SDTMETA.FILTER
						.chkKeyField.Value  = .F.
						.chkUpdatable.Value = .F.
					otherwise
						.txtWidth.Value     = COREMETA.NSIZE
						.txtDecimals.Value  = COREMETA.NDECIMALS
						.txtCaption.Value   = dbgetprop(lcField, 'Field', 'Caption')
						.txtInputMask.Value = dbgetprop(lcField, 'Field', 'InputMask')
						.txtFormat.Value    = dbgetprop(lcField, 'Field', 'Format')
						.txtRuleExpr.Value  = dbgetprop(lcField, 'Field', ;
							'RuleExpression')
						.txtRuleText.Value  = dbgetprop(lcField, 'Field', 'RuleText')
						.txtDefault.Value   = iif('Auto' $ lcType, '', ;
							dbgetprop(lcField, 'Field', 'DefaultValue'))
						.edtComments.Value  = dbgetprop(lcField, 'Field', 'Comment')
						.chkFilter.Value    = SDTMETA.FILTER
						.chkKeyField.Value  = iif(Thisform.cCurrParentType = 'View', ;
							dbgetprop(lcField, 'Field', 'KeyField'), .F.)
						.chkUpdatable.Value = iif(Thisform.cCurrParentType = 'View', ;
							dbgetprop(lcField, 'Field', 'Updatable'), .F.)
				endcase
			endif empty(Thisform.cCurrParent)
		endwith
		dodefault(tlForce)
		
	ENDPROC

	PROCEDURE saveprops
		* Save the extended and DBC properties.
		
		local lcField, ;
			lcDBCAlias, ;
			lcTemp, ;
			lcAlias, ;
			lnRecno, ;
			liParentID, ;
			lcView, ;
			lcViewField
		with This
			lcField = Thisform.cCurrObject
			do case
		
		* Field repository: save the changes, then call UpdateFieldRep to update all
		* tables using this field.
		
				case Thisform.cCurrParentType = ccLIBRARY_TABLE
					replace VALID with alltrim(.txtRuleExpr.Value), ;
						ERROR with alltrim(.txtRuleText.Value), ;
						DEFVALUE with alltrim(.txtDefault.Value), ;
						FILTER with .chkFilter.Value ;
						in LIBSDTMETA
					replace MINPUTMASK with alltrim(.txtInputMask.Value), ;
						MFORMAT with alltrim(.txtFormat.Value), ;
						CCAPTION with alltrim(.txtCaption.Value), ;
						MCOMMENT with alltrim(.edtComments.Value) ;
						in LIBCOREMETA
					Thisform.UpdateFieldRep()
		
		* Free table: save the changes.
		
				case Thisform.cCurrParentType = 'Free Tables'
					replace MINPUTMASK with alltrim(.txtInputMask.Value), ;
						MFORMAT with alltrim(.txtFormat.Value), ;
						CCAPTION with alltrim(.txtCaption.Value), ;
						MCOMMENT with alltrim(.edtComments.Value) ;
						in COREMETA
					replace FILTER with .chkFilter.Value in SDTMETA
		
		* Regular table: save the changes in the database and meta data.
		
				otherwise
					dbsetprop(lcField, 'Field', 'Caption', ;
						alltrim(.txtCaption.Value))
					dbsetprop(lcField, 'Field', 'InputMask', ;
						alltrim(.txtInputMask.Value))
					dbsetprop(lcField, 'Field', 'Format', ;
						alltrim(.txtFormat.Value))
					dbsetprop(lcField, 'Field', 'Comment', ;
						alltrim(.edtComments.Value))
					replace FILTER with .chkFilter.Value in SDTMETA
		
		* If this is a view, we'll need to delete certain properties from the database
		* rather than storing them as blanks to work around a VFP bug.
		
					if Thisform.cCurrParentType = 'View'
						if empty(.txtRuleExpr.Value)
							lcDBCAlias = Thisform.oMeta.oSDTMgr.DBCOpen(Thisform.cDBC)
							Thisform.oMeta.oSDTMgr.DBCFindObject(lcField, 'Field')
							Thisform.oMeta.oSDTMgr.DBCDeleteProp(cnVF_RULE_EXPR)
						else
							lcDBCAlias = ''
							dbsetprop(lcField, 'Field', 'RuleExpression', ;
								alltrim(.txtRuleExpr.Value))
						endif empty(.txtRuleExpr.Value)
						if empty(.txtRuleText.Value)
							if empty(lcDBCAlias)
								lcDBCAlias = Thisform.oMeta.oSDTMgr.DBCOpen(Thisform.cDBC)
								Thisform.oMeta.oSDTMgr.DBCFindObject(lcField, 'Field')
							endif empty(lcDBCAlias)
							Thisform.oMeta.oSDTMgr.DBCDeleteProp(cnVF_RULE_TEXT)
						else
							dbsetprop(lcField, 'Field', 'RuleText', ;
								alltrim(.txtRuleText.Value))
						endif empty(.txtRuleText.Value)
						if empty(.txtDefault.Value)
							if empty(lcDBCAlias)
								lcDBCAlias = Thisform.oMeta.oSDTMgr.DBCOpen(Thisform.cDBC)
								Thisform.oMeta.oSDTMgr.DBCFindObject(lcField, 'Field')
							endif empty(lcDBCAlias)
							Thisform.oMeta.oSDTMgr.DBCDeleteProp(cnVF_DEFAULT)
						else
							dbsetprop(lcField, 'Field', 'DefaultValue', ;
								alltrim(.txtDefault.Value))
						endif empty(.txtDefault.Value)
						if not empty(lcDBCAlias)
							use in (lcDBCAlias)
						endif not empty(lcDBCAlias)
		
		* Save other view properties.
		
						dbsetprop(lcField, 'Field', 'KeyField',  .chkKeyField.Value)
						dbsetprop(lcField, 'Field', 'Updatable', .chkUpdatable.Value)
					endif Thisform.cCurrParentType = 'View'
		
		* If view field properties inherit from field properties, find any view fields
		* using this field as the source and update their properties.
		
					if Thisform.lViewInheritance
						wait window ccMSG_UPDATING_VIEW nowait
						lcDBCAlias = Thisform.oMeta.oSDTMgr.DBCOpen(Thisform.cDBC)
						lcTemp = Thisform.oUtility.TempFile('IDX')
						index on ObjectID to (lcTemp) compact
						lcAlias = upper(juststem(lcField))
						lcField = upper(justext(lcField))
						locate for ObjectType = ccVF_OBJ_FIELD and ;
							(upper(lcField) $ upper(Property) or upper(trim(ObjectName)) == lcField)
						do while found()
							lnRecno    = recno()
							liParentID = ParentID
							seek liParentID
							if ObjectType = ccVF_OBJ_VIEW and lcAlias $ upper(Property)
								lcView = alltrim(ObjectName)
								go lnRecno
								lcViewField = lcView + '.' + alltrim(ObjectName)
								Thisform.UpdateViewField(lcView, lcViewField)
								select (lcDBCAlias)
							else
								go lnRecno
							endif ObjectType = ccVF_OBJ_VIEW ...
							continue
						enddo while found()
						set index to
						use in (lcDBCAlias)
						erase (lcTemp)
						wait clear
					endif Thisform.lViewInheritance
			endcase
		
		* Set the saved values to the same as the current values.
		
			.SetSavedValues()
		endwith
		
	ENDPROC

	PROCEDURE chkFilter.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkFilter.Refresh
		with Thisform
			This.Enabled = .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject))
		endwith
		
	ENDPROC

	PROCEDURE chkKeyField.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkKeyField.Refresh
		with Thisform
			This.Visible = .lGotObject and .cCurrParentType = 'View'
		endwith
		
	ENDPROC

	PROCEDURE chkUpdatable.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkUpdatable.Refresh
		with Thisform
			This.Visible = .lGotObject and .cCurrParentType = 'View'
		endwith
		
	ENDPROC

	PROCEDURE edtComments.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE edtComments.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Enabled, ;
				This.Parent.lblComments.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtCaption.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtCaption.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Enabled, ;
				This.Parent.lblCaption.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtDecimals.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Parent.lblWidth.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtDefault.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtDefault.Refresh
		with Thisform
			store (.lGotObject and .cCurrParentType = 'View') or ;
				(.cCurrParentType == ccLIBRARY_TABLE and not empty(.cCurrObject)) ;
				to This.Enabled, This.Parent.lblDefault.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtFormat.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtFormat.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Enabled, ;
				This.Parent.lblFormat.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtInputMask.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtInputMask.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Enabled, ;
				This.Parent.lblInputMask.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtName.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Parent.lblName.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtRuleExpr.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtRuleExpr.Refresh
		with Thisform
			store (.lGotObject and .cCurrParentType = 'View') or ;
				(.cCurrParentType == ccLIBRARY_TABLE and not empty(.cCurrObject)) ;
				to This.Enabled, This.Parent.lblRuleExpr.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtRuleText.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtRuleText.Refresh
		with Thisform
			store (.lGotObject and .cCurrParentType = 'View') or ;
				(.cCurrParentType == ccLIBRARY_TABLE and not empty(.cCurrObject)) ;
				to This.Enabled, This.Parent.lblRuleText.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtType.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Parent.lblType.Enabled
		endwith
		
	ENDPROC

	PROCEDURE txtWidth.Refresh
		with Thisform
			store .lGotObject or (.cCurrParentType == ccLIBRARY_TABLE and ;
				not empty(.cCurrObject)) to This.Parent.lblWidth.Enabled
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtfilterinput AS sdttextbox OF "sdtcontrols.vcx" 		&& A TextBox that only permits characters matching certain rules to be entered.
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: validchar		&& A method to determine if a character is valid.
		*p: ccharvalid		&& The rule to validate all characters (except the first if cFirstCharValid isn't empty).
		*p: cfirstcharvalid		&& The rule to validate the first character.
		*p: laudiblealert		&& If .T., the field will beep when an invalid character is entered.
	*</DefinedPropArrayMethod>

	ccharvalid = 		&& The rule to validate all characters (except the first if cFirstCharValid isn't empty).
	cfirstcharvalid = 		&& The rule to validate the first character.
	Name = "sdtfilterinput"
	
	PROCEDURE about
		*==============================================================================
		* Class:			SFFilterInput
		* Based On:			SFTextBox (CONTROLS.VCX)
		* Purpose:			Only permit characters matching certain rules to be entered
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	08/29/96
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	KeyPress:		ensure the characters typed pass the defined rules
		*
		* Custom public properties added:
		*	lAudibleInput:	if .T., a beep is sounded when an invalid character is
		*					entered
		*	cCharValid:		the expression used to evaluate whether a character is
		*					valid
		*	cFirstCharValid:	the expression used to evaluate whether the first
		*						character is valid
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	ValidChar:		validate a character based on the rules
		*==============================================================================
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		local llValid
		do case
		
		* Allow cursor/movement keystrokes.
		
			case inlist(nKeyCode, 1, 2, 3, 4, 5, 6, 7, 9, 13, 15, 18, 19, 22, 24, 26, ;
				27, 127, 141, 145) or (inlist(nKeyCode, 49, 50, 52, 54, 55, 56) and ;
				nShiftAltCtrl > 0)
				llValid = .T.
		
		* If this was the first character and the first character is treated
		* differently, ensure it's valid.
		
			case This.SelStart = 0 and not empty(This.cFirstCharValid)
				llValid = This.ValidChar(nKeyCode, nShiftAltCtrl, This.cFirstCharValid)
		
		* Handle other characters.
		
			case not empty(This.cCharValid)
				llValid = This.ValidChar(nKeyCode, nShiftAltCtrl, This.cCharValid)
			otherwise
				llValid = .T.
		endcase
		
		* Don't store the keypress if it wasn't valid.
		
		if not llValid
			nodefault
		endif not llValid
		
	ENDPROC

	PROTECTED PROCEDURE validchar		&& A method to determine if a character is valid.
		lparameters tnKeyCode, ;
			tnShiftAltCtrl, ;
			tcCharValid
		local lcKey, ;
			lcCharValid, ;
			llReturn
		lcKey       = chr(tnKeyCode)
		lcCharValid = strtran(tcCharValid,  '<Key>', 'lcKey')
		lcCharValid = strtran(lcCharValid,  '<KEY>', 'lcKey')
		lcCharValid = strtran(lcCharValid,  '<key>', 'lcKey')
		if type(lcCharValid) = 'L'
			llReturn = evaluate(lcCharValid)
		else
			wait window 'The valid expression provided to SFFilterInput is invalid.'
			llReturn = .T.
		endif type(lcCharValid) = 'L'
		if not llReturn and This.lAudibleAlert
			?? chr(7)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtindexprops AS sdtpropspage OF "sdtccontrol.vcx" 		&& A control to display index properties
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDescend" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtExpression" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboCollate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblExpression" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCollate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkSelect" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*p: _memberdata
	*</DefinedPropArrayMethod>

	ctype = Index
	Name = "sdtindexprops"
	_memberdata = <VFPData>

		</VFPData>

	ADD OBJECT 'cboCollate' AS sdtreadonlycombobox WITH ;
		Left = 75, ;
		Name = "cboCollate", ;
		RowSource = "Thisform.aCollate", ;
		Style = 2, ;
		TabIndex = 12, ;
		Top = 100, ;
		Width = 173
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboType' AS sdtreadonlycombobox WITH ;
		Left = 75, ;
		Name = "cboType", ;
		RowSource = "Thisform.aIndexTypes", ;
		Style = 2, ;
		TabIndex = 5, ;
		Top = 25, ;
		Width = 100
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkDescend' AS sdtreadonlycheckbox WITH ;
		Caption = "Descending", ;
		Left = 190, ;
		Name = "chkDescend", ;
		TabIndex = 6, ;
		Top = 28, ;
		Width = 85
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkSelect' AS sdtcheckbox WITH ;
		Caption = "Selectable", ;
		Left = 190, ;
		Name = "chkSelect", ;
		TabIndex = 3, ;
		Top = 3, ;
		Width = 76
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'edtComments' AS sdteditbox WITH ;
		czoomformcaption = Comments, ;
		Height = 68, ;
		IntegralHeight = .F., ;
		Left = 75, ;
		Name = "edtComments", ;
		TabIndex = 16, ;
		Top = 150, ;
		Width = 260
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'lblCaption' AS sdtlabel WITH ;
		Caption = "Caption", ;
		Left = 0, ;
		Name = "lblCaption", ;
		TabIndex = 13, ;
		Top = 128, ;
		Width = 45
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblCollate' AS sdtlabel WITH ;
		Caption = "Collate", ;
		Left = 0, ;
		Name = "lblCollate", ;
		TabIndex = 11, ;
		Top = 103, ;
		Width = 41
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblComments' AS sdtlabel WITH ;
		Caption = "Comments", ;
		Left = 0, ;
		Name = "lblComments", ;
		TabIndex = 15, ;
		Top = 150, ;
		Width = 64
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblExpression' AS sdtlabel WITH ;
		Caption = "Expression", ;
		Left = 0, ;
		Name = "lblExpression", ;
		TabIndex = 7, ;
		Top = 53, ;
		Width = 64
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblFilter' AS sdtlabel WITH ;
		Caption = "Filter", ;
		Left = 0, ;
		Name = "lblFilter", ;
		TabIndex = 9, ;
		Top = 78, ;
		Width = 29
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblName' AS sdtlabel WITH ;
		Caption = "Tag Name", ;
		Left = 0, ;
		Name = "lblName", ;
		TabIndex = 1, ;
		Top = 3, ;
		Width = 60
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblType' AS sdtlabel WITH ;
		Caption = "Type", ;
		Left = 0, ;
		Name = "lblType", ;
		TabIndex = 4, ;
		Top = 28, ;
		Width = 28
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'txtCaption' AS sdttextbox WITH ;
		Left = 75, ;
		Name = "txtCaption", ;
		TabIndex = 14, ;
		Top = 125, ;
		Width = 260
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtExpression' AS sdtreadonlytextbox WITH ;
		Left = 75, ;
		Name = "txtExpression", ;
		TabIndex = 8, ;
		Top = 50, ;
		Width = 260
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtFilter' AS sdtreadonlytextbox WITH ;
		Left = 75, ;
		Name = "txtFilter", ;
		TabIndex = 10, ;
		Top = 75, ;
		Width = 260
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtName' AS sdtreadonlytextbox WITH ;
		Left = 75, ;
		Name = "txtName", ;
		TabIndex = 2, ;
		Width = 100
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE requery
		local laCollate[1], ;
			lcCollate, ;
			lnCollate
		with This
		
		* If _Library was or no object was selected, set the properties for various
		* objects.
		
			if Thisform.cCurrParent = ccLIBRARY_TABLE or empty(Thisform.cCurrParent)
				.txtName.Value       = ''
				.cboType.Value       = ''
				.txtExpression.Value = ''
				.txtFilter.Value     = ''
				.txtCaption.Value    = ''
				.edtComments.Value   = ''
				.cboCollate.Value    = ''
				.chkDescend.Value    = .F.
				.chkSelect.Value     = .F.
				select _PROPERTY
				zap
		
		* An object was selected, so read properties from the database and the meta
		* data and put them into the appropriate controls.
		
			else
				.txtName.Value = substr(Thisform.cCurrObject, ;
					rat('.', Thisform.cCurrObject) + 1)
				.txtExpression.Value = COREMETA.MTAGEXPR
				.txtFilter.Value     = COREMETA.MTAGFILTER
				.txtCaption.Value    = COREMETA.CCAPTION
				.edtComments.Value   = COREMETA.MCOMMENT
				acopy(Thisform.aCollate, laCollate)
				lcCollate = trim(COREMETA.CCOLLATE)
				lnCollate = Thisform.oUtility.ArrayScan(@laCollate, ;
					lcCollate, 2)
				.cboCollate.Value = iif(lnCollate > 0, laCollate[lnCollate, 1], ;
					proper(lcCollate))
				.chkDescend.Value    = not COREMETA.LASCENDING
				.chkSelect.Value     = SDTMETA.SELECT
				do case
					case COREMETA.CTAGTYPE = 'P'
						.cboType.Value = ccPRIMARY
					case COREMETA.CTAGTYPE = 'C'
						.cboType.Value = ccCANDIDATE
					case COREMETA.CTAGTYPE = 'U'
						.cboType.Value = ccUNIQUE
					case COREMETA.CTAGTYPE = 'B'
						.cboType.Value = ccBINARY
					otherwise
						.cboType.Value = ccREGULAR
				endcase
			endif Thisform.cCurrParent = ccLIBRARY_TABLE ...
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE saveprops
		* Save the extended and DBC properties.
		
		with This
			replace cCaption with alltrim(.txtCaption.Value), ;
				mComment with alltrim(.edtComments.Value) ;
				in CoreMeta
			replace Select with .chkSelect.Value in SDTMeta
		
		* Set the saved values to the same as the current values.
		
			.SetSavedValues()
		endwith
		
	ENDPROC

	PROCEDURE cboCollate.Init
		This.Visible = Thisform.lShowInternational
		dodefault()
		
	ENDPROC

	PROCEDURE cboCollate.Refresh
		store Thisform.lShowInternational to This.Visible, ;
			This.Parent.lblCollate.Visible
		
	ENDPROC

	PROCEDURE chkSelect.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkSelect.Refresh
		This.Enabled = Thisform.lGotObject
		
	ENDPROC

	PROCEDURE edtComments.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE edtComments.Refresh
		store Thisform.lGotObject to This.Enabled, This.Parent.lblComments.Enabled
		
	ENDPROC

	PROCEDURE txtCaption.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtCaption.Refresh
		with This
			store Thisform.lGotObject to .Enabled, .Parent.lblCaption.Enabled
			do case
				case not Thisform.lShowInternational and ;
					.Top <> .Parent.cboCollate.Top
					.Top                    = .Parent.cboCollate.Top
					.Parent.lblCaption.Top  = .Top + 3
					.Parent.edtComments.Top = .Top + .Height + 2
					.Parent.lblComments.Top = .Parent.edtComments.Top 
				case Thisform.lShowInternational and ;
					.Top = This.Parent.cboCollate.Top
					.Top                    = .Parent.cboCollate.Top + ;
						.Parent.cboCollate.Height + 1
					.Parent.lblCaption.Top  = .Top + 3
					.Parent.edtComments.Top = .Top + .Height + 2
					.Parent.lblComments.Top = .Parent.edtComments.Top 
			endcase
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtpropspage AS sdtcontainer OF "sdtcontrols.vcx" 		&& An abstract class to display properties for an object
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: cancelprops
		*m: propschanged
		*m: requery		&& Requeries the row source to which the ListBox or ComboBox control is bound.
		*m: saveprops
		*m: setsavedvalues
		*p: ctype		&& The type of object this container displays properties for.
		*p: lforce		&& .T. if the container is forced to visible
		*a: asaved[1,0]		&& An array of values saved before the user edited them.
	*</DefinedPropArrayMethod>

	ctype = 		&& The type of object this container displays properties for.
	Height = 280
	lforce = .F.		&& .T. if the container is forced to visible
	Name = "sdtpropspage"
	Width = 335
	
	PROCEDURE cancelprops
		* Set the current values to the same as the saved values, set lChanged to .F.,
		* and refresh the form so buttons so they can enable or disable themselves.
		
		local lnI
		Thisform.lChanged = .F.
		with This
			for lnI = 1 to .ControlCount
				if type('.Controls[lnI].Value') <> 'U'
					.Controls[lnI].Value = .aSaved[.Controls[lnI].TabIndex]
				endif type('.Controls[lnI].Value') <> 'U'
			next lnI
		endwith
		Thisform.RefreshForm()
		
	ENDPROC

	PROCEDURE Init
		dimension This.aSaved[This.ControlCount]
		dodefault()
		
	ENDPROC

	PROCEDURE propschanged
		* Set the lChanged property based on whether the user changed anything, and
		* refresh the Save and Cancel buttons so they can enable or disable themselves.
		
		local lnI
		with This
			for lnI = 1 to .ControlCount
				if type('.Controls[lnI].Value') = type('.aSaved[.Controls[lnI].TabIndex]') and ;
					not .Controls[lnI].Value == .aSaved[.Controls[lnI].TabIndex]
					Thisform.lChanged = .T.
					exit
				endif type('.Controls[lnI].Value') = ...
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE Refresh
		with This
			.Visible = Thisform.cCurrObjectType $ .cType or .lForce
			.lForce  = .F.
			if not .Visible
				nodefault
			endif not .Visible
		endwith
		
	ENDPROC

	PROCEDURE requery		&& Requeries the row source to which the ListBox or ComboBox control is bound.
		lparameters tlForce
		This.lForce = tlForce
		This.SetSavedValues()
		
	ENDPROC

	PROCEDURE saveprops
	ENDPROC

	PROCEDURE setsavedvalues
		* Set the saved values to the same as the current values, set lChanged to .F.,
		* and refresh the form so buttons so they can enable or disable themselves.
		
		local lnI
		Thisform.lChanged = .F.
		with This
			for lnI = 1 to .ControlCount
				if type('.Controls[lnI].Value') <> 'U'
					.aSaved[.Controls[lnI].TabIndex] = .Controls[lnI].Value
				endif type('.Controls[lnI].Value') <> 'U'
			next lnI
		endwith
		Thisform.RefreshForm()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdttableprops AS sdtpropspage OF "sdtccontrol.vcx" 		&& A control to display table properties
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGetPath" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPath" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPath" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCodePage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkCanUpdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAutoOpen" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkNoUpdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboCodePage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblBlockSize" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="spnBlockSize" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkFilter" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*m: relativepath
		*p: cpath		&& The full path to the table
	*</DefinedPropArrayMethod>

	cpath = 		&& The full path to the table
	ctype = Table
	Name = "sdttableprops"

	ADD OBJECT 'cboCodePage' AS sdtreadonlycombobox WITH ;
		BoundTo = .F., ;
		Left = 160, ;
		Name = "cboCodePage", ;
		RowSource = "Thisform.aCodePage", ;
		RowSourceType = 5, ;
		Style = 2, ;
		TabIndex = 15, ;
		Top = 130, ;
		Width = 166
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkAutoOpen' AS sdtcheckbox WITH ;
		Caption = "Auto Open", ;
		Name = "chkAutoOpen", ;
		TabIndex = 8, ;
		Top = 80
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkCanUpdate' AS sdtcheckbox WITH ;
		Caption = "Can Reindex/Update", ;
		Name = "chkCanUpdate", ;
		TabIndex = 9, ;
		Top = 95
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkFilter' AS sdtcheckbox WITH ;
		Caption = "Can Filter", ;
		Name = "chkFilter", ;
		TabIndex = 11, ;
		Top = 125
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkNoUpdate' AS sdtcheckbox WITH ;
		Caption = "Open NOUPDATE", ;
		Name = "chkNoUpdate", ;
		TabIndex = 10, ;
		Top = 110
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdGetPath' AS sfputfile WITH ;
		cafterdone = This.Parent.RelativePath(), ;
		cdefault = This.Parent.cPath, ;
		cextensions = 'Table (*.dbf),*.DBF', ;
		cresult = This.Parent.txtPath.Value, ;
		Left = 312, ;
		lusecommondialog = .T., ;
		Name = "cmdGetPath", ;
		TabIndex = 5, ;
		Top = 25
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'edtComments' AS sdteditbox WITH ;
		czoomformcaption = Comments, ;
		Height = 98, ;
		IntegralHeight = .F., ;
		Left = 0, ;
		MaxLength = 255, ;
		Name = "edtComments", ;
		TabIndex = 17, ;
		Top = 165, ;
		Width = 335
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'lblBlockSize' AS sdtlabel WITH ;
		Caption = "Block Size:", ;
		Left = 160, ;
		Name = "lblBlockSize", ;
		TabIndex = 12, ;
		Top = 84
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblCaption' AS sdtlabel WITH ;
		Caption = "Caption", ;
		Left = 0, ;
		Name = "lblCaption", ;
		TabIndex = 6, ;
		Top = 53
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblCodePage' AS sdtlabel WITH ;
		Caption = "Code Page", ;
		Left = 160, ;
		Name = "lblCodePage", ;
		TabIndex = 14, ;
		Top = 110
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblComments' AS sdtlabel WITH ;
		Caption = "Comments", ;
		Left = 0, ;
		Name = "lblComments", ;
		TabIndex = 16, ;
		Top = 145
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblName' AS sdtlabel WITH ;
		Caption = "Name", ;
		Left = 0, ;
		Name = "lblName", ;
		TabIndex = 1, ;
		Top = 3
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblPath' AS sdtlabel WITH ;
		Caption = "Path", ;
		Left = 0, ;
		Name = "lblPath", ;
		TabIndex = 3, ;
		Top = 28
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'spnBlockSize' AS sdtreadonlyspinner WITH ;
		KeyboardHighValue = 99999, ;
		KeyboardLowValue = 0, ;
		Left = 225, ;
		Name = "spnBlockSize", ;
		SpinnerHighValue = 99999.00, ;
		SpinnerLowValue = 0.00, ;
		TabIndex = 13, ;
		Top = 80, ;
		Width = 65
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="spinner" />

	ADD OBJECT 'txtCaption' AS sdttextbox WITH ;
		Left = 50, ;
		Name = "txtCaption", ;
		TabIndex = 7, ;
		Top = 50, ;
		Width = 285
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtName' AS sdtfilterinput WITH ;
		ccharvalid = isalpha(<key>) or isdigit(<key>) or <key> $ ' _', ;
		cfirstcharvalid = isalpha(<key>) or <key> = '_', ;
		laudiblealert = .T., ;
		Left = 50, ;
		Name = "txtName", ;
		TabIndex = 2, ;
		Width = 285
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtPath' AS sdttextbox WITH ;
		Left = 50, ;
		MaxLength = 255, ;
		Name = "txtPath", ;
		TabIndex = 4, ;
		Top = 25, ;
		Width = 260
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE relativepath
		with Thisform
			if .cCurrParentType = 'Table'
				This.txtPath.Value = lower(sys(2014, fullpath(This.txtPath.Value, ;
					.cDBC), .cDBC))
			else
				This.txtPath.Value = lower(sys(2014, fullpath(This.txtPath.Value, ;
					dbf('DBCXREG')), dbf('DBCXREG')))
			endif .cCurrParentType = 'Table'
		endwith
		
	ENDPROC

	PROCEDURE requery
		local lnCodePage, ;
			lcPath
		with This
		
		* No object was selected.
		
			if empty(Thisform.cCurrParent)
				.cPath              = ''
				.txtName.Value      = ''
				.edtComments.Value  = ''
				.txtPath.Value      = ''
				.txtCaption.Value   = ''
				.chkAutoOpen.Value  = .F.
				.chkCanUpdate.Value = .F.
				.chkNoUpdate.Value  = .F.
				.chkFilter.Value    = .F.
				.cboCodePage.Value  = 0
				.spnBlockSize.Value = 0
				select _PROPERTY
				zap
		
		* An object was selected, so read properties from the database and the meta
		* data and put them into the appropriate controls.
		
			else
				acopy(Thisform.aCodePage, laCodePage)
				lnCodePage          = Thisform.oUtility.ArrayScan(@laCodePage, ;
					COREMETA.nCodePage, 2)
				lnCodePage          = iif(lnCodePage = 0, 1, lnCodePage)
				.txtName.Value      = Thisform.cCurrParent
				if Thisform.cCurrParentType = 'Table'
					.edtComments.Value = dbgetprop(Thisform.cCurrParent, 'Table', ;
						'Comment')
					lcPath             = dbgetprop(Thisform.cCurrParent, 'Table', ;
						'Path')
					.txtPath.Value     = lcPath
					.cPath             = lower(fullpath(lcPath, dbc()))
				else
					.edtComments.Value = COREMETA.mComment
					.txtPath.Value     = COREMETA.mPath
					.cPath             = COREMETA.mPath
				endif Thisform.cCurrParentType = 'Table'
				.txtCaption.Value   = COREMETA.cCaption
				.chkAutoOpen.Value  = SDTMETA.AUTOOPEN
				.chkCanUpdate.Value = SDTMETA.CANUPDATE
				.chkNoUpdate.Value  = SDTMETA.NOUPDATE
				.chkFilter.Value    = SDTMETA.FILTER
				.cboCodePage.Value  = lnCodePage
				.spnBlockSize.Value = COREMETA.nBlockSize
			endif empty(Thisform.cCurrParent)
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE saveprops
		local lcNewName, ;
			lcOldName, ;
			laTables[1], ;
			llFound, ;
			lcFullPath, ;
			lcOldPath, ;
			laProps[1], ;
			lnHandle, ;
			oMeta, ;
			lcOldFile, ;
			lcNewFile
		
		* If the user changed the table name, ensure that name hasn't already been
		* used.
		
		with This
			if Thisform.cCurrParentType <> 'Table'
				.txtName.Value = lower(juststem(.txtPath.Value))
			endif Thisform.cCurrParentType <> 'Table'
			lcNewName = alltrim(.txtName.Value)
			lcOldName = .aSaved[.txtName.TabIndex]
			if not upper(lcOldName) == upper(lcNewName)
				adbobjects(laTables, 'Table')
				llFound = Thisform.oUtility.ArrayScan(@laTables, lcNewName) > 0
				if not llFound
					adbobjects(laTables, 'View')
					llFound = Thisform.oUtility.ArrayScan(@laTables, lcNewName) > 0
				endif not llFound
				if llFound
					wait window strtran(ccERR_TABLE_IN_DBC, ccMSG_INSERT1, lcNewName) nowait
					.txtName.SetFocus()
					return
				endif llFound
			endif not upper(lcOldName) == upper(lcNewName)
		
		* Save the extended and DBC properties.
		
			lcFullPath = trim(.txtPath.Value)
			lcOldPath  = trim(.aSaved[.txtPath.TabIndex])
			replace cCaption with alltrim(.txtCaption.Value), ;
				nCodePage with Thisform.aCodePage[.cboCodePage.Value, 2] ;
				in CoreMeta
			replace AutoOpen with .chkAutoOpen.Value, ;
				CanUpdate with .chkCanUpdate.Value, ;
				NoUpdate with .chkNoUpdate.Value, ;
				Filter with .chkFilter.Value ;
				in SDTMeta
			if Thisform.cCurrParentType = 'Table'
				dbsetprop(lcOldName, 'Table', 'Comment', .edtComments.Value)
			else
				replace mComment with .edtComments.Value, ;
					mPath with lcFullPath ;
					in CoreMeta
			endif Thisform.cCurrParentType = 'Table'
		
		* If the user renamed the table, handle it.
		
			if not upper(lcOldName) == upper(lcNewName)
				Thisform.RenameTable(lcOldName, lcNewName, 'Table')
			endif not upper(lcOldName) == upper(lcNewName)
		
		* If the user changed the path to the table or the code page, ensure the table
		* is closed so we update it properly.
		
			if not lcFullPath == lcOldPath or ;
				.aSaved[.cboCodePage.TabIndex] <> .cboCodePage.Value
				Thisform.oUtility.CloseAllAliases(lcOldPath)
			endif lcFullPath <> lcOldPath ...
		
		* If the user changed the path to the table, we need to update both the DBC and
		* the table header, and physically move the table.
		
			lnHandle = -1
			oMeta    = Thisform.oMeta
			if lcFullPath <> lcOldPath and lcFullPath <> '='
				if Thisform.cCurrParentType = 'Table'
					oMeta.oSDTMgr.DBCOpen(Thisform.cDBC)
					oMeta.oSDTMgr.DBCFindObject(lcNewName, ccVF_OBJ_TABLE)
					oMeta.oSDTMgr.DBCSetProp(cnVF_TABLE_FILEPATH, .txtPath.Value)
					use
				endif Thisform.cCurrParentType = 'Table'
		
		* Physically move the table if necessary.
		
				Thisform.oError.ResetError()
				if Thisform.cCurrParentType = 'Table'
					lcFullPath = fullpath(lcFullPath, Thisform.cDBC)
					lcOldPath  = fullpath(lcOldPath, Thisform.cDBC)
				else
					lcFullPath = fullpath(lcFullPath, dbf('DBCXREG'))
					lcOldPath  = fullpath(lcOldPath, dbf('DBCXREG'))
				endif Thisform.cCurrParentType = 'Table'
				if not lcFullPath == lcOldPath and file(lcOldPath)
					copy file (lcOldPath) to (lcFullPath)
					if not Thisform.oError.DidErrorOccur()
						erase (lcOldPath)
						lcOldFile = forceext(lcOldPath,  'CDX')
						lcNewFile = forceext(lcFullPath, 'CDX')
						if file(lcOldFile)
							copy file (lcOldFile) to (lcNewFile)
							if not Thisform.oError.DidErrorOccur()
								erase (lcOldFile)
							endif not Thisform.oError.DidErrorOccur()
						endif file(lcOldFile)
						lcOldFile = forceext(lcOldPath,  'FPT')
						lcNewFile = forceext(lcFullPath, 'FPT')
						if file(lcOldFile)
							copy file (lcOldFile) to (lcNewFile)
							if not Thisform.oError.DidErrorOccur()
								erase (lcOldFile)
							endif not Thisform.oError.DidErrorOccur()
						endif file(lcOldFile)
					endif not Thisform.oError.DidErrorOccur()
				endif not lcFullPath == lcOldPath ...
		
		* Write the backlink to the DBC.
		
				lnHandle = -1
				if file(lcFullPath) and Thisform.cCurrParentType = 'Table'
					lnHandle = oMeta.oSDTMgr.WriteBackLink(lcFullPath, ;
						sys(2014, Thisform.cDBC, lcFullPath), , ;
						.aSaved[.cboCodePage.TabIndex] <> .cboCodePage.Value)
				endif file(lcFullPath) ...
			endif lcFullPath <> lcOldPath ...
		
		* Write the code page to the header if it's changed.
		
			if .aSaved[.cboCodePage.TabIndex] <> .cboCodePage.Value and ;
				file(lcFullPath)
				lnHandle = oMeta.oSDTMgr.WriteCodePage(Thisform.aCodePage[.cboCodePage.Value, 3], ;
					lnHandle, lcFullPath)
			endif .aSaved[.cboCodePage.TabIndex] <> .cboCodePage.Value ...
		
		* Close the table if it's still open.
		
			if lnHandle > 0
				fclose(lnHandle)
			endif lnHandle > 0
		
		* Set the saved values to the same as the current values.
		
			.SetSavedValues()
		
		* If the user renamed the table, reload the tree if necessary.
		
			if not upper(lcOldName) == upper(lcNewName)
				lcKey = Thisform.GetNodeKey(lcNewName, 'Table', Thisform.cDatabase)
				if type('Thisform.oTree.Nodes.Item(lcKey)') = 'O'
					llExpanded = Thisform.oTree.Nodes[lcKey].Expanded
					Thisform.oTree.Nodes.Remove(lcKey)
					if empty(Thisform.cDatabase)
						loNode = Thisform.LoadFreeTable(lcNewName)
					else
						loNode = Thisform.LoadDatabaseCursor(lcNewName, 'Table', ;
							Thisform.cDatabase)
					endif empty(Thisform.cDatabase)
					Thisform.TreeExpand(loNode, .T.)
				endif type('Thisform.oTree.Nodes.Item(lcKey)') = 'O'
			endif not upper(lcOldName) == upper(lcNewName)
		endwith
		
	ENDPROC

	PROCEDURE cboCodePage.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE cboCodePage.Refresh
		with Thisform
			store .lGotTable to This.Enabled, This.Parent.lblCodePage.Enabled
			store .lShowInternational to This.Visible, This.Parent.lblCodePage.Visible
		endwith
		
	ENDPROC

	PROCEDURE cboCodePage.validation
		* Ensure that all index collate sequences are valid for this code page.
		
		local lcTable, ;
			lcFile, ;
			luReturn, ;
			laCollate[1], ;
			lcCodePage, ;
			lnI, ;
			lnCollate
		with Thisform
			lcTable  = .cCurrParent
			if .cCurrParentType = 'Table'
				lcFile = fullpath(dbgetprop(lcTable, 'Table', 'Path'), .cDBC)
			else
				lcFile = fullpath(COREMETA.mPath, dbf('DBCXREG'))
			endif .cCurrParentType = 'Table'
			luReturn = .T.
			if file(lcFile) and .oMeta.oSDTMgr.OpenTable(lcTable)
				.oMeta.oSDTMgr.GetCollateArray(@laCollate)
				lcCodePage = ltrim(str(.aCodePage[This.Value, 2]))
				for lnI = 1 to tagcount()
					lnCollate = .oUtility.ArrayScan(@laCollate, idxcollate(lnI), 2)
					if not lcCodePage + ',' $ laCollate[lnCollate, 3] + ','
						.oMessage.ErrorMessage(strtran(strtran(ccERR_INVALID_COLLATE, ;
							ccMSG_INSERT1, idxcollate(lnI)), ccMSG_INSERT2, tag(lnI)))
						This.Value = This.aSaved[This.TabIndex]
						This.Refresh()
						luReturn = 0
						exit
					endif not lcCodePage + ',' $ laCollate[lnCollate, 3] + ','
				next lnI
				use
			endif file(lcFile) ...
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE chkAutoOpen.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkAutoOpen.Refresh
		This.Enabled = Thisform.lGotObject
		
	ENDPROC

	PROCEDURE chkCanUpdate.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkCanUpdate.Refresh
		This.Enabled = Thisform.lGotTable
		
	ENDPROC

	PROCEDURE chkFilter.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkFilter.Refresh
		This.Enabled = Thisform.lGotObject
		
	ENDPROC

	PROCEDURE chkNoUpdate.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkNoUpdate.Refresh
		This.Enabled = Thisform.lGotObject
		
	ENDPROC

	PROCEDURE cmdGetPath.Click
		dodefault()
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE cmdGetPath.Refresh
		store Thisform.lGotTable to This.Enabled, This.Parent.lblPath.Enabled
		
	ENDPROC

	PROCEDURE edtComments.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE edtComments.Refresh
		store Thisform.lGotObject to This.Enabled, This.Parent.lblComments.Enabled
		
	ENDPROC

	PROCEDURE spnBlockSize.Refresh
		store Thisform.lGotTable to This.Enabled, This.Parent.lblBlockSize.Enabled
		
	ENDPROC

	PROCEDURE txtCaption.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtCaption.Refresh
		store Thisform.lGotObject to This.Enabled, This.Parent.lblCaption.Enabled
		
	ENDPROC

	PROCEDURE txtName.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtName.Refresh
		store Thisform.lGotObject and not Thisform.cCurrParentType = 'Free Tables' ;
			to This.Enabled, This.Parent.lblName.Enabled
		
	ENDPROC

	PROCEDURE txtPath.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtPath.Refresh
		This.Enabled = Thisform.lGotTable and Thisform.cCurrParentType = 'Free Tables'
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtviewprops AS sdtpropspage OF "sdtccontrol.vcx" 		&& A control to display view properties
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAutoOpen" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkNoUpdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkVD" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUpdatable" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtSQL" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblSQL" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	ctype = View
	Name = "sdtviewprops"

	ADD OBJECT 'chkAutoOpen' AS sdtcheckbox WITH ;
		Caption = "Auto Open", ;
		Left = 0, ;
		Name = "chkAutoOpen", ;
		TabIndex = 5, ;
		Top = 55
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkFilter' AS sdtcheckbox WITH ;
		Caption = "Can Filter", ;
		Left = 230, ;
		Name = "chkFilter", ;
		TabIndex = 7, ;
		Top = 55
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkNoUpdate' AS sdtcheckbox WITH ;
		Caption = "Open NOUPDATE", ;
		Left = 95, ;
		Name = "chkNoUpdate", ;
		TabIndex = 6, ;
		Top = 55
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkUpdatable' AS sdtcheckbox WITH ;
		Caption = "Updateable", ;
		Left = 0, ;
		Name = "chkUpdatable", ;
		TabIndex = 8, ;
		Top = 75
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkVD' AS sdtcheckbox WITH ;
		Caption = "Modify in View Designer", ;
		Left = 95, ;
		Name = "chkVD", ;
		TabIndex = 9, ;
		Top = 75
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'edtComments' AS sdteditbox WITH ;
		czoomformcaption = Comments, ;
		Height = 68, ;
		Left = 0, ;
		MaxLength = 255, ;
		Name = "edtComments", ;
		TabIndex = 13, ;
		Top = 210, ;
		Width = 335
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'edtSQL' AS sdtreadonlyeditbox WITH ;
		Height = 68, ;
		IntegralHeight = .F., ;
		Left = 0, ;
		Name = "edtSQL", ;
		TabIndex = 11, ;
		Top = 120, ;
		Width = 335
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'lblCaption' AS sdtlabel WITH ;
		Caption = "Caption", ;
		Left = 0, ;
		Name = "lblCaption", ;
		TabIndex = 3, ;
		Top = 28
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblComments' AS sdtlabel WITH ;
		Caption = "Comments", ;
		Left = 0, ;
		Name = "lblComments", ;
		TabIndex = 12, ;
		Top = 190
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblName' AS sdtlabel WITH ;
		Caption = "Name", ;
		Left = 0, ;
		Name = "lblName", ;
		TabIndex = 1, ;
		Top = 3
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblSQL' AS sdtlabel WITH ;
		Caption = "SQL", ;
		Left = 0, ;
		Name = "lblSQL", ;
		TabIndex = 10, ;
		Top = 100
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'txtCaption' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 50, ;
		Name = "txtCaption", ;
		TabIndex = 4, ;
		Top = 25, ;
		Width = 285
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtName' AS sdtfilterinput WITH ;
		Height = 23, ;
		laudiblealert = .T., ;
		Left = 50, ;
		Name = "txtName", ;
		TabIndex = 2, ;
		Top = 0, ;
		Width = 285
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE requery
		with This
		
		* No object was selected.
		
			if empty(Thisform.cCurrParent)
				.txtName.Value      = ''
				.txtCaption.Value   = ''
				.chkAutoOpen.Value  = .F.
				.chkNoUpdate.Value  = .F.
				.chkFilter.Value    = .F.
				.chkVD.Value        = .F.
				.chkUpdatable.Value = .F.
				.edtSQL.Value       = ''
				.edtComments.Value  = ''
				select _PROPERTY
				zap
		
		* An object was selected, so read properties from the database and the meta
		* data and put them into the appropriate controls.
		
			else
				.txtName.Value      = Thisform.cCurrParent
				.txtCaption.Value   = COREMETA.CCAPTION
				.chkAutoOpen.Value  = SDTMETA.AUTOOPEN
				.chkNoUpdate.Value  = SDTMETA.NOUPDATE
				.chkFilter.Value    = SDTMETA.FILTER
				.chkVD.Value        = SDTMETA.USEVD
				.chkUpdatable.Value = dbgetprop(Thisform.cCurrParent, 'View', ;
					'SendUpdates')
				.edtComments.Value  = dbgetprop(Thisform.cCurrParent, 'View', ;
					'Comment')
				.edtSQL.Value       = dbgetprop(Thisform.cCurrParent, 'View', ;
					'SQL')
			endif empty(Thisform.cCurrParent)
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE saveprops
		local lcNewName, ;
			lcOldName, ;
			laTables[1], ;
			llFound
		
		* If the user changed the name, ensure that name hasn't already been used.
		
		with This
			lcNewName = alltrim(.txtName.Value)
			lcOldName = .aSaved[.txtName.TabIndex]
			if not upper(lcOldName) == upper(lcNewName)
				adbobjects(laTables, 'Table')
				llFound = Thisform.oUtility.ArrayScan(@laTables, lcNewName) > 0
				if not llFound
					adbobjects(laTables, 'View')
					llFound = Thisform.oUtility.ArrayScan(@laTables, lcNewName) > 0
				endif not llFound
				if llFound
					wait window strtran(ccERR_TABLE_IN_DBC, ccMSG_INSERT1, lcNewName) ;
						nowait
					.txtName.SetFocus()
					return
				endif llFound
			endif not upper(lcOldName) == upper(lcNewName)
		
		* Save the extended and DBC properties.
		
			replace cCaption with alltrim(.txtCaption.Value) in CoreMeta
			replace AutoOpen with .chkAutoOpen.Value, ;
				NoUpdate with .chkNoUpdate.Value, ;
				Filter with .chkFilter.Value, ;
				UseVD with .chkVD.Value ;
				in SDTMeta
			dbsetprop(lcOldName, 'View', 'Comment',     .edtComments.Value)
			dbsetprop(lcOldName, 'View', 'SendUpdates', .chkUpdatable.Value)
		
		* If the user renamed the view, handle it.
		
			if not upper(lcOldName) == upper(lcNewName)
				Thisform.RenameTable(lcOldName, lcNewName, 'View')
			endif not upper(lcOldName) == upper(lcNewName)
		
		* Set the saved values to the same as the current values.
		
			.SetSavedValues()
		endwith
		
	ENDPROC

	PROCEDURE chkAutoOpen.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkAutoOpen.Refresh
		This.Enabled = Thisform.lGotObject
		
	ENDPROC

	PROCEDURE chkFilter.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkFilter.Refresh
		This.Enabled = Thisform.lGotObject
		
	ENDPROC

	PROCEDURE chkNoUpdate.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkNoUpdate.Refresh
		This.Enabled = Thisform.lGotObject
		
	ENDPROC

	PROCEDURE chkUpdatable.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE chkUpdatable.Refresh
		This.Enabled = Thisform.lGotObject
		
	ENDPROC

	PROCEDURE chkVD.InteractiveChange
		This.Parent.PropsChanged()
		Thisform.cmdModify.Refresh()
		
	ENDPROC

	PROCEDURE chkVD.Refresh
		This.Enabled = Thisform.lGotObject
		
	ENDPROC

	PROCEDURE edtComments.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE edtComments.Refresh
		store Thisform.lGotObject to This.Enabled, This.Parent.lblComments.Enabled
		
	ENDPROC

	PROCEDURE edtSQL.InteractiveChange
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE edtSQL.Refresh
		This.Parent.lblSQL.Enabled = Thisform.lGotObject
		
	ENDPROC

	PROCEDURE txtCaption.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtCaption.Refresh
		store Thisform.lGotObject to This.Enabled, This.Parent.lblCaption.Enabled
		
	ENDPROC

	PROCEDURE txtName.LostFocus
		This.Parent.PropsChanged()
		
	ENDPROC

	PROCEDURE txtName.Refresh
		store Thisform.lGotObject to This.Enabled, This.Parent.lblName.Enabled
		
	ENDPROC

ENDDEFINE
