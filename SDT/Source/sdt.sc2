*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sdt.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
#INCLUDE "sdt.h"

DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	DataSource = .NULL.
	Height = 0
	Left = 0
	Name = "Dataenvironment"
	Top = 0
	Width = 0

ENDDEFINE

DEFINE CLASS frmsdt AS sdtform OF "sdtcontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="pgfProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProps.Page1.cntDatabasesProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProps.Page1.cntCalcProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProps.Page1.cntTableProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProps.Page1.cntViewProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProps.Page1.cntFieldProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProps.Page1.cntIndexProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProps.Page1.cntDatabaseProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProps.Page2.cntExtProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdModify" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBrowse" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdReindex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdUpdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemove" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCopy" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBatchAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdNew" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPack" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDocument" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFieldRep" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPref" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oReg" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oImageListLoader" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oTreeViewLoader" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oCommonDialog" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDatabase" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtObject" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ctrOpenMRU" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oTreeShape" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdWizard" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRedefine" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrFocus" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oDBUtilities" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oPersist" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addmetapathtomru		&& Adds a meta data path to the MRU list
		*m: addobjecttometadata		&& Adds an object to the meta data
		*m: addoneobjecttometadata		&& Adds a single object to the meta data
		*m: askformetapath		&& Asks the user to locate a set of meta data tables
		*m: batchaddobjects		&& Adds all objects in a directory
		*m: browsetable
		*m: calctwipsperpixel		&& Calculates the number of twips (needed for TreeView.HitTest) per pixel.
		*m: convertpreferences		&& Converts preferences from the former version of SDT to the current one
		*m: copyonetable
		*m: copytable
		*m: copytabletodbc		&& Copies the specified view or table to the DBC
		*m: createnewobject		&& Creates a new object of the appropriate type
		*m: displayversion		&& Displays the current version
		*m: document
		*m: donetd		&& Handles any changes after the TD form is done.
		*m: fieldwizard		&& Updates views to match changes to the current field
		*m: findallusesoftable
		*m: findlastnode		&& Finds the last child node
		*m: findmetatables
		*m: getdatabasefromnodekey		&& Returns the database part of the specified node key
		*m: getdatabaseobject		&& Finds the specified object in the database and read all properties for it.
		*m: getmetadbf
		*m: getmetapaths		&& Get the meta data paths from the Registry
		*m: getnewfile
		*m: getnodekey		&& Creates a key for the specified object
		*m: getobjectfromnodekey		&& Returns the object name part of the specified node key
		*m: getpreferences
		*m: handlesdtmeta		&& Opens or closes SDTMETA.DBF as necessary.
		*m: loadcursor
		*m: loaddatabase		&& Loads a single database into the TreeView
		*m: loaddatabasecursor		&& Loads a single table or view into the TreeView
		*m: loaddatabasecursors		&& Loads the cursors of the specified type in the specified database into the TreeView
		*m: loaddatabases		&& Loads the database in the meta data into the TreeView
		*m: loadfieldrep		&& Loads the tree with Field Repository objects
		*m: loadfreetable		&& Loads a single free table into the TreeView
		*m: loadfreetables		&& Loads the tree with information on free tables
		*m: loadobject		&& Loads the specified object in the TreeView
		*m: loadtree
		*m: loadtreecursor		&& Loads the tree with a single cursor
		*m: modidata		&& Displays the Database Designer.
		*m: modifyobject
		*m: modifytable
		*m: movetable
		*m: newdatabase		&& Creates a new database and adds it to the meta data
		*m: newfreetable		&& Creates a new free table and adds it to the meta data
		*m: newtable
		*m: newview		&& Create a new local or remote view.
		*m: opendatabase		&& Opens the specified database
		*m: openmetadata		&& Opens a set of meta data
		*m: pgdnhotkey		&& Moves to the next item in the tree (fired from a hotkey)
		*m: pguphotkey		&& Moves to the previous item in the tree (fired from a hotkey)
		*m: preferences
		*m: redefineallviews		&& Redefine all views for a table
		*m: redefinesingleview		&& Redefines a single view
		*m: redefineview		&& Redefines a view
		*m: registerpreferences
		*m: reindextable
		*m: removenode		&& Removes the current node from the tree and selects the next sibling.
		*m: removeobjectfrommetadata		&& Removes an object from the meta data
		*m: removerelations		&& Remove relations from the DBC
		*m: renametable
		*m: resethotkeys		&& Reset hot keys
		*m: savechanges
		*m: savemrumetadata		&& Saves the MRU meta data paths to the Registry
		*m: statusresize		&& Resizes the "status" textboxes when the form is resized.
		*m: treecollapse		&& Handle TreeView collapse event
		*m: treedblclick		&& Handle TreeView DblClick event
		*m: treedragdrop		&& Handle TreeView DragDrop event
		*m: treedragover		&& Handle TreeView DragOver event
		*m: treeexpand		&& Handle TreeView Expand event
		*m: treekeypress		&& Handle a TreeView KeyDown event
		*m: treemousedown		&& Handle a TreeView MouseDown event
		*m: treemousemove		&& Handle a TreeView MouseMove event
		*m: treenodeclick		&& Handle TreeView NodeClick event
		*m: updatefieldrep		&& Updates tables from changes in the Field Repository
		*m: updatetable
		*m: updateviewfield		&& Updates a view field with the properties of the source field
		*m: validate
		*m: validatecurrentobject		&& Validates the selected object
		*m: validateobject
		*m: viewwizard
		*p: ccontainer		&& The current properties container
		*p: ccopyicon		&& The icon used for copying a table
		*p: ccurrobject		&& The name of the currently selected object.
		*p: ccurrobjecttype		&& The type of the currently selected object.
		*p: ccurrparent		&& The table or view the selected object belongs to.
		*p: ccurrparenttype		&& The type (table or view) for the parent of the selected object.
		*p: ccurrvalidate		&& The object currently being validated
		*p: cdatabase		&& The name (without path or extension) of the database being maintained
		*p: cdbc		&& The name (including path) of the database being maintained
		*p: cdbcselection		&& The method use to decide which database to work with.
		*p: cdbcspecificdir		&& The location to look in for the database to work with.
		*p: cdbcxsearch		&& A list of directories in which to search for DBCXREG.DBF
		*p: cdbcxspecificdir		&& The directory where DBCXREG.DBF should be created if nDBCXAskLocation is 3
		*p: cdragicon		&& A cursor used when a dragged object can be dropped.
		*p: cfieldrepdir		&& Location of Field Repository meta data.
		*p: clistaction		&& The action to take when the user double-clicks in the tree: "Browse" or "List".
		*p: cmetapath		&& The path where the meta data tables were found.
		*p: cmoveicon		&& The icon used for moving a table
		*p: cnodropicon		&& A cursor used when a dragged object cannot be dropped.
		*p: csystemname		&& The name of the current set of meta data
		*p: cuniqueid		&& A unique ID so SDT instances can distinguish themselves.
		*p: cversion		&& The SDT version number
		*p: cvieweditor		&& The location of the view editor to use
		*p: lautoexpand		&& .T. if nodes should be expanded at startup
		*p: lautoloadtree		&& .T. if the TreeView should be fully loaded at startup
		*p: lchanged		&& .T. if the user changed something.
		*p: ldbcxsamedir		&& .T. if DBCXREG.DBF is normally in the same directory as the database.
		*p: ldemo		&& .T. if we're in demo mode.
		*p: lexpanded		&& .T. if the selected node is expanded
		*p: lextprops		&& .T. if extended properties can be defined for the selected object.
		*p: lgotobject		&& .T. if a "real" object is selected.
		*p: lgottable		&& .T. if a table is selected.
		*p: lmovetable
		*p: lnamingconv		&& .T. if we're using the Codebook naming convention.
		*p: lobjectexists		&& .T. if a view or existing table was selected.
		*p: lshowinternational		&& .T. to show codepages and collate sequences.
		*p: lusefieldrep		&& .T. to use the Field Repository
		*p: lviewinheritance		&& .T. if view field inherit properties from their source fields
		*p: ndbcs		&& The number of databases in the meta data
		*p: ndbcxasklocation		&& 1 to ask to locate DBCXREG.DBF if it can't be found, 2 to create it in the same directory as the DBCX, or 3 to create in the directory specified in cDBCXSpecificDir
		*p: ndragthreshold		&& The number of pixels the user must move the mouse with the button held down to start a drag.
		*p: nheightspacing		&& The height spacing between the bottom of the tree and the bottom of the form.
		*p: nmousex		&& The starting mouse X position to determine if a drag has started.
		*p: nmousey		&& The starting mouse Y position to determine if a drag has started.
		*p: nnodeclick		&& The last time the tree's NodeClick event was fired
		*p: ntreefactorx		&& A conversion factor between X values expected by the HitTest method of the TreeView control and those passed by VFP to methods. See Init() for its calculation.
		*p: ntreefactory		&& A conversion factor between Y values expected by the HitTest method of the TreeView control and those passed by VFP to methods. See Init() for its calculation.
		*p: nwidthspacing		&& The distance between the tree and the pageframe.
		*p: nwidthspacingpage		&& The spacing between the right edge of the pageframe and the form.
		*p: ocontroller		&& A reference to the SDTController object that called this form.
		*p: ometa		&& A reference to a MetaMgr object.
		*a: acodepage[1,0]		&& An array of code pages.
		*a: acollate[1,0]
		*a: adatatypes[1,0]		&& An array of data types.
		*a: aindextypes[1,0]
		*a: ametapaths[9,2]		&& An array of MRU meta data paths
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Stonefield Database Explorer"
	ccontainer = 		&& The current properties container
	ccopyicon = source\dragcopy.cur		&& The icon used for copying a table
	ccurrobject = 		&& The name of the currently selected object.
	ccurrobjecttype = 		&& The type of the currently selected object.
	ccurrparent = 		&& The table or view the selected object belongs to.
	ccurrparenttype = 		&& The type (table or view) for the parent of the selected object.
	ccurrvalidate = 		&& The object currently being validated
	cdatabase = 		&& The name (without path or extension) of the database being maintained
	cdbc = 		&& The name (including path) of the database being maintained
	cdbcselection = 		&& The method use to decide which database to work with.
	cdbcspecificdir = 		&& The location to look in for the database to work with.
	cdbcxsearch = 		&& A list of directories in which to search for DBCXREG.DBF
	cdbcxspecificdir = 		&& The directory where DBCXREG.DBF should be created if nDBCXAskLocation is 3
	cdragicon = source\dragmove.cur		&& A cursor used when a dragged object can be dropped.
	cfieldrepdir = 		&& Location of Field Repository meta data.
	clistaction = 		&& The action to take when the user double-clicks in the tree: "Browse" or "List".
	cmetapath = 		&& The path where the meta data tables were found.
	cmoveicon = source\dragmove.cur		&& The icon used for moving a table
	cnodropicon = source\nodrop01.cur		&& A cursor used when a dragged object cannot be dropped.
	csystemname = 		&& The name of the current set of meta data
	cuniqueid = 		&& A unique ID so SDT instances can distinguish themselves.
	cversion = 		&& The SDT version number
	cvieweditor = 		&& The location of the view editor to use
	DataSession = 2
	DoCreate = .T.
	Height = 390
	HelpContextID = 5
	lautoexpand = .T.		&& .T. if nodes should be expanded at startup
	lautoloadtree = .F.		&& .T. if the TreeView should be fully loaded at startup
	lchanged = .F.		&& .T. if the user changed something.
	ldbcxsamedir = .F.		&& .T. if DBCXREG.DBF is normally in the same directory as the database.
	ldemo = .F.		&& .T. if we're in demo mode.
	lexpanded = .F.		&& .T. if the selected node is expanded
	lextprops = .F.		&& .T. if extended properties can be defined for the selected object.
	lgotobject = .F.		&& .T. if a "real" object is selected.
	lgottable = .F.		&& .T. if a table is selected.
	lmovetable = .F.
	lnamingconv = .F.		&& .T. if we're using the Codebook naming convention.
	lobjectexists = .F.		&& .T. if a view or existing table was selected.
	lshowinternational = .F.		&& .T. to show codepages and collate sequences.
	lusefieldrep = .T.		&& .T. to use the Field Repository
	lviewinheritance = .F.		&& .T. if view field inherit properties from their source fields
	MinHeight = 360
	MinWidth = 500
	Name = "frmSDT"
	nborderstyle = 3
	ndbcs = 0		&& The number of databases in the meta data
	ndbcxasklocation = .F.		&& 1 to ask to locate DBCXREG.DBF if it can't be found, 2 to create it in the same directory as the DBCX, or 3 to create in the directory specified in cDBCXSpecificDir
	ndragthreshold = 3		&& The number of pixels the user must move the mouse with the button held down to start a drag.
	nheightspacing = 0		&& The height spacing between the bottom of the tree and the bottom of the form.
	nmousex = 0		&& The starting mouse X position to determine if a drag has started.
	nmousey = 0		&& The starting mouse Y position to determine if a drag has started.
	nnodeclick = 0		&& The last time the tree's NodeClick event was fired
	ntreefactorx = 0		&& A conversion factor between X values expected by the HitTest method of the TreeView control and those passed by VFP to methods. See Init() for its calculation.
	ntreefactory = 0		&& A conversion factor between Y values expected by the HitTest method of the TreeView control and those passed by VFP to methods. See Init() for its calculation.
	nwidthspacing = 0		&& The distance between the tree and the pageframe.
	nwidthspacingpage = 0		&& The spacing between the right edge of the pageframe and the form.
	ocontroller = .NULL.		&& A reference to the SDTController object that called this form.
	ometa = .NULL.		&& A reference to a MetaMgr object.
	TabIndex = 1
	Width = 606
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'cmdAdd' AS sdtpicturebutton WITH ;
		Left = 49, ;
		Name = "cmdAdd", ;
		Picture = addtabl.bmp, ;
		StatusBarText = "Add object to meta data", ;
		TabIndex = 2, ;
		ToolTipText = "Add object to meta data", ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdBatchAdd' AS sdtpicturebutton WITH ;
		Left = 72, ;
		Name = "cmdBatchAdd", ;
		Picture = batchadd.bmp, ;
		StatusBarText = "Batch add tables", ;
		TabIndex = 3, ;
		ToolTipText = "Batch add tables", ;
		Top = 0, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdBrowse' AS sdtpicturebutton WITH ;
		Left = 239, ;
		Name = "cmdBrowse", ;
		Picture = browstbl.bmp, ;
		StatusBarText = "Browse table or view", ;
		TabIndex = 10, ;
		ToolTipText = "Browse table or view", ;
		Top = 0, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdCopy' AS sdtpicturebutton WITH ;
		Left = 140, ;
		Name = "cmdCopy", ;
		Picture = copy.bmp, ;
		StatusBarText = "Copy table or view", ;
		TabIndex = 6, ;
		ToolTipText = "Copy table or view", ;
		Top = 0, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdDocument' AS sdtpicturebutton WITH ;
		Left = 367, ;
		Name = "cmdDocument", ;
		Picture = print.bmp, ;
		StatusBarText = "Produce documentation", ;
		TabIndex = 15, ;
		ToolTipText = "Produce documentation", ;
		Top = 0, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdFieldRep' AS sdtpicturebutton WITH ;
		Left = 338, ;
		Name = "cmdFieldRep", ;
		Picture = attach.bmp, ;
		StatusBarText = "Update from Field Repository", ;
		TabIndex = 14, ;
		ToolTipText = "Update from Field Repository", ;
		Top = 0, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdHelp' AS sdthelpbutton WITH ;
		Height = 23, ;
		Left = 422, ;
		Name = "cmdHelp", ;
		Picture = help.bmp, ;
		TabIndex = 17, ;
		Top = 0, ;
		Width = 23, ;
		ZOrderSet = 14
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdModify' AS sdtpicturebutton WITH ;
		Left = 170, ;
		Name = "cmdModify", ;
		Picture = modify.bmp, ;
		StatusBarText = "Modify table or view", ;
		TabIndex = 7, ;
		ToolTipText = "Modify table or view", ;
		Top = 0, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdNew' AS sdtpicturebutton WITH ;
		Left = 95, ;
		Name = "cmdNew", ;
		Picture = newtabl.bmp, ;
		StatusBarText = "New table", ;
		TabIndex = 4, ;
		ToolTipText = "New table", ;
		Top = 0, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPack' AS sdtpicturebutton WITH ;
		Left = 315, ;
		Name = "cmdPack", ;
		Picture = import.bmp, ;
		StatusBarText = "Validate meta data", ;
		TabIndex = 13, ;
		ToolTipText = "Validate meta data", ;
		Top = 0, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPref' AS sdtpicturebutton WITH ;
		Left = 390, ;
		Name = "cmdPref", ;
		Picture = projinfo.bmp, ;
		StatusBarText = "Properties", ;
		TabIndex = 16, ;
		ToolTipText = "Properties", ;
		Top = 0, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRedefine' AS sdtpicturebutton WITH ;
		Left = 216, ;
		Name = "cmdRedefine", ;
		Picture = redefine.bmp, ;
		StatusBarText = "Redefine view", ;
		TabIndex = 9, ;
		ToolTipText = "Redefine view", ;
		Top = 0, ;
		ZOrderSet = 25
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdReindex' AS sdtpicturebutton WITH ;
		Left = 262, ;
		Name = "cmdReindex", ;
		Picture = indexes.bmp, ;
		StatusBarText = "Reindex table", ;
		TabIndex = 11, ;
		ToolTipText = "Reindex table", ;
		Top = 0, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemove' AS sdtpicturebutton WITH ;
		Left = 117, ;
		Name = "cmdRemove", ;
		Picture = removtbl.bmp, ;
		StatusBarText = "Remove object from meta data", ;
		TabIndex = 5, ;
		ToolTipText = "Remove object from meta data", ;
		Top = 0, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdUpdate' AS sdtpicturebutton WITH ;
		Left = 285, ;
		Name = "cmdUpdate", ;
		Picture = update.bmp, ;
		StatusBarText = "Update table structure", ;
		TabIndex = 12, ;
		ToolTipText = "Update table structure", ;
		Top = 0, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdWizard' AS sdtpicturebutton WITH ;
		Left = 193, ;
		Name = "cmdWizard", ;
		Picture = wizard.bmp, ;
		StatusBarText = "View Field Properties Wizard", ;
		TabIndex = 8, ;
		ToolTipText = "View Field Properties Wizard", ;
		Top = 0, ;
		ZOrderSet = 25
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'ctrOpenMRU' AS sfdropdownmenubutton WITH ;
		Left = 5, ;
		Name = "ctrOpenMRU", ;
		TabIndex = 1, ;
		cmdMain.Name = "cmdMain", ;
		cmdMain.Picture = open.bmp, ;
		cmdMain.StatusBarText = "Open a set of meta data", ;
		cmdMain.ToolTipText = "Open a set of meta data", ;
		cmdMenu.Name = "cmdMenu", ;
		cmdMenu.StatusBarText = "Select a set of meta data from an MRU list", ;
		cmdMenu.ToolTipText = "Select a set of meta data from an MRU list"
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="container" />

	ADD OBJECT 'oCommonDialog' AS sfcommondialog WITH ;
		Left = 495, ;
		Name = "oCommonDialog", ;
		Top = 55
		*< END OBJECT: ClassLib="..\..\sfcommon\sfutility.vcx" BaseClass="custom" />

	ADD OBJECT 'oDBUtilities' AS sdtdbutilities WITH ;
		Left = 566, ;
		Name = "oDBUtilities", ;
		Top = 56
		*< END OBJECT: ClassLib="sdtmanagers.vcx" BaseClass="custom" />

	ADD OBJECT 'oImageListLoader' AS sfimagelist WITH ;
		cnewobjectname = oImageList, ;
		lautoload = .F., ;
		Left = 520, ;
		Name = "oImageListLoader", ;
		Top = 55
		*< END OBJECT: ClassLib="..\..\sfcommon\sfactivex.vcx" BaseClass="custom" />

	ADD OBJECT 'oPersist' AS sfpersistentform WITH ;
		Left = 474, ;
		lrestoreoninit = .F., ;
		Name = "oPersist", ;
		Top = 56
		*< END OBJECT: ClassLib="..\..\sfcommon\sfpersist.vcx" BaseClass="custom" />

	ADD OBJECT 'oReg' AS sfregistry WITH ;
		Height = 17, ;
		Left = 585, ;
		Name = "oReg", ;
		Top = 55, ;
		Width = 15
		*< END OBJECT: ClassLib="..\..\sfcommon\sfregistry.vcx" BaseClass="custom" />

	ADD OBJECT 'oTreeShape' AS shape WITH ;
		Height = 330, ;
		Left = 5, ;
		Name = "oTreeShape", ;
		Top = 55, ;
		Width = 240, ;
		ZOrderSet = 24
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'oTreeViewLoader' AS sftreeview WITH ;
		cclass = SFTreeList, ;
		cnewobjectname = oTree, ;
		cobjectname = oTreeShape, ;
		lautoload = .F., ;
		Left = 545, ;
		Name = "oTreeViewLoader", ;
		Top = 55
		*< END OBJECT: ClassLib="..\..\sfcommon\sfactivex.vcx" BaseClass="custom" />

	ADD OBJECT 'pgfProps' AS sdtpageframe WITH ;
		ErasePage = .T., ;
		Height = 330, ;
		Left = 248, ;
		Name = "pgfProps", ;
		PageCount = 2, ;
		TabIndex = 18, ;
		TabStyle = 1, ;
		Top = 55, ;
		Width = 355, ;
		ZOrderSet = 0, ;
		Page1.Caption = "Properties", ;
		Page1.Enabled = .F., ;
		Page1.Name = "Page1", ;
		Page2.Caption = "Extended Properties", ;
		Page2.Enabled = .F., ;
		Page2.Name = "Page2"
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="pageframe" />

	ADD OBJECT 'pgfProps.Page1.cntCalcProps' AS sdtcalcprops WITH ;
		Left = 9, ;
		Name = "cntCalcProps", ;
		Top = 7, ;
		ZOrderSet = 1, ;
		cboType.Name = "cboType", ;
		chkFilter.Alignment = 0, ;
		chkFilter.Name = "chkFilter", ;
		edtComments.Name = "edtComments", ;
		edtExpr.Name = "edtExpr", ;
		lblCaption.Name = "lblCaption", ;
		lblComments.Name = "lblComments", ;
		lblDecimals.Name = "lblDecimals", ;
		lblExpr.Name = "lblExpr", ;
		lblFormat.Name = "lblFormat", ;
		lblInputMask.Name = "lblInputMask", ;
		lblName.Name = "lblName", ;
		lblType.Name = "lblType", ;
		lblWidth.Name = "lblWidth", ;
		spnDecimals.Name = "spnDecimals", ;
		spnWidth.Name = "spnWidth", ;
		txtCaption.Name = "txtCaption", ;
		txtFormat.Name = "txtFormat", ;
		txtInputMask.Name = "txtInputMask", ;
		txtName.Name = "txtName"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProps.Page1.cntDatabaseProps' AS sdtdatabaseprops WITH ;
		Left = 9, ;
		Name = "cntDatabaseProps", ;
		Top = 7, ;
		ZOrderSet = 6, ;
		chkDBCEvents.Alignment = 0, ;
		chkDBCEvents.Name = "chkDBCEvents", ;
		cmdGetPath.Name = "cmdGetPath", ;
		cmdInstallSDT.Name = "cmdInstallSDT", ;
		cntDBCEvents.lblLabel.Name = "lblLabel", ;
		cntDBCEvents.Name = "cntDBCEvents", ;
		cntDBCEvents.shpBox.Name = "shpBox", ;
		cntStatistics.lblLabel.Name = "lblLabel", ;
		cntStatistics.Name = "cntStatistics", ;
		cntStatistics.shpBox.Name = "shpBox", ;
		edtComments.Name = "edtComments", ;
		lblComments.Name = "lblComments", ;
		lblEventFile.Name = "lblEventFile", ;
		lblTableCount.Name = "lblTableCount", ;
		lblTables.Name = "lblTables", ;
		lblViewCount.Name = "lblViewCount", ;
		lblViews.Name = "lblViews", ;
		txtEventFile.Name = "txtEventFile"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProps.Page1.cntDatabasesProps' AS sdtdatabasespage WITH ;
		Left = 9, ;
		Name = "cntDatabasesProps", ;
		Top = 7, ;
		ZOrderSet = 0, ;
		LBLDATABASES.Name = "LBLDATABASES"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProps.Page1.cntFieldProps' AS sdtfieldprops WITH ;
		Left = 9, ;
		Name = "cntFieldProps", ;
		Top = 7, ;
		ZOrderSet = 4, ;
		chkFilter.Alignment = 0, ;
		chkFilter.Name = "chkFilter", ;
		chkKeyField.Alignment = 0, ;
		chkKeyField.Name = "chkKeyField", ;
		chkUpdatable.Alignment = 0, ;
		chkUpdatable.Name = "chkUpdatable", ;
		edtComments.Name = "edtComments", ;
		lblCaption.Name = "lblCaption", ;
		lblComments.Name = "lblComments", ;
		lblDecimals.Name = "lblDecimals", ;
		lblDefault.Name = "lblDefault", ;
		lblFormat.Name = "lblFormat", ;
		lblInputMask.Name = "lblInputMask", ;
		lblName.Name = "lblName", ;
		lblRuleExpr.Name = "lblRuleExpr", ;
		lblRuleText.Name = "lblRuleText", ;
		lblType.Name = "lblType", ;
		LBLWIDTH.Name = "LBLWIDTH", ;
		txtCaption.Name = "txtCaption", ;
		TXTDECIMALS.Name = "TXTDECIMALS", ;
		txtDefault.Name = "txtDefault", ;
		txtFormat.Name = "txtFormat", ;
		txtInputMask.Name = "txtInputMask", ;
		txtName.Name = "txtName", ;
		txtRuleExpr.Name = "txtRuleExpr", ;
		txtRuleText.Name = "txtRuleText", ;
		txtType.Name = "txtType", ;
		txtWidth.Name = "txtWidth"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProps.Page1.cntIndexProps' AS sdtindexprops WITH ;
		Left = 9, ;
		Name = "cntIndexProps", ;
		Top = 7, ;
		ZOrderSet = 5, ;
		cboCollate.Name = "cboCollate", ;
		cboType.Name = "cboType", ;
		chkDescend.Alignment = 0, ;
		chkDescend.Name = "chkDescend", ;
		chkSelect.Alignment = 0, ;
		chkSelect.Name = "chkSelect", ;
		edtComments.Name = "edtComments", ;
		lblCaption.Name = "lblCaption", ;
		lblCollate.Name = "lblCollate", ;
		lblComments.Name = "lblComments", ;
		lblExpression.Name = "lblExpression", ;
		lblFilter.Name = "lblFilter", ;
		lblName.Name = "lblName", ;
		lblType.Name = "lblType", ;
		txtCaption.Name = "txtCaption", ;
		txtExpression.Name = "txtExpression", ;
		txtFilter.Name = "txtFilter", ;
		txtName.Name = "txtName"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProps.Page1.cntTableProps' AS sdttableprops WITH ;
		Left = 9, ;
		Name = "cntTableProps", ;
		Top = 7, ;
		ZOrderSet = 2, ;
		cboCodePage.Name = "cboCodePage", ;
		chkAutoOpen.Alignment = 0, ;
		chkAutoOpen.Name = "chkAutoOpen", ;
		chkCanUpdate.Alignment = 0, ;
		chkCanUpdate.Name = "chkCanUpdate", ;
		chkFilter.Alignment = 0, ;
		chkFilter.Name = "chkFilter", ;
		chkNoUpdate.Alignment = 0, ;
		chkNoUpdate.Name = "chkNoUpdate", ;
		cmdGetPath.Name = "cmdGetPath", ;
		edtComments.Name = "edtComments", ;
		lblBlockSize.Name = "lblBlockSize", ;
		lblCaption.Name = "lblCaption", ;
		lblCodePage.Name = "lblCodePage", ;
		lblComments.Name = "lblComments", ;
		lblName.Name = "lblName", ;
		lblPath.Name = "lblPath", ;
		spnBlockSize.Name = "spnBlockSize", ;
		txtCaption.Name = "txtCaption", ;
		txtName.Name = "txtName", ;
		txtPath.Name = "txtPath"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProps.Page1.cntViewProps' AS sdtviewprops WITH ;
		Left = 9, ;
		Name = "cntViewProps", ;
		Top = 7, ;
		ZOrderSet = 3, ;
		chkAutoOpen.Alignment = 0, ;
		chkAutoOpen.Name = "chkAutoOpen", ;
		chkFilter.Alignment = 0, ;
		chkFilter.Name = "chkFilter", ;
		chkNoUpdate.Alignment = 0, ;
		chkNoUpdate.Name = "chkNoUpdate", ;
		chkUpdatable.Alignment = 0, ;
		chkUpdatable.Name = "chkUpdatable", ;
		chkVD.Alignment = 0, ;
		chkVD.Name = "chkVD", ;
		edtComments.Name = "edtComments", ;
		edtSQL.Name = "edtSQL", ;
		lblCaption.Name = "lblCaption", ;
		lblComments.Name = "lblComments", ;
		lblName.Name = "lblName", ;
		lblSQL.Name = "lblSQL", ;
		txtCaption.Name = "txtCaption", ;
		txtName.Name = "txtName"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProps.Page2.cntExtProps' AS sdtextendedprops WITH ;
		Left = 6, ;
		Name = "cntExtProps", ;
		Top = 12, ;
		CNTVALUES.chkValue.Alignment = 0, ;
		CNTVALUES.chkValue.Name = "chkValue", ;
		CNTVALUES.cmdDelete.Name = "cmdDelete", ;
		CNTVALUES.cmdEdit.Name = "cmdEdit", ;
		CNTVALUES.cmdNew.Name = "cmdNew", ;
		CNTVALUES.edtValue.Name = "edtValue", ;
		CNTVALUES.lblValue.Name = "lblValue", ;
		CNTVALUES.Name = "CNTVALUES", ;
		CNTVALUES.spnValue.Name = "spnValue", ;
		CNTVALUES.txtDValue.Name = "txtDValue", ;
		CNTVALUES.txtTValue.Name = "txtTValue", ;
		CNTVALUES.txtValue.Name = "txtValue", ;
		grdProperty.grcField.grhField.Name = "grhField", ;
		grdProperty.grcField.Name = "grcField", ;
		grdProperty.grcField.txtField.Name = "txtField", ;
		grdProperty.grcName.grhName.Name = "grhName", ;
		grdProperty.grcName.Name = "grcName", ;
		grdProperty.grcName.txtName.Name = "txtName", ;
		grdProperty.grcType.grhType.Name = "grhType", ;
		grdProperty.grcType.Name = "grcType", ;
		grdProperty.grcType.txtType.Name = "txtType", ;
		grdProperty.Name = "grdProperty"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'tmrFocus' AS sdttimer WITH ;
		Interval = 1000, ;
		Left = 580, ;
		Name = "tmrFocus", ;
		Top = 0
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="timer" />

	ADD OBJECT 'txtDatabase' AS sdtreadonlytextbox WITH ;
		Height = 23, ;
		Left = 248, ;
		Name = "txtDatabase", ;
		TabIndex = 20, ;
		Top = 30, ;
		Width = 355, ;
		ZOrderSet = 20
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtObject' AS sdtreadonlytextbox WITH ;
		Height = 23, ;
		Left = 5, ;
		Name = "txtObject", ;
		TabIndex = 19, ;
		Top = 30, ;
		Width = 240, ;
		ZOrderSet = 21
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		* Ensure the correct database is selected.
		
		with This
			if not empty(.cDBC)
				set database to (.cDBC)
			endif not empty(.cDBC)
		endwith
		
		* Set some hot keys.
		
		on key label Ctrl+PgUp _screen.ActiveForm.PgUpHotKey()
		on key label Ctrl+PgDn _screen.ActiveForm.PgDnHotKey()
		
		* Do the usual behavior.
		
		dodefault()
		
	ENDPROC

	PROCEDURE addmetapathtomru		&& Adds a meta data path to the MRU list
		lparameters tcPath
		local lcName, ;
			lnI
		with This
			lcName = inputbox('System name:', 'Add Meta Data to MRU List', tcPath)
			if not empty(lcName)
				for lnI = 1 to alen(.aMetaPaths, 1)
					if empty(.aMetaPaths[lnI, 2])
						.aMetaPaths[lnI, 1] = lcName
						.aMetaPaths[lnI, 2] = tcPath
						exit
					endif empty(.aMetaPaths[lnI, 2])
				next lnI
				.cSystemName = lcName
			endif not empty(lcName)
		endwith
		
	ENDPROC

	PROCEDURE addobjecttometadata		&& Adds an object to the meta data
		*==============================================================================
		* Method:			AddObjectToMetaData
		* Purpose:			Adds an object to the meta data
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	07/30/2004
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcFileName, ;
			lcType, ;
			loNode
		with This
		
		* Ensure any changes are saved.
		
			.SaveChanges()
		
		* Get the name of the object to add.
		
			if inlist(This.cCurrObjectType, 'Database', 'Databases')
				lcFileName = .GetNewFile(.cMetaPath, ;
					strtran(ccCAP_ADD, ccMSG_INSERT1, ccDATABASE_PROPER), ;
					'Databases (*.DBC)', '*.DBC')
				lcType     = 'Database'
			else
				lcFileName = .GetNewFile(iif(.cCurrParentType = 'Free Tables', ;
					.cMetaPath, addbs(justpath(.cDBC))), ;
					strtran(ccCAP_ADD, ccMSG_INSERT1, ccTABLE))
				lcType     = 'Table'
			endif inlist(This.cCurrObjectType ...
		
		* If a filename was selected, add the object to the meta data and select its
		* node.
		
			if not empty(lcFileName)
				loNode = .AddOneObjectToMetaData(lcFileName, lcType)
				if not isnull(loNode)
					loNode.Selected = .T.
					.oTree.NodeClick(.oTree.SelectedItem)
				endif not isnull(loNode)
			endif not empty(lcFileName)
		endwith
		
	ENDPROC

	PROCEDURE addoneobjecttometadata		&& Adds a single object to the meta data
		lparameters tcFileName, ;
			tcType, ;
			tlNoWarning
		local loNode, ;
			llAddDBC, ;
			llAddFree, ;
			llAddTable, ;
			lcObject, ;
			llFound, ;
			llOK
		with This
		
		* See if this should be a free table or added to the database.
		
			loNode     = .NULL.
			llAddDBC   = tcType = 'Database'
			llAddFree  = not llAddDBC and empty(.cDatabase)
			llAddTable = not llAddDBC and not llAddFree
			lcObject   = lower(juststem(tcFileName))
			do case
				case llAddDBC
					llFound = .oMeta.FindObject(lcObject, 'Database')
				case llAddFree
					llFound = .oMeta.FindObject('!' + lcObject, 'Table')
				otherwise
					llFound = indbc(lcObject, 'Table') or indbc(lcObject, 'View')
			endcase
			do case
		
		* Don't allow a meta data table to be added to the database.
		
				case inlist(upper(lcObject), 'DBCXREG', 'SDTMETA', 'SDTUSER', ;
					'COREMETA')
					if not tlNoWarning
						.oMessage.ErrorMessage(strtran(ccERR_CANT_ADD_META, ;
							ccMSG_INSERT1, iif(llAddTable, ccDATABASE_LOWER, ;
							ccMETA_DATA)))
					endif not tlNoWarning
		
		* If the file already exists in the data dictionary, remind the user.
		
				case llFound and llAddTable
					if not tlNoWarning
						.oMessage.ErrorMessage(strtran(ccERR_TABLE_IN_DBC, ;
							ccMSG_INSERT1, lcObject))
					endif not tlNoWarning
				case llFound
					if not tlNoWarning
						.oMessage.ErrorMessage(strtran(ccERR_TABLE_IN_META, ;
							ccMSG_INSERT1, lcObject))
					endif not tlNoWarning
		
		* If the file doesn't exist, give an error message.
		
				case not file(tcFileName)
					if not tlNoWarning
						.oMessage.ErrorMessage(strtran(ccERR_FILE_NOT_EXIST, ;
							ccMSG_INSERT1, lcObject))
					endif not tlNoWarning
		
		* If we're adding a free table to the database, try to do so.
		
				otherwise
					if llAddTable
						.oUtility.CloseAllAliases(tcFileName)
						.oError.ResetError()
						add table (tcFileName)
						llOK = not .oError.DidErrorOccur() and ;
							indbc(lcObject, 'Table')
					else
						llOK = .T.
					endif llAddTable
		
		* If everything is OK so far, add the object to the meta data.
		
					do case
						case not llOK
		
		* Add the database to the meta data.
		
						case llAddDBC
							llOK = .OpenDatabase(tcFileName)
							if llOK
								.ValidateObject(tcFileName, 'Database')
								loNode = .LoadDatabase(tcFileName)
							endif llOK
		
		* Add the free table to the meta data if it really is a free table.
		
						case llAddFree
							select 0
							use (tcFileName) alias _TEMP again shared
							llOK = used('_TEMP')
							do case
								case llOK
									llOK = empty(cursorgetprop('Database'))
									use
									llOK = llOK and ;
										.ValidateObject('!' + tcFileName, 'Table')
									if llOK
										loNode = .LoadFreeTable(lcObject)
									endif llOK
								case not tlNoWarning
									.oMessage.ErrorMessage(ccERR_BELONG_ANOTHER)
							endcase
		
		* Add the table to the meta data.
		
						otherwise
							llOK = .ValidateObject(lcObject, 'Table')
							if llOK
								loNode = .LoadDatabaseCursor(lcObject, 'Table', ;
									.cDatabase)
							endif llOK
					endcase
			endcase
		endwith
		return loNode
		
	ENDPROC

	PROCEDURE askformetapath		&& Asks the user to locate a set of meta data tables
		lparameters tcInitialPath
		local lcPath, ;
			lcFile
		with This.oCommonDialog
			.ClearFilters(.T.)
			.AddFilter('Tables (*.DBF)', '*.DBF')
			.cFileName         = 'DBCXREG.DBF'
			.cTitleBarText     = 'Locate DBCXREG.DBF'
			if not empty(tcInitialPath)
				.cInitialDirectory = tcInitialPath
			endif not empty(tcInitialPath)
			.ShowDialog()
			lcPath = addbs(.cFilePath) + .cFileTitle
			lcFile = upper(.cFileTitle)
		endwith
		do case
			case empty(lcFile) or lcFile <> 'DBCXREG.DBF'
				lcPath = ''
			case file(lcPath)
				lcPath = addbs(justpath(lcPath))
			otherwise
				lcPath = ccUNTITLED + addbs(justpath(lcPath))
		endcase
		return lcPath
		
	ENDPROC

	PROCEDURE batchaddobjects		&& Adds all objects in a directory
		*==============================================================================
		* Method:			BatchAddObjects
		* Purpose:			Adds all objects in a directory to the meta data
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	07/30/2004
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcDirectory, ;
			llAddDBC, ;
			llAddTable, ;
			laObjects[1], ;
			lnObjects, ;
			llAdded, ;
			loLastObject, ;
			lcType, ;
			lnI, ;
			lcFileName, ;
			loNode
		with This
		
		* Ensure any changes are saved.
		
			.SaveChanges()
		
		* Get the directory for the objects and process all objects in the specified
		* directory.
		
		#if clVFP7ORLATER
			lcDirectory = getdir(.cMetaPath, ccMSG_DIRECTORY, ccMSG_DIRECTORY)
		#else
			lcDirectory = getdir(.cMetaPath, ccMSG_DIRECTORY)
		#endif
			if not empty(lcDirectory)
				llAddDBC   = inlist(.cCurrObjectType, 'Database', 'Databases')
				llAddTable = .cCurrParentType = 'Table'
				if llAddDBC
					lnObjects = adir(laObjects, lcDirectory + '*.DBC')
				else
					lnObjects = adir(laObjects, lcDirectory + '*.DBF')
				endif llAddDBC
				if lnObjects > 0
					llAdded      = .F.
					loLastObject = .NULL.
					lcType       = iif(llAddDBC, 'Database', 'Table')
		
		* Add each object to the meta data.
		
					for lnI = 1 to lnObjects
						lcFileName = lcDirectory + laObjects[lnI, 1]
						loNode     = .AddOneObjectToMetaData(lcFileName, lcType, .T.)
						if not isnull(loNode)
							llAdded      = .T.
							loLastObject = loNode
						endif not isnull(loNode)
					next lnI
		
		* If any objects were added, select the last one added in the tree.
		
					if llAdded
						loLastObject.Selected = .T.
						.oTree.NodeClick(.oTree.SelectedItem)
					endif llAdded
				else
					.oMessage.ErrorMessage(ccERR_NO_TABLES_IN_DIR, ccMSG_TITLE)
				endif lnObjects > 0
			endif not empty(lcDirectory)
		endwith
		
	ENDPROC

	PROCEDURE browsetable
		*==============================================================================
		* Method:			BrowseTable
		* Purpose:			Browses the selected table or view
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	03/22/2004
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcAlias, ;
			lcCursor, ;
			lcOrder, ;
			llOpened, ;
			lcField
		with This
			.SaveChanges()
			lcAlias = strtran(.cCurrParent, ' ', '_')
		
		* If this is a parameterized view and it's already open, close it so the user
		* will be asked for the parameters again.
		
			if .cCurrParentType = 'View' and used(lcAlias) and ;
				'?' $ cursorgetprop('SQL', lcAlias)
				use in (lcAlias)
			endif .cCurrParentType = 'View' ...
		
		* Determine the name of the table or view to open and if an index node is
		* selected, the order to use.
		
			lcCursor = iif(.cCurrParentType = 'Free Tables', ;
				.oMeta.oSDTMgr.GetFreeTablePath('!' + .cCurrParent), .cCurrParent)
			if .cCurrObjectType = 'Index'
				lcOrder = justext(.cCurrObject)
			else
				lcOrder = ''
			endif .cCurrObjectType = 'Index'
		
		* If the table or view is already open, select the desired order and go to the
		* first record.
		
			if used(lcAlias)
				select (lcAlias)
				if not empty(lcOrder)
					set order to (lcOrder)
				endif not empty(lcOrder)
				locate
		
		* The table or view isn't open, so try to open it. We're going to USE IN 0,
		* thenselect the alias because if the view needs to be redefined, we may have
		* to RETRY, and we want to retry opening in a new area.
		
			else
				lcOrder = iif(empty(lcOrder), '', 'order ' + lcOrder)
				use (lcCursor) in 0 again shared &lcOrder
			endif used(lcAlias)
		
		* If the table or view was opened, browse it. If a field was selected, we'll
		* just browse that field.
		
			llOpened = used(lcAlias)
			if llOpened
				activate screen
				select (lcAlias)
				if .cCurrObjectType = 'Field'
					lcField = justext(.cCurrObject)
					browse fields &lcField nowait
				else
					browse nowait
				endif .cCurrObjectType = 'Field'
			else
				.oMessage.ErrorMessage(strtran(ccERR_CANT_OPEN_FILE, ccMSG_INSERT1, ;
					lcCursor))
			endif llOpened
		endwith
		
	ENDPROC

	PROCEDURE calctwipsperpixel		&& Calculates the number of twips (needed for TreeView.HitTest) per pixel.
		*==============================================================================
		* Method:			CalcTwipsPerPixel
		* Purpose:			Calculate the conversion factor between VFP window units
		*						(in pixels) and TreeView window units (in twips)
		* Author:			Doug Hennig
		* Copyright:		(c) 1997 Stonefield Systems Group Inc.
		* Last Revision:	12/22/97
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local liHWnd, ;
			liHDC, ;
			liPixelsPerInchX, ;
			liPixelsPerInchY
		
		* Define some constants.
		
		#define cnLOG_PIXELS_X      88
			* From WINGDI.H
		#define cnLOG_PIXELS_Y      90
			* From WINGDI.H
		#define cnTWIPS_PER_INCH  1440
			* 1440 twips per inch
		
		* Declare some Windows API functions.
		
		declare integer GetActiveWindow in WIN32API
		declare integer GetDC           in WIN32API ;
			integer iHDC
		declare integer GetDeviceCaps   in WIN32API ;
			integer iHDC, integer iIndex
		
		* Get a device context for VFP.
		
		liHWnd = GetActiveWindow()
		liHDC  = GetDC(liHWnd)
		
		* Get the pixels per inch.
		
		liPixelsPerInchX = GetDeviceCaps(liHDC, cnLOG_PIXELS_X)
		liPixelsPerInchY = GetDeviceCaps(liHDC, cnLOG_PIXELS_Y)
		
		* Get the twips per pixel.
		
		with This
			.nTreeFactorX = cnTWIPS_PER_INCH/liPixelsPerInchX
			.nTreeFactorY = cnTWIPS_PER_INCH/liPixelsPerInchY
		endwith
		
	ENDPROC

	PROCEDURE convertpreferences		&& Converts preferences from the former version of SDT to the current one
		*==============================================================================
		* Method:			ConvertPreferences
		* Purpose:			Convert preferences in the Windows registry from former
		*						versions of SDT to the current one (all except the
		*						Field Repository location)
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/19/2001
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcValue, ;
			lcKey, ;
			llReturn
		with This.oReg
			lcValue = .GetKey(ccREG_KEY_SDT51, ccPREF_LISTACTION, 'Dummy')
			if lcValue <> 'Dummy'
				lcKey    = ccREG_KEY_SDT51
				llReturn = .SetKey(ccREG_KEY, ccPREF_LISTACTION, lcValue)
			else
				lcValue = .GetKey(ccREG_KEY_FORMER, ccPREF_LISTACTION, 'Dummy')
				if lcValue <> 'Dummy'
					lcKey    = ccREG_KEY_FORMER
					llReturn = .SetKey(ccREG_KEY, ccPREF_LISTACTION, lcValue)
				endif lcValue <> 'Dummy'
			endif lcValue <> 'Dummy'
			lcValue = .GetKey(lcKey, ccPREF_DBCXREG_SAME_DIR, 'Dummy')
			if lcValue <> 'Dummy'
				llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_DBCXREG_SAME_DIR, ;
					lcValue)
			endif lcValue <> 'Dummy'
			lcValue = .GetKey(lcKey, ccPREF_DBCXREG_SPEC_DIR, 'Dummy')
			if lcValue <> 'Dummy'
				llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_DBCXREG_SPEC_DIR, ;
					lcValue)
			endif lcValue <> 'Dummy'
			lcValue = .GetKey(lcKey, ccPREF_ASK_FOR_DBCXREG, 'Dummy')
			if lcValue <> 'Dummy'
				llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_ASK_FOR_DBCXREG, ;
					lcValue)
			endif lcValue <> 'Dummy'
			lcValue = .GetKey(lcKey, ccPREF_SHOW_INTL, 'Dummy')
			if lcValue <> 'Dummy'
				llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_SHOW_INTL, lcValue)
			endif lcValue <> 'Dummy'
			lcValue = .GetKey(lcKey, ccPREF_NAMING_CONV, 'Dummy')
			if lcValue <> 'Dummy'
				llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_NAMING_CONV, lcValue)
			endif lcValue <> 'Dummy'
			lcValue = .GetKey(lcKey, ccPREF_DBC_SELECTION, 'Dummy')
			if lcValue <> 'Dummy'
				llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_DBC_SELECTION, ;
					lcValue)
			endif lcValue <> 'Dummy'
			lcValue = .GetKey(lcKey, ccPREF_DBC_SPEC_DIR, 'Dummy')
			if lcValue <> 'Dummy'
				llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_DBC_SPEC_DIR, ;
					lcValue)
			endif lcValue <> 'Dummy'
			lcValue = .GetKey(lcKey, ccPREF_VIEW_INHERITANCE, 'Dummy')
			if lcValue <> 'Dummy'
				llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_VIEW_INHERITANCE, ;
					lcValue)
			endif lcValue <> 'Dummy'
			lcValue = .GetKey(lcKey, ccPREF_AUTO_EXPAND, 'Dummy')
			if lcValue <> 'Dummy'
				llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_AUTO_EXPAND, ;
					lcValue)
			endif lcValue <> 'Dummy'
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE copyonetable
		*==============================================================================
		* Method:			CopyOneTable
		* Purpose:			Copies the specified table or view in the current database
		* Author:			Doug Hennig
		* Copyright:		(c) 1997 Stonefield Systems Group Inc.
		* Last Revision:	12/22/97
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		with This
			.CopyTable(.cCurrParent, .cCurrParentType, .cDBC, , This)
		endwith
		
	ENDPROC

	PROCEDURE copytable
		*==============================================================================
		* Method:			CopyTable
		* Purpose:			Copies a table or view
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	03/22/2004
		* Parameters:		tcTable - the table or view being copied
		*					tcType  - "Table" or "View"
		*					tcDBC   - the database the table or view is being copied
		*						from
		*					tcNew   - the new name if the table or view is being copied
		*						into the same database
		*					toOther - an object reference to the other SDT form
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcTable, ;
			tcType, ;
			tcDBC, ;
			tcNew, ;
			toOther
		local llRemote, ;
			lcTable, ;
			lcFileName, ;
			llReturn
		with This
		
		* Ensure any changes are saved.
		
			.SaveChanges()
			do case
		
		* If the new name for a view wasn't passed, ask the user for one.
		
				case empty(tcNew) and tcType = 'View'
					llRemote = dbgetprop(tcTable, 'View', 'SourceType') = 2
					do form NewView with llRemote, .T. name loNewView
					if vartype(loNewView) = 'O'
						lcTable = loNewView.cViewName
					endif vartype(loNewView) = 'O'
				case tcType = 'View'
					lcTable = tcTable
		
		* If the new name for a table wasn't passed or it was but the DBCs are in the
		* same directory (so we need a new DBF name), ask the user for one.
		
				case empty(tcNew) or ;
					(addbs(justpath(tcDBC)) = addbs(justpath(.cDBC)) and ;
					tcType = 'Table')
					lcFileName = .GetNewFile(addbs(justpath(.cDBC)), ;
						strtran(ccMSG_COPY_TABLE_FROM, ccMSG_INSERT1, tcTable))
					lcTable    = iif(empty(lcFileName), '', juststem(lcFileName))
		
		* The name was passed, so get the full path for it.
		
				otherwise
					lcFileName = fullpath(justfname(tcNew), .cDBC)
					lcTable    = tcTable
			endcase
		
		* If a name was entered, copy it.
		
			if not empty(lcTable)
				llReturn = .CopyTableToDBC(tcTable, lcTable, lcFileName, tcType, ;
					tcDBC, toOther.oMeta)
			endif not empty(lcTable)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE copytabletodbc		&& Copies the specified view or table to the DBC
		lparameters tcSourceTable, ;
			tcTargetTable, ;
			tcFileName, ;
			tcType, ;
			tcDBC, ;
			toOtherMeta, ;
			tlMove
		local lcDBC, ;
			lcFileName, ;
			llSameDir, ;
			llReturn, ;
			laOpenTables[1], ;
			lcOldDBCAlias, ;
			lcNewDBCAlias, ;
			lnRecno, ;
			liParentID, ;
			lcOrigAlias, ;
			lcPrimary, ;
			lnCurrSelect, ;
			laTable[1], ;
			lnFields, ;
			lnI, ;
			lnJ, ;
			lcFile, ;
			llAdjust, ;
			lcConnect, ;
			lcRemote, ;
			lcSQL, ;
			laProps[1], ;
			lcField1, ;
			lcField2, ;
			lcComment, ;
			lcCaption, ;
			lcFormat, ;
			lcInput, ;
			lcClass, ;
			lcLibrary, ;
			lcType, ;
			llKey, ;
			llUpdate, ;
			lcUpdate, ;
			lnTags, ;
			lcTag, ;
			lcIndex1, ;
			lcIndex2, ;
			lnBatch, ;
			llCompare, ;
			llFetch, ;
			llFetchMemo, ;
			lnFetch, ;
			lnMaxRecs, ;
			lcParams, ;
			llPrepared, ;
			lcRule, ;
			lcRuleText, ;
			llSendUpd, ;
			lcTables, ;
			lnUpdType, ;
			llUseMemo, ;
			lnWhere, ;
			laObjects[1], ;
			lnObjects, ;
			lcObject1, ;
			lcObject2, ;
			loNode
		with This
		
		* If we're moving a table, get the location of the source table.
		
			lcDBC = .cDBC
			if tlMove and tcType = 'Table'
				set database to (tcDBC)
				lcFileName = fullpath(dbgetprop(tcSourceTable, 'Table', 'Path'), tcDBC)
				set database to (lcDBC)
				llSameDir = tcFileName == lcFileName
			endif tlMove ...
			llReturn = .T.
			do case
		
		* If an item with that name already exists in the database, remind the user.
		
				case indbc(tcTargetTable, 'Table') or indbc(tcTargetTable, 'View')
					.oMessage.ErrorMessage(strtran(ccERR_TABLE_IN_DBC, ;
						ccMSG_INSERT1, tcTargetTable))
					llReturn = .F.
		
		* If the file already exists and we're not moving a table to a different DBC in
		* the same directory, give an error message.
		
				case tcType = 'Table' and file(tcFileName) and (not tlMove or ;
					not llSameDir)
					.oMessage.ErrorMessage(strtran(ccERR_FILE_EXISTS, ;
						ccMSG_INSERT1, tcFileName))
					llReturn = .F.
		
		* If everything is OK so far, save the extended properties for the current
		* item and try to create a copy of it. If the passed database name isn't the
		* same as ours, open it.
		
				otherwise
					wait window strtran(iif(tlMove, ccMSG_MOVING, ccMSG_COPYING), ;
						ccMSG_INSERT1, tcSourceTable) nowait
					aused(laOpenTables)
					if tcDBC <> lcDBC
						set database to (tcDBC)
					endif tcDBC <> lcDBC
					.oError.ResetError()
					do case
		
		* If we're moving the table from one DBC to another in the same directory,
		* copy records for the table from the former database to the new one.
		
						case llSameDir
							lcOldDBCAlias = .oMeta.oSDTMgr.DBCOpen(tcDBC)
							lcNewDBCAlias = .oMeta.oSDTMgr.DBCOpen(lcDBC)
							go bottom
							lnRecno    = recno()
							liParentID = .oMeta.oSDTMgr.DBCGetField(tcSourceTable, ;
								tcType, 'OBJECTID', lcOldDBCAlias)
							append from (tcDBC) for OBJECTID = liParentID or ;
								PARENTID = liParentID
							go lnRecno
							skip
							replace OBJECTID with recno()
							liParentID = OBJECTID
							skip
							replace rest OBJECTID with recno(), ;
								PARENTID with liParentID
							use in (lcOldDBCAlias)
							use in (lcNewDBCAlias)
		
		* Open the table.
		
							.oUtility.CloseAllAliases(tcFileName)
							select 0
							.oError.ResetError()
							.oError.SetSuppressErrors(.T.)
							use (tcSourceTable) again shared
							lcOrigAlias = alias()
							.oError.SetSuppressErrors(.F.)
							lnFields = afields(laTable)
		
		* Copy the table by creating a new one.
		
						case tcType = 'Table'
							lcPrimary    = upper(dbgetprop(tcSourceTable, 'Table', ;
								'PrimaryKey'))
							lnCurrSelect = select()
							.oUtility.CloseAllAliases(tcFileName)
							select 0
							.oError.ResetError()
							.oError.SetSuppressErrors(.T.)
							use (tcSourceTable) again shared
							lcOrigAlias = alias()
							.oError.SetSuppressErrors(.F.)
							if tcDBC <> lcDBC
								set database to (lcDBC)
							endif tcDBC <> lcDBC
							if .oError.DidErrorOccur()
								.oMessage.ErrorMessage(strtran(ccERR_CANT_OPEN_FILE, ;
									ccMSG_INSERT1, tcSourceTable))
								llReturn = .F.
							else
								lnFields = afields(laTable)
								laTable[1, 12] = tcTargetTable
		
		* Ensure none of the DBC properties are longer than allowed.
		
								for lnI = 1 to lnFields
									for lnJ = 7 to 16
										if len(laTable[lnI, lnJ]) > 254
											.oMessage.ErrorMessage(strtran(ccERR_COPY_PROP_LEN, ;
												ccMSG_INSERT1, tcSourceTable))
											wait clear
											return .F.
										endif len(laTable[lnI, lnJ]) > 254
									next lnJ
								next lnI
								create table (tcFileName) name (tcTargetTable) ;
									from array laTable
								use
							endif .oError.DidErrorOccur()
							select (lnCurrSelect)
		
		* Physically move the file if we're moving.
		
							if tlMove
								use in (lcOrigAlias)
								copy file (lcFileName) to (tcFileName)
								lcFile = forceext(lcFileName, 'cdx')
								if file(lcFile)
									copy file (lcFile) to ;
										(forceext(tcFileName, 'cdx'))
								endif file(lcFile)
								lcFile = forceext(lcFileName, 'fpt')
								if file(lcFile)
									copy file (lcFile) to ;
										(forceext(tcFileName, 'fpt'))
								endif file(lcFile)
								.oMeta.oSDTMgr.WriteBackLink(tcFileName, .cDBC)
								use (tcSourceTable) again shared
							endif tlMove
		
		* Copy a view.
		
						otherwise
							llAdjust = iif(tcDBC == lcDBC, .F., ;
								.oMessage.YesNo(ccQST_ADJUST_VIEW))
							select 0
							.oError.ResetError()
							.oError.SetSuppressErrors(.T.)
							use (tcSourceTable) again nodata shared
							if .oError.DidErrorOccur()
								.oMessage.ErrorMessage(strtran(ccERR_CANT_OPEN_FILE, ;
									ccMSG_INSERT1, tcSourceTable))
								llReturn = .F.
							else
								lcOrigAlias = alias()
								lnFields    = afields(laTable)
								lcConnect   = dbgetprop(tcSourceTable, 'View', ;
									'ConnectName')
								lcConnect   = iif(empty(lcConnect), '', ;
									' connection ' + '"' + lcConnect + '"') + ;
									iif(dbgetprop(tcSourceTable, 'View', ;
									'ShareConnection'), ' share ', '')
								lcRemote    = iif(dbgetprop(tcSourceTable, 'View', ;
									'SourceType') = 2, ' remote ', '')
								lcSQL       = dbgetprop(tcSourceTable, 'View', 'SQL')
								.oError.ResetError()
								.oError.SetSuppressErrors(.T.)
								if tcDBC <> lcDBC
									set database to (lcDBC)
								endif tcDBC <> lcDBC
								create sql view (tcTargetTable) &lcRemote &lcConnect ;
									as &lcSQL
							endif .oError.DidErrorOccur()
							.oError.SetSuppressErrors(.F.)
		
		* If we're supposed to adjust the SQL statement, do so after the view has been
		* created in case the tables haven't been moved to the DBC yet.
		
							if llAdjust and not .oError.DidErrorOccur()
								lcSQL = strtran(lcSQL, ;
									lower(juststem(tcDBC)) + '!', ;
									lower(juststem(lcDBC)) + '!')
								lcNewDBCAlias = .oMeta.oSDTMgr.DBCOpen(lcDBC)
								.oMeta.oSDTMgr.DBCFindObject(tcTargetTable, 'View')
								.oMeta.oSDTMgr.DBCSetProp(cnVF_VIEW_SQL, lcSQL)
								use in (lcNewDBCAlias)
							endif llAdjust ...
					endcase
		
		* If the table or view was successfully created, use the DBC and extended
		* properties for the original table or view for the new one.
		
					if not .oError.DidErrorOccur()
						.ValidateObject(tcTargetTable, tcType)
						wait window strtran(iif(tlMove, ccMSG_MOVING, ccMSG_COPYING), ;
							ccMSG_INSERT1, tcSourceTable) nowait
						toOtherMeta.DBCXGetRowProp(@laProps, tcSourceTable, tcType)
						with .oMeta.oSDTMgr
							.StripProperty(@laProps, 'CBiID')
							.StripProperty(@laProps, 'CBcObjectNam')
							.StripProperty(@laProps, 'CBcDBCName')
							.StripProperty(@laProps, 'CBtLastMod')
							.StripProperty(@laProps, 'SDTObjectName')
							.StripProperty(@laProps, 'SDTDBCName')
							.StripProperty(@laProps, 'SDTUpdated')
						endwith
						.oMeta.DBCXSetRowProp(@laProps, tcTargetTable, tcType)
		
		* Get the extended properties for every field in the table and use it for the
		* corresponding field in the new table.
		
						for lnI = 1 to lnFields
							lcField1 = tcSourceTable + '.' + laTable[lnI, 1]
							lcField2 = tcTargetTable + '.' + laTable[lnI, 1]
							dimension laProps[1]
							laProps = ''
							toOtherMeta.DBCXGetRowProp(@laProps, lcField1, 'Field')
							with .oMeta.oSDTMgr
								.StripProperty(@laProps, 'CBiID')
								.StripProperty(@laProps, 'CBcObjectNam')
								.StripProperty(@laProps, 'CBcDBCName')
								.StripProperty(@laProps, 'CBtLastMod')
								.StripProperty(@laProps, 'SDTObjectName')
								.StripProperty(@laProps, 'SDTDBCName')
								.StripProperty(@laProps, 'SDTUpdated')
							endwith
							.oMeta.DBCXSetRowProp(@laProps, lcField2, 'Field')
							if tcDBC <> lcDBC
								set database to (tcDBC)
							endif tcDBC <> lcDBC
							lcComment = dbgetprop(lcField1, 'Field', ;
								'Comment')
							lcCaption = dbgetprop(lcField1, 'Field', ;
								'Caption')
							lcFormat  = dbgetprop(lcField1, 'Field', ;
								'Format')
							lcInput   = dbgetprop(lcField1, 'Field', ;
								'InputMask')
							lcClass   = dbgetprop(lcField1, 'Field', ;
								'DisplayClass')
							lcLibrary = dbgetprop(lcField1, 'Field', ;
								'DisplayClassLibrary')
							if tcType = 'View'
								lcType   = dbgetprop(lcField1, 'Field', ;
									'DataType')
								llKey    = dbgetprop(lcField1, 'Field', ;
									'KeyField')
								llUpdate = dbgetprop(lcField1, 'Field', ;
									'Updatable')
								lcUpdate = dbgetprop(lcField1, 'Field', ;
									'UpdateName')
								if llAdjust
									lcUpdate = strtran(lcUpdate, ;
										lower(juststem(tcDBC)) + '!', ;
										lower(juststem(lcDBC)) + '!')
								endif llAdjust
							endif tcType = 'View'
							if tcDBC <> lcDBC
								set database to (lcDBC)
							endif tcDBC <> lcDBC
							dbsetprop(lcField2, 'Field', 'Comment', ;
								lcComment)
							dbsetprop(lcField2, 'Field', 'Caption', ;
								lcCaption)
							dbsetprop(lcField2, 'Field', 'Format', ;
								lcFormat)
							dbsetprop(lcField2, 'Field', 'InputMask', ;
								lcInput)
							dbsetprop(lcField2, 'Field', 'DisplayClass', ;
								lcClass)
							dbsetprop(lcField2, 'Field', 'DisplayClassLibrary', ;
								lcLibrary)
							if tcType = 'View'
								dbsetprop(lcField2, 'Field', 'DataType', ;
									lcType)
								dbsetprop(lcField2, 'Field', 'KeyField', ;
									llKey)
								dbsetprop(lcField2, 'Field', 'Updatable', ;
									llUpdate)
								dbsetprop(lcField2, 'Field', 'UpdateName', ;
									lcUpdate)
							endif tcType = 'View'
						next lnI
		
		* Get the extended properties for every index in the table and use it for the
		* corresponding index in the new table. Create each index using Reindex().
		
						if tcType = 'Table'
							lnTags = tagcount('', lcOrigAlias)
							for lnI = 1 to lnTags
								lcTag    = tag(lnI, lcOrigAlias)
								lcIndex1 = tcSourceTable + '.' + lcTag
								lcIndex2 = tcTargetTable + '.' + lcTag
								dimension laProps[1]
								laProps = ''
								toOtherMeta.DBCXGetRowProp(@laProps, lcIndex1, ;
									'Index')
								with .oMeta.oSDTMgr
									.StripProperty(@laProps, 'CBiID')
									.StripProperty(@laProps, 'CBcObjectNam')
									.StripProperty(@laProps, 'CBcDBCName')
									.StripProperty(@laProps, 'CBtLastMod')
									.StripProperty(@laProps, 'SDTObjectName')
									.StripProperty(@laProps, 'SDTDBCName')
									.StripProperty(@laProps, 'SDTUpdated')
								endwith
								.oMeta.AddRow(lcIndex2, 'Index')
								.oMeta.DBCXSetRowProp(@laProps, lcIndex2, 'Index')
							next lnI
							use in (lcOrigAlias)
							.oMeta.oSDTMgr.Reindex(tcTargetTable, .F., .T.)
		
		* Handle some view-specific properties.
		
						else
							if tcDBC <> lcDBC
								set database to (tcDBC)
							endif tcDBC <> lcDBC
							lnBatch     = dbgetprop(tcSourceTable, 'View', ;
								'BatchUpdateCount')
							lcComment   = dbgetprop(tcSourceTable, 'View', ;
								'Comment')
							llCompare   = dbgetprop(tcSourceTable, 'View', ;
								'CompareMemo')
							llFetch     = dbgetprop(tcSourceTable, 'View', ;
								'FetchAsNeeded')
							llFetchMemo = dbgetprop(tcSourceTable, 'View', ;
								'FetchMemo')
							lnFetch     = dbgetprop(tcSourceTable, 'View', ;
								'FetchSize')
							lnMaxRecs   = dbgetprop(tcSourceTable, 'View', ;
								'MaxRecords')
							lcParams    = dbgetprop(tcSourceTable, 'View', ;
								'ParameterList')
							llPrepared  = dbgetprop(tcSourceTable, 'View', ;
								'Prepared')
							lcRule      = dbgetprop(tcSourceTable, 'View', ;
								'RuleExpression')
							lcRuleText  = dbgetprop(tcSourceTable, 'View', ;
								'RuleText')
							llSendUpd   = dbgetprop(tcSourceTable, 'View', ;
								'SendUpdates')
							lcTables    = dbgetprop(tcSourceTable, 'View', ;
								'Tables')
							lnUpdType   = dbgetprop(tcSourceTable, 'View', ;
								'UpdateType')
							llUseMemo   = dbgetprop(tcSourceTable, 'View', ;
								'UseMemoSize')
							lnWhere     = dbgetprop(tcSourceTable, 'View', ;
								'WhereType')
							if tcDBC <> lcDBC
								set database to (lcDBC)
							endif tcDBC <> lcDBC
							dbsetprop(tcTargetTable, 'View', 'BatchUpdateCount', ;	
								lnBatch)
							dbsetprop(tcTargetTable, 'View', 'Comment', ;
								lcComment)
							dbsetprop(tcTargetTable, 'View', 'CompareMemo', ;
								llCompare)
							dbsetprop(tcTargetTable, 'View', 'FetchAsNeeded', ;
								llFetch)
							dbsetprop(tcTargetTable, 'View', 'FetchMemo', ;
								llFetchMemo)
							dbsetprop(tcTargetTable, 'View', 'FetchSize', ;
								lnFetch)
							dbsetprop(tcTargetTable, 'View', 'MaxRecords', ;
								lnMaxRecs)
							dbsetprop(tcTargetTable, 'View', 'ParameterList', ;
								lcParams)
							dbsetprop(tcTargetTable, 'View', 'Prepared', ;
								llPrepared)
							if not empty(lcRule)
								dbsetprop(tcTargetTable, 'View', 'RuleExpression', ;
									lcRule)
							endif not empty(lcRule)
							if not empty(lcRuleText)
								dbsetprop(tcTargetTable, 'View', 'RuleText', ;
									lcRuleText)
							endif not empty(lcRuleText)
							dbsetprop(tcTargetTable, 'View', 'SendUpdates', ;
								llSendUpd)
							if not empty(lcTables)
								if llAdjust
									lcTables = strtran(lcTables, ;
										lower(juststem(tcDBC)) + '!', ;
										lower(juststem(lcDBC)) + '!')
								endif llAdjust
								dbsetprop(tcTargetTable, 'View', 'Tables', lcTables)
							endif not empty(lcTables)
							dbsetprop(tcTargetTable, 'View', 'UpdateType', ;
								lnUpdType)
							dbsetprop(tcTargetTable, 'View', 'UseMemoSize', ;
								llUseMemo)
							dbsetprop(tcTargetTable, 'View', 'WhereType', ;
								lnWhere)
		
		* Now go get view indexes for the view.
		
							lnObjects = toOtherMeta.DBCXGetAllObjects('Index ' + ;
								tcSourceTable, @laObjects)
							for lnI = 1 to lnObjects
								lcObject1 = laObjects[lnI]
								lcObject2 = tcTargetTable + ;
									substr(lcObject1, at('.', lcObject1))
								dimension laProps[1]
								laProps = ''
								toOtherMeta.DBCXGetRowProp(@laProps, lcObject1, ;
									'Index')
								with .oMeta.oSDTMgr
									.StripProperty(@laProps, 'CBiID')
									.StripProperty(@laProps, 'CBcObjectNam')
									.StripProperty(@laProps, 'CBcDBCName')
									.StripProperty(@laProps, 'CBtLastMod')
									.StripProperty(@laProps, 'SDTObjectName')
									.StripProperty(@laProps, 'SDTDBCName')
									.StripProperty(@laProps, 'SDTUpdated')
								endwith
								.oMeta.AddRow(lcObject2, 'Index')
								.oMeta.DBCXSetRowProp(@laProps, lcObject2, 'Index')
							next lnI
						endif tcType = 'View'
		
		* Now go get calculated fields for the table or view.
		
						lnObjects = toOtherMeta.DBCXGetAllObjects('User ' + ;
							tcSourceTable, @laObjects)
						for lnI = 1 to lnObjects
							lcObject1 = laObjects[lnI]
							lcObject2 = tcTargetTable + ;
								substr(lcObject1, at('.', lcObject1))
							dimension laProps[1]
							laProps = ''
							toOtherMeta.DBCXGetRowProp(@laProps, lcObject1, 'User')
							with .oMeta.oSDTMgr
								.StripProperty(@laProps, 'CBiID')
								.StripProperty(@laProps, 'CBcObjectNam')
								.StripProperty(@laProps, 'CBcDBCName')
								.StripProperty(@laProps, 'CBtLastMod')
								.StripProperty(@laProps, 'SDTObjectName')
								.StripProperty(@laProps, 'SDTDBCName')
								.StripProperty(@laProps, 'SDTUpdated')
							endwith
							.oMeta.AddRow(lcObject2, 'User')
							.oMeta.DBCXSetRowProp(@laProps, lcObject2, 'User')
						next lnI
		
		* Close the tables and update the tree.
		
						.oMeta.CloseOpenedCursors(@laOpenTables)
						loNode = .LoadDatabaseCursor(tcTargetTable, tcType, .cDatabase)
						loNode.Selected = .T.
						.oTree.NodeClick(.oTree.SelectedItem)
					endif not .oError.DidErrorOccur()
					wait clear
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE createnewobject		&& Creates a new object of the appropriate type
		* Create a new object based on the current context. Note: due to a bug in VFP
		* that causes a GPF in the View Designer when it's called from within a WITH
		* block and the view has a logical filter condition, we won't use WITH here.
		
		do case
			case inlist(This.cCurrObjectType, 'Database', 'Databases')
				This.NewDatabase()
			case This.cCurrParentType = 'Free Tables'
				This.NewFreeTable()
			case This.cCurrParentType = 'Table'
				This.NewTable()
			case This.cCurrParentType = 'View'
				This.NewView()
		endcase
		
	ENDPROC

	PROCEDURE Deactivate
		This.ResetHotKeys()
		dodefault()
		
	ENDPROC

	PROCEDURE Destroy
		* Ensure any changes are saved before exiting.
		
		with This
			.ResetHotKeys()
			.SaveChanges()
		
		* Save the MRU meta data paths.
		
			.SaveMRUMetaData()
		
		* If the SDTController exists, tell it we're shutting down.
		
			if vartype(.oController) = 'O'
				.oController.CloseSDT()
			endif vartype(.oController) = 'O'
			.oController = .NULL.
		
		* Nuke other member objects.
		
			if vartype(.oMeta) = 'O'
				.oMeta.Release()
			endif vartype(.oMeta) = 'O'
			if vartype(.oDBUtilities) = 'O'
				.oDBUtilities.Release()
			endif vartype(.oDBUtilities) = 'O'
		
		* Close all tables (workaround for problem releasing the form in VFP 6 due to
		* the TreeView control) and databases.
		
			close databases all
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE displayversion		&& Displays the current version
		* Display the version number.
		
		wait window ccFULL_PRODUCT_NAME + ccCR + 'Version ' + This.cVersion + ccCR + ;
			ccMSG_COPYRIGHT
		
	ENDPROC

	PROCEDURE document
		*==============================================================================
		* Method:			Document
		* Purpose:			Runs the documentation form
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	07/30/2004
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		with This
			.SaveChanges()
			do form SYSDOC with This, .cCurrParentType, ;
				iif(.cCurrParentType = 'Free Tables' or empty(.cCurrParent), '', ;
				.cDatabase + '!') + .cCurrParent
		endwith
		
	ENDPROC

	PROCEDURE donetd		&& Handles any changes after the TD form is done.
		*==============================================================================
		* Method:			DoneTD
		* Purpose:			Finishes processing a modified or new table when the
		*						Extended Table Designer is done
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2002 Stonefield Systems Group Inc.
		* Last Revision:	06/25/2002
		* Parameters:		tlSaved    - .T. if the user saved in TD.SCX
		*					tlNew      - .T. if this is a new table
		*					tcTable    - the name of the table
		*					tcNewName  - the new name of the table if it was changed
		*					tcDatabase - the database the table belongs to
		* Returns:			.T.
		*==============================================================================
		
		lparameters tlSaved, ;
			tlNew, ;
			tcTable, ;
			tcNewName, ;
			tcDatabase
		local lcTable, ;
			lcNode, ;
			loParent, ;
			loNode, ;
			llSave, ;
			lcComment, ;
			lcPropCursor
		with This
			if tlSaved
				if not empty(tcDatabase)
					.OpenDatabase(tcDatabase)
				endif not empty(tcDatabase)
				do case
		
		* If the table was created, add it to the tree if the parent "Tables" node
		* has already been expanded; if not, expand it now (which will cause the new
		* node to be added to the tree) since the node will be selected in a moment.
		
					case tlNew
						lcTable  = lower(tcTable)
						lcNode   = .GetNodeKey(lcTable, 'Table', tcDatabase)
						loParent = .oTree.Nodes[.GetNodeKey('Heading', 'Table', ;
							tcDatabase)]
						if loParent.Expanded or .lAutoLoadTree or loParent.Children = 0
							loNode = .LoadDatabaseCursor(lcTable, 'Table', tcDatabase)
						endif loParent.Expanded ...
						if not loParent.Expanded
							.TreeExpand(loParent, .T.)
						endif not loParent.Expanded
		
		* If the user was modifying the Field Repository, ensure the former selected
		* item still is. Propagate changes to other tables.
		
					case tcTable == ccLIBRARY_TABLE
						lcNode = .oTree.SelectedItem.Key
						.UpdateFieldRep()
						loNode = .LoadFieldRep(.T.)
		
		* This was a modified existing table, so find any views involving this table
		* and redefine them.
		
					otherwise
						.RedefineAllViews(tcTable, .T.)
		
		* The comments might have changed.
		
						with .pgfProps.Page1.cntTableProps
							llSave    = .F.
							lcComment = dbgetprop(tcTable, 'Table', 'Comment')
							if not lcComment == .edtComments.Value
								.edtComments.Value = lcComment
							endif not lcComment == .edtComments.Value
		
		* If the user renamed the table, handle it.
		
							if not tcTable == tcNewName
								This.RenameTable(tcTable, tcNewName, 'Table')
								.txtName.Value = tcNewName
							endif not tcTable == tcNewName
						endwith
						lcNode = .oTree.SelectedItem.Key
						.LoadTreeCursor(tcNewName, 'Table', tcDatabase, .T.)
				endcase
		
		* If the node we want to select no longer exists, select the node for the
		* table. Otherwise, select the node.
		
				do case
					case vartype(loNode) = 'O'
					case .oTree.SelectedItem.Key = lcNode
						loNode = .oTree.SelectedItem
					case type('.oTree.Nodes.Item[lcNode]') = 'O'
						loNode = .oTree.Nodes.Item[lcNode]
					otherwise
						lcNode = .GetNodeKey(tcNewName, 'Table', tcDatabase)
						loNode = .oTree.Nodes.Item[lcNode]
				endcase
				.oTree.NodeClick(loNode)
			endif tlSaved
		
		* Close and reopen the DBCX properties cursor because the user may have added
		* or deleted properties in TD.SCX.
		
			lcPropCursor = .oMeta.cPropCursorName
			if used(lcPropCursor)
				use in (lcPropCursor)
			endif used(lcPropCursor)
			.oMeta.CreatePropCursor()
		
		* Requery the appropriate controls.
		
			.GetDatabaseObject(.cCurrParent, .cCurrParentType, .cCurrObject, ;
				.cCurrObjectType, .cDatabase)
		endwith
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcReturn, ;
			llValidation, ;
			lcView
		aerror(laError)
		lcReturn = ccMSG_CONTINUE
		
		* Set glError to .T. so ViewEditor sees that an error has occurred (if that's
		* where we were called from).
		
		glError = .T.
		with This
			do case
		
		* The specified object wasn't found in the database: ignore it.
		
				case tnError = cnERR_OBJECT_NOT_IN_DBC
		
		* This table belongs to another database.
		
				case tnError = cnERR_BELONGANOTHER or ;
					tnError = cnERR_BELONGANOTHER2
					.oMessage.ErrorMessage(ccERR_BELONG_ANOTHER)
		
		* The view needs to be redefined.
		
				case tnError = cnERR_BASE_FIELDS_CHANGED
					llValidation = not empty(.oMeta.cValidateObjectName)
					lcView       = lower(iif(llValidation, .oMeta.cValidateObjectName, ;
						.cCurrParent))
					if .oMessage.YesNo(strtran(ccQST_REDEFINE_VIEW, ccMSG_INSERT1, ;
						set('DATABASE') + '!' + lcView), .T.)
						.RedefineSingleView(lcView, not llValidation)
						if '.' $ tcMethod
							lcReturn = ccMSG_RETRY
						else
							retry
						endif '.' $ tcMethod
					else
						.lErrorOccurred = .T.
						cancel
					endif .oMessage.YesNo(strtran(...
		
		* SQL column not found: view needs to be redefined.
		
				case tnError = cnERR_SQL_COLUMN_NOT_FOUND
					llValidation = not empty(.oMeta.cValidateObjectName)
					lcView       = lower(set('DATABASE') + '!' + ;
						iif(llValidation, .oMeta.cValidateObjectName, .cCurrParent))
					.oMessage.ErrorMessage(strtran(strtran(ccERR_INVALID_VIEW, ;
						ccMSG_INSERT1, lcView), ccMSG_INSERT2, laError[2]))
					.lErrorOccurred = .T.
		
		* The user decided not to enter view parameters or entered invalid view
		* parameters when browsing the view.
		
				case (tnError = cnERR_EXECUTION_CANCELED or ;
					tnError = cnERR_TYPE_MISMATCH) and upper(tcMethod) = 'BROWSETABLE'
		
		* We have a "file in use error": just return, because the code trying to open
		* the table will check to see if the table was opened.
		
				case tnError = cnERR_FILE_IN_USE
		
		* Use the normal error handling mechanism for all other types of errors. Note
		* that we add a period to the method name passed. This tells our parent class
		* to return the error resolution string back to us, which is required for RETRY
		* to work.
		
				otherwise
					lcReturn = dodefault(tnError, '.' + tcMethod, tnLine)
					lcReturn = iif(vartype(lcReturn) <> 'C', ccMSG_CONTINUE, lcReturn)
					do case
		
		* It wasn't our error, so pass it back to the calling method.
		
						case '.' $ tcMethod
							return lcReturn
		
		* Handle the error choices.
		
						case lcReturn = ccMSG_RETRY
							retry
						case lcReturn = ccMSG_DEBUG
							debug
							if wexist('Visual FoxPro Debugger')
								keyboard '{SHIFT+F7}' plain
							endif wexist('Visual FoxPro Debugger')
							suspend
						case lcReturn = ccMSG_CANCEL
							cancel
						otherwise
							return
					endcase
			endcase
		endwith
		return lcReturn
		
	ENDPROC

	PROCEDURE fieldwizard		&& Updates views to match changes to the current field
		local lcField, ;
			lcView
		with This
			wait window ccMSG_UPDATING_VIEW nowait
			lcField = .cCurrObject
			lcView  = .cCurrParent
			.UpdateViewField(lcView, lcField)
			.pgfProps.Page1.cntFieldProps.Requery()
			wait clear
		endwith
		
	ENDPROC

	PROCEDURE findallusesoftable
		*==============================================================================
		* Method:			FindAllUsesOfTable
		* Purpose:			Finds and displays all references in the database to a
		*						table
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2005 Stonefield Systems Group Inc.
		* Last Revision:	03/23/2005
		* Parameters:		tcTable    - the name of the table
		*					tcDBCAlias - the name of the alias the DBC is open as or
		*						the path to the DBC if it isn't open
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcTable
		local lcTable, ;
			laDBCs[1], ;
			lnDBCs, ;
			lnI, ;
			lcDBC, ;
			lcPath, ;
			lcDBCAlias, ;
			lnPos, ;
			lcObject, ;
			lnRecno, ;
			liParent, ;
			lcProperty, ;
			loNotify
		with This
			lcTable = .cDatabase + '!' + tcTable
		
		* Create a cursor to contain notes for the developer.
		
			create cursor __NOTIFY (MESSAGE C(128), NOTIFY M)
			insert into __NOTIFY (MESSAGE) values ;
				(strtran(ccMSG_REMOVE_EDITS, ccMSG_INSERT1, tcTable))
		
		* Process each database in the meta data. Start by opening the DBC as a table.
		
			lnDBCs = .oMeta.DBCXGetAllObjects('Database', @laDBCs)
			for lnI = 1 to lnDBCs
				.OpenDatabase(laDBCs[lnI])
				lcDBC      = dbc()
				lcDBCAlias = .oMeta.oSDTMgr.DBCOpen(lcDBC)
		
		* Check the DBC for all occurrences of the table. First, check the stored
		* procedures.
		
				if not empty(lcDBCAlias)
					set database to (lcDBC)
					select (lcDBCAlias)
					set order to OBJECTNAME
					seek str(cnVF_OBJID_DATABASE) + ccVF_OBJ_DATABASE + ;
						lower(ccVF_OBJ_STOREDPROCSRC)
					if (lcDBC == .cDatabase and .oUtility.InExpr(tcTable, CODE, ;
						.F., .T.)) or .oUtility.InExpr(lcTable, CODE, .F., .T.)
						replace NOTIFY with 'Stored Procedures' + ccCR in __NOTIFY
					endif (lcDBC == .cDatabase ...
		
		* Now check all validation rules, defaults, etc.
		
					scan for (lcDBC == .cDatabase and ;
						atc(tcTable, PROPERTY) > 0) or ;
						atc(lcTable, PROPERTY) > 0
						if lcDBC == .cDatabase
							lnPos = .oUtility.InExpr(tcTable, PROPERTY, .T., .T.)
						else
							lnPos = 0
						endif lcDBC == .cDatabase
						if lnPos = 0
							lnPos = .oUtility.InExpr(lcTable, PROPERTY, .T., .T.)
							if lnPos > 0
								lnPos = lnPos + len(.cDatabase) + 1
							endif lnPos > 0
						endif lnPos = 0
						lcObject = alltrim(OBJECTNAME)
						do case
		
		* If it wasn't found exactly, ignore it.
		
							case lnPos = 0
		
		* For fields and indexes, flag that we found it.
		
							case inlist(OBJECTTYPE, ccVF_OBJ_FIELD, ccVF_OBJ_INDEX)
								lnRecno  = recno()
								liParent = PARENTID
								locate for OBJECTID = liParent
								lcObject = alltrim(OBJECTNAME) + '.' + lcObject
								replace NOTIFY with NOTIFY + lcObject + ccCR in __NOTIFY
								go lnRecno
		
		* In the case of a view, delete it.
		
							case OBJECTTYPE = ccVF_OBJ_VIEW
								delete view (lcObject)
								.RemoveNode(lcObject, 'View', lcDBC, .T.)
		
		* For tables, just flag that we found it.
		
							case OBJECTTYPE = ccVF_OBJ_TABLE
								lcProperty = PROPERTY
								do while lnPos > 0
									if upper(substr(lcProperty, lnPos + ;
										len(tcTable), 4)) <> '.DBF'
										replace NOTIFY with NOTIFY + lcObject + ccCR ;
											in __NOTIFY
										lnPos = 0
									else
										lcProperty = stuff(lcProperty, lnPos, ;
											len(tcTable), '')
										lnPos = .oUtility.InExpr(tcTable, lcProperty, ;
											.T., .T.)
									endif upper(substr(PROPERTY, ...
								enddo while lnPos > 0
						endcase
					endscan for (lcDBC == .cDatabase ...
		
		* Close the DBC.
		
					use in (lcDBCAlias)
				endif not empty(lcDBCAlias)
			next lnI
			set database to (.cDBC)
		
		* Now display a message so the user knows what objects were affected.
		
			wait clear
			if not empty(__NOTIFY.NOTIFY)
				do form NOTIFY with '__NOTIFY', .oError name loNotify linked
			endif not empty(__NOTIFY.NOTIFY)
			use in __NOTIFY
		endwith
		
	ENDPROC

	PROCEDURE findlastnode		&& Finds the last child node
		lparameters toNode
		local loChild
		with toNode
			loChild = toNode
			if .Expanded
				loChild = .Child
				do while type('loChild.Next.Text') = 'C'
					loChild = loChild.Next
				enddo while type('loChild.Next.Text') = 'C'
				loChild = This.FindLastNode(loChild)
			endif .Expanded
		endwith
		return loChild
		
	ENDPROC

	PROCEDURE findmetatables
		*==============================================================================
		* Method:			FindMetaTables
		* Purpose:			Locate the SDT meta tables based on certain factors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	08/01/2001
		* Parameters:		tcPath - the default path for the meta tables
		* Returns:			the path where the meta tables are found, or a path and
		*						UNTITLED if the user chose "New"
		*==============================================================================
		
		lparameters tcPath
		local lcPath, ;
			llFound, ;
			laDir[1], ;
			lnDir, ;
			lnI, ;
			lcTestPath
		with This
		
		* First try either the same directory as the DBC or a specific directory,
		* depending on the preference settings.
		
			do case
				case .nDBCXAskLocation = 3
					lcPath = tcPath
				case .nDBCXAskLocation = 4
					lcPath = .cDBCXSpecificDir
			endcase
			llFound = not empty(lcPath) and file(lcPath + 'DBCXREG.DBF')
		
		* Next try the directories specified in cDBCXSearch.
		
			if not llFound
				lnDir = alines(laDir, .cDBCXSearch)
				for lnI = 1 to lnDir
					lcPath = laDir[lnI]
					do case
						case empty(lcPath)
						case left(lcPath, 1) = '='
							lcTestPath = evaluate(lcPath)
						otherwise
							lcTestPath = addbs(fullpath(lcPath, .cDBC))
					endcase
					do case
						case empty(lcPath)
						case file(lcTestPath + 'DBCXREG.DBF')
							lcPath  = lcTestPath
							llFound = .T.
							exit
					endcase
				next lnI
			endif not llFound
			do case
		
		* If we found DBCXREG.DBF, we're done.
		
				case llFound
		
		* If we're not supposed to open the meta data tables, blank the path.
		
				case .nDBCXAskLocation = 2
					lcPath = ''
		
		* If we're supposed to ask where to find DBCXREG when we can't find it, do so.
		
				case .nDBCXAskLocation = 1
					lcPath = .AskForMetaPath(tcPath)
		
		* Indicate that we're going to create a new set of meta data tables, either in
		* the same directory as the DBC or in a specific directory.
		
				case .nDBCXAskLocation = 3
					lcPath = tcPath + ccUNTITLED
				otherwise
					lcPath = .cDBCXSpecificDir + ccUNTITLED
			endcase
		endwith
		return lcPath
		
	ENDPROC

	PROCEDURE getdatabasefromnodekey		&& Returns the database part of the specified node key
		lparameters tcKey
		local lnPos
		lnPos = at('!', tcKey)
		return substr(tcKey, 2, lnPos - 2)
		
	ENDPROC

	PROCEDURE getdatabaseobject		&& Finds the specified object in the database and read all properties for it.
		*==============================================================================
		* Method:			GetDatabaseObject
		* Purpose:			Updates the form to show information for the specified
		*						object
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2002 Stonefield Systems Group Inc.
		* Last revision:	04/18/2002
		* Parameters:		tcParent     - the name of the parent object
		*					tcParentType - the type of the parent object
		*					tcObject     - the name of the object
		*					tcObjectType - the type of the object
		*					tcDatabase   - the name of the database
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcParent, ;
			tcParentType, ;
			tcObject, ;
			tcObjectType, ;
			tcDatabase
		local lcObject
		
		* Save the properties of the new selected object.
		
		with This
			if not empty(tcDatabase)
				.OpenDatabase(tcDatabase)
				.cDatabase = tcDatabase
				.cDBC      = dbc()
			else
				store '' to .cDatabase, .cDBC
			endif not empty(tcDatabase)
			.oMeta.SetDatabase(.cDBC)
			.cCurrParent     = tcParent
			.cCurrParentType = tcParentType
			.cCurrObject     = tcObject
			.cCurrObjectType = tcObjectType
			lcObject         = tcObject
		
		* If the Properties page is disabled (meaning we had no meta data open before),
		* enable it now.
		
			if not .pgfProps.Page1.Enabled
				.pgfProps.Page1.Enabled = .T.
			endif not .pgfProps.Page1.Enabled
		
		* The Extended Properties page is only enabled for certain types of objects. If
		* it isn't enabled but it's the current page, make the first page current.
		
			.pgfProps.Page2.cntExtProps.cCurrObjectType = tcObjectType
			.pgfProps.Page2.Enabled = not empty(tcParent) or tcObjectType == 'Database'
			if not .pgfProps.Page2.Enabled and .pgfProps.ActivePage = 2
				.pgfProps.ActivePage = 1
			endif not .pgfProps.Page2.Enabled ...
		
		* Position the appropriate meta data tables to the record for this object.
		
			do case
				case tcParentType = ccLIBRARY_TABLE
					= seek(upper(space(len(LIBSDTMETA.DBCNAME)) + ;
							left(tcObjectType, 1) + ;
							padr(lcObject, len(LIBSDTMETA.OBJECTNAME))), ;
							'LIBSDTMETA', 'OBJECTNAME') and ;
						seek(space(len(LIBCOREMETA.CDBCNAME)) + ;
							left(tcObjectType, 1) + ;
							padr(upper(lcObject), len(LIBCOREMETA.COBJECTNAM)), ;
							'LIBCOREMETA', 'OBJECTNAME')
		
		* Position the meta data tables to the records for the selected object.
		
				case tcParentType = 'Free Tables' and not empty(lcObject)
					= seek(upper(space(len(SDTMETA.DBCNAME)) + ;
							left(tcObjectType, 1) + ;
							padr(lcObject, len(SDTMETA.OBJECTNAME))), 'SDTMETA', ;
							'OBJECTNAME') and ;
						seek(upper(space(len(COREMETA.CDBCNAME)) + ;
							left(tcObjectType, 1) + ;
							padr(lcObject, len(COREMETA.COBJECTNAM))), ;
							'COREMETA', 'OBJECTNAME')
		
		* Position the meta data tables to the records for the selected object.
		
				case not empty(lcObject)
					= seek(upper(padr(.cDatabase, len(SDTMETA.DBCNAME)) + ;
							left(tcObjectType, 1) + ;
							padr(lcObject, len(SDTMETA.OBJECTNAME))), 'SDTMETA', ;
							'OBJECTNAME') and ;
						seek(upper(padr(.cDatabase, len(COREMETA.CDBCNAME)) + ;
							left(tcObjectType, 1) + ;
							padr(lcObject, len(COREMETA.COBJECTNAM))), ;
							'COREMETA', 'OBJECTNAME')
			endcase
		
		* Set some properties that indicate whether the user chose an object, whether
		* it's a table or not, and whether the object exists or not.
		
			.lGotObject    = (not empty(tcParent) and ;
				tcParentType <> ccLIBRARY_TABLE) or tcObjectType == 'Database'
			.lExtProps     = .lGotObject or tcObjectType == 'Database'
			.lGotTable     = .lGotObject and inlist(tcParentType, 'Table', ;
				'Free Tables')
			.lObjectExists = .lGotObject and (tcParentType = 'View' or ;
				(tcParentType = 'Table' and file(fullpath(dbgetprop(tcParent, ;
				'Table', 'Path'), .cDBC))) or (tcParentType = 'Free Tables' and ;
				file(.oMeta.oSDTMgr.GetFreeTablePath('!' + tcParent))))
		
		* Requery the appropriate property container.
		
			with .pgfProps.Page1
				do case
					case tcObjectType = 'Table' or tcObjectType = 'Free Tables'
						.cntTableProps.Requery()
						This.cContainer = 'cntTableProps'
					case tcObjectType = 'View'
						.cntViewProps.Requery()
						This.cContainer = 'cntViewProps'
					case inlist(tcObjectType, 'Field', ccLIBRARY_TABLE)
						.cntFieldProps.Requery(.T.)
						This.cContainer = 'cntFieldProps'
					case tcObjectType = 'User'
						.cntCalcProps.Requery()
						This.cContainer = 'cntCalcProps'
					case tcObjectType = 'Index'
						.cntIndexProps.Requery()
						This.cContainer = 'cntIndexProps'
					case tcObjectType = 'Databases'
						.cntDatabasesProps.Requery()
						This.cContainer = 'cntDatabasesProps'
					case tcObjectType = 'Database'
						.cntDatabaseProps.Requery()
						This.cContainer = 'cntDatabaseProps'
				endcase
			endwith
		
		* Get the extended properties for the selected object.
		
			with .pgfProps.Page2.cntExtProps
				.lGotObject = This.lExtProps or tcParentType = ccLIBRARY_TABLE
				if .lGotObject
					.GetExtProps(lcObject, tcObjectType)
				endif .lGotObject
			endwith
			if .pgfProps.ActivePage = 2
				.pgfProps.Page2.Refresh()
			endif .pgfProps.ActivePage = 2
		endwith
		return
		
	ENDPROC

	PROCEDURE getmetadbf
		*==============================================================================
		* Method:			GetMetaDBF
		* Purpose:			Returns the DBF name for the SDTMETA table. This is needed
		*						because another instance of this form (which is in a
		*						different datasession) might need to know this
		*						(specifically, the MoveTable() method)
		* Author:			Doug Hennig
		* Copyright:		(c) 1997 Stonefield Systems Group Inc.
		* Last Revision:	12/22/97
		* Parameters:		none
		* Returns:			the DBF name for the SDTMETA table
		*==============================================================================
		
		return dbf('SDTMETA')
		
	ENDPROC

	PROCEDURE getmetapaths		&& Get the meta data paths from the Registry
		local laPaths[1], ;
			lnPaths, ;
			lnI, ;
			lcPath, ;
			laMetaPaths[1]
		with This.oReg
			lnPaths = .EnumerateKeyValues(ccREG_KEY_META_PATHS, @laPaths)
			This.aMetaPaths = ''
			for lnI = 1 to min(lnPaths, alen(This.aMetaPaths, 1))
				lcPath = strtran(laPaths[lnI, 2], '~', chr(13))
				alines(laMetaPaths, lcPath)
				This.aMetaPaths[lnI, 1] = laMetaPaths[1, 1]
				This.aMetaPaths[lnI, 2] = lower(laMetaPaths[1, 2])
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE getnewfile
		*==============================================================================
		* Method:			GetNewFile
		* Purpose:			Gets a new filename
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	03/22/2004
		* Parameters:		tcDirectory - the initial directory to use
		*					tcCaption   - the caption for the dialog
		*					tcFilter    - the filter to use (optional: if it isn't
		*						specified, "Tables (*.DBF)" is used
		*					tcFileSpec  - the file spec to use (optional: if it isn't
		*						specified, "*.DBF" is used
		* Returns:			the filename entered by the user
		*==============================================================================
		
		lparameters tcDirectory, ;
			tcCaption, ;
			tcFilter, ;
			tcFileSpec
		local lcFileName
		with This.oCommonDialog
			.ClearFilters(.T.)
			if vartype(tcFilter) = 'C'
				.AddFilter(tcFilter, tcFileSpec)
			else
				.AddFilter('Tables (*.DBF)', '*.DBF')
			endif vartype(tcFilter) = 'C'
			.cTitleBarText     = iif(vartype(tcCaption)   = 'C', tcCaption, ;
				proper(strtran(ccCAP_CREATE, ccMSG_INSERT1, ccTABLE)))
			.cInitialDirectory = iif(vartype(tcDirectory) = 'C', tcDirectory, '')
			.cFileName         = ''
			.ShowDialog()
			lcFileName = addbs(.cFilePath) + .cFileTitle
		endwith
		return lcFileName
		
	ENDPROC

	PROCEDURE getnodekey		&& Creates a key for the specified object
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcDatabase
		local lcObjectType, ;
			lcDatabase, ;
			lcKey
		lcObjectType = upper(left(tcObjectType, 1))
		lcDatabase   = iif(vartype(tcDatabase) = 'C', lower(juststem(tcDatabase)), '')
		do case
			case tcObjectName = 'Heading' and tcObjectType = 'Free Tables'
				lcKey = 'H!Table'
			case tcObjectName = 'Heading' and tcObjectType = 'Field Repository'
				lcKey = 'H!' + ccLIBRARY_TABLE
			case tcObjectName = 'Heading' and tcObjectType = 'Databases'
				lcKey = 'HDatabases'
			case tcObjectName = 'Heading' and lcObjectType = 'T'
				lcKey = 'H' + lcDatabase + '!Table'
			case tcObjectName = 'Heading' and lcObjectType = 'V'
				lcKey = 'H' + lcDatabase + '!View'
			otherwise
				lcKey = lcObjectType + iif(lcObjectType = 'D', '', ;
					lcDatabase + '!') + lower(tcObjectName)
		endcase
		return lcKey
		
	ENDPROC

	PROCEDURE getobjectfromnodekey		&& Returns the object name part of the specified node key
		lparameters tcKey
		local lnPos
		lnPos = max(at('!', tcKey), 1)
		return substr(tcKey, lnPos + 1)
		
	ENDPROC

	PROCEDURE getpreferences
		*==============================================================================
		* Method:			GetPreferences
		* Purpose:			Read our preferences from the Windows registry
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2006 Stonefield Systems Group Inc.
		* Last Revision:	03/24/2006
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcAskDBCX
		with This.oReg
			This.cListAction = .GetKey(ccREG_KEY, ccPREF_LISTACTION, 'No Action')
			lcAskDBCX        = .GetKey(ccREG_KEY, ccPREF_ASK_FOR_DBCXREG)
			do case
				case lcAskDBCX = 'Yes'
					This.nDBCXAskLocation = 1
				case lcAskDBCX = 'No'
					This.nDBCXAskLocation = 3
				otherwise
					This.nDBCXAskLocation = val(lcAskDBCX)
			endcase
			This.cDBCXSearch        = .GetKey(ccREG_KEY, ccPREF_DBCXSEARCH)
			This.cDBCXSpecificDir   = .GetKey(ccREG_KEY, ccPREF_DBCXREG_SPEC_DIR)
			This.lShowInternational = .GetKey(ccREG_KEY, ccPREF_SHOW_INTL) = 'Yes'
			This.lNamingConv        = .GetKey(ccREG_KEY, ccPREF_NAMING_CONV) = 'Yes'
			This.cDBCSelection      = .GetKey(ccREG_KEY, ccPREF_DBC_SELECTION)
			This.cDBCSpecificDir    = .GetKey(ccREG_KEY, ccPREF_DBC_SPEC_DIR)
			This.cFieldRepDir       = .GetKey(ccREG_KEY, ccPREF_FIELD_REP_DIR)
			This.lViewInheritance   = .GetKey(ccREG_KEY, ccPREF_VIEW_INHERITANCE) = 'Yes'
			This.lAutoExpand        = .GetKey(ccREG_KEY, ccPREF_AUTO_EXPAND) = 'Yes'
			This.lAutoLoadTree      = .GetKey(ccREG_KEY, ccPREF_AUTO_LOADTREE) = 'Yes'
			This.lUseFieldRep       = .GetKey(ccREG_KEY, ccPREF_USE_FIELDREP, 'Yes') = 'Yes'
			This.GetMetaPaths()
		endwith
		
	ENDPROC

	PROCEDURE handlesdtmeta		&& Opens or closes SDTMETA.DBF as necessary.
		*==============================================================================
		* Method:			HandleSDTMeta
		* Purpose:			Opens or closes SDTMETA
		* Author:			Doug Hennig
		* Copyright:		(c) 1997 Stonefield Systems Group Inc.
		* Last Revision:	09/02/99
		* Parameters:		tcSDTMeta  - the alias the SDTMETA is open under
		*					tcMetaPath - the file (including directory) to open
		*					tlOpen     - .T. if SDTMETA should be opened
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcSDTMeta, ;
			tcMetaPath, ;
			tlOpen
		with This
			do case
				case tlOpen and not used(tcSDTMeta)
					use (tcMetaPath) in 0 again shared alias (tcSDTMeta)
				case not tlOpen and used(tcSDTMeta)
					use in (tcSDTMeta)
			endcase
		endwith
		
	ENDPROC

	PROCEDURE Init
		lparameters toController, ;
			tcDatabase, ;
			taDatabases, ;
			tlNoShow
		local lcDirectory, ;
			lcAction, ;
			lnAsk, ;
			lcDBC, ;
			laDir[1], ;
			lnFiles, ;
			laDatabases[1], ;
			lnI, ;
			lcPath, ;
			llError, ;
			laTables[1], ;
			lnTables, ;
			llCreate, ;
			lcOldDir, ;
			loMeta, ;
			laCodePage[1], ;
			laTypes[1], ;
			laIndexes[1], ;
			laCollate[1], ;
			lcEditor
		with This
		
		* If nothing was passed, we're just running the form, so create the necessary
		* objects.
		
			if vartype(toController) <> 'O'
				.oError   = MakeObject('SDTErrorMgr',  'SDTManagers.vcx')
				.oMessage = MakeObject('SFMessageMgr', 'SFMessage.vcx')
		
		* Save passed objects in properties.
		
			else
				.oController = toController
				.oError      = toController.oError
				.oMessage    = toController.oMessage
			endif vartype(toController) <> 'O'
		
		* We need to instantiate SFUtility here rather than using SDTController's
		* because we want it to be in our data session.
		
			.oUtility = MakeObject('SFUtility', 'SFUtility.vcx')
		
		* Get the directory we're running from.
		
			lcDirectory = .oUtility.GetAppDirectory(sys(16, program(-1) - 2))
		
		* If we're supposed to display, load and set properties for our ActiveX
		* controls.
		
			if not tlNoShow
				if not file(lcDirectory + 'ITable.bmp')
					lcDirectory = lcDirectory + 'SOURCE\'
				endif not file(lcDirectory + 'ITable.bmp')
				.oImageListLoader.LoadActiveX()
				with .oImageList
					.ImageHeight = 15
					.ImageWidth  = 17
					.ListImages.Add(1, , loadpicture(lcDirectory + 'ITable.bmp'))
					.ListImages.Add(2, , loadpicture(lcDirectory + 'IView.bmp'))
					.ListImages.Add(3, , loadpicture(lcDirectory + 'IFields.bmp'))
					.ListImages.Add(4, , loadpicture(lcDirectory + 'IIndexes.bmp'))
					.ListImages.Add(5, , loadpicture(lcDirectory + 'IKey.bmp'))
					.ListImages.Add(6, , loadpicture(lcDirectory + 'IDatabas.bmp'))
					.ListImages.Add(7, , loadpicture(lcDirectory + 'ILibrary.bmp'))
					.ListImages.Add(8, , loadpicture(lcDirectory + 'ICalc.bmp'))
					.ListImages.Add(9, , loadpicture(lcDirectory + 'IRemView.bmp'))
				endwith
				.oTreeViewLoader.LoadActiveX()
				with .oTree
					.BorderStyle      = 0
					.HideSelection    = .F.
					.ImageList        = This.oImageList.Object
					.Indentation      = 10
					.LabelEdit        = 1
					.LineStyle        = 1
					.PathSeparator    = '\'
					.Style            = 7
					.TabIndex         = 2
					.Object.Font.Name = 'Tahoma'
					.Object.Font.Size = 9
					if vartype(toController) = 'O'
						.Object.Font.Name = _screen.SDTController.cFontName
						.Object.Font.Size = _screen.SDTController.nFontSize
					endif vartype(toController) = 'O'
				endwith
			endif not tlNoShow
		
		* Read our preferences from the Windows registry.
		
			lcAction = .oReg.GetKey(ccREG_KEY, ccPREF_LISTACTION, 'No Action')
			do case
		
		* We have a valid value, so carry on.
		
				case lcAction <> 'No Action'
		
		* We have preferences from the previous release of SDT, so convert them to the
		* new version.
		
				case .oReg.GetKey(ccREG_KEY_FORMER, ccPREF_LISTACTION, ;
					'No Action') <> 'No Action' or ;
					.oReg.GetKey(ccREG_KEY_SDT51, ccPREF_LISTACTION, ;
					'No Action') <> 'No Action' and .RegisterPreferences()
					.ConvertPreferences()
		
		* We registered our current preferences.
		
				case .RegisterPreferences()
		
		* We can't register our preferences, so give an error and exit.
						
				otherwise
					.oMessage.ErrorMessage(ccERR_CANT_DEF_PREF)
					return .F.
			endcase
			.oReg.SetKey(ccREG_KEY, 'Location', lcDirectory)
			.GetPreferences()
		
		* Error if we don't have a field repository directory.
		
			if .lUseFieldRep and empty(.cFieldRepDir)
				.oMessage.ErrorMessage(ccERR_NO_FIELD_REP_DIR)
				return .F.
			endif .lUseFieldRep ...
		
		* Select the database to work with.
		
			lnAsk = 0
			do case
		
		* If this is the demo version, use the sample database.
		
				case .lDemo
					lcDBC = lcDirectory + 'SAMPLE.DBC'
		
		* If we're supposed to always ask for the database, flag that we'll do so.
		
				case .cDBCSelection = ccPREF_ALWAYS_ASK_DBC
					lnAsk = 1
		
		* If we're supposed to open a database in a specific directory, see how many
		* there are there. If there isn't exactly one, we'll need to ask.
		
				case .cDBCSelection = ccPREF_OPEN_DBC_IN_DIR
					lnFiles = adir(laDir, .cDBCSpecificDir + '*.DBC')
					if lnFiles > 0
						dimension laDatabases[lnFiles, 2]
						for lnI = 1 to lnFiles
							laDatabases[lnI, 1] = juststem(laDir[lnI, 1])
							laDatabases[lnI, 2] = .cDBCSpecificDir + laDir[lnI, 1]
						next lnI
						lnAsk = 2
						lcDBC = iif(lnFiles = 1, laDatabases[1, 2], '')
					else
						lnAsk = 1
						lcDBC = ''
					endif lnFiles > 0
		
		* If more than one database is currently open and we're supposed to ask, flag
		* that.
		
				case .cDBCSelection = ccPREF_ASK_IF_MANY and ;
					type('taDatabases[1, 1]') <> 'U' and alen(taDatabases, 1) > 1
					lnAsk = 2
					acopy(taDatabases, laDatabases)
		
		* If no database is open, we'll just carry on.
		
				case empty(tcDatabase)
					lnAsk = 0
		
		* Use the only open database.
		
				otherwise
					lcDBC = tcDatabase
			endcase
			do case
		
		* We have a database, so we don't need to do anything else.
		
				case lnAsk = 0 or not empty(lcDBC)
		
		* Ask which database to use using an Open File dialog
		
				case lnAsk = 1
					lcDBC = getfile('DBC', ccMSG_OPEN_DATABASE)
		
		* Display a dialog of specific databases to choose from.
		
				otherwise
					do form SELDBC with tcDatabase, laDatabases, .oUtility to lcDBC
			endcase
		
		* If the database is open, ensure it's the current one.
		
			if not empty(lcDBC)
				lcPath = addbs(justpath(lcDBC))
				if dbused(lcDBC)
					set database to (lcDBC)
		
		* If the database isn't open, try to open it.
		
				else
					.oError.SetSuppressErrors(.T.)
					.oError.ResetError()
					open database (lcDBC) shared
					llError = .oError.DidErrorOccur()
					.oError.ResetError()
					.oError.SetSuppressErrors(.F.)
					if llError
						.oMessage.ErrorMessage(strtran(ccERR_CANT_OPEN_FILE, ;
							ccMSG_INSERT1, lcDBC))
						return .F.
					endif llError
				endif dbused(lcDBC)
		
		* Save the name of the current database.
		
				.cDBC      = dbc()
				.cDatabase = lower(juststem(dbc()))
		
		* If this is the demo version, ensure only the demo tables are in it.
		
				lnTables = adbobject(laTables, 'Table')
				if lnTables > 2 and .lDemo
					.oMessage.ErrorMessage(ccERR_INVALID_DEMO)
					return .F.
				endif lnTables > 2 ...
			else
				lcPath = ''
			endif not empty(lcDBC)
		
		* Try to find DBCXREG.DBF.
		
			lcPath   = .FindMetaTables(lcPath)
			llCreate = .F.
			if (ccUNTITLED $ lcPath or ;
				(not file(lcPath + 'SDTMETA.DBF') and ;
				not file(lcPath + 'SDTVMETA.DBF')) or ;
				(not file(lcPath + 'SDTUSER.DBF') and ;
				not file(lcPath + 'SDTVUSER.DBF')) or ;
				not file(lcPath + 'COREMETA.DBF')) and .nDBCXAskLocation <> 2
				lcPath   = addbs(justpath(strtran(lcPath, ccUNTITLED)))
				llCreate = .T.
			endif ccUNTITLED $ lcPath ...
		
		* If the Fields Repository directory doesn't exist, create it.
		
			if .lUseFieldRep
				if not directory(.cFieldRepDir)
					md (.cFieldRepDir)
				endif not directory(.cFieldRepDir)
		
		* If we don't have any Field Repository meta data tables but we do from a
		* previous version of SDT, copy those to the Field Repository directory.
		
				lcOldDir = .oReg.GetKey(ccREG_KEY_FORMER, ccPREF_FIELD_REP_DIR, ;
					'No Action')
				if lcOldDir <> 'No Action' and not file(.cFieldRepDir + 'SDTMETA.DBF') and ;
					file(lcOldDir + 'SDTMETA.DBF')
					copy file (lcOldDir + '*.*') to (.cFieldRepDir + '*.*')
				endif lcOldDir <> 'No Action' ...
		
		* Instantiate a version of DBCXMgr solely for the purpose of creating meta data
		* tables or converting the structures from an earlier version if necessary.
		
				loMeta = MakeObject('SDTDBCXMgr', 'SDTManagers.VCX', '', .F., ;
					.cFieldRepDir, .T.)
				if vartype(loMeta) <> 'O'
					return .F.
				endif vartype(loMeta) <> 'O'
		
		* If the SDT Manager isn't registered, do it and then alter the structure of
		* SDTMETA as we'll need for the Field Repository.
		
				if not loMeta.IsManagerRegistered('oSDTMgr')
					lcDirectory = .oUtility.GetAppDirectory(sys(16))
					loMeta.RegisterManager('Stonefield Database Toolkit', lcDirectory, ;
						'SDT.VCX', 'SDTMgr')
					select SDTMETA
					use dbf() exclusive
					alter table SDTMETA ;
						add column VALID M ;
						add column ERROR M ;
						add column DEFVALUE M ;
						add column AUTOLIB M ;
						add column AUTOCLASS M
				endif not loMeta.IsManagerRegistered('oSDTMgr')
				replace all OBJECTNAME with upper(SDTMETA.OBJECTNAME)  in SDTMETA
				replace all COBJECTNAM with upper(COREMETA.COBJECTNAM) in COREMETA
				erase (.cFieldRepDir + 'CDBKMETA.*')
		
		* Now release DBCXMgr and open the Field Repository tables as free tables.
		
				release loMeta
				use (.cFieldRepDir + 'SDTMETA.DBF')  alias LIBSDTMETA  again shared in 0
				use (.cFieldRepDir + 'COREMETA.DBF') alias LIBCOREMETA again shared in 0
				use (.cFieldRepDir + 'SDTUSER.DBF')  alias LIBSDTUSER  again shared in 0
			endif .lUseFieldRep
		
		* If we have a path for the meta data, open or create it.
		
			if not empty(lcPath)
				.OpenMetaData(fullpath(lcPath), llCreate)
			endif not empty(lcPath)
		
		* Calculate the nHeightSpacing and nWidthSpacing properties and resize the
		* objects.
		
			if not tlNoShow
				.nHeightSpacing    = .Height - .oTree.Top - .oTree.Height
				.nWidthSpacing     = .pgfProps.Left - .oTree.Left - .oTree.Width
				.nWidthSpacingPage = .Width - .pgfProps.Left - .pgfProps.Width
				.oPersist.cKey     = addbs(ccREG_KEY) + 'Database Explorer'
				.oPersist.Restore()
				.Resize()
			endif not tlNoShow
		
		* Calculate the conversion factor between VFP window units and TreeView window
		* units.
		
			.CalcTwipsPerPixel()
		
		* Set the form's caption to our title, assign ourselves a unique ID, then call
		* the baseclass Init().
		
			.Caption   = ccFRM_SDT_CAPTION
			.cUniqueID = sys(2015)
		
		* Get the location of ViewEditor.
		
			lcEditor = .oReg.GetKey('Software\WhiteLightComputingTools\ViewEditor\' + ;
				'3.0\Options', 'cVEPath')
			if empty(lcEditor)
				lcEditor = .oReg.GetKey('Software\G2Tools\ViewEditor\3.0\Options', ;
					'cVEPath')
				if empty(lcEditor)
					lcEditor = .oReg.GetKey('Software\Sawyer\ViewEditor\Config', ;
						'Location')
				endif empty(lcEditor)
			endif empty(lcEditor)
			if not empty(lcEditor) and file(lcEditor)
				.cViewEditor = lcEditor
			endif not empty(lcEditor) ...
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE KeyPress
		* Close the form if the user hit Esc.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = 27
			This.Release()
		else
			dodefault(tnKeyCode, tnShiftAltCtrl)
		endif tnKeyCode = 27
		
	ENDPROC

	PROCEDURE Load
		* Create a cursor for extended properties.
		
		dodefault()
		local lcCurrCollate
		create cursor _PROPERTY (PROPERTY C(128), TYPE C(15), FIELD_NAME C(10), ;
			CVALUE M, DVALUE D, DTVALUE T, LVALUE L, NVALUE B(8), FIELD_LEN N(3), ;
			FIELD_DEC N(3), FIELD_TYPE C(1))
		cursorsetprop('Buffering', 1)
		lcCurrCollate = set('COLLATE')
		set collate to 'MACHINE'
		index on PROPERTY   for not deleted() tag PROPERTY
		index on FIELD_NAME for not deleted() tag FIELD_NAME
		set collate to lcCurrCollate
		
		* Set AutoYield and SYS(2333) to work with ActiveX controls.
		
		_VFP.AutoYield = .F.
		sys(2333, 0)
		
		* Dimension aMetaPaths.
		
		dimension This.aMetaPaths[20, 2]
		
	ENDPROC

	PROCEDURE loadcursor
		*==============================================================================
		* Method:			LoadCursor
		* Purpose:			Loads the tree with a single cursor
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/08/2001
		* Parameters:		tcObjectName - the name of the table or view (which may be
		*						a new name if the object was renamed)
		*					tcObjectType - "Table" or "View"
		*					tcDatabase   - the database the table or view belongs to
		*					taObjects    - an array of child objects for the table or
		*						view
		*					tcPrimary    - the primary key for the table
		*					tlReload     - .T. to reload the node
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcDatabase, ;
			taObjects, ;
			tcPrimary, ;
			tlReload
		local lcCursorKey, ;
			lcObjectName, ;
			lcObjectType, ;
			loCursor, ;
			lnNode, ;
			llExpanded, ;
			lnImage, ;
			lcParentKey, ;
			llValid, ;
			lnObjects, ;
			lcFieldKey, ;
			lcIndexKey, ;
			lcUserKey, ;
			lnI, ;
			lcAliasedName, ;
			lcKey
		external array taObjects
		
		* Add a node for the cursor if there isn't one already.
		
		with This.oTree
			lcCursorKey  = This.GetNodeKey(tcObjectName, tcObjectType, tcDatabase)
			lcObjectName = lower(tcObjectName)
			lcObjectType = left(tcObjectType, 1)
			loCursor     = .Nodes.Item(lcCursorKey)
		
		* If we're supposed to reload the cursor node, nuke the node and recreate it.
		
			if tlReload
				lnNode      = loCursor.Index
				llExpanded  = loCursor.Expanded
				lnImage     = loCursor.Image
				lcParentKey = loCursor.Parent.Key
				.Nodes.Remove(lnNode)
				loCursor    = .Nodes.Add(lcParentKey, 4, lcCursorKey, ;
					lcObjectName, lnImage)
				loCursor.Expanded = llExpanded
			endif tlReload
		
		* Try to find the cursor in the meta data; if we can't, we'll need to validate
		* it.
		
			llValid = .F.
			if not This.oMeta.FindObject(tcDatabase + '!' + tcObjectName, tcObjectType)
				This.ValidateObject(tcObjectName, tcObjectType)
				llValid = .T.
			endif not This.oMeta.FindObject...
		
		* Process every object belonging to the cursor.
		
			lnObjects = alen(taObjects, 1)
			store '' to lcFieldKey, lcIndexKey, lcUserKey
			lcPrefix = substr(lcCursorKey, 2)
			for lnI = 1 to lnObjects
				lcAliasedName = alltrim(taObjects[lnI, 1])
				lcObjectName  = substr(lcAliasedName, at('.', lcAliasedName) + 1)
				lcObjectType  = left(taObjects[lnI, 2], 1)
				lcKey         = This.GetNodeKey(lcAliasedName, lcObjectType, ;
					tcDatabase)
		
		* If we haven't previously validated the cursor, ensure we have meta data for
		* the current field or index.
		
				if not llValid and lcObjectType <> 'U' and ;
					not This.oMeta.FindObject(tcDatabase + '!' + lcAliasedName, ;
						lcObjectType)
					This.ValidateObject(tcObjectName, tcObjectType)
					llValid = .T.
				endif not llValid ...
				do case
		
		* If this is the first field, index, or user-defined field for this cursor, add
		* it below the parent node.
		
					case empty(lcFieldKey) and lcObjectType = 'F'
						.Nodes.Add(lcCursorKey, 4, lcKey, lcObjectName, 3)
						lcFieldKey = lcKey
					case empty(lcUserKey) and lcObjectType = 'U'
						.Nodes.Add(lcCursorKey, 4, lcKey, lcObjectName, 8)
						lcUserKey = lcKey
					case empty(lcIndexKey) and lcObjectType = 'I'
						.Nodes.Add(lcCursorKey, 4, lcKey, lcObjectName, ;
							iif(lcObjectName == tcPrimary, 5, 4))
						lcIndexKey = lcKey
		
		* If this is a field, add it below the last field node.
		
					case lcObjectType = 'F'
						.Nodes.Add(lcFieldKey, 2, lcKey, lcObjectName, 3)
						lcFieldKey = lcKey
		
		* If this is a user-defined field, add it below the last user-defined field
		* node.
		
					case lcObjectType = 'U'
						.Nodes.Add(lcUserKey, 2, lcKey, lcObjectName, 8)
						lcUserKey = lcKey
		
		* If this is an index, add it below the last index node.
		
					otherwise
						.Nodes.Add(lcIndexKey, 2, lcKey, lcObjectName, ;
							iif(lcObjectName == tcPrimary, 5, 4))
						lcIndexKey = lcKey
				endcase
			next lnI
		endwith
		return
		
	ENDPROC

	PROCEDURE loaddatabase		&& Loads a single database into the TreeView
		lparameters tcDatabase
		local lcDatabase, ;
			loNode, ;
			llReturn, ;
			lcParentNode, ;
			lcDBCKey, ;
			lcTablesKey, ;
			loTables, ;
			lcViewsKey, ;
			loViews, ;
			laCursors[1], ;
			llCursors
		with This
		
		* Try to open the database; we'll only add it if we can.
		
			lcDatabase = lower(juststem(tcDatabase))
			loNode     = .NULL.
			llReturn   = .OpenDatabase(tcDatabase)
		
		* Create a node for this database in the TreeView.
		
			if llReturn
				lcParentNode    = .GetNodeKey('Heading', 'Databases')
				lcDBCKey        = .GetNodeKey(lcDatabase, 'Database')
				loNode          = .oTree.Nodes.Add(lcParentNode, 4, lcDBCKey, ;
					lcDatabase, 6)
				loNode.Expanded = .lAutoExpand
				loNode.Sorted   = .T.
		
		* Create nodes for tables and views under the database. The "!" is used as a
		* delimiter between the database name and the cursor type.
		
				lcTablesKey     = .GetNodeKey('Heading', 'Tables', lcDatabase)
				loTables        = .oTree.Nodes.Add(lcDBCKey, 4, lcTablesKey, ;
					ccTABLES_PROPER, 1)
				loTables.Sorted = .T.
				lcViewsKey      = .GetNodeKey('Heading', 'Views', lcDatabase)
				loViews         = .oTree.Nodes.Add(lcDBCKey, 4, lcViewsKey, ;
					ccVIEWS_PROPER,  2)
				loViews.Sorted  = .T.
		
		* If we're supposed to, add each table and view in the database to the
		* TreeView. Otherwise, add "Loading" nodes under the "Tables" and "Views"
		* heading nodes (if there are any tables or views) as a signal to create nodes
		* for tables and views when the node is expanded for the first time.
		
				if .lAutoLoadTree
					.LoadDatabaseCursors(lcDatabase, 'Table')
					.LoadDatabaseCursors(lcDatabase, 'View')
				else
					llCursors = adbobjects(laCursors, 'Table') > 0
					if llCursors
						.oTree.Nodes.Add(lcTablesKey, 4, lcTablesKey + ccLOADING, ;
							ccLOADING)
					endif llCursors
					llCursors = adbobjects(laCursors, 'View') > 0
					if llCursors
						.oTree.Nodes.Add(lcViewsKey,  4, lcViewsKey  + ccLOADING, ;
							ccLOADING)
					endif llCursors
				endif .lAutoLoadTree
			endif llReturn
		endwith
		return loNode
		
	ENDPROC

	PROCEDURE loaddatabasecursor		&& Loads a single table or view into the TreeView
		lparameters tcTable, ;
			tcType, ;
			tcDatabase
		local lcKey, ;
			lcParentKey, ;
			loParent, ;
			lnImage, ;
			loNode
		with This
			lcKey       = .GetNodeKey(tcTable, tcType, tcDatabase)
			lcParentKey = .GetNodeKey('Heading', tcType, tcDatabase)
			loParent    = .oTree.Nodes[lcParentKey]
			do case
				case tcType = 'Table'
					lnImage = 1
				case dbgetprop(tcTable, 'View', 'SourceType') = 1
					lnImage = 2
				otherwise
					lnImage = 9
			endcase
			if not loParent.Expanded
				.TreeExpand(loParent, .T.)
				loNode = iif(type('.oTree.Nodes[lcKey]') = 'O', .oTree.Nodes[lcKey], ;
					.NULL.)
			endif not loParent.Expanded
			if vartype(loNode) <> 'O'
				loNode = .oTree.Nodes.Add(lcParentKey, 4, lcKey, tcTable, lnImage)
				if .lAutoLoadTree
					.LoadTreeCursor(tcTable, tcType, tcDatabase)
				else
					.oTree.Nodes.Add(lcKey, 4, lcKey + ccLOADING, ccLOADING)
				endif .lAutoLoadTree
			endif vartype(loNode) <> 'O'
		endwith
		return loNode
		
	ENDPROC

	PROCEDURE loaddatabasecursors		&& Loads the cursors of the specified type in the specified database into the TreeView
		* Add each cursor of the specified type in the specified database into the
		* TreeView.
		
		lparameters tcDatabase, ;
			tcType
		local laCursors[1], ;
			lnCursors, ;
			lnI, ;
			lcCursor
		with This
			if .OpenDatabase(tcDatabase)
				lnCursors = adbobjects(laCursors, tcType)
				for lnI = 1 to lnCursors
					lcCursor = lower(laCursors[lnI])
					.LoadDatabaseCursor(lcCursor, tcType, tcDatabase)
				next lnI
			endif .OpenDatabase(tcDatabase)
		endwith
		
	ENDPROC

	PROCEDURE loaddatabases		&& Loads the database in the meta data into the TreeView
		local lcNode, ;
			loNode, ;
			llReturn, ;
			laDBCs[1], ;
			lnI, ;
			lcDatabase
		with This
		
		* Create a "databases" node in the TreeView. The "H" prefix in the key means
		* this is a heading node.
		
			lcNode          = .GetNodeKey('Heading', 'Databases')
			loNode          = .oTree.Nodes.Add(, 1, lcNode, ccDATABASES, 6)
			loNode.Expanded = .lAutoExpand
			loNode.Sorted   = .T.
		
		* Get an array of all the databases in the meta data and process each one. If
		* we don't have any SDT meta data for this database, validate the entire meta
		* data.
		
			llReturn = .T.
			.nDBCs   = .oMeta.DBCXGetAllObjects('Database', @laDBCs)
			for lnI = 1 to .nDBCs
				lcDatabase = laDBCs[lnI]
				if isnull(.oMeta.DBCXGetProp(lcDatabase, 'Database', 'SDTUpdated'))
					llReturn = .oMessage.YesNo(strtran(ccQST_NO_EXTENSIONS, ;
						ccMSG_INSERT1, lcDatabase), .T.) and .Validate(.T.)
				endif isnull( ...
				llReturn = llReturn and not isnull(.LoadDatabase(lcDatabase))
			next lnI
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE loadfieldrep		&& Loads the tree with Field Repository objects
		*==============================================================================
		* Method:			LoadFieldRep
		* Purpose:			Loads the tree with Field Repository nodes
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tlReload - .T. to reload the Field Repository node
		* Returns:			the node reference for the Field Repository node
		*==============================================================================
		
		lparameters tlReload
		local lcNode, ;
			loNode, ;
			lnNode, ;
			llExpanded, ;
			lcField, ;
			lcKey
		with This.oTree
			select LIBCOREMETA
			set order to OBJECTNAME
			seek space(len(COREMETA.CDBCNAME)) + 'F' + ccLIBRARY_TABLE + '.'
		
		* If we're supposed to reload the Field Repository, remove the former node.
		
			lcNode = This.GetNodeKey('Heading', 'Field Repository')
			loNode = .Nodes[lcNode]
			if tlReload
				lnNode     = loNode.Index
				llExpanded = loNode.Expanded
				.Nodes.Remove(lnNode)
				loNode          = .Nodes.Add(, 1, lcNode, ccLIBRARY, 7)
				loNode.Expanded = llExpanded
				loNode.Sorted   = .T.
			endif tlReload
		
		* Add a Field Repository node and fields nodes.
		
			scan while COBJECTNAM = ccLIBRARY_TABLE + '.'
				lcField = lower(justext(alltrim(COBJECTNAM)))
				lcKey   = This.GetNodeKey(alltrim(COBJECTNAM), 'Field', '')
		
		* If a node for this object doesn't exist, add it.
		
				if type('.Nodes[lcKey]') <> 'O'
					.Nodes.Add(lcNode, 4, lcKey, lcField, 3)
				endif type('.Nodes[lcKey]') <> 'O'
			endscan while COBJECTNAM = ccLIBRARY_TABLE + '.'
		endwith
		return loNode
		
	ENDPROC

	PROCEDURE loadfreetable		&& Loads a single free table into the TreeView
		lparameters tcTable
		local lcKey, ;
			lcParentKey, ;
			loParent, ;
			loNode
		with This
			lcKey       = .GetNodeKey(tcTable, 'Table', '')
			lcParentKey = .GetNodeKey('Heading', 'Free Tables')
			loParent    = .oTree.Nodes[lcParentKey]
			if not loParent.Expanded
				.TreeExpand(loParent, .T.)
				loNode = iif(type('.oTree.Nodes[lcKey]') = 'O', .oTree.Nodes[lcKey], ;
					.NULL.)
			endif not loParent.Expanded
			if vartype(loNode) <> 'O'
				loNode = .oTree.Nodes.Add(lcParentKey, 4, lcKey, tcTable, 1)
				if .lAutoLoadTree
					.LoadObject(tcTable, 'Free Tables', .T.)
				else
					.oTree.Nodes.Add(lcKey, 4, lcKey + ccLOADING, ccLOADING)
				endif .lAutoLoadTree
			endif vartype(loNode) <> 'O'
		endwith
		return loNode
		
	ENDPROC

	PROCEDURE loadfreetables		&& Loads the tree with information on free tables
		*==============================================================================
		* Method:			LoadFreeTables
		* Purpose:			Loads the tree with free table nodes
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2001 Stonefield Systems Group Inc.
		* Last Revision:	09/24/2001
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local laTables[1], ;
			lnTables, ;
			llReturn, ;
			lnI, ;
			lcTable
		with This
			lnTables = .oMeta.DBCXGetAllObjects('!Table', @laTables)
			llReturn = .T.
			for lnI = 1 to lnTables
				lcTable = lower(alltrim(laTables[lnI]))
		
		* If we don't have any SDT meta data for this table, validate the entire meta
		* data.
		
				if isnull(.oMeta.DBCXGetProp('!' + lcTable, 'Table', 'SDTUpdated'))
					llReturn = .oMessage.YesNo(strtran(ccQST_NO_EXTENSIONS, ;
						ccMSG_INSERT1, lcTable), .T.) and .Validate(.T.)
				endif isnull( ...
		
		* Add it to the TreeView.
		
				llReturn = llReturn and not isnull(.LoadFreeTable(lcTable))
			next lnI
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE loadobject		&& Loads the specified object in the TreeView
		*==============================================================================
		* Method:			LoadObject
		* Purpose:			Loads the specified object in the TreeView
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	10/15/2004
		* Parameters:		tcObjectName - the name of the object
		*					tcObjectType - the object type
		*					tlNoSelect   - .F. to not select a node
		*					tlReload     - .T. to remove the object's node first
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tlNoSelect, ;
			tlReload
		local lcKey, ;
			lcObject, ;
			lcCursorKey, ;
			lcTypeKey, ;
			laFields[1], ;
			lnFields, ;
			laObjects[1], ;
			lnI, ;
			laIndexes[1], ;
			lnIndexes, ;
			lnObjects
		with This
			if not tlNoSelect
				lcKey = .oTree.SelectedItem.Key
			endif not tlNoSelect
			lcObject = lower(tcObjectName)
			do case
		
		* Load a view.
		
				case tcObjectType = 'View'
					lcCursorKey = .GetNodeKey(lcObject, 'View', .cDatabase)
					lcTypeKey   = .GetNodeKey('Heading', 'Views', .cDatabase)
					.LoadTreeCursor(lcObject, 'View', .cDatabase, tlReload)
		
		* Load a free table.
		
				case tcObjectType = 'Free Tables'
					lcObject = lower(juststem(tcObjectName))
					lnFields = .oMeta.DBCXGetAllObjects('!Field ' + lcObject, ;
						@laFields)
					dimension laObjects[lnFields, 2]
					for lnI = 1 to lnFields
						laObjects[lnI, 1] = laFields[lnI]
						laObjects[lnI, 2] = 'F'
					next lnI
					lnIndexes = .oMeta.DBCXGetAllObjects('!Index ' + lcObject, ;
						@laIndexes)
					lnObjects = lnFields + lnIndexes
					dimension laObjects[lnObjects, 2]
					for lnI = 1 to lnIndexes
						laObjects[lnFields + lnI, 1] = laIndexes[lnI]
						laObjects[lnFields + lnI, 2] = 'I'
					next lnI
					lnFields = .oMeta.DBCXGetAllObjects('!User ' + lcObject, ;
						@laFields)
					dimension laObjects[lnObjects + lnFields, 2]
					for lnI = 1 to lnFields
						laObjects[lnObjects + lnI, 1] = laFields[lnI]
						laObjects[lnObjects + lnI, 2] = 'U'
					next lnI
					lcCursorKey = .GetNodeKey(lcObject, 'Table', '')
					lcTypeKey   = .GetNodeKey('Heading', 'Free Tables')
					.LoadCursor(lcObject, 'Table', '', @laObjects, '', tlReload)
		
		* Load a table.
		
				otherwise
					lcCursorKey = .GetNodeKey(lcObject, 'Table', .cDatabase)
					lcTypeKey   = .GetNodeKey('Heading', 'Tables', .cDatabase)
					.LoadTreeCursor(lcObject, 'Table', .cDatabase, tlReload)
			endcase
		
		* If we're not supposed to select a node, do nothing. If the node we want to
		* select exists, select it. If not and the parent node exists, select it.
		* Otherwise, select the type node.
		
			do case
				case tlNoSelect
				case type('.oTree.Nodes[lcKey]') = 'O'
					.TreeNodeClick(.oTree.Nodes[lcKey])
				case type('.oTree.Nodes[lcCursorKey]') = 'O'
					.TreeNodeClick(.oTree.Nodes[lcCursorKey])
				otherwise
					.TreeNodeClick(.oTree.Nodes[lcTypeKey])
			endcase
		endwith
		
	ENDPROC

	PROCEDURE loadtree
		*==============================================================================
		* Method:			LoadTree
		* Purpose:			Loads the TreeView
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2006 Stonefield Systems Group Inc.
		* Last revision:	03/24/2006
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcKey, ;
			loNode, ;
			laTables[1], ;
			lnTables, ;
			laFields[1]
		wait window ccMSG_READING_DBC nowait
		with This
		
		* Move the TreeView off screen for slightly better performance.
		
			.LockScreen = .T.
			with .oTree
				.Left = .Left - 1000
				.Top  = .Top  - 1000
				.Nodes.Clear()
			endwith
		
		* Load the databases in the meta data.
		
			.LoadDatabases()
		
		* Create a "free tables" node in the TreeView (the "H" prefix in the key means
		* this is a heading node). Then either load all the free tables or a "loading"
		* node.
		
			lcKey         = .GetNodeKey('Heading', 'Free Tables')
			loNode        = .oTree.Nodes.Add(, 1, lcKey, ccFREE_TABLES, 1)
			loNode.Sorted = .T.
			if .lAutoExpand
				.LoadFreeTables()
			else
				lnTables = .oMeta.DBCXGetAllObjects('!Table', laTables)
				if lnTables > 0
					.oTree.Nodes.Add(lcKey, 4, lcKey + ccLOADING, ccLOADING)
				endif lnTables > 0
			endif .lAutoExpand
		
		* Create a node for the Field Repository.
		
			if .lUseFieldRep
				lcKey         = .GetNodeKey('Heading', 'Field Repository')
				loNode        = .oTree.Nodes.Add(, 1, lcKey, ccLIBRARY, 7)
				loNode.Sorted = .T.
				if .lAutoExpand
					.LoadFieldRep()
				else
					select cnt(*) from LIBCOREMETA into array laFields
					if laFields[1] > 0
						.oTree.Nodes.Add(lcKey, 4, lcKey + ccLOADING, ccLOADING)
					endif laFields[1] > 0
				endif .lAutoExpand
			endif .lUseFieldRep
		
		* Put the TreeView back.
		
			with .oTree
				.Left = .Left + 1000
				.Top  = .Top  + 1000
			endwith
			.LockScreen = .F.
		endwith
		wait clear
		return
		
	ENDPROC

	PROCEDURE loadtreecursor		&& Loads the tree with a single cursor
		*==============================================================================
		* Method:			LoadTreeCursor
		* Purpose:			Loads the tree with a single table or view belonging to a
		*						database
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	10/15/2004
		* Parameters:		tcObjectName - the name of the table or view
		*					tcObjectType - "Table" or "View"
		*					tcDatabase   - the database the table or view belongs to
		*					tlReload     - .T. to reload the node
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcDatabase, ;
			tlReload
		local lcDBCAlias, ;
			liParentID, ;
			laObjects[1], ;
			lnObjects, ;
			lnI, ;
			laFields[1], ;
			lnFields, ;
			lcPrimary, ;
			laIndexes[1], ;
			lnIndexes
		
		* If the DBC isn't open as a table, do so.
		
		with This
			.OpenDatabase(tcDatabase)
			lcDBCAlias = .oMeta.oSDTMgr.DBCOpen(dbc())
		
		* Get an array of all objects in the specified cursor.
		
			liParentID = .oMeta.oSDTMgr.DBCGetField(tcObjectName, tcObjectType, ;
				'ObjectID')
			select OBJECTNAME, ;
					OBJECTTYPE ;
				from (lcDBCAlias) ;
				where PARENTID = liParentID and ;
					inlist(OBJECTTYPE, ccVF_OBJ_FIELD, ccVF_OBJ_INDEX) ;
				into array laObjects ;
				order by 2
			use in (lcDBCAlias)
			lnObjects = alen(laObjects, 1)
			for lnI = 1 to lnObjects
				laObjects[lnI, 1] = tcObjectName + '.' + laObjects[lnI, 1]
			next lnI
		
		* Add any calculated fields.
		
			lnFields  = .oMeta.DBCXGetAllObjects(tcDatabase + '!' + 'User ' + ;
				tcObjectName, @laFields)
			dimension laObjects[lnObjects + lnFields, 2]
			for lnI = 1 to lnFields
				laObjects[lnObjects + lnI, 1] = laFields[lnI]
				laObjects[lnObjects + lnI, 2] = 'U'
			next lnI
		
		* If we're doing a table, get its primary key (if there is one).
		
			if tcObjectType = 'Table'
				lcPrimary = lower(dbgetprop(tcObjectName, 'Table', 'PrimaryKey'))
		
		* If this is a view, add any view indexes.
		
			else
				lnIndexes = .oMeta.DBCXGetAllObjects(tcDatabase + '!' + 'Index ' + ;
					tcObjectName, @laIndexes)
				lnObjects = alen(laObjects, 1)
				dimension laObjects[lnObjects + lnIndexes, 2]
				for lnI = 1 to lnIndexes
					laObjects[lnObjects + lnI, 1] = laIndexes[lnI]
					laObjects[lnObjects + lnI, 2] = 'I'
				next lnI
				lcPrimary = ''
			endif tcObjectType = 'Table'
		
		* Load the cursor into the tree.
		
			.LoadCursor(tcObjectName, tcObjectType, tcDatabase, @laObjects, ;
				lcPrimary, tlReload)
		endwith
		return
		
	ENDPROC

	PROCEDURE modidata		&& Displays the Database Designer.
		*==============================================================================
		* Method:			ModiData
		* Purpose:			Modifies the database
		* Author:			Doug Hennig
		* Copyright:		(c) 1997 Stonefield Systems Group Inc.
		* Last Revision:	12/22/97
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		modify database nowait
		
	ENDPROC

	PROCEDURE modifyobject
		*==============================================================================
		* Method:			ModifyObject
		* Purpose:			Modifies the selected object
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2005 Stonefield Systems Group Inc.
		* Last Revision:	03/23/2005
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local laTables[1], ;
			lcKey, ;
			lnSelect, ;
			lcEditor, ;
			lcView, ;
			lcAlias, ;
			llOpened, ;
			lcRuleExpr, ;
			lcRuleText, ;
			llEnabled, ;
			lcTable, ;
			lcDBF
		
		* Note: due to a bug in VFP that causes a GPF in the View Designer when it's
		* called from within a WITH block and the view has a logical filter condition,
		* we won't use WITH here.
		
		* Ensure any changes are saved.
		
		This.SaveChanges()
		aused(laTables)
		lcKey    = This.oTree.SelectedItem.Key
		lnSelect = select()
		lcEditor = iif(This.pgfProps.Page1.cntViewProps.chkVD.Value, '', ;
			This.cViewEditor)
		do case
		
		* This is a database, so call the Database Designer.
		
			case This.cCurrObjectType = 'Database'
				This.ModiData()
		
		* Use ViewEditor if this is a view and we're supposed to use it. Since the view
		* can be deleted in ViewEditor, we have to ensure it still exists upon return.
		
			case This.cCurrParentType = 'View' and not empty(lcEditor)
				lcView = This.cCurrParent
				if upper(juststem(lcEditor)) = 'VIEWEDIT'
					do (lcEditor) with This.cDBC, lcView, .T.
				else
					do (lcEditor) with lcView, This.cDBC, .T.
				endif upper(juststem(lcEditor)) = 'VIEWEDIT'
				if indbc(lcView, 'View')
					This.ValidateObject(lcView, 'View')
					This.LoadObject(lcView, 'View', .F., .T.)
					if This.cCurrObjectType = 'View' and This.cCurrObject = lcView
						This.GetDatabaseObject(lcView, 'View', lcView, 'View', ;
							This.cDatabase)
					endif This.cCurrObjectType = 'View' ...
				else
					This.oMeta.DBCXDeleteRow(lcView, 'View')
					create cursor __NOTIFY (MESSAGE C(128), NOTIFY M)
					insert into __NOTIFY (MESSAGE) values ;
						(strtran(ccMSG_REMOVE_EDITS, ccMSG_INSERT1, lcView))
					This.FindAllUsesOfTable(lcView)
					This.RemoveNode(lcView, 'View', This.cDatabase)
				endif indbc(lcView, 'View')
		
		* Call the View Designer for the view.
		
			case This.cCurrParentType = 'View'
				lcView = This.cCurrParent
				select 0
				use (lcView) again nodata
				lcAlias  = alias()
				llOpened = not empty(lcAlias)
				if llOpened
					lcRuleExpr = dbgetprop(lcView, 'View', 'RuleExpression')
					lcRuleText = dbgetprop(lcView, 'View', 'RuleText')
					use
					llEnabled = This.tmrFocus.Enabled
					This.tmrFocus.Enabled = .F.
					modify view (lcView)
					This.tmrFocus.Enabled = llEnabled
					if not empty(lcRuleExpr)
						dbsetprop(lcView, 'View', 'RuleExpression', lcRuleExpr)
					endif not empty(lcRuleExpr)
					if not empty(lcRuleText)
						dbsetprop(lcView, 'View', 'RuleText', lcRuleText)
					endif not empty(lcRuleText)
					This.ValidateObject(lcView, 'View')
					if This.lViewInheritance
						This.ViewWizard(lcView)
					endif This.lViewInheritance
					This.LoadObject(lcView, 'View', .F., .T.)
					if This.cCurrObjectType = 'View' and This.cCurrObject = lcView
						This.GetDatabaseObject(lcView, 'View', lcView, 'View', ;
							This.cDatabase)
					endif This.cCurrObjectType = 'View' ...
				else
					This.oMessage.ErrorMessage(strtran(ccERR_CANT_OPEN_FILE, ;
						ccMSG_INSERT1, lcView))
				endif llOpened
		
		* For a free table, use the VFP Table Designer.
		
			case This.cCurrParentType = 'Free Tables'
				lcTable = This.cCurrParent
				lcDBF   = This.oMeta.oSDTMgr.GetFreeTablePath(This.cCurrParent)
				This.oUtility.CloseAllAliases(lcDBF)
				select 0
				use (lcDBF) exclusive
				llOpened = used(strtran(lcTable, ' ', '_'))
				if llOpened
					modify structure
					This.ValidateCurrentObject()
				else
					This.oMessage.ErrorMessage(strtran(ccERR_CANT_OPEN_FILE, ;
						ccMSG_INSERT1, lcTable))
				endif llOpened
		
		* Use the ModifyTable() method to modify a table in a database.
		
			otherwise
				This.ModifyTable()
		endcase
		This.oMeta.CloseOpenedCursors(@laTables)
		select (lnSelect)
		
	ENDPROC

	PROCEDURE modifytable
		*==============================================================================
		* Method:			ModifyTable
		* Purpose:			Modifies the specified table using the Extended Table
		*						Designer form
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/08/2001
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local llRepository, ;
			lcTable, ;
			lcPath
		with This
			llRepository = .cCurrParentType = ccLIBRARY_TABLE
			lcTable      = iif(llRepository, ccLIBRARY_TABLE, .cCurrParent)
			lcPath       = iif(llRepository, .cFieldRepDir, ;
				addbs(justpath(dbf(.oMeta.cRegistryName))))
			wait window ccMSG_PLEASE_WAIT nowait
			do form TD with lcPath, This, lcTable, '', .F., .cDBC
		endwith
		
	ENDPROC

	PROCEDURE movetable
		*==============================================================================
		* Method:			MoveTable
		* Purpose:			Moves the specified table or view to another database
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/08/2001
		* Parameters:		tcTable - the table or view being copied
		*					tcType  - "Table" or "View"
		*					tcDBC   - the database the table or view is being copied
		*						from
		*					toOther - an object reference to the DBCXMgr object
		*						managing the other database
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcTable, ;
			tcType, ;
			tcDBC, ;
			toOther
		local lcFileName, ;
			lcOldFile, ;
			loOtherMeta, ;
			llReturn
		with This
		
		* Ensure any changes are saved.
		
			.SaveChanges()
		
		* Define some variables. See if the table or view already exists in the
		* database. Also, check to see if both databases are managed by the same meta
		* data. If so, we'll do things a little differently.
		
			if tcType = 'Table'
				set database to (tcDBC)
				lcFileName = dbgetprop(tcTable, 'Table', 'Path')
				lcOldFile  = fullpath(lcFileName, tcDBC)
				lcFileName = fullpath(lcFileName, .cDBC)
				set database to (.cDBC)
			endif tcType = 'Table'
			loOtherMeta = toOther.oMeta
			llReturn    = .CopyTableToDBC(tcTable, tcTable, lcFileName, tcType, ;
				tcDBC, toOther.oMeta, .T.)
		
		* Remove any relations in which this table is the parent, since VFP doesn't
		* allow the table to be removed in that case.
		
			if llReturn
				.RemoveRelations(tcTable, tcDBC)
		
		* Remove any views based on this table and tell the user about any other places
		* it appears. We need to have the other manager do this.
		
				toOther.FindAllUsesOfTable(tcTable)
		
		* Close tables we opened and remove the table from the former database. Because
		* the REMOVE TABLE command nukes the table's backlink, we need to rewrite it.
		
				set database to (tcDBC)
				do case
					case tcType = 'Table' and lcOldFile == lcFileName
						remove table (tcTable)
						.oMeta.oSDTMgr.WriteBackLink(lcFileName, .cDBC)
					case tcType = 'Table'
						drop table (tcTable)
					otherwise
						delete view (tcTable)
				endcase
				set database to (.cDBC)
		
		* Update the trees for this and the other database.
		
				toOther.RemoveNode(tcTable, tcType, tcDBC)
			endif llReturn
		endwith
		return
		
	ENDPROC

	PROCEDURE newdatabase		&& Creates a new database and adds it to the meta data
		*==============================================================================
		* Method:			NewDatabase
		* Purpose:			Creates a new database
		* Author:			Doug Hennig
		* Copyright:		(c) 2001-2004 Stonefield Systems Group Inc.
		* Last Revision:	03/22/2004
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcFileName, ;
			lcName, ;
			loNode
		with This
		
		* Get the path of the database.
		
			lcFileName = .GetNewFile(.cMetaPath, ;
				proper(strtran(ccCAP_CREATE, ccMSG_INSERT1, ccDATABASE)), ;
				'Database (*.DBC)', '*.DBC')
			lcName     = lower(juststem(lcFileName))
			do case
		
		* No name was entered.
		
				case empty(lcFileName)
		
		* If the database already exists in the data dictionary, remind the user.
		
				case .oMeta.FindObject(lcName + '!' + lcName, 'Database')
					.oMessage.ErrorMessage(strtran(ccERR_TABLE_IN_META, ;
						ccMSG_INSERT1, lcName))
		
		* If the database already exists, give an error message.
		
				case file(lcFileName)
					.oMessage.ErrorMessage(strtran(ccERR_FILE_EXISTS, ccMSG_INSERT1, ;
						lcName))
		
		* Create the database, extend it, reload the tree, and ensure the new node
		* is selected.
		
				otherwise
					create database (lcFileName)
					.ValidateObject(lcName, 'Database')
					loNode = .LoadDatabase(lcName)
					loNode.Selected = .T.
					.oTree.NodeClick(.oTree.SelectedItem)
			endcase
		endwith
		
	ENDPROC

	PROCEDURE newfreetable		&& Creates a new free table and adds it to the meta data
		*==============================================================================
		* Method:			NewFreeTable
		* Purpose:			Creates a new free table
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcFileName, ;
			lcAlias, ;
			laTables[1], ;
			loNode
		with This
		
		* Get the path of the table.
		
			lcFileName = .GetNewFile(.cMetaPath)
			lcAlias    = juststem(lcFileName)
			do case
		
		* No name was entered.
		
				case empty(lcFileName)
		
		* Don't allow a meta data table name to be used.
		
				case inlist(upper(lcAlias), 'DBCXREG', 'SDTMETA', 'SDTUSER', ;
					'COREMETA')
					.oMessage.ErrorMessage(strtran(ccERR_CANT_ADD_META, ;
						ccMSG_INSERT1, ccMETA_DATA))
		
		* If the file already exists in the data dictionary, remind the user.
		
				case .oMeta.FindObject('!' + lcAlias, 'Table')
					.oMessage.ErrorMessage(strtran(ccERR_TABLE_IN_META, ;
						ccMSG_INSERT1, lcAlias))
		
		* If the file already exists, give an error message.
		
				case file(lcFileName)
					.oMessage.ErrorMessage(strtran(ccERR_FILE_EXISTS, ccMSG_INSERT1, ;
						lcAlias))
		
		* Display the Table Designer.
		
				otherwise
					aused(laTables)
					set database to
					select 0
					create (lcFileName)
		
		* If the table was saved, extend it, reload the tree, and ensure the new node
		* is selected.
		
					if file(lcFileName)
						lcAlias = lower(alias())
						.ValidateObject('!' + lcFileName, 'Table')
						.oMeta.CloseOpenedCursors(@laTables)
						loNode = .LoadFreeTable(lcAlias)
						loNode.Selected = .T.
						.oTree.NodeClick(.oTree.SelectedItem)
					endif file(lcFileName)
			endcase
		endwith
		
	ENDPROC

	PROCEDURE newtable
		*==============================================================================
		* Method:			NewTable
		* Purpose:			Creates a new table in the database using the Extended
		*						Table Designer form
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/04/2001
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcFileName, ;
			lcTable, ;
			llFound, ;
			lcPath
		
		* Ensure any changes are saved.
		
		with This
			.SaveChanges()
		
		* Get the name of the table to create.
		
			lcFileName = .GetNewFile(addbs(justpath(.cDBC)))
			if not empty(lcFileName)
				lcTable = juststem(lcFileName)
				llFound = indbc(lcTable, 'Table') or indbc(lcTable, 'View')
				do case
		
		* Don't allow a meta data table to be added to the database.
		
					case inlist(lcTable, 'DBCXREG', 'SDTMETA', 'SDTUSER', 'COREMETA')
						.oMessage.ErrorMessage(strtran(ccERR_CANT_ADD_META, ;
							ccMSG_INSERT1, ccDATABASE_LOWER))
		
		* If the file already exists in the data dictionary, remind the user.
		
					case llFound
						.oMessage.ErrorMessage(strtran(ccERR_TABLE_IN_DBC, ;
							ccMSG_INSERT1, lcTable))
		
		* If the file already exists, give an error message.
		
					case file(lcFileName)
						.oMessage.ErrorMessage(strtran(ccERR_FILE_EXISTS, ;
							ccMSG_INSERT1, lcTable))
		
		* If the file doesn't exist, bring up the TD form so the user can define the
		* table.
		
					otherwise
						lcPath = addbs(justpath(dbf(.oMeta.cRegistryName)))
						wait window ccMSG_PLEASE_WAIT nowait
						do form TD with lcPath, This, lcTable, lcFileName, .T., .cDBC
				endcase
			endif not empty(lcFileName)
		endwith
		
	ENDPROC

	PROCEDURE newview		&& Create a new local or remote view.
		*==============================================================================
		* Method:			NewView
		* Purpose:			Creates a new view
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2002 Stonefield Systems Group Inc.
		* Last Revision:	06/25/2002
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local loNewView, ;
			lcViewName, ;
			llRemote, ;
			laTables[1], ;
			lcType, ;
			llEnabled, ;
			loNode
		
		* Note: due to a bug in VFP that causes a GPF in the View Designer when it's
		* called from within a WITH block and the view has a logical filter condition,
		* we won't use WITH here.
		
		* First get the name of the view. If one was entered and it's valid, create the
		* view, then extend it and add it to the tree.
		
		do form NewView name loNewView
		if vartype(loNewView) = 'O'
			lcViewName = loNewView.cViewName
			llRemote   = loNewView.lRemote
			aused(laTables)
			lcType = iif(llRemote, ' remote', '')
			llEnabled = This.tmrFocus.Enabled
			This.tmrFocus.Enabled = .F.
			create sql view (lcViewName) &lcType
			This.tmrFocus.Enabled = llEnabled
			This.oMeta.CloseOpenedCursors(@laTables)
		
		* If the view was saved, extend it, reload the tree, and ensure the new node is
		* selected.
		
			if indbc(lcViewName, 'View')
				This.ValidateObject(lcViewName, 'View')
				This.ViewWizard(lcViewName)
				loParent = This.oTree.Nodes[This.GetNodeKey('Heading', 'View', ;
					This.cDatabase)]
				if loParent.Expanded or This.lAutoLoadTree or loParent.Children = 0
					loNode = This.LoadDatabaseCursor(lcViewName, 'View', ;
						This.cDatabase)
				endif loParent.Expanded ...
				if not loParent.Expanded
					This.TreeExpand(loParent, .T.)
				endif not loParent.Expanded
				if vartype(loNode) <> 'O'
					lcNode = This.GetNodeKey(lcViewName, 'View', This.cDatabase)
					loNode = This.oTree.Nodes.Item[lcNode]
				endif vartype(loNode) <> 'O'
				loNode.Selected = .T.
				This.oTree.NodeClick(This.oTree.SelectedItem)
				wait clear
			endif indbc(lcViewName, 'View')
		endif vartype(loNewView) = 'O'
		
	ENDPROC

	PROCEDURE opendatabase		&& Opens the specified database
		lparameters tcDatabase
		local lcDatabase, ;
			lcPath, ;
			llFound, ;
			lcDBC
		with This
			lcDatabase = juststem(tcDatabase)
			lcPath     = nvl(.oMeta.DBCXGetProp(lcDatabase, 'Database', 'CBmPath'), '')
			do case
				case '\' $ tcDatabase
					lcPath = tcDatabase
				case not empty(lcPath)
					lcPath = iif(empty(lcPath), '', fullpath(lcPath, ;
						.oMeta.cRegistryPath))
				case upper(tcDatabase) == set('DATABASE')
					lcPath = dbc()
			endcase
			llFound = not empty(lcPath) and file(lcPath)
			do case
		
		* The database is already open and we had a valid path for it, so select it.
		
				case llFound and dbused(lcPath)
					set database to (lcPath)
		
		* The database is already open but we didn't have a path for it, so update the
		* path.
		
				case dbused(lcPath)
					set database to (lcPath)
					.oMeta.DBCXSetProp(lcDatabase, 'Database', 'CBmPath', ;
						sys(2014, dbc(), .oMeta.cRegistryPath))
		
		* The database isn't open but we have a path for it, so open it.
		
				case llFound
					open database (lcPath)
		
		* The database isn't open and we don't a path for it, so try to find it by
		* looking in the current directory/VFP path, the same directory as the meta
		* data, a specific directory if we're supposed to, and a DATA subdirectory of
		* the parent of the meta data. If we can't find it, ask the user to locate it.
		
				otherwise
					lcDBC   = forceext(lcDatabase, '.DBC')
					lcPath  = lcDBC
					llFound = file(lcPath)
					if not llFound
						lcPath  = fullpath(lcPath, .oMeta.cRegistryPath)
						llFound = file(lcPath)
					endif not llFound
					if not llFound and .cDBCSelection = ccPREF_OPEN_DBC_IN_DIR
						lcPath  = .cDBCSpecificDir + lcDBC
						llFound = file(lcPath)
					endif not llFound ...
					if not llFound
						lcPath  = fullpath('..\DATA\' + lcDBC, .oMeta.cRegistryPath)
						llFound = file(lcPath)
					endif not llFound
					if not llFound
						lcPath  = getfile('DBC', '', 'Open', 0, 'Locate ' + lcDBC)
						if not empty(lcPath)
							lcPath  = addbs(justpath(lcPath)) + lcDBC
							llFound = file(lcPath)
						else
							.LockScreen = .F.
							if .oMessage.YesNo(strtran(ccQST_REMOVE_FREE_TABLE, ;
								ccMSG_INSERT1, ccDATABASE + ' ' + lcDBC))
								wait window strtran(ccMSG_REMOVING, ccMSG_INSERT1, ;
									ccDATABASE + ' ' + lcDBC) nowait
								.oMeta.DBCXDeleteRow(lcDBC, 'Database')
								wait clear
							endif .oMessage.YesNo ...
							.LockScreen = .T.
						endif not empty(lcPath)
					endif not llFound
					if llFound
						open database (lcPath)
						.oMeta.DBCXSetProp(lcDatabase, 'Database', 'CBmPath', ;
							sys(2014, dbc(), .oMeta.cRegistryPath))
					endif llFound
			endcase
		endwith
		return dbused(lcPath)
		
	ENDPROC

	PROCEDURE openmetadata		&& Opens a set of meta data
		lparameters tcPath, ;
			tlCreate
		local llCreate, ;
			laMetaPaths[1], ;
			lcPath, ;
			lnMeta, ;
			lcDirectory, ;
			laCodePage[1], ;
			laTypes[1], ;
			laIndexes[1], ;
			laCollate[1]
		with This
			llCreate = tlCreate
		
		* If the Field Repository is in the same place as the selected meta data, warn
		* the user.
		
			if .cFieldRepDir == tcPath
				.oMessage.ErrorMessage(ccERR_BAD_FIELD_REP_DIR)
				return .F.
			endif .cFieldRepDir == tcPath
		
		* Get the row for the path in our list of registered paths.
		
			acopy(.aMetaPaths, laMetaPaths)
			lcPath = lower(tcPath)
			lnMeta = .oUtility.ArrayScan(@laMetaPaths, lcPath, 2)
		
		* If there aren't any meta data tables in the specified directory but there's
		* supposed to be, give a warning.
		
			if not file(addbs(tcPath) + 'DBCXREG.DBF') and not tlCreate
				lnChoice = .oMessage.YesNoCancel(ccQST_NO_META_DATA)
				do case
					case lnChoice = 0
						if lnMeta > 0
							adel(.aMetaPaths, lnMeta)
						endif lnMeta > 0
						return .F.
					case lnChoice = 1
						llCreate = .T.
						if not directory(tcPath)
							md (tcPath)
						endif not directory(tcPath)
					otherwise
						return .F.
				endcase
			endif not file(addbs(tcPath) + 'DBCXREG.DBF') ...
		
		* If we have an existing DBCXMgr object, nuke it.
		
			if vartype(.oMeta) = 'O'
				.oMeta.Release()
			endif vartype(.oMeta) = 'O'
		
		* Create a DBCXMgr object.
		
			.oMeta = MakeObject('SDTDBCXMgr', 'SDTManagers.VCX', '', .T., tcPath, ;
				llCreate)
			if vartype(.oMeta) <> 'O'
				return .F.
			endif vartype(.oMeta) <> 'O'
			.oMeta.lShowStatus = .T.
			.oMeta.lDebugMode  = .F.
			.cMetaPath         = .oMeta.cRegistryPath
		
		* If the SDT Manager isn't registered, do it now.
		
			if not .oMeta.IsManagerRegistered('oSDTMgr')
				lcDirectory = .oUtility.GetAppDirectory(sys(16))
				.oMeta.RegisterManager('Stonefield Database Toolkit', lcDirectory, ;
					'SDT.VCX', 'SDTMgr')
			endif not .oMeta.IsManagerRegistered('oSDTMgr')
		
		* If this set of meta data isn't in our MRU list, add it.
		
			do case
				case .lDemo
					.cSystemName = 'SDT Demo Sample Database'
				case lnMeta = 0
					.AddMetaPathToMRU(lcPath)
				otherwise
					.cSystemName = .aMetaPaths[lnMeta, 1]
			endcase
		
		* If we created a set of meta data and we have a DBC open, let's validate it.
		
			if llCreate and not empty(.cDBC)
				.Validate(.T.)
			endif llCreate ...
		
		* Load the TreeView control with the tables and views in the database.
		
			.LoadTree()
		
		* Ensure the database properties are displayed.
		
			.GetDatabaseObject('', 'Databases', '', 'Databases', '')
			.oTree.Nodes[1].Selected = .T.
		
		* Get copies of SDTMgr arrays so we can use them.
		
			if empty(.aCodePage[1])
				.oMeta.oSDTMgr.GetCodePageArray(@laCodePage)
				acopy(laCodePage, .aCodePage)
				.pgfProps.Page1.cntTableProps.cboCodePage.Requery()
				.oMeta.oSDTMgr.GetDataTypeArray(@laTypes)
				acopy(laTypes, .aDataTypes)
				.oMeta.oSDTMgr.GetIndexTypeArray(@laIndexes)
				acopy(laIndexes, .aIndexTypes)
				.pgfProps.Page1.cntIndexProps.cboType.Requery()
				.oMeta.oSDTMgr.GetCollateArray(@laCollate)
				acopy(laCollate, .aCollate)
				.pgfProps.Page1.cntIndexProps.cboCollate.Requery()
				.cVersion = .oMeta.oSDTMgr.cVersion
			endif empty(.aCodePage[1])
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE pgdnhotkey		&& Moves to the next item in the tree (fired from a hotkey)
		local loObject
		with This
		
		* Find the active control and call its LostFocus method so the lChanged flag
		* will be updated properly.
		
			.LockScreen = .T.
			loObject = .FindActiveControl()
			if vartype(loObject) = 'O'
				loObject.LostFocus()
			endif vartype(loObject) = 'O'
		
		* Find the previous node in the tree and select it.
		
			with .oTree.SelectedItem
				do case
					case type('.Child.Text') = 'C' and .Expanded
						This.oTree.NodeClick(.Child)
					case type('.Next.Text') = 'C'
						This.oTree.NodeClick(.Next)
					case type('.Parent.Text') = 'C' and type('.Parent.Next.Text') = 'C'
						This.oTree.NodeClick(.Parent.Next)
					case type('.Parent.Parent.Text') = 'C' and ;
						type('.Parent.Parent.Next.Text') = 'C'
						This.oTree.NodeClick(.Parent.Parent.Next)
					case type('.Parent.Parent.Parent.Text') = 'C' and ;
						type('.Parent.Parent.Parent.Next.Text') = 'C'
						This.oTree.NodeClick(.Parent.Parent.Parent.Next)
					case type('.Parent.Parent.Parent.Parent.Text') = 'C' and ;
						type('.Parent.Parent.Parent.Parent.Next.Text') = 'C'
						This.oTree.NodeClick(.Parent.Parent.Parent.Parent.Next)
				endcase
			endwith
		
		* If we're changing to a different node type, see if the new container has a
		* control with the same name as the current one (for example, Caption) and set
		* focus to it if so. If not, set focus to the first control in the new
		* container. If we didn't change focus (for example, the first control has WHEN
		* .F.), keyboard a TAB to force the change.
		
			if vartype(loObject) = 'O' and not loObject.Parent.Visible
				if type('.pgfProps.Page1.' + .cContainer + '.' + loObject.Name + ;
					'.Name') = 'C'
					evaluate('.pgfProps.Page1.' + .cContainer + '.' + loObject.Name + ;
						'.SetFocus()')
				else
					.SetFocusToFirstObject(evaluate('.pgfProps.Page1.' + .cContainer))
				endif type('.pgfProps.Page1.' ...
				loObject = .FindActiveControl()
				if vartype(loObject) = 'O' and ;
					upper(loObject.Parent.Name) <> upper(.cContainer)
					keyboard '{tab}'
					doevents
					.RefreshForm()
				endif vartype(loObject) = 'O' ...
			endif vartype(loObject) = 'O' ...
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE pguphotkey		&& Moves to the previous item in the tree (fired from a hotkey)
		local loObject, ;
			loChild
		with This
		
		* Find the active control and call its LostFocus method so the lChanged flag
		* will be updated properly.
		
			.LockScreen = .T.
			loObject = .FindActiveControl()
			if vartype(loObject) = 'O'
				loObject.LostFocus()
			endif vartype(loObject) = 'O'
		
		* Find the next node in the tree and select it.
		
			with .oTree.SelectedItem
				do case
					case type('.Previous.Text') = 'C'
						loChild = This.FindLastNode(.Previous)
						This.oTree.NodeClick(loChild)
					case type('.Parent.Text') = 'C'
						This.oTree.NodeClick(.Parent)
				endcase
			endwith
		
		* If we're changing to a different node type, see if the new container has a
		* control with the same name as the current one (for example, Caption) and set
		* focus to it if so. If not, set focus to the first control in the new
		* container. If we didn't change focus (for example, the first control has WHEN
		* .F.), keyboard a TAB to force the change.
		
			if vartype(loObject) = 'O' and not loObject.Parent.Visible
				if type('.pgfProps.Page1.' + .cContainer + '.' + loObject.Name + ;
					'.Name') = 'C'
					evaluate('.pgfProps.Page1.' + .cContainer + '.' + loObject.Name + ;
						'.SetFocus()')
				else
					.SetFocusToFirstObject(evaluate('.pgfProps.Page1.' + .cContainer))
				endif type('.pgfProps.Page1.' ...
				loObject = .FindActiveControl()
				if vartype(loObject) = 'O' and ;
					upper(loObject.Parent.Name) <> upper(.cContainer)
					keyboard '{tab}'
					doevents
					.RefreshForm()
				endif vartype(loObject) = 'O' ...
			endif vartype(loObject) = 'O' ...
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE preferences
		*==============================================================================
		* Method:			Preferences
		* Purpose:			Runs the preferences form
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/08/2001
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local loSDTPref
		with This
			.SaveChanges()
			do form SDTPREF name loSDTPref linked
			.GetPreferences()
			.SetAll('FontName', _screen.SDTController.cFontName)
			.SetAll('FontSize', _screen.SDTController.nFontSize)
			.RefreshForm()
		endwith
		
	ENDPROC

	PROCEDURE redefineallviews		&& Redefine all views for a table
		*==============================================================================
		* Method:			RedefineAllViews
		* Purpose:			Redefine all applicable views
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2002 Stonefield Systems Group Inc.
		* Last Revision:	04/07/2002
		* Parameters:		tcTable    - the name of the table or DBC: if a table is
		*						passed (no ! in the parameter), all views in all DBCs
		*						based on that table are redefined. If a DBC is passed,
		*						all views in that DBC are redefined
		*					tlRedefine - .T. to redefine the views or .F. to just
		*						update properties
		* Returns:			.T.
		* Environment in:	This.oDBUtilities contains a reference to an SDTDBUtilities
		*						object
		* Environment out:	any applicable view has been redefined and properties
		*						updated
		*==============================================================================
		
		lparameters tcTable, ;
			tlRedefine
		with This
			.oDBUtilities.oHook = This
			.oDBUtilities.RedefineAllViews(tcTable, .oMeta, tlRedefine, ;
				.lViewInheritance)
			.oDBUtilities.oHook = .NULL.
		endwith
		
	ENDPROC

	PROCEDURE redefinesingleview		&& Redefines a single view
		*==============================================================================
		* Method:			RedefineSingleView
		* Purpose:			Redefines the specified view
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last Revision:	05/09/2001
		* Parameters:		tcView       - the name of the view to redefine
		*					tlNoValidate - .T. to not validate the view
		* Returns:			.T.
		* Environment in:	This.oDBUtilities contains a reference to an SDTDBUtilities
		*						object
		* Environment out:	the specified view has been redefined
		*==============================================================================
		
		lparameters tcView, ;
			tlNoValidate
		with This
			.oDBUtilities.oHook = This
			.oDBUtilities.RedefineView(tcView, .oMeta, tlNoValidate)
			.oDBUtilities.oHook = .NULL.
		endwith
		
	ENDPROC

	PROCEDURE redefineview		&& Redefines a view
		* Reload the tree nodes for the view.
		
		lparameters tcView, ;
			tlNoValidate
		local lcNode, ;
			lcKey
		with This
			if not tlNoValidate
				lcNode = .GetNodeKey(tcView, 'View', .cDatabase)
				if type('.oTree.Nodes[lcNode]') = 'O'
					lcKey = .oTree.SelectedItem.Key
					.LoadTreeCursor(tcView, 'View', .cDatabase, .T.)
					if .oTree.SelectedItem.Key <> lcKey and ;
						type('.oTree.Nodes[lcKey]') = 'O'
						.oTree.Nodes[lcKey].Selected = .T.
					endif .oTree.SelectedItem.Key <> lcKey ...
				endif type('.oTree.Nodes[lcNode]') = 'O'
			endif not tlNoValidate
		endwith
		
	ENDPROC

	PROCEDURE registerpreferences
		*==============================================================================
		* Method:			RegisterPreferences
		* Purpose:			Register default preferences in the Windows registry
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	07/30/2004
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcDirectory, ;
			llReturn
		with This.oReg
			lcDirectory = fullpath('..\FieldRep\', ;
				This.oUtility.GetAppDirectory(sys(16)))
			llReturn = .SetKey(ccREG_KEY, ccPREF_LISTACTION, ccBROWSE)
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_DBCXREG_SPEC_DIR, '')
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_ASK_FOR_DBCXREG, 3)
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_DBCXSEARCH, ;
				'..\SOURCE' + ccCR + '..\METADATA' + ccCR)
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_SHOW_INTL, 'Yes')
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_NAMING_CONV, 'No')
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_DBC_SELECTION, ;
				ccPREF_USE_CURRENT_DBC)
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_DBC_SPEC_DIR, '')
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_FIELD_REP_DIR, ;
				lcDirectory)
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_VIEW_INHERITANCE, 'Yes')
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_AUTO_EXPAND, 'Yes')
			llReturn = llReturn and .SetKey(ccREG_KEY, ccPREF_AUTO_LOADTREE, 'No')
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE reindextable
		*==============================================================================
		* Method:			ReindexTable
		* Purpose:			Reindexes the selected table
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	07/30/2004
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		with This
			.SaveChanges()
			.oMeta.oSDTMgr.Reindex(iif(.cCurrParentType = 'Free Tables', '', ;
				.cDatabase) + '!' + .cCurrParent)
		endwith
		
	ENDPROC

	PROCEDURE removenode		&& Removes the current node from the tree and selects the next sibling.
		*==============================================================================
		* Method:			RemoveNode
		* Purpose:			Removes the current node from the tree and selects the next
		*						node
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	07/30/2004
		* Parameters:		tcObjectName - the name of the object to remove
		*					tcObjectType - the type of the object
		*					tcDatabase   - the database the object belongs to
		*					tlNoSelect   - .T. to not select the next node
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcDatabase, ;
			tlNoSelect
		local lcKey, ;
			lcObjectType, ;
			loNode, ;
			lnObject, ;
			lcNextKey
		with This
			if tcObjectType = 'Database'
				lcKey = .GetNodeKey(tcDatabase, tcObjectType)
			else
				lcObjectType = iif(tcObjectType = 'Free Tables', 'Table', tcObjectType)
				lcKey        = .GetNodeKey(tcObjectName, lcObjectType, tcDatabase)
			endif tcObjectType = 'Database'
			if type('.oTree.Nodes[lcKey]') = 'O'
				loNode   = .oTree.Nodes[lcKey]
				lnObject = loNode.Index
				do case
					case tlNoSelect
					case not isnull(loNode.Next)
						lcNextKey = loNode.Next.Key
					case not isnull(loNode.Previous)
						lcNextKey = loNode.Previous.Key
					otherwise
						lcNextKey = loNode.Parent.Key
				endcase
				.oTree.Nodes.Remove(lnObject)
				if not tlNoSelect
					.oTree.Nodes[lcNextKey].Selected = .T.
					.oTree.NodeClick(.oTree.SelectedItem)
				endif not tlNoSelect
			endif type('.oTree.Nodes[lcKey]') = 'O'
		endwith
		
	ENDPROC

	PROCEDURE removeobjectfrommetadata		&& Removes an object from the meta data
		*==============================================================================
		* Method:			RemoveObjectFromMetaData
		* Purpose:			Removes an object from the meta data (and, in the case of a
		*						table or view, from the database)
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2005 Stonefield Systems Group Inc.
		* Last Revision:	03/23/2005
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lcObject, ;
			lcType, ;
			lcDBC, ;
			llRemoved, ;
			lcFile, ;
			laFields[1], ;
			lnFields, ;
			lnIndexes, ;
			lnI, ;
			laIndexes[1], ;
			lcField, ;
			lnJ, ;
			lnPos, ;
			lcCurrCollate, ;
			lcExpression, ;
			lcOptions
		
		* Ask the user to confirm that this table or view should be removed.
		
		with This
			lcObject  = .cCurrParent
			lcType    = .cCurrParentType
			lcDBC     = .cDBC
			llRemoved = .F.
			do case
		
		* Remove a database from the meta data.
		
				case .cCurrObjectType = 'Database' and ;
					.oMessage.YesNo(strtran(ccQST_REMOVE_FREE_TABLE, ccMSG_INSERT1, ;
					ccDATABASE + ' ' + .cDatabase))
					wait window strtran(ccMSG_REMOVING, ccMSG_INSERT1, ;
						ccDATABASE + ' ' + .cDatabase) nowait
					.oMeta.DBCXDeleteRow(.cDatabase, 'Database')
					llRemoved = .T.
					lcType    = .cCurrObjectType
					if dbused(.cDBC)
						close database
					endif dbused(.cDBC)
				case .cCurrObjectType = 'Database'
		
		* Remove a free table from the meta data.
		
				case .cCurrParentType = 'Free Tables' and ;
					.oMessage.YesNo(strtran(ccQST_REMOVE_FREE_TABLE, ccMSG_INSERT1, ;
					lcObject))
					wait window strtran(ccMSG_REMOVING, ccMSG_INSERT1, lcObject) nowait
					.oMeta.DBCXDeleteRow('!' + lcObject, 'Table')
					llRemoved = .T.
				case .cCurrParentType = 'Free Tables'
		
		* Confirm the user want to remove the table or view.
		
				case .oMessage.YesNo(strtran(ccQST_REMOVE_TABLE, ccMSG_INSERT1, ;
					lcObject))
					wait window strtran(ccMSG_REMOVING, ccMSG_INSERT1, lcObject) nowait
		
		* If this is a table, close any copies that might be open.
		
					if .cCurrParentType == 'Table'
						lcFile = fullpath(dbgetprop(lcObject, 'Table', 'Path'), lcDBC)
						.oUtility.CloseAllAliases(lcFile)
		
		* Remove any relations in which this table is the parent, since VFP doesn't
		* allow the table to be removed in that case.
		
						.RemoveRelations(lcObject)
		
		* If the table exists, create arrays of fields and indexes in the table.
		
						if file(lcFile)
							select 0
							use (lcObject) exclusive
							lnFields  = afields(laFields)
							lnIndexes = tagcount()
							for lnI = 1 to lnIndexes
								dimension laIndexes[lnI, 6]
								laIndexes[lnI, 1] = tag(lnI)
								laIndexes[lnI, 2] = key(lnI)
								laIndexes[lnI, 3] = sys(2021, lnI)
								laIndexes[lnI, 4] = iif(empty(for(lnI)), '', ;
									' for ' + for(lnI)) + ;
									iif(candidate(lnI), ' candidate', '') + ;
									iif(unique(lnI), ' unique', '') + ;
									iif(descending(lnI), ' descending', '')
								laIndexes[lnI, 5] = .F.
								laIndexes[lnI, 6] = idxcollate(lnI)
							next lnI
		
		* If any fields have long names and are involved in indexes, those indexes
		* must be deleted for now (since we'll have a problem reopening the table) and
		* recreated later.
		
							for lnI = 1 to lnFields
								lcField = laFields[lnI, 1]
								if len(lcField) > 10
									for lnJ = 1 to lnIndexes
										if .oUtility.InExpr(lcField, laIndexes[lnJ, 2]) or ;
											.oUtility.InExpr(lcField, laIndexes[lnJ, 3])
											delete tag (laIndexes[lnJ, 1])
											laIndexes[lnJ, 5] = .T.
										endif .oUtility.InExpr(lcField, laIndexes[lnJ, 2]) ...
									next lnJ
								endif len(lcField) > 10
							next lnI
							use
						endif file(lcFile)
		
		* Now try to remove the table.
		
						.oError.ResetError()
						remove table (lcObject)
						llRemoved = not .oError.DidErrorOccur()
						if llRemoved
		
		* If the file still exists and long names were used in index expressions,
		* replace them with the "real" names.
		
							if file(lcFile)
								select 0
								use (lcFile) exclusive
								for lnI = 1 to lnFields
									lcField = laFields[lnI, 1]
									if len(lcField) > 10
										for lnJ = 1 to lnIndexes
											lnPos = .oUtility.InExpr(lcField, ;
												laIndexes[lnJ, 2], .T.)
											do while lnPos > 0
												laIndexes[lnJ, 2] = stuff(laIndexes[lnJ, 2], ;
													lnPos, len(lcField), field(lnI))
												lnPos = .oUtility.InExpr(lcField, ;
													laIndexes[lnJ, 2], .T.)
											enddo while lnPos > 0
											lnPos = .oUtility.InExpr(lcField, ;
												laIndexes[lnJ, 3], .T.)
											do while lnPos > 0
												laIndexes[lnJ, 3] = stuff(laIndexes[lnJ, 3], ;
													lnPos, len(lcField), field(lnI))
												lnPos = .oUtility.InExpr(lcField, ;
													laIndexes[lnJ, 3], .T.)
											enddo while lnPos > 0
										next lnJ
									endif len(lcField) > 10
								next lnI
		
		* If any indexs were changed, recreate them.
		
								lcCurrCollate = set('COLLATE')
								for lnI = 1 to lnIndexes
									if laIndexes[lnI, 5]
										lcExpression = laIndexes[lnI, 2]
										lcOptions    = laIndexes[lnI, 4]
										set collate to laIndexes[lnI, 6]
										index on &lcExpression tag (laIndexes[lnI, 1]) ;
											&lcOptions
									endif laIndexes[lnI, 5]
								next lnI
								set collate to lcCurrCollate
								use
							endif file(lcFile)
						endif llRemoved
		
		* If this was a view, just delete it.
		
					else
						.oError.ResetError()
						delete view (lcObject)
						llRemoved = not .oError.DidErrorOccur()
					endif .cCurrParentType == 'Table'
		
		* Remove the table or view from the meta data, then create a cursor to contain
		* notes for the developer.
		
					if llRemoved
						.oMeta.DBCXDeleteRow(lcObject, .cCurrParentType)
						create cursor __NOTIFY (MESSAGE C(128), NOTIFY M)
						insert into __NOTIFY (MESSAGE) values ;
							(strtran(ccMSG_REMOVE_EDITS, ccMSG_INSERT1, lcObject))
		
		* Check all DBCs for all occurrences of the table.
		
						.FindAllUsesOfTable(lcObject)
					endif llRemoved
			endcase
		
		* Remove the node for the table or view and select the next one.
		
			if llRemoved
				.RemoveNode(lcObject, lcType, .cDatabase)
			endif llRemoved
			wait clear
		endwith
		
	ENDPROC

	PROCEDURE removerelations		&& Remove relations from the DBC
		*==============================================================================
		* Method:			RemoveRelations
		* Status:			Public
		* Purpose:			Removes all relations from child tables for the specified
		*						table (this is important because VFP doesn't allow a
		*						table to be removed from the database in that case)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/08/2001
		* Parameters:		tcTable - the table to remove relations for
		*					tcDBC   - the database the table belongs to (optional: if
		*						it isn't specified, the current database is used)
		* Returns:			.T. if everything went OK
		* Environment in:	the database for the specified table must be the selected
		*						database or passed in the second parameter
		* Environment out:	all relations from child tables for the specified table
		*						have been removed
		*==============================================================================
		
		lparameters tcTable, ;
			tcDBC
		local lcDBC, ;
			lcOldDBC, ;
			laRelations[1], ;
			lnRelations, ;
			lcAlias1, ;
			lcAlias2, ;
			laUsed[1], ;
			lnPos, ;
			lcRelated
		with This
			if empty(tcDBC)
				lcDBC = dbc()
			else
				lcOldDBC = dbc()
				lcDBC    = tcDBC
				set database to (tcDBC)
			endif empty(tcDBC)
			lnRelations = adbobjects(laRelations, 'Relation')
			if lnRelations > 0
				lcAlias1 = upper(tcTable)
				lcAlias2 = '"' + lcAlias1 + '"'
				aused(laUsed)
				lnPos = .oUtility.ArrayScan(@laRelations, lcAlias1, 2)
				lnPos = iif(lnPos = 0, .oUtility.ArrayScan(@laRelations, lcAlias2, ;
					2), lnPos)
				do while lnPos > 0
					lcRelated = laRelations[lnPos, 1]
					lcRelated = iif(left(lcRelated, 1) = '"', ;
						substr(lcRelated, 2, len(lcRelated) - 2), lcRelated)
					if file(fullpath(dbgetprop(lcRelated, 'Table', 'Path'), lcDBC))
						alter table (lcRelated) ;
							drop foreign key tag (laRelations[lnPos, 3]) save
					endif file(fullpath(dbgetprop(lcRelated, 'Table', 'Path'), lcDBC))
					adel(laRelations, lnPos)
					lnPos = .oUtility.ArrayScan(@laRelations, lcAlias1, 2)
					lnPos = iif(lnPos = 0, .oUtility.ArrayScan(@laRelations, ;
						lcAlias2, 2), lnPos)
				enddo while lnPos > 0
				.oUtility.CloseOpenedTables(@laUsed)
			endif lnRelations > 0
			if not empty(tcDBC)
				set database to (lcOldDBC)
			endif not empty(tcDBC)
		endwith
		
	ENDPROC

	PROCEDURE renametable
		*==============================================================================
		* Method:			RenameTable
		* Purpose:			Renames the specified table or viw
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2005 Stonefield Systems Group Inc.
		* Last revision:	03/23/2005
		* Parameters:		tcOldName - the old table or view name
		*					tcNewName - the new name
		*					tcType    - the object type
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcOldName, ;
			tcNewName, ;
			tcType
		local lcNewKey, ;
			lcOldKey, ;
			loNode, ;
			lcOldName, ;
			lcNewName, ;
			laDBCs[1], ;
			lnDBCs, ;
			lnI, ;
			lcPath, ;
			lcDBCAlias, ;
			lnPos, ;
			lcObject, ;
			lnRecno, ;
			liParent, ;
			lcProperty, ;
			loNotify
		
		* The table's or view's long name was changed so rename it in the database and
		* the tree.
		
		with This
			do case
				case empty(.cDatabase)
				case tcType = 'Table'
					rename table (tcOldName) to (tcNewName)
				case tcType = 'View'
					rename view  (tcOldName) to (tcNewName)
			endcase
			lcNewKey    = .GetNodeKey(tcNewName, tcType, .cDatabase)
			lcOldKey    = .GetNodeKey(tcOldName, tcType, .cDatabase)
			loNode      = .oTree.Nodes.Item[lcOldKey]
			loNode.Text = tcNewName
			loNode.Key  = lcNewKey
			lcOldName   = .cDatabase + '!' + tcOldName
			lcNewName   = .cDatabase + '!' + tcNewName
		
		* Rename the table in all meta data. Do more processing if it's not a free
		* table.
		
			.oMeta.DBCXRenameObject(lcOldName, tcType, lcNewName)
			if not empty(.cDatabase)
		
		* Create a cursor to contain notes for the developer.
		
				create cursor __NOTIFY (MESSAGE C(128), NOTIFY M)
				insert into __NOTIFY (MESSAGE) values ;
					(strtran(strtran(ccMSG_RENAME_EDITS, ccMSG_INSERT1, tcNewName), ;
					ccMSG_INSERT2, tcOldName))
		
		* Process each database in the meta data.
		
				lnDBCs = .oMeta.DBCXGetAllObjects('Database', @laDBCs)
				for lnI = 1 to lnDBCs
					lcDBC = laDBCs[lnI]
		
		* Open the DBC as a table.
		
					lcPath     = .oMeta.DBCXGetProp(lcDBC, 'Database', 'CBmPath')
					lcPath     = fullpath(lcPath, .oMeta.cRegistryPath)
					lcDBCAlias = .oMeta.oSDTMgr.DBCOpen(lcPath)
					if not empty(lcDBCAlias)
		
		* First, check the stored procedures.
		
						set order to OBJECTNAME
						seek str(cnVF_OBJID_DATABASE) + ccVF_OBJ_DATABASE + ;
							lower(ccVF_OBJ_STOREDPROCSRC)
						if (lcDBC == .cDatabase and .oUtility.InExpr(tcOldName, CODE, ;
							.F., .T.)) or .oUtility.InExpr(lcOldName, CODE, .F., .T.)
							replace NOTIFY with 'Stored procedures for ' + ;
								lcDBC + ccCR in __NOTIFY
						endif (lcDBC == .cDatabase ...
		
		* Now check all validation rules, defaults, etc. We'll ignore relations since
		* VFP handles renaming the parent table there.
		
						scan for (lcDBC == .cDatabase and ;
							atc(tcOldName, PROPERTY) > 0) or ;
							atc(lcOldName, PROPERTY) > 0
							if lcDBC == .cDatabase
								lnPos = .oUtility.InExpr(tcOldName, PROPERTY, .T., .T.)
							else
								lnPos = 0
							endif lcDBC == .cDatabase
							if lnPos = 0
								lnPos = .oUtility.InExpr(lcOldName, PROPERTY, .T., .T.)
								if lnPos > 0
									lnPos = lnPos + len(.cDatabase) + 1
								endif lnPos > 0
							endif lnPos = 0
							do case
		
		* If it wasn't found exactly, ignore it.
		
								case lnPos = 0
		
		* For fields and indexes, flag that we found it if it's in a table or change
		* it if it's part of a view.
		
								case inlist(OBJECTTYPE, ccVF_OBJ_FIELD, ccVF_OBJ_INDEX)
									lcObject = alltrim(OBJECTNAME)
									lnRecno  = recno()
									liParent = PARENTID
									locate for OBJECTID = liParent
									if OBJECTTYPE = ccVF_OBJ_VIEW
										go lnRecno
										lcProperty = .oMeta.oSDTMgr.DBCGetProp(cnVF_VIEWFLD_UPDATENAME)
										lnPos = .oUtility.InExpr(tcOldName + '.', ;
											lcProperty, .T.)
										do while lnPos > 0
											lcProperty = stuff(lcProperty, lnPos, ;
												len(tcOldName), tcNewName)
											lnPos = .oUtility.InExpr(tcOldName + '.', ;
												lcProperty, .T.)
										enddo while lnPos > 0
										.oMeta.oSDTMgr.DBCSetProp(cnVF_VIEWFLD_UPDATENAME, ;
											lcProperty)
									else
										lcObject = lcDBC + '!' + ;
											alltrim(OBJECTNAME) + '.' + lcObject
										replace NOTIFY with NOTIFY + lcObject + ccCR ;
											in __NOTIFY
										go lnRecno
									endif OBJECTTYPE = ccVF_OBJ_VIEW
		
		* In the case of a view, rename the table in the SQL and Tables properties. If
		* it exists in other properties, flag that.
		
								case OBJECTTYPE = ccVF_OBJ_VIEW
									lcProperty = .oMeta.oSDTMgr.DBCGetProp(cnVF_VIEW_SQL)
									lnPos = .oUtility.InExpr(tcOldName, lcProperty, ;
										.T., .T.)
									do while lnPos > 0
										lcProperty = stuff(lcProperty, lnPos, ;
											len(tcOldName), tcNewName)
										lnPos = .oUtility.InExpr(tcOldName, ;
											lcProperty, .T., .T.)
									enddo while lnPos > 0
									.oMeta.oSDTMgr.DBCSetProp(cnVF_VIEW_SQL, ;
										lcProperty)
									lcProperty = .oMeta.oSDTMgr.DBCGetProp(cnVF_VIEW_TABLES)
									lnPos = .oUtility.InExpr(tcOldName, lcProperty, ;
										.T.)
									do while lnPos > 0
										lcProperty = stuff(lcProperty, lnPos, ;
											len(tcOldName), tcNewName)
										lnPos = .oUtility.InExpr(tcOldName, ;
											lcProperty, .T.)
									enddo while lnPos > 0
									.oMeta.oSDTMgr.DBCSetProp(cnVF_VIEW_TABLES, ;
										lcProperty)
									if .oUtility.InExpr(tcOldName, lcProperty, .F., ;
										.T.)
										lcObject = lcDBC + '!' + alltrim(OBJECTNAME)
										replace NOTIFY with NOTIFY + lcObject + ccCR ;
											in __NOTIFY
									endif .oUtility.InExpr ...
		
		* For tables, just flag that we found it (we need to skip any references to
		* the DBF name, so we'll remove those as we find them).
		
								case OBJECTTYPE = ccVF_OBJ_TABLE
									lcProperty = PROPERTY
									do while lnPos > 0
										if upper(substr(lcProperty, lnPos + ;
											len(tcOldName), 4)) <> '.DBF'
											lcObject = lcDBC + '!' + ;
												alltrim(OBJECTNAME)
											replace NOTIFY with NOTIFY + lcObject + ;
												ccCR in __NOTIFY
											lnPos = 0
										else
											lcProperty = stuff(lcProperty, lnPos, ;
												len(tcOldName), '')
											lnPos = .oUtility.InExpr(tcOldName, ;
												lcProperty, .T., .T.)
										endif upper(substr(PROPERTY, ...
									enddo while lnPos > 0
							endcase
						endscan for atc(tcOldName, PROPERTY)
						use in (lcDBCAlias)
					endif not empty(lcDBCAlias)
				next lnI
		
		* Now display a message so the user knows what objects were affected.
		
				if not empty(__NOTIFY.NOTIFY)
					do form NOTIFY with '__NOTIFY', .oError name loNotify linked
				endif not empty(__NOTIFY.NOTIFY)
				use in __NOTIFY
			endif not empty(.cDatabase)
		endwith
		
	ENDPROC

	PROCEDURE resethotkeys		&& Reset hot keys
		on key label Ctrl+PgUp
		on key label Ctrl+PgDn
		
	ENDPROC

	PROCEDURE Resize
		with This
			.LockScreen = .T.
			.pgfProps.Resize()
			.oTree.Width  = .Width - .nWidthSpacingPage - .pgfProps.Width - ;
				.nWidthSpacing - .oTree.Left
			.oTree.Height = .Height - .oTree.Top - .nHeightSpacing
			.StatusResize()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE savechanges
		*==============================================================================
		* Method:			SaveChanges
		* Purpose:			Saves properties changes for the selected object
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2002 Stonefield Systems Group Inc.
		* Last Revision:	04/24/2002
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		with This
			do case
				case not .lChanged or (not .lGotObject and ;
					.cCurrParentType <> ccLIBRARY_TABLE)
				case .cCurrObjectType = 'Table'
					.pgfProps.Page1.cntTableProps.SaveProps()
				case .cCurrObjectType = 'View'
					.pgfProps.Page1.cntViewProps.SaveProps()
				case .cCurrObjectType = 'Field'
					.pgfProps.Page1.cntFieldProps.SaveProps()
				case .cCurrObjectType = 'User'
					.pgfProps.Page1.cntCalcProps.SaveProps()
				case .cCurrObjectType = 'Index'
					.pgfProps.Page1.cntIndexProps.SaveProps()
				case .cCurrObjectType = 'Database'
					.pgfProps.Page1.cntDatabaseProps.SaveProps()
			endcase
		endwith
		
	ENDPROC

	PROCEDURE savemrumetadata		&& Saves the MRU meta data paths to the Registry
		local lnI
		with This
			.oReg.DeleteKey(ccREG_KEY_META_PATHS)
			for lnI = 1 to alen(.aMetaPaths, 1)
				if not empty(.aMetaPaths[lnI, 2])
					.oReg.SetKey(ccREG_KEY_META_PATHS, 'Path ' + transform[lnI], ;
						.aMetaPaths[lnI, 1] + '~' + .aMetaPaths[lnI, 2])
				else
					exit
				endif not empty(.aMetaPaths[lnI, 2])
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu
		lparameters toMenu, ;
			tcObject
		with toMenu
			if .nBarCount > 0
				.AddMenuSeparator()
			endif .nBarCount > 0
			.AddMenuBar('\<' + This.cmdAdd.ToolTipText + '...', tcObject + ;
				'.AddObjectToMetaData()', , , , 'not ' + tcObject + '.cmdAdd.Enabled', ;
				, This.cmdAdd.Picture)
			.AddMenuBar(strtran(This.cmdBatchAdd.ToolTipText, 'Bat', 'Ba\<t') + ;
				'...', tcObject + '.BatchAddObjects()', , , , 'not ' + tcObject + ;
				'.cmdBatchAdd.Enabled', , This.cmdBatchAdd.Picture)
			.AddMenuBar('\<' + This.cmdNew.ToolTipText + '...', tcObject + ;
				'.CreateNewObject()', , , , 'not ' + tcObject + '.cmdNew.Enabled', ;
				, This.cmdNew.Picture)
			.AddMenuBar(strtran(This.cmdRemove.ToolTipText, 'Rem', 'Re\<m') + ;
				'...', tcObject + '.RemoveObjectFromMetaData()', , , , ;
				'not ' + tcObject + '.cmdRemove.Enabled', , This.cmdRemove.Picture)
			.AddMenuBar('\<' + This.cmdCopy.ToolTipText + '...', tcObject + ;
				'.CopyOneTable()', , , , 'not ' + tcObject + '.cmdCopy.Enabled', ;
				, This.cmdCopy.Picture)
			.AddMenuSeparator()
			.AddMenuBar('\<' + This.cmdModify.ToolTipText, tcObject + ;
				'.ModifyObject()', , , , 'not ' + tcObject + '.cmdModify.Enabled', ;
				, This.cmdModify.Picture)
			.AddMenuBar('View field \<wizard', tcObject + '.cmdWizard.Click()', , , , ;
				'not ' + tcObject + '.cmdWizard.Enabled', , This.cmdWizard.Picture)
			.AddMenuBar(strtran(This.cmdRedefine.ToolTipText, 'Redef', 'Rede\<f'), ;
				tcObject + '.cmdRedefine.Click()', , , , 'not ' + tcObject + ;
				'.cmdRedefine.Enabled', , This.cmdRedefine.Picture)
			.AddMenuBar('\<Browse', tcObject + '.BrowseTable()', , , , ;
				'not ' + tcObject + '.cmdBrowse.Enabled', , This.cmdBrowse.Picture)
			.AddMenuBar('Reinde\<x', tcObject + '.ReindexTable()', , , , ;
				'not ' + tcObject + '.cmdReindex.Enabled', , This.cmdReindex.Picture)
			.AddMenuBar('\<Update', tcObject + '.UpdateTable()', , , , ;
				'not ' + tcObject + '.cmdUpdate.Enabled', , This.cmdUpdate.Picture)
			.AddMenuSeparator()
			.AddMenuBar('Validate \<object', tcObject + '.ValidateCurrentObject()', , , , ;
				'not ' + tcObject + '.lObjectExists and ' + tcObject + ;
				".cCurrObjectType <> 'Database'")
			.AddMenuBar('\<Validate meta data', tcObject + '.Validate()', , , , ;
				'not ' + tcObject + '.cmdPack.Enabled', , This.cmdPack.Picture)
			.AddMenuBar('Update from Field Repo\<sitory', tcObject + ;
				'.UpdateFieldRep()', , , , 'not ' + tcObject + '.cmdFieldRep.Enabled', ;
				, This.cmdFieldRep.Picture)
			.AddMenuSeparator()
			.AddMenuBar('Produce \<documentation', tcObject + '.Document()', , , , ;
				'not ' + tcObject + '.cmdDocument.Enabled', , This.cmdDocument.Picture)
			.AddMenuBar('\<Properties...', tcObject + '.Preferences()', , , , ;
				'not ' + tcObject + '.cmdPref.Enabled', , This.cmdPref.Picture)
			.AddMenuSeparator()
			.AddMenuBar('Displa\<y SDT version...', tcObject + '.DisplayVersion()')
		endwith
		
	ENDPROC

	PROCEDURE Show
		* Set focus to the TreeView control.
		
		lparameters tnStyle
		This.oTree.SetFocus()
		
	ENDPROC

	PROCEDURE showmenu
		if vartype(This.oMenu) = 'O'
			This.oMenu.ClearMenu()
		endif vartype(This.oMenu) = 'O'
		dodefault()
		
	ENDPROC

	PROCEDURE statusresize		&& Resizes the "status" textboxes when the form is resized.
		*==============================================================================
		* Method:			StatusResize
		* Purpose:			Resizes the status areas when the form is resized
		* Author:			Doug Hennig
		* Copyright:		(c) 1997 Stonefield Systems Group Inc.
		* Last Revision:	12/22/97
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		local lnLeft
		with This
			lnLeft             = .txtDatabase.Left - .txtObject.Left - .txtObject.Width
			.txtObject.Width   = .oTree.Width
			.txtDatabase.Left  = .txtObject.Left + .txtObject.Width + lnLeft
			.txtDatabase.Width = .Width - .txtObject.Left * 2 - ;
				.txtObject.Width
		endwith
		
	ENDPROC

	PROCEDURE treecollapse		&& Handle TreeView collapse event
		*==============================================================================
		* Method:			TreeCollapse
		* Purpose:			Ensure the node in the tree that was just collapsed is
		*						selected
		* Author:			Doug Hennig
		* Copyright:		(c) 1997 Stonefield Systems Group Inc.
		* Last Revision:	05/06/98
		* Parameters:		toNode - an object reference to the node
		* Returns:			.T.
		*==============================================================================
		
		lparameters toNode
		This.TreeNodeClick(toNode)
		
	ENDPROC

	PROCEDURE treedblclick		&& Handle TreeView DblClick event
		*==============================================================================
		* Method:			TreeDblClick
		* Purpose:			Handle a node being double-clicked
		* Author:			Doug Hennig
		* Copyright:		(c) 1997 Stonefield Systems Group Inc.
		* Last Revision:	05/06/98
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		with This
		
		* Restore the saved expanded setting for the node, then do the desired action.
		
			.oTree.SelectedItem.Expanded = .lExpanded
			do case
				case .cmdBrowse.Enabled and .cListAction = ccBROWSE
					.BrowseTable()
				case .cmdModify.Enabled
					.ModifyObject()
			endcase
		endwith
		
	ENDPROC

	PROCEDURE treedragdrop		&& Handle TreeView DragDrop event
		*==============================================================================
		* Method:			TreeDragDrop
		* Purpose:			Handle something being dropped on the tree
		* Author:			Doug Hennig
		* Copyright:		(c) 1997, 2000 Stonefield Systems Group Inc.
		* Last Revision:	09/19/2000
		* Parameters:		toSource - an object reference to the object being dragged
		*					tnXCoord - the X coordinate of the mouse
		*					tnYCoord - the Y coordinate of the mouse
		* Returns:			.T.
		*==============================================================================
		
		lparameters toSource, ;
			tnXCoord, ;
			tnYCoord
		local loParent, ;
			lcTable, ;
			lcType, ;
			lcDBC, ;
			lcNew
		
		* If we've had a table dropped from another copy of SDT managing a different
		* database, handle it.
		
		if type('toSource.Parent') <> 'O' or isnull(toSource.Parent) or ;
			upper(toSource.BaseClass) <> 'OLECONTROL' or ;
			not 'TREECTRL' $ upper(toSource.OLEClass)
			return
		endif type('toSource.Parent') <> 'O'  ...
		loParent = toSource.Parent
		with This
			if upper(toSource.Name) == 'OTREE' and type('loParent.cUniqueID') = 'C' and ;
				loParent.cUniqueID <> .cUniqueID and loParent.cDBC <> .cDBC and ;
				inlist(loParent.cCurrObjectType, 'Table', 'View') and ;
				not indbc(loParent.cCurrParent, loParent.cCurrParentType)
		
		* Get the name of the table or view and the database it comes from, then use
		* either the CopyTable or MoveTable method to do the dirty work.
		
				lcTable = loParent.cCurrParent
				lcType  = loParent.cCurrParentType
				lcDBC   = loParent.cDBC
				if lcType = 'Table'
					set database to (lcDBC)
					lcNew = dbgetprop(lcTable, 'Table', 'Path')
					set database to (.cDBC)
				else
					lcNew = lcTable
				endif lcType = 'Table'
				if loParent.lMoveTable
					.MoveTable(lcTable, lcType, lcDBC, loParent)
				else
					.CopyTable(lcTable, lcType, lcDBC, lcNew, loParent)
				endif loParent.lMoveTable
			endif upper(toSource.Name) == 'OTREE' ...
		endwith
		
	ENDPROC

	PROCEDURE treedragover		&& Handle TreeView DragOver event
		*==============================================================================
		* Method:			TreeDragOver
		* Purpose:			Handle a node being dragged over
		* Author:			Doug Hennig
		* Copyright:		(c) 1997, 2000 Stonefield Systems Group Inc.
		* Last Revision:	09/19/2000
		* Parameters:		toSource - an object reference to the object being dragged
		*					tnXCoord - the X coordinate of the mouse
		*					tnYCoord - the Y coordinate of the mouse
		*					tnState  - indicates if we're over, entering, or leaving
		* Returns:			.T.
		*==============================================================================
		
		lparameters toSource, ;
			tnXCoord, ;
			tnYCoord, ;
			tnState
		local loParent
		loParent = iif(type('toSource.Parent') = 'O' and not isnull(toSource.Parent), ;
			toSource.Parent, .NULL.)
		
		* If the mouse is entering the object and the source is from an SDT session,
		* change the icon so it appears we can drop the source here.
		
		with This
			do case
				case tnState = DRAG_ENTER and not isnull(loParent) and ;
					upper(toSource.BaseClass) = 'OLECONTROL' and ;
					'TREECTRL' $ upper(toSource.OLEClass) and ;
					loParent.Name == .Name and type('loParent.cUniqueID') = 'C' and ;
					loParent.cUniqueID <> .cUniqueID and loParent.cDBC <> .cDBC and ;
					inlist(loParent.cCurrObjectType, 'Table', 'View') and ;
					not indbc(loParent.cCurrParent, loParent.cCurrParentType)
					toSource.DragIcon = toSource.Parent.cDragIcon
		
		* If the mouse is leaving the object, change to a "no drop" icon.
		
				case tnState = DRAG_LEAVE
					toSource.DragIcon = .cNoDropIcon
			endcase
		endwith
		
	ENDPROC

	PROCEDURE treeexpand		&& Handle TreeView Expand event
		*==============================================================================
		* Method:			TreeExpand
		* Purpose:			Ensure the node in the tree that was just expanded is
		*						selected and add child nodes to it if necessary
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2002 Stonefield Systems Group Inc.
		* Last Revision:	10/29/2002
		* Parameters:		toNode  - an object reference to the node
		*					tlForce - .T. for force the expansion (for backwards
		*						compatibility only)
		* Returns:			.T.
		*==============================================================================
		
		lparameters toNode, ;
			tlForce
		local lcKey, ;
			lcNodeType, ;
			lcDatabase, ;
			lcObject
		with This
		
		* If the node has a "Loading" child, this is the first time the node has been
		* expanded, so nuke the child and add the appropriate child nodes, depending on
		* the type of node this is.
		
			if toNode.Children > 0 and toNode.Child.Text = ccLOADING
				.oTree.Nodes.Remove(toNode.Child.Key)
				lcKey      = toNode.Key
				lcNodeType = left(lcKey, 1)
				lcDatabase = .GetDatabaseFromNodeKey(lcKey)
				lcObject   = .GetObjectFromNodeKey(lcKey)
				toNode.Expanded = .T.
				do case
					case lcNodeType = 'H' and lcObject = ccLIBRARY_TABLE
						.LoadFieldRep()
					case lcNodeType = 'H' and empty(lcDatabase)
						.LoadFreeTables()
					case lcNodeType = 'H'
						.LoadDatabaseCursors(lcDatabase, lcObject)
					case lcNodeType = 'T' and not empty(lcDatabase)
						.LoadTreeCursor(lcObject, 'Table', lcDatabase)
					case lcNodeType = 'T'
						.LoadObject(lcObject, 'Free Tables', .T.)
					case lcNodeType = 'V'
						.LoadTreeCursor(lcObject, 'View', lcDatabase)
				endcase
			endif toNode.Children > 0 ...
		
		* Ensure the node is expanded (we may have been called programmatically).
		
			if not toNode.Expanded
				toNode.Expanded = .T.
			endif not toNode.Expanded
		
		* Act like the node was just clicked so it's selected.
		
			.TreeNodeClick(toNode)
		endwith
		
	ENDPROC

	PROCEDURE treekeypress		&& Handle a TreeView KeyDown event
		lparameters tnKeyCode, ;
			tnShift
		with This
			do case
		
		* Delete was pressed, so remove the selected object.
		
				case tnKeyCode = 46 and .lGotObject
					.RemoveObjectFromMetaData()
		
		* Insert was pressed, so create a new table.
		
				case tnKeyCode = 45
					.NewTable()
		
		* Esc was pressed, so close the form.
		
				case tnKeyCode = 27
					.Release()
		
		* Shift-F10 was pressed, so display the menu.
		
				case tnKeyCode = 121
					.ShowMenu()
		
		* Enter was pressed, so treat it like a double-click.
		
				case tnKeyCode = 13 and .cmdBrowse.Enabled and .cListAction = ccBROWSE
					.BrowseTable()
				case tnKeyCode = 13 and .cmdModify.Enabled
					.ModifyObject()
			endcase
		endwith
		
	ENDPROC

	PROCEDURE treemousedown		&& Handle a TreeView MouseDown event
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		local loNode
		with This
		
		* The user pressed the right mouse button, so first see if a different node
		* was selected. If so, make that the current node.
		
			if tnButton = BUTTON_RIGHT
				loNode = .oTree.HitTest(tnXCoord * .nTreeFactorX, ;
					tnYCoord * .nTreeFactorY)
				if vartype(loNode) = 'O' and ;
					not loNode.Key == .oTree.SelectedItem.Key
					loNode.Selected = .T.
					.TreeNodeClick(loNode)
				endif vartype(loNode) = 'O' ...
				.ShowMenu()
		
		* The user pressed the mouse button, so record the current mouse position so
		* we can later determine if the mouse moved enough to start a drag operation.
		
			else
				.nMouseX = tnXCoord
				.nMouseY = tnYCoord
			endif tnButton = BUTTON_RIGHT
		endwith
		
	ENDPROC

	PROCEDURE treemousemove		&& Handle a TreeView MouseMove event
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		
		* If the left mouse button is pressed and the user has moved the mouse (since
		* the button was first pressed) by more than our defined threshold and we're on
		* an object we'll allow to be dragged, start the drag operation. We may need to
		* ensure the node is properly selected, since the user may have clicked on
		* a different node.
		
		with This
			if tnButton = BUTTON_LEFT and ;
				(abs(tnXCoord - .nMouseX) > .nDragThreshold or ;
				abs(tnYCoord - .nMouseY) > .nDragThreshold)
				loNode = .oTree.HitTest(tnXCoord * .nTreeFactorX, ;
					tnYCoord * .nTreeFactorY)
				if vartype(loNode) = 'O' and ;
					not loNode.Key == .oTree.SelectedItem.Key
					.oTree.NodeClick(loNode)
				endif vartype(loNode) = 'O' ...
				if not empty(.cCurrParent) and ;
					((.cCurrObjectType = 'Field' and .cCurrParentType <> 'View') or ;
					.cCurrObjectType = 'User' or ;
					.cCurrObjectType = 'View' or ;
					(.cCurrObjectType = 'Table' and .cCurrParentType <> 'Free Tables'))
					.lMoveTable   = tnShift = 1
					.cDragIcon    = iif(.lMoveTable, .cMoveIcon, .cCopyIcon)
					.oTree.DragIcon = .cDragIcon
					.oTree.Drag()
				endif not empty(.cCurrParent) ...
			endif tnButton = BUTTON_LEFT ...
		endwith
		
	ENDPROC

	PROCEDURE treenodeclick		&& Handle TreeView NodeClick event
		*==============================================================================
		* Method:			TreeNodeClick
		* Purpose:			Handle a node being selected
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	07/30/2004
		* Parameters:		toNode - an object reference to the node
		* Returns:			.T.
		*==============================================================================
		
		lparameters toNode
		local lnSeconds, ;
			lcKey, ;
			lcNodeType, ;
			lcDatabase, ;
			lcObject, ;
			lcParentType, ;
			lcParent, ;
			lcObjectType
		
		* Save any changes and ensure the node is selected. Save its Expanded property
		* if this isn't the second click of a double-click.
		
		with This
			lcKey = toNode.Key
			if type('Thisform.ActiveControl') = 'O' and ;
				pemstatus(Thisform.ActiveControl, 'LostFocus', 5)
				Thisform.ActiveControl.LostFocus()
			endif type('Thisform.ActiveControl') = 'O' ...
			.SaveChanges()
			if type('.oTree.Nodes.Item(lcKey)') = 'O'
				toNode.Selected = .T.
				toNode.EnsureVisible()
				lnSeconds = seconds()
				if lnSeconds - .nNodeClick > _dblclick
					.lExpanded = toNode.Expanded
				endif lnSeconds - .nNodeClick > _dblclick
				.nNodeClick = seconds()
		
		* Figure out what type of object we have, the database, and the parent from the
		* node's key.
		
				lcNodeType = left(lcKey, 1)
				lcDatabase = .GetDatabaseFromNodeKey(lcKey)
				lcObject   = .GetObjectFromNodeKey(lcKey)
				do case
					case lcNodeType = 'D'
						store '' to lcParentType, lcParent
						lcObjectType = 'Database'
						store substr(lcKey, 2) to lcObject, lcDatabase
					case lcNodeType = 'H' and lcObject = 'Table' and empty(lcDatabase)
						lcObjectType = 'Table'
						lcParentType = 'Free Tables'
						store '' to lcParent, lcObject
					case lcNodeType = 'H'
						store lcObject to lcParentType, lcObjectType
						store ''       to lcParent,     lcObject
					case lcNodeType = 'T' and empty(lcDatabase)
						lcParentType = 'Free Tables'
						lcObjectType = 'Table'
						lcParent     = lcObject
					case lcNodeType = 'T'
						store 'Table' to lcParentType, lcObjectType
						lcParent = lcObject
					case lcNodeType = 'V'
						store 'View' to lcParentType, lcObjectType
						lcParent = lcObject
					case lcNodeType $ 'FIU'
						do case
							case upper(lcObject) = ccLIBRARY_TABLE
								lcParentType = ccLIBRARY_TABLE
							case empty(lcDatabase)
								lcParentType = 'Free Tables'
							case left(toNode.Parent.Key, 1) = 'T'
								lcParentType = 'Table'
							otherwise
								lcParentType = 'View'
						endcase
						do case
							case lcNodeType = 'F'
								lcObjectType = 'Field'
							case lcNodeType = 'I'
								lcObjectType = 'Index'
							otherwise
								lcObjectType = 'User'
						endcase
						lcParent = juststem(lcObject)
				endcase
		
		* If the user chose a different object than formerly selected, use the
		* GetDatabaseObject method to update everything based on which object we just
		* chose.
		
				if not lcParent == .cCurrParent or ;
					not lcParentType == .cCurrParentType or ;
					not lcObject == .cCurrObject or ;
					not lcObjectType == .cCurrObjectType or ;
					not lcDatabase == .cDatabase
					.GetDatabaseObject(lcParent, lcParentType, lcObject, ;
						lcObjectType, lcDatabase)
				endif not lcParent == .cCurrParent ...
			endif type('.oTree.Nodes.Item(lcKey)') = 'O'
		endwith
		
	ENDPROC

	PROCEDURE updatefieldrep		&& Updates tables from changes in the Field Repository
		local lcField, ;
			lcPrevName, ;
			lcObject, ;
			lnPos, ;
			lcAlias, ;
			lcTField, ;
			lcAlter, ;
			llChanged, ;
			lcDBC, ;
			laProps[1], ;
			lcRuleExpr, ;
			lcRuleText, ;
			lcDefault, ;
			lcNewDefault, ;
			lcNewRuleExpr, ;
			lcNewRuleText, ;
			laChanged[1, 3], ;
			lnI, ;
			lcTable
		wait window ccMSG_UPDATING_LINKED nowait
		select LIBSDTMETA
		scan
			lcField    = padr(substr(OBJECTNAME, at('.', OBJECTNAME) + 1), ;
				len(REPLINKFLD))
			lcPrevName = padr(substr(PREVNAME, at('.', PREVNAME) + 1), ;
				len(REPLINKFLD))
			= seek(space(len(LIBCOREMETA.CDBCNAME)) + 'F' + ;
				padr(upper(LIBSDTMETA.OBJECTNAME), len(LIBCOREMETA.COBJECTNAM)), ;
				'LIBCOREMETA', 'OBJECTNAME')
			select SDTMETA
			scan for REPLINK and (REPLINKFLD = lcField or ;
				REPLINKFLD = lcPrevName)
				lcObject  = trim(SDTMETA.OBJECTNAME)
				lnPos     = at('.', OBJECTNAME)
				lcAlias   = left(OBJECTNAME, lnPos - 1)
				lcTField  = substr(OBJECTNAME, lnPos + 1)
				lcAlter   = ''
				llChanged = .F.
				lcDBC     = trim(SDTMETA.DBCNAME)
				if not empty(lcDBC)
					This.OpenDatabase(lcDBC)
				endif not empty(lcDBC)
				= seek(upper(SDTMETA.DBCNAME + 'F' + ;
					padr(lcObject, len(COREMETA.COBJECTNAM))), 'COREMETA', ;
					'OBJECTNAME') or ;
					seek(upper(SDTMETA.DBCNAME + 'U' + ;
					padr(lcObject, len(COREMETA.COBJECTNAM))), 'COREMETA', ;
					'OBJECTNAME')
				do case
		
		* Update free table properties.
		
					case empty(DBCNAME)
						dimension laProps[4, 3]
						laProps[1, 1] = 'oCoreMgr'
						laProps[1, 2] = 'cCaption'
						laProps[1, 3] = LIBCOREMETA.cCaption
						laProps[2, 1] = 'oCoreMgr'
						laProps[2, 2] = 'mComment'
						laProps[2, 3] = LIBCOREMETA.mComment
						laProps[3, 1] = 'oCoreMgr'
						laProps[3, 2] = 'mFormat'
						laProps[3, 3] = LIBCOREMETA.mFormat
						laProps[4, 1] = 'oCoreMgr'
						laProps[4, 2] = 'mInputMask'
						laProps[4, 3] = LIBCOREMETA.mInputMask
						This.oMeta.DBCXSetRowProp(@laProps, '!' + lcObject, 'Field')
		
		* Update database properties.
		
					case not empty(DBCNAME) and indbc(lcAlias, 'Table') and ;
						indbc(lcObject, 'Field')
						dbsetprop(lcObject, 'Field', 'Caption', ;
							trim(LIBCOREMETA.cCaption))
						dbsetprop(lcObject, 'Field', 'Comment', ;
							trim(LIBCOREMETA.mComment))
						dbsetprop(lcObject, 'Field', 'DisplayClass', ;
							trim(LIBSDTMETA.AutoClass))
						dbsetprop(lcObject, 'Field', 'DisplayClassLibrary', ;
							trim(LIBSDTMETA.AutoLib))
						dbsetprop(lcObject, 'Field', 'Format', ;
							trim(LIBCOREMETA.mFormat))
						dbsetprop(lcObject, 'Field', 'InputMask', ;
							trim(LIBCOREMETA.mInputMask))
		
		* Handle database properties we can't set with DBSETPROP.
		
						lcRuleExpr    = dbgetprop(lcObject, 'Field', 'RuleExpression')
						lcRuleExpr    = iif(empty(lcRuleExpr), '', ;
							normalize(lcRuleExpr))
						lcRuleText    = dbgetprop(lcObject, 'Field', 'RuleText')
						lcRuleText    = iif(empty(lcRuleText), '', ;
							normalize(lcRuleText))
						lcDefault     = dbgetprop(lcObject, 'Field', 'DefaultValue')
						lcDefault     = iif(empty(lcDefault), '', normalize(lcDefault))
						lcNewDefault  = trim(LIBSDTMETA.DefValue)
						lcNewDefault  = iif(empty(lcNewDefault), '', ;
							normalize(lcNewDefault))
						lcNewRuleExpr = trim(LIBSDTMETA.Valid)
						lcNewRuleExpr = iif(empty(lcNewRuleExpr), '', ;
							normalize(lcNewRuleExpr))
						lcNewRuleText = trim(LIBSDTMETA.Error)
						lcNewRuleText = iif(empty(lcNewRuleText), '', ;
							normalize(lcNewRuleText))
						lcAlter    = ''
						do case
							case lcNewDefault == lcDefault
							case empty(LIBSDTMETA.DefValue)
								lcAlter = ' alter column ' + lcTField + ' drop default'
							otherwise
								lcAlter = ' alter column ' + lcTField + ;
									' set default ' + trim(LIBSDTMETA.DefValue)
						endcase
						do case
							case lcNewRuleExpr == lcRuleExpr and ;
								lcRuleText == lcRuleText
							case empty(LIBSDTMETA.Valid)
								lcAlter = iif(empty(lcAlter), ' alter column ' + ;
									lcTField, lcAlter) + ' drop check'
							otherwise
								lcAlter = iif(empty(lcAlter), ' alter column ' + ;
									lcTField, lcAlter) + ' set check ' + ;
									trim(LIBSDTMETA.Valid) + ;
									iif(empty(LIBSDTMETA.Error), '', ' error ' + ;
									trim(LIBSDTMETA.Error))
						endcase
				endcase
		
		* Update structural meta data if necessary.
		
				if LIBCOREMETA.cType <> COREMETA.cType or ;
					LIBCOREMETA.nSize <> COREMETA.nSize or ;
					LIBCOREMETA.nDecimals <> COREMETA.nDecimals or ;
					LIBCOREMETA.lBinary <> COREMETA.lBinary or ;
					LIBCOREMETA.lNull <> COREMETA.lNull or ;
					LIBCOREMETA.nStepValue <> COREMETA.nStepValue
					replace cType with LIBCOREMETA.cType, ;
						nSize with LIBCOREMETA.nSize, ;
						nDecimals with LIBCOREMETA.nDecimals, ;
						lBinary with LIBCOREMETA.lBinary, ;
						lNull with LIBCOREMETA.lNull, ;
						nStepValue with LIBCOREMETA.nStepValue ;
						in CoreMeta
					llChanged = .T.
				endif LIBCOREMETA.cType <> COREMETA.cType ...
				if not LIBCOREMETA.mExpr == COREMETA.mExpr
					replace mExpr with LIBCOREMETA.mExpr ;
						in CoreMeta
				endif not LIBCOREMETA.mExpr == COREMETA.mExpr
				replace Filter with LIBSDTMETA.Filter, ;
					RepLinkFld with lcField in SDTMeta
		
		* Flag if something changed.
		
				lnPos = This.oUtility.ArrayScan(@laChanged, lcAlias)
				if lnPos = 0
					lnPos = iif(empty(laChanged[1, 1]), 1, alen(laChanged, 1) + 1)
					dimension laChanged[lnPos, 3]
					laChanged[lnPos, 1] = lcDBC + '!' + lcAlias
					laChanged[lnPos, 2] = lcAlter
					laChanged[lnPos, 3] = llChanged
				else
					laChanged[lnPos, 2] = laChanged[lnPos, 2] + lcAlter
					laChanged[lnPos, 3] = laChanged[lnPos, 3] or llChanged
				endif lnPos = 0
			endscan for REPLINK ...
		endscan
		
		* Now update all changed tables and views.
		
		for lnI = 1 to alen(laChanged, 1)
			lcTable = laChanged[lnI, 1]
			if not empty(lcTable)
				if laChanged[lnI, 3]
					This.oMeta.oSDTMgr.Update(lcTable)
				endif laChanged[lnI, 3]
				lcAlter = laChanged[lnI, 2]
				if not empty(lcAlter)
					alter table (lcTable) &lcAlter novalidate
					lcAlias = strtran(lcTable, ' ', '_')
					if used(lcAlias)
						use in (lcAlias)
					endif used(lcAlias)
				endif not empty(lcAlter)
				This.RedefineAllViews(lcTable, laChanged[lnI, 3])
			endif not empty(lcAlias)
		next lnI
		wait clear
		
	ENDPROC

	PROCEDURE updatetable
		*==============================================================================
		* Method:			UpdateTable
		* Purpose:			Updates the selected table
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2004 Stonefield Systems Group Inc.
		* Last Revision:	07/30/2004
		* Parameters:		none
		* Returns:			.T.
		*==============================================================================
		
		with This
			.SaveChanges()
			.oMeta.oSDTMgr.Update(iif(.cCurrParentType = 'Free Tables', '', ;
				.cDatabase) + '!' + .cCurrParent)
			.RefreshForm()
		endwith
		
	ENDPROC

	PROCEDURE updateviewfield		&& Updates a view field with the properties of the source field
		*==============================================================================
		* Method:			UpdateViewField
		* Purpose:			Updates the properties of the specified view field
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2001 Stonefield Systems Group Inc.
		* Last Revision:	05/24/2001
		* Parameters:		tcView  - the name of the view
		*					tcField - the name of the field
		* Returns:			.T.
		* Environment in:	This.oDBUtilities contains a reference to an SDTDBUtilities
		*						object
		* Environment out:	the specified field in the specified view has been updated
		*==============================================================================
		
		lparameters tcView, ;
			tcField
		with This
			.oDBUtilities.oHook = This
			.oDBUtilities.UpdateViewField(tcView, tcField, .oMeta)
			.oDBUtilities.oHook = .NULL.
		endwith
		
	ENDPROC

	PROCEDURE validate
		*==============================================================================
		* Method:			Validate
		* Purpose:			Validates and packs the meta data
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/04/2001
		* Parameters:		tlInitValidate - .T. if this is being called to create the
		*						meta data for the first time
		* Returns:			.T.
		*==============================================================================
		
		lparameters tlInitValidate
		local laDBCs[1], ;
			lnDBCs, ;
			llReturn, ;
			lnI, ;
			lcDBC, ;
			laTables[1], ;
			lnTables, ;
			lcPath
		with This
			.SaveChanges()
			if tlInitValidate or .oMessage.YesNo(ccQST_VALIDATE)
		
		* See how many databases are already in the meta data; we'll validate all of
		* them.
		
				lnDBCs = .oMeta.DBCXGetAllObjects('Database', @laDBCs)
				do case
		
		* If we don't have a current database, we're OK so far.
		
					case empty(.cDatabase)
		
		* If there aren't any databases in the meta data yet, or if the current
		* database isn't in the meta data, add it to the list.
		
					case lnDBCs = 0 or ascan(laDBCs, .cDatabase) = 0
						lnDBCs = lnDBCs + 1
						dimension laDBCs[lnDBCs]
						laDBCs[lnDBCs] = .cDatabase
				endcase			
		
		* Open and validate each database in the list.
		
				llReturn = .T.
				for lnI = 1 to lnDBCs
					lcDBC = laDBCs[lnI]
					.oUtility.CloseAllAliases(lcDBC)
					llReturn = .OpenDatabase(lcDBC) and ;
						.ValidateObject(lcDBC, 'Database')
					if not llReturn
						exit
					endif not llReturn
				next lnI
		
		* Now validate free tables.
		
				if llReturn
					lnTables = .oMeta.DBCXGetAllObjects('!Table', @laTables)
					for lnI = 1 to lnTables
						lcPath   = .oMeta.oSDTMgr.GetFreeTablePath(laTables[lnI])
						llReturn = .ValidateObject('!' + lcPath, 'Table')
						if not llReturn
							exit
						endif not llReturn
					next lnI
				endif llReturn
		
		* Now reload the tree if we're supposed to.
		
				if not tlInitValidate
					.LoadTree()
				endif not tlInitValidate
			endif tlInitValidate ...
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE validatecurrentobject		&& Validates the selected object
		local lcObject, ;
			lcObjectType, ;
			llReturn
		with This
			if .cCurrParentType = 'Free Tables'
				lcObject     = .oMeta.oSDTMgr.GetFreeTablePath(.cCurrParent)
				lcObjectType = 'Table'
			else
				lcObject     = .cCurrObject
				lcObjectType = .cCurrObjectType
			endif .cCurrParentType = 'Free Tables'
		
		* Validate the object, and reload it in the TreeView if it succeeded.
		
			llReturn = .ValidateObject(lcObject, lcObjectType)
			do case
				case not llReturn
				case lcObjectType = 'Database'
					lnIndex = .oTree.SelectedItem.Index
					lcKey   = .oTree.SelectedItem.Key
					.oTree.Nodes.Remove(lnIndex)
					.LoadDatabase(lcObject)
					.oTree.Nodes[lcKey].Selected = .T.
				otherwise
					.LoadObject(.cCurrParent, .cCurrParentType, .F., .T.)
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE validateobject
		lparameters tcObjectName, ;
			tcObjectType
		local lcObjectName, ;
			llReturn
		with This
		
		* Point DBCXMgr's error handler to us so we can handle an error in DBCX. Flag
		* that no error occurred.
		
			.oMeta.oError = This
			.lErrorOccurred = .F.
		
		* Save the name of the object being validated so Error can know about it, then
		* validate the object.
		
			.cCurrValidate = tcObjectName
			lcObjectName   = iif(tcObjectType = 'Database' or '!' $ tcObjectName, '', ;
				.cDBC + '!') + tcObjectName
		*** This code was commented out in case we want to use it in the future. We will
		*** only stop validation if something went wrong and the user doesn't want to
		*** continue
		*!*		llReturn       = .oMeta.Validate(lcObjectName, tcObjectType) and ;
		*!*			not .lErrorOccurred
			llReturn       = .oMeta.Validate(lcObjectName, tcObjectType)
			.cCurrValidate = ''
		
		* Nuke DBCXMgr's error object, then return whether validate succeeded or not.
		
			.oMeta.oError = .NULL.
		endwith
		return llReturn
	ENDPROC

	PROCEDURE viewwizard
		lparameters tcView
		local lcDBCAlias, ;
			liParentID, ;
			laFields[1], ;
			lnFields, ;
			lnI, ;
			lcField
		with This
		
		* Get an array of all objects in the specified cursor.
		
			wait window ccMSG_UPDATING_VIEW nowait
			lcDBCAlias = .oMeta.oSDTMgr.DBCOpen(.cDBC)
			liParentID = .oMeta.oSDTMgr.DBCGetField(tcView, 'View', 'ObjectID')
			select OBJECTNAME ;
				from (lcDBCAlias) ;
				where PARENTID = liParentID and ;
					ObjectType = ccVF_OBJ_FIELD ;
				into array laFields
			use in (lcDBCAlias)
		
		* For each field, get database properties from the source field and use them
		* for the view field.
		
			lnFields = alen(laFields)
			for lnI = 1 to lnFields
				lcField = tcView + '.' + trim(laFields[lnI])
				.UpdateViewField(tcView, lcField)
			next lnI
			wait clear
		endwith
		
	ENDPROC

	PROCEDURE cmdAdd.Click
		Thisform.AddObjectToMetaData()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdAdd.Refresh
		with Thisform
			This.Enabled = not .lDemo and not empty(.cMetaPath) and ;
				not inlist(.cCurrParentType, 'View', ccLIBRARY_TABLE)
			do case
				case inlist(.cCurrObjectType, 'Database', 'Database')
					store strtran(ccCAP_ADD_TO_META_DATA, ccMSG_INSERT1, ;
						ccDATABASE_LOWER) to This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'Free Tables'
					store strtran(ccCAP_ADD_TO_META_DATA, ccMSG_INSERT1, ;
						ccFREE_TABLE_LOWER) to This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'Table'
					store strtran(ccCAP_ADD_TO_DBC, ccMSG_INSERT1, ;
						ccFREE_TABLE_LOWER) to This.ToolTipText, ;
						This.StatusBarText
				otherwise
					store strtran(ccCAP_ADD_TO_META_DATA, ccMSG_INSERT1, ;
						ccOBJECT) to This.ToolTipText, This.StatusBarText
			endcase
		endwith
		
	ENDPROC

	PROCEDURE cmdBatchAdd.Click
		Thisform.BatchAddObjects()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdBatchAdd.Refresh
		with Thisform
			This.Enabled = not .lDemo and not empty(.cMetaPath) and ;
				not inlist(.cCurrParentType, 'View', ccLIBRARY_TABLE)
			do case
				case inlist(.cCurrObjectType, 'Database', 'Databases')
					store strtran(ccCAP_BATCHADD_META, ccMSG_INSERT1, ;
						ccDATABASES_LOWER) to This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'Free Tables'
					store strtran(ccCAP_BATCHADD_META, ccMSG_INSERT1, ;
						ccFREE_TABLES_LOWER) to This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'Table'
					store strtran(ccCAP_BATCHADD_DBC, ccMSG_INSERT1, ;
						ccTABLES) to This.ToolTipText, This.StatusBarText
				otherwise
					store strtran(ccCAP_BATCHADD_META, ccMSG_INSERT1, ccOBJECTS) to ;
						This.ToolTipText, This.StatusBarText
			endcase
		endwith
		
	ENDPROC

	PROCEDURE cmdBrowse.Click
		Thisform.BrowseTable()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdBrowse.Refresh
		with Thisform
			This.Enabled = .lObjectExists
			do case
				case inlist(.cCurrParentType, 'Table', 'Free Tables')
					store strtran(ccCAP_BROWSE, ccMSG_INSERT1, ccTABLE_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'View'
					store strtran(ccCAP_BROWSE, ccMSG_INSERT1, ccVIEW_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				otherwise
					store strtran(ccCAP_BROWSE, ccMSG_INSERT1, ccTABLE_OR_VIEW) to ;
						This.ToolTipText, This.StatusBarText
			endcase
		endwith
		
	ENDPROC

	PROCEDURE cmdCopy.Click
		Thisform.CopyOneTable()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdCopy.Refresh
		with Thisform
			This.Enabled = .lObjectExists and not .lDemo and ;
				.cCurrParentType <> 'Free Tables'
			do case
				case .cCurrParentType = 'Table'
					store strtran(ccCAP_COPY, ccMSG_INSERT1, ccTABLE_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'View'
					store strtran(ccCAP_COPY, ccMSG_INSERT1, ccVIEW_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				otherwise
					store strtran(ccCAP_COPY, ccMSG_INSERT1, ccTABLE_OR_VIEW) to ;
						This.ToolTipText, This.StatusBarText
			endcase
		endwith
		
	ENDPROC

	PROCEDURE cmdDocument.Click
		Thisform.Document()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdDocument.Refresh
		This.Enabled = not empty(Thisform.cMetaPath)
		
	ENDPROC

	PROCEDURE cmdFieldRep.Click
		Thisform.UpdateFieldRep()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdFieldRep.Refresh
		This.Enabled = not empty(Thisform.cMetaPath)
		
	ENDPROC

	PROCEDURE cmdHelp.RightClick
		Thisform.DisplayVersion()
		
	ENDPROC

	PROCEDURE cmdModify.Click
		Thisform.ModifyObject()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdModify.Refresh
		with Thisform
			This.Enabled = .cCurrParentType = ccLIBRARY_TABLE or (.lObjectExists and ;
				(.cCurrParentType <> 'View' or ;
				.pgfProps.Page1.cntViewProps.chkVD.Value or ;
				not empty(.cViewEditor))) or .cCurrObjectType == 'Database'
			do case
				case .cCurrObjectType = 'Database'
					store strtran(ccCAP_MODIFY, ccMSG_INSERT1, ccDATABASE_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				case .cCurrParentType = ccLIBRARY_TABLE
					store strtran(ccCAP_MODIFY, ccMSG_INSERT1, ccLIBRARY) to ;
						This.ToolTipText, This.StatusBarText
				case inlist(.cCurrParentType, 'Table', 'Free Tables')
					store strtran(ccCAP_MODIFY, ccMSG_INSERT1, ccTABLE_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'View'
					store strtran(ccCAP_MODIFY, ccMSG_INSERT1, ccVIEW_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				otherwise
					store strtran(ccCAP_MODIFY, ccMSG_INSERT1, ccTABLE_OR_VIEW) to ;
						This.ToolTipText, This.StatusBarText
			endcase
		endwith
		
	ENDPROC

	PROCEDURE cmdNew.Click
		Thisform.CreateNewObject()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdNew.Refresh
		with Thisform
			This.Enabled = not .lDemo and not empty(.cMetaPath) and ;
				.cCurrParentType <> ccLIBRARY_TABLE
			do case
				case inlist(.cCurrObjectType, 'Database', 'Databases')
					store strtran(ccCAP_CREATE, ccMSG_INSERT1, ccDATABASE_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'Free Tables'
					store strtran(ccCAP_CREATE, ccMSG_INSERT1, ccFREE_TABLE_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'Table'
					store strtran(ccCAP_CREATE, ccMSG_INSERT1, ccTABLE_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'View'
					store strtran(ccCAP_CREATE, ccMSG_INSERT1, ccVIEW_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				otherwise
					store strtran(ccCAP_CREATE, ccMSG_INSERT1, ccOBJECT) to ;
						This.ToolTipText, This.StatusBarText
			endcase
		endwith
		
	ENDPROC

	PROCEDURE cmdPack.Click
		Thisform.Validate()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdPack.Refresh
		This.Enabled = not empty(Thisform.cMetaPath)
		
	ENDPROC

	PROCEDURE cmdPref.Click
		Thisform.Preferences()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdRedefine.Click
		with Thisform
			if .lGotObject
				.RedefineSingleView(.cCurrParent)
			else
				.RedefineAllViews(.cDatabase + '!', .T.)
			endif .lGotObject
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE cmdRedefine.Refresh
		This.Enabled = Thisform.cCurrParentType = 'View'
		store iif(Thisform.lGotObject, ccCAP_REDEFINE_VIEW, ;
			ccCAP_REDEFINE_ALL_VIEWS) to This.ToolTipText, This.StatusBarText
		
	ENDPROC

	PROCEDURE cmdReindex.Click
		Thisform.ReindexTable()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdReindex.Refresh
		with Thisform
			This.Enabled = .lGotTable and .lObjectExists
		endwith
		
	ENDPROC

	PROCEDURE cmdRemove.Click
		Thisform.RemoveObjectFromMetaData()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdRemove.Refresh
		with Thisform
			This.Enabled = .lGotObject and not .lDemo
			do case
				case .cCurrObjectType = 'Database'
					store strtran(ccCAP_REMOVE_META_DATA, ccMSG_INSERT1, ;
						ccDATABASE_LOWER) to This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'Free Tables'
					store strtran(ccCAP_REMOVE_META_DATA, ccMSG_INSERT1, ;
						ccFREE_TABLE_LOWER) to This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'Table'
					store strtran(ccCAP_REMOVE_DBC, ccMSG_INSERT1, ccTABLE_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				case .cCurrParentType = 'View'
					store strtran(ccCAP_REMOVE_DBC, ccMSG_INSERT1, ccVIEW_LOWER) to ;
						This.ToolTipText, This.StatusBarText
				otherwise
					store strtran(ccCAP_REMOVE_META_DATA, ccMSG_INSERT1, ccOBJECT) to ;
						This.ToolTipText, This.StatusBarText
			endcase
		endwith
		
	ENDPROC

	PROCEDURE cmdUpdate.Click
		Thisform.UpdateTable()
		dodefault()
		
	ENDPROC

	PROCEDURE cmdUpdate.Refresh
		This.Enabled = Thisform.lGotTable
		
	ENDPROC

	PROCEDURE cmdWizard.Click
		with Thisform
			if .cCurrObjectType = 'View'
				.ViewWizard(.cCurrParent)
			else
				.FieldWizard()
			endif .cCurrObjectType = 'View'
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE cmdWizard.Refresh
		with Thisform
			This.Enabled = .lGotObject and .cCurrParentType = 'View'
		endwith
		
	ENDPROC

	PROCEDURE ctrOpenMRU.cmdMain.Click
		local lcPath
		lcPath = Thisform.AskForMetaPath()
		do case
		
		* The user didn't pick a path.
		
			case empty(lcPath)
		
		* The user picked a directory where the tables don't exist, so create the meta
		* data.
		
			case ccUNTITLED $ lcPath or not file(lcPath + 'SDTMETA.DBF') or ;
				not file(lcPath + 'SDTUSER.DBF') or ;
				not file(lcPath + 'COREMETA.DBF')
				lcPath   = addbs(justpath(strtran(lcPath, ccUNTITLED)))
				Thisform.OpenMetaData(lcPath, .T.)
		
		* Open the meta data.
		
			otherwise
				Thisform.OpenMetaData(lcPath)
		endcase
		
	ENDPROC

	PROCEDURE ctrOpenMRU.cmdMenu.MouseDown
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		dodefault(tnButton, tnShift, tnXCoord, tnYCoord)
		Thisform.oTree.SetFocus()
		
	ENDPROC

	PROCEDURE ctrOpenMRU.Refresh
		This.Enabled = not Thisform.lDemo
		
	ENDPROC

	PROCEDURE ctrOpenMRU.shortcutmenu
		lparameters toMenu, ;
			tcObject
		local lnItem, ;
			lnI, ;
			lcSystem, ;
			lcPath, ;
			lcPrompt
		with Thisform
			lnItem = 0
			for lnI = 1 to alen(.aMetaPaths, 1)
				lcSystem = .aMetaPaths[lnI, 1]
				lcPath   = .aMetaPaths[lnI, 2]
				if not empty(lcPath)
					lnItem   = lnItem + 1
					lcPrompt = '\<' + transform(lnItem) + ' ' + ;
						iif(lcSystem == lcPath, lcPath, lcSystem + ' (' + lcPath + ')')
					toMenu.AddMenuBar(lcPrompt, 'loForm.OpenMetaData("' + lcPath + ;
						'")')
				endif not empty(lcPath)
			next lnI
		endwith
		dodefault(toMenu, tcObject)
		
	ENDPROC

	PROCEDURE ctrOpenMRU.showmenu
		with This
			if vartype(.oMenu) = 'O'
				.oMenu.ClearMenu()
			endif vartype(.oMenu) = 'O'
			dodefault()
		endwith
		
	ENDPROC

	PROCEDURE pgfProps.Page1.Activate
		with Thisform
			.LockScreen = .T.
			This.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE pgfProps.Page1.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE pgfProps.Page2.Activate
		with Thisform
			.LockScreen = .T.
			This.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE pgfProps.Page2.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE pgfProps.Resize
		local lnHeight, ;
			lnHeightChange
		with This
			lnHeight = .Height
			.Left    = Thisform.Width - .Width - Thisform.nWidthSpacingPage
			.Height  = Thisform.Height - .Top - Thisform.nHeightSpacing
			lnHeightChange = .Height - lnHeight
		endwith
		if lnHeightChange = 0
			return
		endif lnHeightChange = 0
		
		* Resize certain things in certain controls.
		
		with This.Page1
			.cntDatabaseProps.Height = .cntDatabaseProps.Height + lnHeightChange
			.cntDatabaseProps.edtComments.Height = .cntDatabaseProps.edtComments.Height + ;
				lnHeightChange
			.cntDatabaseProps.cntDBCEvents.Top   = .cntDatabaseProps.cntDBCEvents.Top + ;
				lnHeightChange
			.cntDatabaseProps.cntStatistics.Top  = .cntDatabaseProps.cntStatistics.Top + ;
				lnHeightChange
			.cntDatabaseProps.lblTables.Top      = .cntDatabaseProps.lblTables.Top + ;
				lnHeightChange
			.cntDatabaseProps.lblViews.Top       = .cntDatabaseProps.lblViews.Top + ;
				lnHeightChange
			.cntDatabaseProps.chkDBCEvents.Top   = .cntDatabaseProps.chkDBCEvents.Top + ;
				lnHeightChange
			.cntDatabaseProps.cmdGetPath.Top     = .cntDatabaseProps.cmdGetPath.Top + ;
				lnHeightChange
			.cntDatabaseProps.txtEventFile.Top   = .cntDatabaseProps.txtEventFile.Top + ;
				lnHeightChange
			.cntDatabaseProps.lblEventFile.Top   = .cntDatabaseProps.lblEventFile.Top + ;
				lnHeightChange
			.cntDatabaseProps.lblTableCount.Top  = .cntDatabaseProps.lblTableCount.Top + ;
				lnHeightChange
			.cntDatabaseProps.lblViewCount.Top   = .cntDatabaseProps.lblViewCount.Top + ;
				lnHeightChange
			.cntDatabaseProps.cmdInstallSDT.Top  = .cntDatabaseProps.cmdInstallSDT.Top + ;
				lnHeightChange
		
			.cntTableProps.Height = .cntTableProps.Height + lnHeightChange
			.cntTableProps.edtComments.Height = .cntTableProps.edtComments.Height + ;
				lnHeightChange
		
			.cntViewProps.Height = .cntViewProps.Height + lnHeightChange
			.cntViewProps.edtSQL.Height   = .cntViewProps.edtSQL.Height + lnHeightChange
			.cntViewProps.edtComments.Top = .cntViewProps.edtComments.Top + ;
				lnHeightChange
			.cntViewProps.lblComments.Top = .cntViewProps.lblComments.Top + ;
				lnHeightChange
		
			.cntFieldProps.Height = .cntFieldProps.Height + lnHeightChange
			.cntFieldProps.chkFilter.Top      = .cntFieldProps.chkFilter.Top + ;
				lnHeightChange
			.cntFieldProps.chkKeyField.Top    = .cntFieldProps.chkKeyField.Top + ;
				lnHeightChange
			.cntFieldProps.chkUpdatable.Top   = .cntFieldProps.chkUpdatable.Top + ;
				lnHeightChange
			.cntFieldProps.edtComments.Height = .cntFieldProps.edtComments.Height + ;
				lnHeightChange
		
			.cntCalcProps.Height = .cntCalcProps.Height + lnHeightChange
			.cntCalcProps.chkFilter.Top      = .cntCalcProps.chkFilter.Top + ;
				lnHeightChange
			.cntCalcProps.edtComments.Height = .cntCalcProps.edtComments.Height + ;
				lnHeightChange
		
			.cntIndexProps.Height = .cntIndexProps.Height + lnHeightChange
			.cntIndexProps.edtComments.Height = .cntIndexProps.edtComments.Height + ;
				lnHeightChange
		endwith
		with This.Page2
			.cntExtProps.Height = .cntExtProps.Height + lnHeightChange
			.cntExtProps.grdProperty.Height = .cntExtProps.grdProperty.Height + ;
				lnHeightChange
			.cntExtProps.cntValues.Top      = .cntExtProps.cntValues.Top + ;
				lnHeightChange
		endwith
		
	ENDPROC

	PROCEDURE tmrFocus.Init
		This.Enabled = clVFP7ORLATER
		
	ENDPROC

	PROCEDURE tmrFocus.Timer
		with Thisform
			if wvisible('Trace')
				This.Enabled = .F.
			endif wvisible('Trace')
			if wontop() = upper(.Name) and type('.ActiveControl.Name') = 'C' and ;
				upper(.ActiveControl.Name) = 'CMD'
				.oTree.SetFocus()
			endif wontop() = upper(.Name) ...
		endwith
		
	ENDPROC

	PROCEDURE txtDatabase.Refresh
		This.Value = Thisform.cDBC
		
	ENDPROC

	PROCEDURE txtObject.Refresh
		with Thisform
			do case
				case .cCurrParentType = 'Databases'
					This.Value = ccDATABASES
				case .cCurrObjectType = 'Database'
					This.Value = ccDATABASE_PROPER + ': ' + .cCurrObject
				case .cCurrParentType = ccLIBRARY_TABLE
					This.Value = ccLIBRARY
				case .cCurrParentType = 'Table'
					This.Value = ccTABLE + ': ' + .cCurrParent
				case .cCurrParentType = 'View'
					This.Value = ccVIEW + ': ' + .cCurrParent
				case .cCurrParentType = 'Free Tables'
					This.Value = ccFREE_TABLE + ': ' + .cCurrParent
			endcase
		endwith
		
	ENDPROC

ENDDEFINE
