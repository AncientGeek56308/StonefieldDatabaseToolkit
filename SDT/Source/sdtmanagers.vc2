*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sdtmanagers.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sdtcontroller AS sdtcontainer OF "sdtcontrols.vcx" 		&& A class that controls all open instances of SDT
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oError" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oMessage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oUtility" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oReg" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*m: closesdt		&& Cleanup after an instance of SDT
		*m: opendbc		&& Opens the specified database in the default datasession
		*m: restoreerror		&& Restores the former error handler
		*m: restorehelp		&& Restore the former help
		*m: setuperror		&& Sets up the error handler
		*m: setuphelp		&& Sets up our help file
		*m: startsdt		&& Start an instance of SDT
		*p: cclasslib		&& The setting of CLASSLIB at instantiation.
		*p: ccollate		&& The collate sequence before SDT is brought up.
		*p: cfontname		&& The font to use for all controls
		*p: chelp		&& The setting of HELP at instantiation.
		*p: chelpfile		&& The name of the HELP file at instantiation.
		*p: cmessage		&& The setting of MESSAGE at instantiation.
		*p: cnotify		&& The former NOTIFY setting
		*p: conerror		&& The former ON ERROR setting
		*p: courhelpfile		&& The name and path to our help file
		*p: nfontsize		&& The size to use for all controls
		*p: ninstances		&& The number of open instances of the SDT main form.
	*</DefinedPropArrayMethod>

	PROTECTED cclasslib,chelp,chelpfile,cmessage,cnotify,courhelpfile,ninstances
	cclasslib = 		&& The setting of CLASSLIB at instantiation.
	ccollate = 		&& The collate sequence before SDT is brought up.
	cfontname = Tahoma		&& The font to use for all controls
	chelp = 		&& The setting of HELP at instantiation.
	chelpfile = 		&& The name of the HELP file at instantiation.
	cmessage = 		&& The setting of MESSAGE at instantiation.
	cnotify = 		&& The former NOTIFY setting
	conerror = 		&& The former ON ERROR setting
	courhelpfile = 		&& The name and path to our help file
	Height = 17
	Name = "sdtcontroller"
	nfontsize = 9		&& The size to use for all controls
	ninstances = 0		&& The number of open instances of the SDT main form.
	Visible = .F.
	Width = 81

	ADD OBJECT 'oError' AS sdterrormgr WITH ;
		ctitle = Stonefield Database Explorer, ;
		lsetonerror = .T., ;
		Name = "oError"
		*< END OBJECT: ClassLib="sdtmanagers.vcx" BaseClass="custom" />

	ADD OBJECT 'oMessage' AS sfmessagemgr WITH ;
		cdefaulttitle = Stonefield Database Explorer, ;
		Left = 20, ;
		Name = "oMessage"
		*< END OBJECT: ClassLib="..\..\sfcommon\sfmessage.vcx" BaseClass="custom" />

	ADD OBJECT 'oReg' AS sfregistry WITH ;
		Left = 60, ;
		Name = "oReg", ;
		Top = 1
		*< END OBJECT: ClassLib="..\..\sfcommon\sfregistry.vcx" BaseClass="custom" />

	ADD OBJECT 'oUtility' AS sfutility WITH ;
		Left = 40, ;
		Name = "oUtility"
		*< END OBJECT: ClassLib="..\..\sfcommon\sfutility.vcx" BaseClass="custom" />
	
	PROCEDURE closesdt		&& Cleanup after an instance of SDT
		* Decrement the instance counter. If that was the last one, we're done.
		
		with This
			.nInstances = .nInstances - 1
			if .nInstances < 1
				_screen.RemoveObject('SDTController')
			endif .nInstances < 1
		endwith
		
	ENDPROC

	PROCEDURE Destroy
		local lnI
		with This
		
		* Restore the former help.
		
			.RestoreHelp()
		
		* Ensure our class libraries are closed.
		
			if '\DBCXMGR' $ set('CLASSLIB') and not '\DBCXMGR' $ This.cClassLib
				release classlib alias DBCXMGR
			endif '\DBCXMGR' $ set('CLASSLIB') ...
			if '\SDT.VCX' $ set('CLASSLIB') and not '\SDT.VCX' $ This.cClassLib
				release classlib alias SDT
			endif '\SDT.VCX' $ set('CLASSLIB') ...
			if '\SDTMANAGERS.VCX' $ set('CLASSLIB')
				release classlib alias SDTMANAGERS
			endif '\SDTMANAGERS.VCX' $ set('CLASSLIB')
			if '\SFREGISTRY.VCX' $ set('CLASSLIB')
				release classlib alias SFREGISTRY
			endif '\SFREGISTRY.VCX' $ set('CLASSLIB')
		
		* Cleanup other things.
		
			if empty(.cMessage)
				set message to
			else
				set message to .cMessage
			endif empty(.cMessage)
			if .cNotify = 'ON'
				set notify on
			endif .cNotify = 'ON'
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE Init
		local lcDirectory, ;
			lnI
		
		* Set the default title for the error and message handler objects. Get the
		* saved error handler.
		
		dodefault()
		with This
			.oError.cTitle          = ccMSG_TITLE
			.oMessage.cDefaultTitle = ccMSG_TITLE
			.cOnError               = .oError.cCurrError
		
		* Save current settings.
		
			.cClassLib = set('CLASSLIB')
			.cNotify   = set('NOTIFY')
		
		* Save the current help setting and file, and try to locate our help file.
		
			.cHelp        = set('HELP')
			.cHelpFile    = set('HELP', 1)
			lcDirectory   = .oUtility.GetAppDirectory(sys(16, program(-1) - 1))
			lcHelpFile    = lcDirectory + 'SDT.CHM'
			.cOurHelpFile = iif(file(lcHelpFile), lcHelpFile, '')
		
		* Display a message in the status bar if it's on.
		
			.cMessage = set('MESSAGE', 1)
			if set('STATUS BAR') = 'ON'
				set message to ccFULL_PRODUCT_NAME + ' ' + ccMSG_COPYRIGHT
			endif set('STATUS BAR') = 'ON'
		
		* Get the selected font settings.
		
			.cFontName = .oReg.GetKey(ccREG_KEY, ccPREF_FONTNAME, .cFontName)
			.nFontSize = val(.oReg.GetKey(ccREG_KEY, ccPREF_FONTSIZE, ;
				transform(.nFontSize)))
		endwith
		
	ENDPROC

	PROCEDURE opendbc		&& Opens the specified database in the default datasession
		lparameters tcDBC
		set database to (tcDBC)
		
	ENDPROC

	PROCEDURE restoreerror		&& Restores the former error handler
		local lcError
		lcError = This.cOnError
		on error &lcError
		
	ENDPROC

	PROCEDURE restorehelp		&& Restore the former help
		* Restore the former help setting and file.
		
		with This
			set topic id to
			if not empty(.cHelpFile) and file(.cHelpFile)
				set help to (.cHelpFile)
			endif not empty(.cHelpFile) ...
			if .cHelp = 'OFF'
				set help off
			endif .cHelp = 'OFF'
		endwith
		
	ENDPROC

	PROCEDURE setuperror		&& Sets up the error handler
		on error _screen.SDTController.oError.ErrorHandler(error(), sys(16), ;
			lineno())
		
	ENDPROC

	PROCEDURE setuphelp		&& Sets up our help file
		* Set up our help file.
		
		with This
			if not empty(.cOurHelpFile) and file(.cOurHelpFile)
				set help on
				set help to (.cOurHelpFile)
			endif not empty(.cOurHelpFile) ...
		endwith
		
	ENDPROC

	PROCEDURE startsdt		&& Start an instance of SDT
		local laDatabases[1], ;
			loForm
		
		* Increment our instance counter.
		
		with This
			.nInstances = .nInstances + 1
		
		* Save the current collate sequence.
		
			.cCollate = proper(set('COLLATE'))
		
		* Create an array of open databases because the SDT main form uses a private
		* datasession so it can't "see" any. Run the SDT main form.
		
			adatabases(laDatabases)
			do form ccSDT_FORM with This, dbc(), laDatabases name loForm
		
		* If the form didn't run properly, use CloseSDT to clean up as if the form was
		* just closed. Otherwise, get the SDT version number.
		
			if vartype(loForm) <> 'O'
				.CloseSDT()
			else
				.oError.cVersion = loForm.cVersion
			endif vartype(loForm) <> 'O'
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtdbcxmgr AS dbcxmgr OF "dbcxmgr.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	DataSession = 1
	DoCreate = .T.
	Name = "sdtdbcxmgr"
	
	PROCEDURE setdatabase
		* Don't close the current database if tcDatabase is blank.
		
		lparameters tcDatabase
		local llReturn
		if pcount() = 0 or empty(tcDatabase)
			This.cCurrentDBC = ''
			llReturn = .T.
		else
			llReturn = dodefault(tcDatabase)
		endif pcount() = 0 ...
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtdbutilities AS sdtcustom OF "sdtcontrols.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*m: closeopenedcursors		&& Closes any cursor opened by a process
		*m: opendatabase		&& Opens the specified database
		*m: redefineallviews		&& Redefines all views based on the specified table
		*m: redefineview		&& Redefines the specified view
		*m: updateview		&& Updates the properties of the specified view
		*m: updateviewfield		&& Updates the properties of the specified field in the specified view
	*</DefinedPropArrayMethod>

	Name = "sdtdbutilities"
	
	PROCEDURE closeopenedcursors		&& Closes any cursor opened by a process
		*==============================================================================
		* Method:			CloseOpenedCursors
		* Status:			Public
		* Purpose:			Closes any tables opened since a snapshot was taken
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	11/28/97
		* Parameters:		taUsed - a array of cursors opened when the snapshot was
		*						taken
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	any cursors that weren't open in taUsed but are open now
		*						are closed
		*==============================================================================
		
		lparameters taUsed
		local laCursor[1], ;
			lnCursors, ;
			lnI, ;
			lcCursor
		
		* Get an array of currently open cursors and go through them one at a time. If
		* the cursor wasn't open before, close it.
		
		lnCursors = aused(laCursors)
		for lnI = 1 to lnCursors
			lcCursor = laCursors[lnI, 1]
			if not empty(lcCursor) and ascan(taUsed, lcCursor) = 0
				use in (lcCursor)
			endif not empty(lcCursor) ...
		next lnI
		return .T.
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lcReturn
		This.lErrorOccurred = .T.
		lcReturn = dodefault(tnError, '.' + tcMethod, tnLine)
		lcReturn = iif(vartype(lcReturn) <> 'C', ccMSG_CONTINUE, lcReturn)
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ tcMethod
				return lcReturn
		
		* Handle the error choices.
		
			case lcReturn = ccMSG_RETRY
				retry
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
			case lcReturn = ccMSG_CANCEL
				cancel
			otherwise
				return
		endcase
		return lcReturn
		
	ENDPROC

	PROCEDURE opendatabase		&& Opens the specified database
		lparameters tcDatabase, ;
			toMeta
		local lcPath, ;
			llFound
		with This
			lcPath  = nvl(toMeta.DBCXGetProp(tcDatabase, 'Database', 'CBmPath'), '')
			llFound = not empty(lcPath) and ;
				file(fullpath(lcPath, toMeta.cRegistryPath))
			do case
		
		* The database is already open and we had a valid path for it, so select it.
		
				case dbused(tcDatabase) and llFound
					set database to (tcDatabase)
		
		* The database is already open but we didn't have a path for it, so update the
		* path.
		
				case dbused(tcDatabase)
					set database to (tcDatabase)
					toMeta.DBCXSetProp(tcDatabase, 'Database', 'CBmPath', ;
						sys(2014, dbc(), toMeta.cRegistryPath))
		
		* The database isn't open but we have a path for it, so open it.
		
				case llFound
					open database (fullpath(lcPath, toMeta.cRegistryPath))
		
		* The database isn't open and we don't a path for it, so try to find it by
		* looking in the current directory/VFP path, the same directory as the meta
		* data, and a DATA subdirectory of the parent of the meta data. If we can't
		* find it, ask the user to locate it.
		
				otherwise
					lcDBC   = forceext(tcDatabase, '.DBC')
					lcPath  = lcDBC
					llFound = file(lcPath)
					if not llFound
						lcPath  = fullpath(lcPath, toMeta.cRegistryPath)
						llFound = file(lcPath)
					endif not llFound
					if not llFound
						lcPath  = fullpath('..\DATA\' + lcDBC, toMeta.cRegistryPath)
						llFound = file(lcPath)
					endif not llFound
					if not llFound
						lcPath  = getfile('DBC', '', 'Open', 0, 'Locate ' + lcDBC)
						llFound = not empty(lcPath) and file(lcPath)
					endif not llFound
					if llFound
						open database (lcPath)
						toMeta.DBCXSetProp(tcDatabase, 'Database', 'CBmPath', ;
							sys(2014, dbc(), toMeta.cRegistryPath))
					endif llFound
			endcase
		endwith
		return dbused(tcDatabase)
		
	ENDPROC

	PROCEDURE redefineallviews		&& Redefines all views based on the specified table
		*==============================================================================
		* Method:			RedefineAllViews
		* Purpose:			Redefine all applicable views
		* Author:			Doug Hennig
		* Copyright:		(c) 1997-2002 Stonefield Systems Group Inc.
		* Last Revision:	04/07/2002
		* Parameters:		tcTable    - the name of the table or DBC: if a table is
		*						passed (no ! in the parameter), all views in all DBCs
		*						based on that table are redefined. If a DBC is passed,
		*						all views in that DBC are redefined
		*					toMeta     - a reference to a DBCXMgr object
		*					tlRedefine - .T. to redefine the views
		*					tlUpdate   - .T. to update view properties
		* Returns:			.T. if all applicable views were successfully processed
		* Environment in:	none
		* Environment out:	any applicable view has been redefined and/or properties
		*						updated
		*==============================================================================
		
		lparameters tcTable, ;
			toMeta, ;
			tlRedefine, ;
			tlUpdate
		local llReturn, ;
			lcDBC, ;
			laDBCs[1], ;
			lnDBCs, ;
			lcTable, ;
			lnI, ;
			lcDatabase, ;
			laViews[1], ;
			lnViews, ;
			lnJ, ;
			lcView, ;
			lcSQL
		with This
			llReturn = .T.
			lcDBC    = set('DATABASE')
			lcDBC    = iif(empty(lcDBC), '', '"' + lcDBC + '"')
			if right(tcTable, 1) = '!'
				laDBCs[1] = left(tcTable, len(tcTable) - 1)
				lnDBCs    = 1
				lcTable   = ''
			else
				lnDBCs  = toMeta.DBCXGetAllObjects('Database', @laDBCs)
				lcTable = tcTable
			endif right(tcTable, 1) = '!'
			for lnI = 1 to lnDBCs
				lcDatabase = laDBCs[lnI]
		
		* Try to open the database; exit if we can't.
		
				if not .OpenDatabase(lcDatabase, toMeta)
					llReturn = .F.
					exit
				endif not .OpenDatabase(lcDatabase, toMeta)
		
		* Process all the views in the database.
		
				lnViews = adbobjects(laViews, 'View')
				for lnJ = 1 to lnViews
					lcView = laViews[lnJ]
					lcSQL  = dbgetprop(lcView, 'View', 'SQL')
					if empty(lcTable) or (atc(lcTable, lcSQL) > 0 and ;
						dbgetprop(lcView, 'View', 'SourceType') <> 2)
						if tlRedefine
							.RedefineView(lcView, toMeta)
						endif tlRedefine
						if tlUpdate
							.UpdateView(lcView, toMeta)
						endif tlUpdate
					endif empty(lcTable) ...
				next lnJ
			next lnI
		
		* Restore the former database.
		
			set database to &lcDBC
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE redefineview		&& Redefines the specified view
		lparameters tcView, ;
			toMeta, ;
			tlNoValidate
		local lcDBCAlias, ;
			liParentID, ;
			laFieldList[1], ;
			lnFields, ;
			laFields[1], ;
			lnI, ;
			lcField, ;
			lnBatch, ;
			lcComment, ;
			llCompare, ;
			lcConnect, ;
			llFetch, ;
			llFetchMemo, ;
			lnFetch, ;
			lnMaxRecs, ;
			llOffline, ;
			lcParmList, ;
			llPrepared, ;
			lcRuleExpr, ;
			lcRuleText, ;
			llSendUpdate, ;
			llShareConn, ;
			lnViewType, ;
			lcSQL, ;
			lcTables, ;
			lnUpdate, ;
			lnUseMemo, ;
			lnWhereType, ;
			lcRemote, ;
			laOpenTables[1], ;
			lnEngineBehavior
		with This
		
		* Get a list of fields for the view.
		
			wait window strtran(ccMSG_REDEFINING, ccMSG_INSERT1, tcView) nowait
			lnDataSession = set('DATASESSION')
			lcDBCAlias    = toMeta.oSDTMgr.DBCOpen(dbc(), '', lnDataSession)
			liParentID    = toMeta.oSDTMgr.DBCGetField(tcView, 'View', 'ObjectID', ;
				lcDBCAlias, lnDataSession)
			select OBJECTNAME ;
				from (lcDBCAlias) ;
				where PARENTID = liParentID and ;
					OBJECTTYPE = ccVF_OBJ_FIELD ;
				into array laFieldList
			use in (lcDBCAlias)
			lnFields = alen(laFieldList)
		
		* Get the database properties for the fields.
		
			dimension laFields[lnFields, 14]
			for lnI = 1 to lnFields
				lcField           = tcView + '.' + trim(laFieldList[lnI])
				laFields[lnI,  1] = lcField
				laFields[lnI,  2] = dbgetprop(lcField, 'Field', 'Caption')
				laFields[lnI,  3] = dbgetprop(lcField, 'Field', 'Comment')
				laFields[lnI,  4] = dbgetprop(lcField, 'Field', 'DataType')
				laFields[lnI,  5] = dbgetprop(lcField, 'Field', 'DefaultValue')
				laFields[lnI,  6] = dbgetprop(lcField, 'Field', 'DisplayClass')
				laFields[lnI,  7] = dbgetprop(lcField, 'Field', 'DisplayClassLibrary')
				laFields[lnI,  8] = dbgetprop(lcField, 'Field', 'Format')
				laFields[lnI,  9] = dbgetprop(lcField, 'Field', 'InputMask')
				laFields[lnI, 10] = dbgetprop(lcField, 'Field', 'KeyField')
				laFields[lnI, 11] = dbgetprop(lcField, 'Field', 'RuleExpression')
				laFields[lnI, 12] = dbgetprop(lcField, 'Field', 'RuleText')
				laFields[lnI, 13] = dbgetprop(lcField, 'Field', 'Updatable')
				laFields[lnI, 14] = dbgetprop(lcField, 'Field', 'UpdateName')
			next lnI
		
		* Read the current database properties for the view.
		
			lnBatch      = dbgetprop(tcView, 'View', 'BatchUpdateCount')
			lcComment    = dbgetprop(tcView, 'View', 'Comment')
			lcComment    = iif(left(lcComment, 1) = '*', substr(lcComment, 3), ;
				lcComment)
			llCompare    = dbgetprop(tcView, 'View', 'CompareMemo')
			lcConnect    = dbgetprop(tcView, 'View', 'ConnectName')
			llFetch      = dbgetprop(tcView, 'View', 'FetchAsNeeded')
			llFetchMemo  = dbgetprop(tcView, 'View', 'FetchMemo')
			lnFetch      = dbgetprop(tcView, 'View', 'FetchSize')
			lnMaxRecs    = dbgetprop(tcView, 'View', 'MaxRecords')
			llOffline    = dbgetprop(tcView, 'View', 'Offline')
			lcParmList   = dbgetprop(tcView, 'View', 'ParameterList')
			llPrepared   = dbgetprop(tcView, 'View', 'Prepared')
			lcRuleExpr   = dbgetprop(tcView, 'View', 'RuleExpression')
			lcRuleText   = dbgetprop(tcView, 'View', 'RuleText')
			llSendUpdate = dbgetprop(tcView, 'View', 'SendUpdates')
			llShareConn  = dbgetprop(tcView, 'View', 'ShareConnection')
			lnViewType   = dbgetprop(tcView, 'View', 'SourceType')
			lcSQL        = dbgetprop(tcView, 'View', 'SQL')
			lcTables     = dbgetprop(tcView, 'View', 'Tables')
			lnUpdate     = dbgetprop(tcView, 'View', 'UpdateType')
			lnUseMemo    = dbgetprop(tcView, 'View', 'UseMemoSize')
			lnWhereType  = dbgetprop(tcView, 'View', 'WhereType')
		
		* Now recreate the view.
		
			lcRemote = iif(lnViewType = cnVFP_LOCAL_VIEW, '', 'remote ' + ;
				iif(empty(lcConnect), '', 'connection ' + '"' + lcConnect + '"' + ;
				iif(llShareConn, ' share', '')))
			aused(laOpenTables)
			.lErrorOccurred = .F.
			toMeta.cValidateObjectName = tcView
			toMeta.cValidateObjectType = 'View'
		#if version(5) >= 800
			if version(5) >= 800
				lnEngineBehavior = set('EngineBehavior')
				set enginebehavior 70
			endif version(5) >= 800
		#endif
			create sql view (tcView) &lcRemote as &lcSQL
		#if version(5) >= 800
			if version(5) >= 800
				set enginebehavior lnEngineBehavior
			endif version(5) >= 800
		#endif
		
		* Set the previously saved properties.
		
			if not .lErrorOccurred
				dbsetprop(tcView, 'View', 'BatchUpdateCount', lnBatch)
				dbsetprop(tcView, 'View', 'CompareMemo',      llCompare)
				dbsetprop(tcView, 'View', 'FetchAsNeeded',    llFetch)
				dbsetprop(tcView, 'View', 'FetchMemo',        llFetchMemo)
				dbsetprop(tcView, 'View', 'FetchSize',        lnFetch)
				dbsetprop(tcView, 'View', 'MaxRecords',       lnMaxRecs)
				dbsetprop(tcView, 'View', 'Prepared',         llPrepared)
				dbsetprop(tcView, 'View', 'SendUpdates',      llSendUpdate)
				dbsetprop(tcView, 'View', 'UpdateType',       lnUpdate)
				dbsetprop(tcView, 'View', 'UseMemoSize',      lnUseMemo)
				dbsetprop(tcView, 'View', 'WhereType',        lnWhereType)
				if not empty(lcComment)
					dbsetprop(tcView, 'View', 'Comment',        lcComment)
				endif not empty(lcComment)
				if not empty(lcParmList)
					dbsetprop(tcView, 'View', 'ParameterList',  lcParmList)
				endif not empty(lcParmList)
				if not empty(lcRuleExpr)
					dbsetprop(tcView, 'View', 'RuleExpression', lcRuleExpr)
				endif not empty(lcRuleExpr)
				if not empty(lcRuleText)
					dbsetprop(tcView, 'View', 'RuleText',       lcRuleText)
				endif not empty(lcRuleText)
				if not empty(lcTables)
					dbsetprop(tcView, 'View', 'Tables',         lcTables)
				endif not empty(lcTables)
		
		* Set the database properties for the fields.
		
				for lnI = 1 to lnFields
					lcField = laFields[lnI, 1]
					if indbc(lcField, 'Field')
						dbsetprop(lcField, 'Field', 'DataType',  laFields[lnI,  4])
						dbsetprop(lcField, 'Field', 'KeyField',  laFields[lnI, 10])
						dbsetprop(lcField, 'Field', 'Updatable', laFields[lnI, 13])
						if not empty(laFields[lnI,  2])
							dbsetprop(lcField, 'Field', 'Caption', ;
								laFields[lnI,  2])
						endif not empty(laFields[lnI,  2])
						if not empty(laFields[lnI,  3])
							dbsetprop(lcField, 'Field', 'Comment', ;
								laFields[lnI,  3])
						endif not empty(laFields[lnI,  3])
						if not empty(laFields[lnI,  5])
							dbsetprop(lcField, 'Field', 'DefaultValue', ;
								laFields[lnI,  5])
						endif not empty(laFields[lnI,  5])
						if not empty(laFields[lnI,  6])
							dbsetprop(lcField, 'Field', 'DisplayClass', ;
								laFields[lnI,  6])
						endif not empty(laFields[lnI,  6])
						if not empty(laFields[lnI,  7])
							dbsetprop(lcField, 'Field', 'DisplayClassLibrary', ;
								laFields[lnI,  7])
						endif not empty(laFields[lnI,  7])
						if not empty(laFields[lnI,  8])
							dbsetprop(lcField, 'Field', 'Format', ;
								laFields[lnI,  8])
						endif not empty(laFields[lnI,  8])
						if not empty(laFields[lnI,  9])
							dbsetprop(lcField, 'Field', 'InputMask', ;
								laFields[lnI,  9])
						endif not empty(laFields[lnI,  9])
						if not empty(laFields[lnI,  11])
							dbsetprop(lcField, 'Field', 'RuleExpression', ;
								laFields[lnI, 11])
						endif not empty(laFields[lnI,  11])
						if not empty(laFields[lnI,  12])
							dbsetprop(lcField, 'Field', 'RuleText', ;
								laFields[lnI, 12])
						endif not empty(laFields[lnI,  12])
						if not empty(laFields[lnI,  14])
							dbsetprop(lcField, 'Field', 'UpdateName', ;
								laFields[lnI, 14])
						endif not empty(laFields[lnI,  14])
					endif indbc(lcField, 'Field')
				next lnI
		
		* Now validate the view so the meta data is updated properly.
		
				if not tlNoValidate
					wait clear
					toMeta.Validate(set('DATABASE') + '!' + tcView, 'View')
		
		* Call a hooked object's RedefineView method if possible.
		
					if vartype(.oHook) = 'O' and pemstatus(.oHook, 'RedefineView', 5)
						.oHook.RedefineView(tcView, tlNoValidate)
					endif vartype(.oHook) = 'O' ...
				endif not tlNoValidate
			endif not .lErrorOccurred
			.CloseOpenedCursors(@laOpenTables)
			wait clear
		endwith
		
	ENDPROC

	PROCEDURE updateview		&& Updates the properties of the specified view
		lparameters tcView, ;
			toMeta
		local laFields[1], ;
			lnFields, ;
			lnI, ;
			lcField
		with This
		
		* Get a list of fields for the view.
		
			lnFields = toMeta.DBCXGetAllObjects(set('DATABASE') + '!Fields ' + ;
				tcView, @laFields)
		
		* For each field, get database properties from the source field and use them
		* for the view field.
		
			for lnI = 1 to lnFields
				lcField = laFields[lnI]
				.UpdateViewField(tcView, lcField, toMeta)
			next lnI
			wait clear
		endwith
		
	ENDPROC

	PROCEDURE updateviewfield		&& Updates the properties of the specified field in the specified view
		lparameters tcView, ;
			tcField, ;
			toMeta
		local lcSQL, ;
			lcDSource, ;
			lnPos, ;
			lcDBC, ;
			lcSource, ;
			lcAlias, ;
			lnI, ;
			lcChar, ;
			lcDatabase, ;
			llDBC, ;
			laValues[6], ;
			loValues
		
		* Get the source name for the specified view field.
		
		lcSQL     = upper(dbgetprop(tcView, 'View', 'SQL'))
		lcDSource = dbgetprop(tcField, 'Field', 'UpdateName')
		if empty(lcDSource)
			lcSource = justext(tcField)
		else
			lnPos    = at('!', lcDSource)
			lcDBC    = iif(lnPos = 0, '', left(lcDSource, lnPos - 1))
			lcSource = iif(lnPos = 0, lcDSource, substr(lcDSource, lnPos + 1))
		endif empty(lcDSource)
		
		* If no alias is specified in UpdateName, we'll have to figure out which alias
		* the field came from.
		
		if not '.' $ lcSource
			lnPos = atc('.' + lcSource + ',', lcSQL)
			if lnPos > 0
				lcAlias = ''
				for lnI = lnPos - 1 to 1 step -1
					lcChar = substr(lcSQL, lnI, 1)
					if lcChar $ ', '
						exit
					else
						lcAlias = lcChar + lcAlias
					endif lcChar $ ', '
				next lnI
				if empty(lcAlias)
					lcSource = ''
				else
					lcSource = lcAlias + '.' + lcSource
				endif empty(lcAlias)
			else
				lnPos = atc('.' + lcSource + ' ', lcSQL)
				if lnPos > 0
					lcAlias = ''
					for lnI = lnPos - 1 to 1 step -1
						lcChar = substr(lcSQL, lnI, 1)
						if lcChar $ ', '
							exit
						else
							lcAlias = lcChar + lcAlias
						endif lcChar $ ', '
					next lnI
					if empty(lcAlias)
						lcSource = ''
					else
						lcSource = lcAlias + '.' + lcSource
					endif empty(lcAlias)
				else
					lnPos = atc(' AS ' + lcSource, lcSQL)
					if lnPos > 0
						lcSource = ''
						for lnI = lnPos - 1 to 1 step -1
							lcChar = substr(lcSQL, lnI, 1)
							if lcChar $ ', '
								exit
							else
								lcSource = lcChar + lcSource
							endif lcChar $ ', '
						next lnI
					else
						lcSource = ''
					endif lnPos > 0
				endif lnPos > 0
			endif lnPos > 0
		
		* If we now have an aliased source, let's set the field's UpdateName property
		* to it.
		
			if not empty(lcSource)
				dbsetprop(tcField, 'Field', 'UpdateName', lcSource)
			endif not empty(lcSource)
		endif not '.' $ lcSource
		
		* Now set properties for the field based on the source field.
		
		if not empty(lcSource)
			lcDatabase = upper(set('DATABASE'))
			lcDBC      = iif(empty(lcDBC), lcDatabase, lcDBC)
			llDBC      = not upper(lcDBC) == lcDatabase and dbused(lcDBC)
			if llDBC
				set database to (lcDBC)
			endif llDBC
		 	if indbc(lcSource, 'Field')
				laValues[1] = dbgetprop(lcSource, 'Field', 'Caption')
				laValues[2] = dbgetprop(lcSource, 'Field', 'Comment')
				laValues[3] = dbgetprop(lcSource, 'Field', 'DisplayClass')
				laValues[4] = dbgetprop(lcSource, 'Field', 'DisplayClassLibrary')
				laValues[5] = dbgetprop(lcSource, 'Field', 'Format')
				laValues[6] = dbgetprop(lcSource, 'Field', 'InputMask')
				loValues    = toMeta.DBCXGetPropertyObject(lcDBC + '!' + ;
					lcSource, 'Field')
				if llDBC
					set database to (lcDatabase)
				endif llDBC
				if not empty(laValues[1])
					dbsetprop(tcField, 'Field', 'Caption', laValues[1])
				endif not empty(laValues[1])
				if not empty(laValues[2])
					dbsetprop(tcField, 'Field', 'Comment', laValues[2])
				endif not empty(laValues[2])
				if not empty(laValues[3])
					dbsetprop(tcField, 'Field', 'DisplayClass', laValues[3])
				endif not empty(laValues[3])
				if not empty(laValues[4])
					dbsetprop(tcField, 'Field', 'DisplayClassLibrary', laValues[4])
				endif not empty(laValues[4])
				if not empty(laValues[5])
					dbsetprop(tcField, 'Field', 'Format', laValues[5])
				endif not empty(laValues[5])
				if not empty(laValues[6])
					dbsetprop(tcField, 'Field', 'InputMask', laValues[6])
				endif not empty(laValues[6])
				if not isnull(loValues)
					store '' to loValues.PrevName, loValues.RealName
					toMeta.DBCXSetPropertyObject(loValues, lcDatabase + '!' + ;
						tcField, 'Field')
				endif not isnull(loValues)
		 	endif indbc(lcSource, 'Field')
		endif not empty(lcSource)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdterrormessage AS sdtmodaldialog OF "sdtcontrols.vcx" 		&& A modal dialog to display error messages
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="edtMessage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgIcon" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdContinue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDebug" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClipboard" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*p: cchoice		&& The user's choice
		*p: cversion		&& The SDT version number
	*</DefinedPropArrayMethod>

	Caption = "Error"
	cchoice = 		&& The user's choice
	Closable = .F.
	ControlBox = .F.
	cversion = 		&& The SDT version number
	DoCreate = .T.
	Height = 231
	Name = "sdterrormessage"
	Width = 471

	ADD OBJECT 'cmdCancel' AS sdtmessagebutton WITH ;
		Caption = "Cancel", ;
		Left = 100, ;
		Name = "cmdCancel", ;
		Top = 190
		*< END OBJECT: ClassLib="sdtmanagers.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdClipboard' AS sdtcommandbutton WITH ;
		Caption = "Clipboard", ;
		Left = 380, ;
		Name = "cmdClipboard", ;
		Top = 65
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdContinue' AS sdtmessagebutton WITH ;
		Caption = "Continue", ;
		Left = 195, ;
		Name = "cmdContinue", ;
		Top = 190
		*< END OBJECT: ClassLib="sdtmanagers.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdDebug' AS sdtmessagebutton WITH ;
		Caption = "Debug", ;
		Left = 290, ;
		Name = "cmdDebug", ;
		Top = 190
		*< END OBJECT: ClassLib="sdtmanagers.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS sdtcommandbutton WITH ;
		Caption = "Print", ;
		Left = 380, ;
		Name = "cmdPrint", ;
		Top = 30
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'edtMessage' AS sdteditbox WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 160, ;
		Left = 76, ;
		Name = "edtMessage", ;
		ScrollBars = 0, ;
		Top = 15, ;
		Width = 280
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'imgIcon' AS sdtimage WITH ;
		Height = 32, ;
		Left = 5, ;
		Name = "imgIcon", ;
		Picture = ..\..\sfcommon\stop.bmp, ;
		Top = 10, ;
		Width = 32
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="image" />
	
	PROCEDURE Show
		lparameters tnStyle
		?? chr(7)
		
	ENDPROC

	PROCEDURE cmdCancel.Init
		This.Caption = ccCANCEL
		
	ENDPROC

	PROCEDURE cmdClipboard.Click
		_cliptext = 'SDT version: ' + Thisform.cVersion + ccCR + ;
			Thisform.edtMessage.Value
		wait window ccMSG_ERR_ON_CLIPBOARD
		
	ENDPROC

	PROCEDURE cmdContinue.Init
		This.Caption = ccCONTINUE
		
	ENDPROC

	PROCEDURE cmdDebug.Init
		This.Caption = ccDEBUG
		
	ENDPROC

	PROCEDURE cmdPrint.Click
		local lnSelect
		private lcMessage, ;
			lcVersion
		lnSelect = select()
		create cursor TEMP (FIELD1 I)
		append blank
		lcMessage = Thisform.edtMessage.Value
		lcVersion = Thisform.cVersion
		report form ERROR next 1 noconsole to print prompt
		use
		select (lnSelect)
		
	ENDPROC

	PROCEDURE edtMessage.ProgrammaticChange
		* This comment prevents anything from happening when a value is assigned.
		
	ENDPROC

	PROCEDURE edtMessage.When
		return .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdterrormgr AS sdtcustom OF "sdtcontrols.vcx" 		&& An error manager class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*m: diderroroccur		&& An exposed method to return the value of the protected lErrorOccurred.
		*m: errorhandler		&& The ON ERROR handler.
		*m: reseterror		&& An exposed method to reset the values of the protected lErrorOccurred and public aClassError.
		*m: setsuppresserrors		&& An exposed method to set the value of the protected lSuppressErrors.
		*p: ccurrerror		&& The former ON ERROR handler.
		*p: ctitle		&& The default title for the error message dialog.
		*p: cversion		&& The SDT version number
		*p: lerroroccurred		&& Set to .T. when an error occurs.
		*p: lsetonerror		&& .T. to set ON ERROR to point to the ErrorHandler method.
		*p: lsuppresserrors		&& If .T., an error message isn't displayed when an error occurs.
		*a: aclasserror[1,0]		&& An array containing error information; see the ErrorHandler method documentation for the structure of this array.
	*</DefinedPropArrayMethod>

	PROTECTED lerroroccurred,lsuppresserrors
	ccurrerror = 		&& The former ON ERROR handler.
	ctitle = Error		&& The default title for the error message dialog.
	cversion = 		&& The SDT version number
	Height = 18
	Name = "sdterrormgr"
	Width = 17
	
	PROCEDURE Destroy
		*==============================================================================
		* Function:			Destroy
		* Status:			Public
		* Purpose:			Resets the former ON ERROR handler as the object is
		*						destroyed
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	08/03/99
		* Parameters:		None
		* Returns:			.T.
		* Environment in:	if This.lSetOnError is .T., This.cCurrError contains the
		*						former ON ERROR handler
		* Environment out:	if This.lSetOnError is .T., the ON ERROR handler is reset
		*						to the contents of This.cCurrError
		*==============================================================================
		
		local lcError
		with This
			if .lSetOnError
				lcError = .cCurrError
				on error &lcError
			endif .lSetOnError
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE diderroroccur		&& An exposed method to return the value of the protected lErrorOccurred.
		*==============================================================================
		* Function:			DidErrorOccur
		* Status:			Public
		* Purpose:			Determines if an error occurred (an exposed method to
		*						return the value of the protected property
		*						This.lErrorOccurred
		* Author:			Doug Hennig
		* Copyright:		(c) 1995 Stonefield Systems Group Inc.
		* Last revision:	12/10/95
		* Parameters:		None
		* Returns:			.T. if an error occured
		* Environment in:	This.lErrorOccurred is .T. if an error occurred
		* Environment out:	none
		*==============================================================================
		
		return This.lErrorOccurred
		
	ENDPROC

	PROCEDURE errorhandler		&& The ON ERROR handler.
		*==============================================================================
		* Function:			ErrorHandler
		* Status:			Public
		* Purpose:			Handle errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/06/2001
		* Parameters:		tnError  - the error number
		*					tcMethod - the method or function the error occurred in
		*					tnLine   - the line number within tcMethod
		* Returns:			ccMSG_CONTINUE or ccMSG_DEBUG (see DBCXMGR.H and SDT.H
		*						for the definitions of these constants)
		* Environment in:	This.lSuppressError is .T. if no message should be
		*						displayed
		* Environment out:	This.lErrorOccurred is .T.
		*					This.aClassError is filled with error information as
		*						follows:
		*
		*					Column	Information
		*					------	-----------
		*					1 - 7	same as AERROR()
		*					8		method error occurred in
		*					9		line error occurred on
		*					10		code causing error
		*
		*					a dialog of choices may have been displayed to the user
		*						and one of three choices taken:
		*
		*						- Display debugger: brings up the Trace and Debug
		*							windows
		*						- Don't display debugger: returns to the command
		*							following the one that caused the error
		*						- Cancel: issues CLEAR EVENTS and cancels
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lcCurrTalk, ;
			lcReturn, ;
			lnDataSession, ;
			lcLine1, ;
			lcLine2, ;
			lcLine3, ;
			lcLine4, ;
			lnPos, ;
			lcModule, ;
			lcObject, ;
			lcMethod, ;
			lcLine5, ;
			lcLine6, ;
			lcLine7, ;
			lcMessage, ;
			loMessage, ;
			lcChoice
		
		* Ensure TALK is off (it gets set ON by reindex and update, for example).
		
		if set('TALK') = 'ON'
			set talk off
			lcCurrTalk = 'ON'
		else
			lcCurrTalk = 'OFF'
		endif set('TALK') = 'ON'
		
		* Put the error into the aClassError array and set the lErrorOccurred flag.
		
		lcReturn = ccMSG_CONTINUE
		with This
			aerror(.aClassError)
			dimension .aClassError[cnAERR_MAX]
			.aClassError[cnAERR_METHOD] = tcMethod
			.aClassError[cnAERR_LINE]   = tnLine
			.aClassError[cnAERR_SOURCE] = message(1)
			.lErrorOccurred             = .T.
		
		* Display the error if we're not suppressing them.
		
			if not .lSuppressErrors
				if type('_screen.ActiveForm.Name') = 'C'
					_screen.ActiveForm.LockScreen = .F.
				endif type('_screen.ActiveForm.Name') = 'C'
				lcLine1 = ccMSG_ERROR_NUM + ccTAB + ;
					ltrim(str(.aClassError[cnAERR_NUMBER]))
				lcLine2 = ccMSG_MESSAGE + ccTAB + .aClassError[cnAERR_MESSAGE]
				lcLine3 = ccMSG_LINE_NUM + ccTAB + ;
					ltrim(str(.aClassError[cnAERR_LINE]))
				lcLine4 = ccMSG_CODE + ccTAB + .aClassError[cnAERR_SOURCE]
		
		* Figure out the object, method, and module.
		
				lnPos = rat(' ', .aClassError[cnAERR_METHOD])
				if lnPos = 0
					lcModule = ''
					lcObject = .aClassError[cnAERR_METHOD]
				else
					lcModule = substr(.aClassError[cnAERR_METHOD], lnPos + 1)
					lcModule = substr(lcModule, rat('\', lcModule))
					lcObject = left(.aClassError[cnAERR_METHOD], lnPos - 1)
					lcObject = substr(lcObject, at(' ', lcObject) + 1)
				endif lnPos = 0
				lnPos     = rat('.', lcObject)
				lcMethod  = substr(lcObject, lnPos + 1)
				lcObject  = left(lcObject, lnPos - 1)
				lcLine5   = ccMSG_METHOD + ccTAB + lcMethod
				lcLine6   = ccMSG_OBJECT + ccTAB + lcObject
				lcLine7   = iif(empty(lcModule), '', 'Module:  ' + lcModule)
				lcMessage = lcLine1 + ccCRLF + lcLine2 + ccCRLF + lcLine3 + ccCRLF + ;
					iif(empty(lcLine4), '', lcLine4 + ccCRLF) + ;
					iif(empty(lcLine5), '', lcLine5 + ccCRLF) + lcLine6 + ;
					ccCRLF + iif(empty(lcLine7), '', lcLine7 + ccCRLF)
				loMessage = MakeObject('SDTErrorMessage', 'SDTManagers.vcx')
				loMessage.Caption          = .cTitle
				loMessage.cVersion         = .cVersion
				loMessage.edtMessage.Value = lcMessage
				loMessage.Show(1)
				lcChoice = loMessage.cChoice
				do case
		
		* Cancel: remove any WAIT window, issue a CLEAR EVENTS, and then cancel
		
					case lcChoice = ccCANCEL
						wait clear
						clear events
						cancel
		
		* Display the debugger: activate the Trace and Debug windows.
		
					case lcChoice = ccDEBUG
						lcReturn = ccMSG_DEBUG
				endcase
			endif not .lSuppressErrors
		endwith
		
		* Restore TALK.
		
		if lcCurrTalk = 'ON'
			set talk on
		endif lcCurrTalk = 'ON'
		return lcReturn
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Function:			Init
		* Status:			Public
		* Purpose:			Initialize this class
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	05/09/2001
		* Parameters:		tcTitle      - the default title to use for the error
		*						dialog
		*					tlSetOnError - .T. to set ON ERROR
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	if tcTitle was passed, This.cTitle is set to it
		*					if tlSetOnError was passed, This.lSetOnError is set to it
		*					This.lErrorOccurred and This.lSuppressErrors are .F.
		*					if This.lSetOnError is .T., This.cCurrError contains the
		*						former ON ERROR handler and ON ERROR is set to this
		*						class's ErrorHandler method
		*==============================================================================
		
		* Set our message box title if one is passed. Set out lSetOnError property if
		* it's passed.
		
		lparameters tcTitle, ;
			tlSetOnError
		with This
			if vartype(tcTitle) = 'C'
				.cTitle = tcTitle
			endif vartype(tcTitle) = 'C'
			if pcount() = 2
				.lSetOnError = tlSetOnError
			endif pcount() = 2
		
		* If necessary, point the ON ERROR method to our Errorhandler routine. Set
		* flags to default values.
		
			if .lSetOnError
				.cCurrError = on('ERROR')
				on error _screen.SDTController.oError.ErrorHandler(error(), sys(16), ;
					lineno())
			endif .lSetOnError
			.lErrorOccurred  = .F.
			.lSuppressErrors = .F.
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE reseterror		&& An exposed method to reset the values of the protected lErrorOccurred and public aClassError.
		*==============================================================================
		* Function:			ResetError
		* Status:			Public
		* Purpose:			Resets the error flag and array (an exposed method to
		*						handle these protectd properties)
		* Author:			Doug Hennig
		* Copyright:		(c) 1995 Stonefield Systems Group Inc.
		* Last revision:	01/10/97
		* Parameters:		None
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.lErrorOccurred is set to .F.
		*					This.aClassError is redimensioned and blanked
		*==============================================================================
		
		with This
			.lErrorOccurred = .F.
			dimension .aClassError[cnAERR_MAX]
			.aClassError = ''
		endwith
		
	ENDPROC

	PROCEDURE setsuppresserrors		&& An exposed method to set the value of the protected lSuppressErrors.
		*==============================================================================
		* Function:			SetSuppressErrors
		* Status:			Public
		* Purpose:			Sets This.lSuppressErrors and returns its former value (an
		*						exposed method to handle this protected property)
		* Author:			Doug Hennig
		* Copyright:		(c) 1995-2001 Stonefield Systems Group Inc.
		* Last revision:	05/09/2001
		* Parameters:		tlSuppress - .T. to suppress errors or .F. to show them
		* Returns:			the former value of This.lSuppressErrors
		* Environment in:	none
		* Environment out:	This.lSuppressErrors is set as desired as long as the
		*						passed value is logical and not null. Otherwise, it
		*						isn't changed
		*==============================================================================
		
		lparameters tlSuppress
		local llSuppress
		with This
			llSuppress       = .lSuppressErrors
			.lSuppressErrors = iif(vartype(tlSuppress) = 'L', tlSuppress, ;
				.lSuppressErrors)
		endwith
		return llSuppress
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtmessagebutton AS sdtcommandbutton OF "sdtcontrols.vcx" 		&& A button used in SFErrorMessage
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "sdtmessagebutton"
	
	PROCEDURE Click
		with Thisform
			.cChoice = This.Caption
			.Hide()
		endwith
		
	ENDPROC

ENDDEFINE
