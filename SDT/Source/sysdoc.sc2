*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sysdoc.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
#INCLUDE "sdt.h"

DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="1" />

	DataSource = .NULL.
	Height = 0
	Left = 0
	Name = "Dataenvironment"
	Top = 0
	Width = 0

ENDDEFINE

DEFINE CLASS frmsysdoc AS sdtform OF "sdtcontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="boxReports" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="boxOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblSystem" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTables" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkIndexes" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkViews" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkSummary" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkFields" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSysName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPreview" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboTables" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTable" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPutFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkComments" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkCalculated" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAlpha" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: cleanupafterprint		&& Cleans up things after printing is done.
		*m: docprinted		&& Called when a report has finished printing so we can flag that it wasn't cancelled
		*m: getfieldinfo		&& Puts information about fields in the specified array into the fields cursor
		*m: getfields
		*m: getfieldtype		&& Gets the full-text field type.
		*m: getindexes
		*m: getlines
		*m: getsummary
		*m: gettables
		*m: mergeascii
		*m: outputhtml		&& Outputs to an HTML document
		*m: printdoc
		*m: setprint
		*p: cfieldstemplate		&& The HTML template to use for the fields report
		*p: cindexestemplate		&& The HTML template to use for the indexes report
		*p: csummarytemplate		&& The HTML template to use for the summary report
		*p: ctable		&& The table this documentation is for, or blank if it's for all tables.
		*p: ctablestemplate		&& The HTML template to use for the tables report
		*p: cviewstemplate		&& The HTML template to use for the views report
		*p: lcancelprocess		&& .T. if the current process should be canceled.
		*p: lprinted		&& .T. if the current report was printed
		*p: lshowinternational		&& .T. to show codepages and collate sequences.
		*p: ometa		&& A reference to the MetaMgr object.
		*p: osdtform		&& An object reference to the form calling this one.
		*a: acodepage[1,0]
		*a: adatatypes[1,0]		&& An array of data types.
		*a: aindextypes[1,0]
		*a: atables[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Database Documentation"
	cfieldstemplate = 		&& The HTML template to use for the fields report
	cindexestemplate = 		&& The HTML template to use for the indexes report
	csummarytemplate = 		&& The HTML template to use for the summary report
	ctable = 		&& The table this documentation is for, or blank if it's for all tables.
	ctablestemplate = 		&& The HTML template to use for the tables report
	cviewstemplate = 		&& The HTML template to use for the views report
	DoCreate = .T.
	Height = 304
	HelpContextID = 65
	lcancelprocess = .F.		&& .T. if the current process should be canceled.
	lprinted = .F.		&& .T. if the current report was printed
	lshowinternational = .F.		&& .T. to show codepages and collate sequences.
	MaxButton = .F.
	Name = "frmSysDoc"
	omessage = .NULL.
	ometa = .NULL.		&& A reference to the MetaMgr object.
	osdtform = .NULL.		&& An object reference to the form calling this one.
	outility = .NULL.
	Width = 540
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'boxOptions' AS sdtlabelledbox WITH ;
		Height = 185, ;
		Left = 150, ;
		Name = "boxOptions", ;
		TabIndex = 7, ;
		Top = 10, ;
		Width = 380, ;
		ZOrderSet = 2, ;
		lblLabel.Caption = " Options: ", ;
		lblLabel.Name = "lblLabel", ;
		shpBox.Height = 179, ;
		shpBox.Left = 0, ;
		shpBox.Name = "shpBox", ;
		shpBox.Top = 6, ;
		shpBox.Width = 380
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'boxReports' AS sdtlabelledbox WITH ;
		Height = 185, ;
		Left = 10, ;
		Name = "boxReports", ;
		TabIndex = 1, ;
		Top = 10, ;
		Width = 130, ;
		ZOrderSet = 1, ;
		lblLabel.Caption = " Reports: ", ;
		lblLabel.Name = "lblLabel", ;
		shpBox.Height = 179, ;
		shpBox.Name = "shpBox", ;
		shpBox.Width = 130
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'cboTables' AS sdtcombobox WITH ;
		Enabled = .F., ;
		Left = 235, ;
		Name = "cboTables", ;
		RowSource = "Thisform.aTables", ;
		RowSourceType = 5, ;
		Style = 2, ;
		TabIndex = 10, ;
		Top = 80, ;
		Width = 286, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkAlpha' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Print fields in alphabetical order", ;
		Left = 165, ;
		Name = "chkAlpha", ;
		TabIndex = 17, ;
		Top = 165, ;
		ZOrderSet = 19
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkCalculated' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Include calculated fields", ;
		Left = 300, ;
		Name = "chkCalculated", ;
		TabIndex = 16, ;
		Top = 145, ;
		ZOrderSet = 19
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkComments' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Include comments", ;
		Left = 165, ;
		Name = "chkComments", ;
		TabIndex = 15, ;
		Top = 145, ;
		ZOrderSet = 19
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkFields' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Fields", ;
		Left = 30, ;
		Name = "chkFields", ;
		TabIndex = 5, ;
		Top = 115, ;
		Value = .F., ;
		Width = 52, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkFile' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Output to file:", ;
		Left = 165, ;
		Name = "chkFile", ;
		TabIndex = 11, ;
		Top = 118, ;
		Width = 89, ;
		ZOrderSet = 16
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkIndexes' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Indexes", ;
		Left = 30, ;
		Name = "chkIndexes", ;
		TabIndex = 4, ;
		Top = 90, ;
		Value = .F., ;
		Width = 61, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkSummary' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Summary", ;
		Left = 30, ;
		Name = "chkSummary", ;
		TabIndex = 6, ;
		Top = 140, ;
		Value = .F., ;
		Width = 71, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkTables' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Tables", ;
		Left = 30, ;
		Name = "chkTables", ;
		TabIndex = 2, ;
		Top = 40, ;
		Value = .F., ;
		Width = 56, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkViews' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Views", ;
		Left = 30, ;
		Name = "chkViews", ;
		TabIndex = 3, ;
		Top = 65, ;
		Value = .F., ;
		Width = 51, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdExit' AS sdtexitbuttontext WITH ;
		Caption = "Exit", ;
		Left = 273, ;
		Name = "cmdExit", ;
		TabIndex = 22, ;
		Top = 265, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdHelp' AS sdthelpbuttontext WITH ;
		Left = 363, ;
		Name = "cmdHelp", ;
		TabIndex = 23, ;
		Top = 265, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPreview' AS sdtcommandbutton WITH ;
		Caption = "Preview", ;
		Left = 183, ;
		Name = "cmdPreview", ;
		TabIndex = 21, ;
		Top = 265, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS sdtcommandbutton WITH ;
		Caption = "Print", ;
		Left = 93, ;
		Name = "cmdPrint", ;
		TabIndex = 20, ;
		Top = 265, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPutFile' AS sfputfile WITH ;
		cdefault = Thisform.txtFile.Value, ;
		cextensions = 'HTML (*.htm),*.HTM;Text file (*.txt),*.TXT', ;
		cresult = Thisform.txtFile.Value, ;
		Enabled = .F., ;
		Left = 480, ;
		lusecommondialog = .T., ;
		Name = "cmdPutFile", ;
		TabIndex = 13, ;
		Top = 115, ;
		ZOrderSet = 18
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lblSystem' AS sdtlabel WITH ;
		Caption = "System Name", ;
		Left = 12, ;
		Name = "lblSystem", ;
		TabIndex = 18, ;
		Top = 205, ;
		Width = 80, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblTable' AS sdtlabel WITH ;
		Caption = "Table/view:", ;
		Left = 170, ;
		Name = "lblTable", ;
		TabIndex = 9, ;
		Top = 84, ;
		Width = 63, ;
		ZOrderSet = 14
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'opgOptions' AS sdtoptiongroup WITH ;
		AutoSize = .F., ;
		BorderStyle = 0, ;
		ButtonCount = 4, ;
		Height = 45, ;
		Left = 160, ;
		Name = "opgOptions", ;
		TabIndex = 8, ;
		Top = 25, ;
		Width = 335, ;
		OPTION1.AutoSize = .T., ;
		OPTION1.Caption = "Select individual tables and views", ;
		OPTION1.Left = 5, ;
		OPTION1.Name = "OPTION1", ;
		OPTION1.Top = 5, ;
		OPTION2.AutoSize = .T., ;
		OPTION2.Caption = "Print all tables and views", ;
		OPTION2.Left = 5, ;
		OPTION2.Name = "OPTION2", ;
		OPTION2.Top = 24, ;
		Option3.AutoSize = .T., ;
		Option3.Caption = "Print all tables", ;
		Option3.Height = 17, ;
		Option3.Left = 230, ;
		Option3.Name = "Option3", ;
		Option3.Top = 5, ;
		Option3.Width = 96, ;
		Option4.AutoSize = .T., ;
		Option4.Caption = "Print all views", ;
		Option4.Height = 17, ;
		Option4.Left = 230, ;
		Option4.Name = "Option4", ;
		Option4.Top = 25, ;
		Option4.Width = 93
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtFile' AS sdttextbox WITH ;
		Enabled = .F., ;
		Left = 265, ;
		Name = "txtFile", ;
		TabIndex = 12, ;
		Top = 115, ;
		Width = 211, ;
		ZOrderSet = 17
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtSysName' AS sdttextbox WITH ;
		Format = "K", ;
		Left = 12, ;
		Name = "txtSysName", ;
		TabIndex = 19, ;
		Top = 225, ;
		Width = 516, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />
	
	PROCEDURE cleanupafterprint		&& Cleans up things after printing is done.
		lparameters tcCurrCollate, ;
			tcCurrEsc, ;
			tcCurrOnEsc, ;
			tcCurrPrinter
		
		* Cleanup before returning.
		
		set collate to tcCurrCollate
		if tcCurrEsc = 'OFF'
			set escape off
		endif tcCurrEsc = 'OFF'
		on escape &tcCurrOnEsc
		if not empty(tcCurrPrinter)
			set printer to name (tcCurrPrinter)
		endif not empty(tcCurrPrinter)
		wait clear
		
	ENDPROC

	PROCEDURE docprinted		&& Called when a report has finished printing so we can flag that it wasn't cancelled
		This.lPrinted = .T.
		
	ENDPROC

	PROCEDURE getfieldinfo		&& Puts information about fields in the specified array into the fields cursor
		lparameters taFields, ;
			tcFieldType, ;
			tcTable, ;
			tcTableType, ;
			tcCursor, ;
			tcDBC
		external array taFields
		local lcCoreMeta, ;
			lcSDTMeta, ;
			lcTable, ;
			lnFields, ;
			lcObjectType, ;
			lnI, ;
			lcAField, ;
			lcField, ;
			lcFieldNum, ;
			lcType, ;
			llBinary, ;
			lnStepValue, ;
			lnSize, ;
			lnDecimals, ;
			llNull, ;
			lcExpr, ;
			lcCaption, ;
			lcComments, ;
			lcInputMask, ;
			lcFormat, ;
			lcDefault, ;
			lcRule, ;
			lcRuleText, ;
			lcClass, ;
			lcLibrary, ;
			llKey, ;
			llUpdate, ;
			lcUpdate, ;
			lcUser, ;
			lcProp, ;
			lcUserProp, ;
			lcMetaAlias, ;
			luValue, ;
			lcPrompt, ;
			lcValues
		with This
		
		* Determine which meta data tables to use.
		
			if tcTable = ccLIBRARY_TABLE
				lcCoreMeta = 'LIBCOREMETA'
				lcSDTMeta  = 'LIBSDTMETA'
				lcTable    = ccLIBRARY
			else
				lcCoreMeta = 'COREMETA'
				lcSDTMeta  = 'SDTMETA'
				lcTable    = tcTable
			endif tcTable = ccLIBRARY_TABLE
		
		* Pick up each field for the table and add to the FIELDS cursor.
		
			lnFields    = iif(empty(taFields[1]), 0, alen(taFields))
			lcFieldType = upper(left(tcFieldType, 1))
			for lnI = 1 to lnFields
				if plStopped
					exit
				endif plStopped
				lcAField   = taFields[lnI]
				lcField    = substr(lcAField, at('.', lcAField) + 1)
				lcFieldNum = str(lnI, 4)
				= seek(upper(padr(tcDBC, fsize('DBCNAME', lcSDTMeta)) + ;
					lcFieldType + padr(lcAField, fsize('OBJECTNAME', lcSDTMeta))), ;
					lcSDTMeta, 'OBJECTNAME')
				= seek(upper(padr(tcDBC, fsize('CDBCNAME', lcCoreMeta)) + ;
					lcFieldType + padr(lcAField, fsize('COBJECTNAM', lcCoreMeta))), ;
					lcCoreMeta, 'OBJECTNAME')
				lcType      = evaluate(lcCoreMeta + '.cType')
				llBinary    = evaluate(lcCoreMeta + '.lBinary')
				lnStepValue = evaluate(lcCoreMeta + '.nStepValue')
				lcType      = .GetFieldType(lcType, llBinary, lnStepValue)
				lnSize      = evaluate(lcCoreMeta + '.nSize')
				lnDecimals  = evaluate(lcCoreMeta + '.nDecimals')
				llNull      = evaluate(lcCoreMeta + '.lNull')
				lcExpr      = ''
		
		* Get the DBC properties if this is a table, or the equivalent for the Field
		* Repository and free tables.
		
				if tcTable = ccLIBRARY_TABLE or tcTableType = 'F' or tcFieldType = 'U'
					lcCaption   = alltrim(evaluate(lcCoreMeta + '.cCaption'))
					lcComments  = alltrim(evaluate(lcCoreMeta + '.mComment'))
					lcInputMask = alltrim(evaluate(lcCoreMeta + '.mInputMask'))
					lcFormat    = alltrim(evaluate(lcCoreMeta + '.mFormat'))
					if tcTable = ccLIBRARY_TABLE
						lcDefault  = alltrim(evaluate(lcSDTMeta  + '.DefValue'))
						lcRule     = alltrim(evaluate(lcSDTMeta  + '.Valid'))
						lcRuleText = alltrim(evaluate(lcSDTMeta  + '.Error'))
						lcClass    = alltrim(evaluate(lcSDTMeta  + '.AutoClass'))
						lcLibrary  = alltrim(evaluate(lcSDTMeta  + '.AutoLib'))
					else
						store '' to lcDefault, lcRule, lcRuleText, lcClass, lcLibrary
					endif tcTable = ccLIBRARY_TABLE
					if tcFieldType = 'U'
						lcExpr     = alltrim(evaluate(lcCoreMeta  + '.mExpr'))
						lcFieldNum = '*'
					endif tcFieldType = 'U'
				else
					lcCaption   = dbgetprop(lcAField, 'Field', 'Caption')
					lcComments  = dbgetprop(lcAField, 'Field', 'Comment')
					lcInputMask = dbgetprop(lcAField, 'Field', 'InputMask')
					lcFormat    = dbgetprop(lcAField, 'Field', 'Format')
					lcDefault   = dbgetprop(lcAField, 'Field', 'DefaultValue')
					lcRule      = dbgetprop(lcAField, 'Field', 'RuleExpression')
					lcRuleText  = dbgetprop(lcAField, 'Field', 'RuleText')
					lcClass     = dbgetprop(lcAField, 'Field', 'DisplayClass')
					lcLibrary   = dbgetprop(lcAField, 'Field', 'DisplayClassLibrary')
					if tcTableType = 'V'
						llKey    = dbgetprop(lcAField, 'Field', 'KeyField')
						llUpdate = dbgetprop(lcAField, 'Field', 'Updatable')
						lcUpdate = dbgetprop(lcAField, 'Field', 'UpdateName')
					endif tcTableType = 'V'
				endif tcTable = ccLIBRARY_TABLE ...
		
		* Pick up the user-defined properties.
		
				lcUser      = ''
				lcProp      = ''
				lcUserProp  = ''
				lcMetaAlias = iif(tcTable = ccLIBRARY_TABLE, 'LIB', '') + ;
					.oMeta.oSDTMgr.GetMetaAlias()
				select (lcMetaAlias)
				scan for lcFieldType $ OBJECTTYPE and not plStopped
					luValue = evaluate(lcSDTMeta + '.' + trim(FIELD_NAME))
					if not isnull(luValue) and not empty(luValue)
						luValue = iif(vartype(luValue) = 'C', alltrim(luValue), ;
							luValue)
						lcProp  = iif(empty(lcProp), '', lcProp + ccCR) + ;
							trim(PROPERTY) + ':'
						lcUser  = iif(empty(lcUser), '', lcUser + ccCR) + ;
							transform(luValue, '')
						lcUserProp = iif(empty(lcUserProp), '', lcUserProp + ccCR) + ;
							trim(PROPERTY) + ':' + ccTAB + transform(luValue, '')
					endif not isnull(luValue) ...
				endscan for lcFieldType $ OBJECTTYPE ...
		
		* Populate lcPrompt and lcValues with the appropriate row heading and value for
		* each property.
		
				lcPrompt = iif(empty(lcCaption), '', ccREP_CAPTION)
				lcValues = iif(empty(lcCaption), '', lcCaption)
				if tcTableType = 'V'
					lcPrompt = iif(empty(lcPrompt), '', lcPrompt + ;
						.GetLines(lcPrompt, lcValues)) + ccREP_UPDATENAME
					lcValues = iif(empty(lcValues), '', lcValues + ccCR) + lcUpdate
				endif tcTableType = 'V'
				if tcFieldType = 'U'
					lcPrompt = iif(empty(lcExpr), lcPrompt, ;
						iif(empty(lcPrompt), '', lcPrompt + ;
						.GetLines(lcPrompt, lcValues)) + ccREP_CALCULATION)
					lcValues = iif(empty(lcExpr), lcValues, ;
						iif(empty(lcValues), '', lcValues + ccCR) + lcExpr)
				endif tcFieldType = 'U'
				lcPrompt = iif(empty(lcComments), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_COMMENTS)
				lcValues = iif(empty(lcComments), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcComments)
				lcPrompt = iif(empty(lcInputMask), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_INPUTMASK)
				lcValues = iif(empty(lcInputMask), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcInputMask)
				lcPrompt = iif(empty(lcFormat), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_FORMAT)
				lcValues = iif(empty(lcFormat), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcFormat)
				lcPrompt = iif(empty(lcDefault), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_DEFAULT)
				lcValues = iif(empty(lcDefault), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcDefault)
				lcPrompt = iif(empty(lcRule), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_VALID_RULE)
				lcValues = iif(empty(lcRule), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcRule)
				lcPrompt = iif(empty(lcRuleText), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_VALID_TEXT)
				lcValues = iif(empty(lcRuleText), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcRuleText)
				lcPrompt = iif(empty(lcClass), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_DISPLAYCLASS)
				lcValues = iif(empty(lcClass), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcClass)
				lcPrompt = iif(empty(lcLibrary), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_CLASSLIBRARY)
				lcValues = iif(empty(lcLibrary), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcLibrary)
				lcPrompt = iif(empty(lcProp), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + lcProp)
				lcValues = iif(empty(lcUser), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcUser)
		
		* Add a new record to the cursor.
		
				lcPrompt = iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues))
				alines(laValues, lcValues)
				for lnJ = 1 to alines(laPrompt, lcPrompt)
					insert into (tcCursor) values ;
						(tcDBC, ;
						tcDBC + iif(empty(tcDBC), '', '!') + lcTable, ;
						tcTableType, ;
						lcFieldNum, ;
						lcField, ;
						lcType, ;
						lnSize, ;
						lnDecimals, ;
						lnStepValue, ;
						llNull, ;
						llKey, ;
						llUpdate, ;
						laPrompt[lnJ], ;
						laValues[lnJ], ;
						not empty(lcExpr))
		
		* Reset lnSize and llNull so the total is calculated correctly later.
		
					lnSize = 0
					llNull = .F.
				next lnJ
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE getfields
		lparameters tcTable, ;
			tcType, ;
			tcCursor
		local lcDBC, ;
			lcTable, ;
			lnFields, ;
			laFields[1]
		
		* If this is the Field Repository, get a list of fields defined in it.
		
		with This
			if tcTable = ccLIBRARY
				select LIBCOREMETA
				lcDBC    = ''
				lcTable  = ccLIBRARY_TABLE
				lnFields = 0
				laFields = ''
				scan for cObjectNam = ccLIBRARY_TABLE and not plStopped
					lnFields = lnFields + 1
					dimension laFields[lnFields]
					laFields[lnFields] = trim(cObjectNam)
				endscan for cObjectNam = ccLIBRARY_TABLE ...
		
		* Get a list of fields in the table.
		
			else
				lcDBC      = iif(tcType = 'F', '', .oMeta.GetDatabase(tcTable))
				lcTable    = .oMeta.StripDatabase(tcTable)
				lnFields   = .oMeta.oSDTMgr.DBCXGetAllObjects(lcDBC + '!Field ' + ;
					lcTable, @laFields)
				if not empty(lcDBC)
					set database to (lcDBC)
				endif not empty(lcDBC)
			endif tcTable = ccLIBRARY
		
		* Populate the fields cursor.
		
			.GetFieldInfo(@laFields, 'Field', lcTable, tcType, tcCursor, lcDBC)
		
		* Now get calculated fields for the table.
		
			if tcTable <> ccLIBRARY and .chkCalculated.Value
				lnFields = .oMeta.oSDTMgr.DBCXGetAllObjects(lcDBC + '!User ' + ;
					lcTable, @laFields)
				if lnFields > 0
					.GetFieldInfo(@laFields, 'User', lcTable, tcType, tcCursor, lcDBC)
				endif lnFields > 0
			endif tcTable <> ccLIBRARY ...
		endwith
		
	ENDPROC

	PROCEDURE getfieldtype		&& Gets the full-text field type.
		lparameters tcType, ;
			tlBinary, ;
			tnStepValue
		local lcType, ;
			laTypes[1], ;
			lnType
		with This
			do case
				case tcType = 'C' and tlBinary
					lcType = 'Character (Binary)'
				case tcType = 'M' and tlBinary
					lcType = 'Memo (Binary)'
				case tnStepValue <> 0
					lcType = 'Integer (Auto-Inc)'
				otherwise
					acopy(.aDataTypes, laTypes)
					lnType = .oUtility.ArrayScan(@laTypes, tcType, 2)
					lcType = iif(lnType > 0, .aDataTypes[lnType, 1], tcType)
			endcase
		endwith
		return lcType
		
	ENDPROC

	PROCEDURE getindexes
		lparameters tcTable, ;
			tcType, ;
			tcCursor
		local lcDBC, ;
			lcTable, ;
			laIndexes[1], ;
			lnIndexes, ;
			lnI, ;
			lcAindex, ;
			lcIndex, ;
			lcType, ;
			lcExpression, ;
			llDescending, ;
			lcFilter, ;
			llSelect, ;
			lcCaption, ;
			lcCollate, ;
			lcComments, ;
			lcUser, ;
			lcProp, ;
			lcUserProp, ;
			lcMetaAlias, ;
			luValue, ;
			lcPrompt, ;
			lcValues
		with This
		
		* Get an array of indexes for the table.
		
			lcDBC     = iif(tcType = 'F', '', .oMeta.GetDatabase(tcTable))
			lcTable   = .oMeta.StripDatabase(tcTable)
			lnIndexes = .oMeta.oSDTMgr.DBCXGetAllObjects(lcDBC + '!Index ' + ;
				lcTable, @laIndexes)
		
		* Pick up each index for the table and add to the INDEXES cursor.
		
			for lnI = 1 to lnIndexes
				if plStopped
					exit
				endif plStopped
				lcAIndex = laIndexes[lnI]
				lcIndex  = strtran(lcAIndex, lcTable + '.')
				= seek(upper(padr(lcDBC, fsize('DBCNAME', 'SDTMETA')) + 'I' + ;
					padr(lcAIndex, fsize('OBJECTNAME', 'SDTMETA'))), 'SDTMETA', ;
					'OBJECTNAME')
				= seek(upper(padr(lcDBC, fsize('CDBCNAME', 'COREMETA')) + 'I' + ;
					padr(lcAIndex, fsize('COBJECTNAM', 'COREMETA'))), 'COREMETA', ;
					'OBJECTNAME')
				do case
					case COREMETA.CTAGTYPE = 'P'
						lcType = .aIndexTypes[1]
					case COREMETA.CTAGTYPE = 'C'
						lcType = .aIndexTypes[2]
					case COREMETA.CTAGTYPE = 'U'
						lcType = .aIndexTypes[4]
					case COREMETA.CTAGTYPE = 'B'
						lcType = .aIndexTypes[5]
					otherwise
						lcType = .aIndexTypes[3]
				endcase
				lcExpression = COREMETA.mTagExpr
				llDescending = not COREMETA.lAscending
				lcFilter     = COREMETA.mTagFilter
				llSelect     = SDTMETA.Select
				lcCaption    = alltrim(COREMETA.cCaption)
				lcCollate    = alltrim(COREMETA.cCollate)
				lcComments   = alltrim(COREMETA.mComment)
		
		* Pick up the user-defined properties.
		
				lcUser      = ''
				lcProp      = ''
				lcUserProp  = ''
				lcMetaAlias = .oMeta.oSDTMgr.GetMetaAlias()
				select (lcMetaAlias)
				scan for 'I' $ OBJECTTYPE and not plStopped
					luValue = evaluate('SDTMETA.' + trim(FIELD_NAME))
					if not isnull(luValue) and not empty(luValue)
						luValue = iif(vartype(luValue) = 'C', alltrim(luValue), ;
							luValue)
						lcProp  = iif(empty(lcProp), '', lcProp + ccCR) + ;
							trim(PROPERTY) + ':'
						lcUser  = iif(empty(lcUser), '', lcUser + ccCR) + ;
							transform(luValue, '')
						lcUserProp = iif(empty(lcUserProp), '', lcUserProp + ccCR) + ;
							trim(PROPERTY) + ':' + ccTAB + transform(luValue, '')
					endif not isnull(luValue) ...
				endscan for 'I' $ OBJECTTYPE ...
		
		* Populate lcPrompt and lcValues with the appropriate row heading and value for
		* each property.
		
				lcPrompt = ccREP_EXPRESSION
				lcValues = lcExpression
				lcPrompt = iif(empty(lcFilter), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + .GetLines(lcPrompt, lcValues)) + ;
					ccREP_FILTER)
				lcValues = iif(empty(lcFilter), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcFilter)
				lcPrompt = iif(empty(lcComments), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + .GetLines(lcPrompt, lcValues)) + ;
					ccREP_COMMENTS)
				lcValues = iif(empty(lcComments), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcComments)
				lcPrompt = iif(empty(lcCollate) or not .lShowInternational, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + .GetLines(lcPrompt, lcValues)) + ;
					ccREP_COLLATE)
				lcValues = iif(empty(lcCollate) or not .lShowInternational, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcCollate)
				lcPrompt = iif(empty(lcProp), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + .GetLines(lcPrompt, lcValues)) + ;
					lcProp)
				lcValues = iif(empty(lcUser), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcUser)
		
		* Add a new record to the cursor.
		
				lcPrompt = iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues))
				alines(laValues, lcValues)
				for lnJ = 1 to alines(laPrompt, lcPrompt)
				insert into (tcCursor) values ;
					(lcDBC, ;
					lcDBC + iif(empty(lcDBC), '', '!') + lcTable, ;
					lcIndex, ;
					lcCaption, ;
					lcType, ;
					llDescending, ;
					llSelect, ;
					laPrompt[lnJ], ;
					laValues[lnJ])
				next lnJ
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE getlines
		lparameters tcText1, ;
			tcText2
		local laText2[1], ;
			laText1[1], ;
			lcResult
		lcResult = replicate(ccCR, alines(laText2, tcText2) - ;
			alines(laText1, tcText1) + 1)
		return lcResult
		
	ENDPROC

	PROCEDURE getsummary
		lparameters tcTable, ;
			tcType, ;
			tcCursor
		local lcDBC, ;
			lcTable, ;
			laFields[1], ;
			lnFields, ;
			lnI, ;
			lcAField, ;
			lcField, ;
			lcType, ;
			lnSize, ;
			lnDecimals, ;
			llNull, ;
			lcCaption, ;
			lcComment, ;
			laIndexes[1], ;
			lnIndexes, ;
			lcAIndex, ;
			lcIndex, ;
			lcExpression, ;
			llDescending
		
		* Get an array of fields for the table.
		
		with This
			lcDBC    = iif(tcType = 'F', '', .oMeta.GetDatabase(tcTable))
			lcTable  = .oMeta.StripDatabase(tcTable)
			lnFields = .oMeta.oSDTMgr.DBCXGetAllObjects(lcDBC + '!Field ' + ;
				lcTable, @laFields)
			if not empty(lcDBC)
				set database to (lcDBC)
			endif not empty(lcDBC)
			for lnI = 1 to lnFields
				if plStopped
					exit
				endif plStopped
				lcAField = laFields[lnI]
				lcField  = substr(lcAField, at('.', lcAField) + 1)
				= seek(upper(padr(lcDBC, fsize('CDBCNAME', 'COREMETA')) + 'F' + ;
					padr(lcAField, fsize('COBJECTNAM', 'COREMETA'))), 'COREMETA', ;
					'OBJECTNAME')
				lcType     = .GetFieldType(CoreMeta.cType, CoreMeta.lBinary, ;
					CoreMeta.nStepValue)
				lnSize     = CoreMeta.nSize
				lnDecimals = CoreMeta.nDecimals
				llNull     = CoreMeta.lNull
				lcCaption  = iif(tcType = 'F', trim(CoreMeta.cCaption), ;
					dbgetprop(lcAField, 'Field', 'Caption'))
				if .chkComments.Value
					lcComment  = iif(tcType = 'F', trim(CoreMeta.mComment), ;
						dbgetprop(lcAField, 'Field', 'Comment'))
				else
					lcComment = ''
				endif .chkComments.Value
				insert into (tcCursor) ;
						(DATABASE, ;
						TABLE, ;
						NAME, ;
						FIELD_NUM, ;
						TYPE, ;
						RTYPE, ;
						FIELD_LEN, ;
						FIELD_DEC, ;
						DESCEND, ;
						EXPRESSION, ;
						COMMENT, ;
						TABLETYPE) ;
					values ;
						(lcDBC, ;
						tcTable, ;
						lcField, ;
						lnI, ;
						lcType, ;
						'F', ;
						lnSize, ;
						lnDecimals, ;
						transform(llNull, 'Y'), ;
						lcCaption, ;
						lcComment, ;
						tcType)
			next lnI
		
		* Get an array of indexes for the table.
		
			lnIndexes = .oMeta.oSDTMgr.DBCXGetAllObjects(lcDBC + '!Index ' + ;
				lcTable, @laIndexes)
			for lnI = 1 to lnIndexes
				if plStopped
					exit
				endif plStopped
				lcAIndex = laIndexes[lnI]
				lcIndex  = substr(lcAIndex, at('.', lcAIndex) + 1)
				= seek(upper(padr(lcDBC, fsize('CDBCNAME', 'COREMETA')) + 'I' + ;
					padr(lcAIndex, fsize('COBJECTNAM', 'COREMETA'))), 'COREMETA', ;
					'OBJECTNAME')
				do case
					case CoreMeta.cTagType = 'P'
						lcType = .aIndexTypes[1]
					case CoreMeta.cTagType = 'C'
						lcType = .aIndexTypes[2]
					case CoreMeta.cTagType = 'U'
						lcType = .aIndexTypes[4]
					case CoreMeta.cTagType = 'B'
						lcType = .aIndexTypes[5]
					otherwise
						lcType = .aIndexTypes[3]
				endcase
				lcExpression = CoreMeta.mTagExpr
				llDescending = not CoreMeta.lAscending
				lcComment    = iif(.chkComments.Value, trim(CoreMeta.mComment), '')
				insert into (tcCursor) ;
						(DATABASE, ;
						TABLE, ;
						NAME, ;
						TYPE, ;
						RTYPE, ;
						EXPRESSION, ;
						DESCEND, ;
						COMMENT, ;
						TABLETYPE) ;
					values ;
						(lcDBC, ;
						tcTable, ;
						lcIndex, ;
						lcType, ;
						'I', ;
						lcExpression, ;
						transform(llDescending, 'Y'), ;
						lcComment, ;
						tcType)
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE gettables
		lparameters tcTable, ;
			tcType, ;
			tcCursor
		local laCodePage[1], ;
			lcDBC, ;
			lcTable, ;
			lcType, ;
			llAuto, ;
			llUpdate, ;
			llNoUpdate, ;
			lcCaption, ;
			lnCodePage, ;
			lcCodePage, ;
			lcUser, ;
			lcProp, ;
			lcUserProp, ;
			lcMetaAlias, ;
			luValue, ;
			lcComments, ;
			lcRule, ;
			lcRuleText, ;
			lcViewType, ;
			lcPath, ;
			lcDelTrigger, ;
			lcInsTrigger, ;
			lcUpdTrigger, ;
			lcPrimary, ;
			lnBatch, ;
			llCompare, ;
			lcConnect, ;
			llFetch, ;
			llFetchMemo, ;
			lnFetch, ;
			lnMaxRecs, ;
			llOffline, ;
			lcParmList, ;
			llPrepared, ;
			llSendUpdate, ;
			llShareConn, ;
			lcViewType, ;
			lcSQL, ;
			lcTables, ;
			lnUpdate, ;
			lnUseMemo, ;
			lnWhereType, ;
			lcPrompt, ;
			lcValues, ;
			laValues[1], ;
			laPrompt[1], ;
			lnI
		with This
		
		* Pick up information about the table and add to the cursor.
		
			acopy(.aCodePage, laCodePage)
			lcDBC   = iif(tcType = 'Free', '', .oMeta.GetDatabase(tcTable))
			lcTable = .oMeta.StripDatabase(tcTable)
			lcType  = left(tcType, 1)
			lcType  = iif(lcType = 'F', 'T', lcType)
			if not empty(lcDBC)
				set database to (lcDBC)
			endif not empty(lcDBC)
		
		* Find the table in the meta data.
		
			= seek(upper(padr(lcDBC, fsize('DBCNAME', 'SDTMETA')) + lcType + ;
				padr(lcTable, fsize('OBJECTNAME', 'SDTMETA'))), 'SDTMETA', ;
				'OBJECTNAME')
			= seek(upper(padr(lcDBC, fsize('CDBCNAME', 'COREMETA')) + lcType + ;
				padr(lcTable, fsize('COBJECTNAM', 'COREMETA'))), 'COREMETA', ;
				'OBJECTNAME')
			llAuto     = SDTMeta.AutoOpen
			llUpdate   = SDTMeta.CanUpdate
			llNoUpdate = SDTMeta.NoUpdate
			lcCaption  = alltrim(CoreMeta.cCaption)
			lnCodePage = .oUtility.ArrayScan(@laCodePage, CoreMeta.nCodePage, 2)
			lcCodePage = iif(lnCodePage > 0, .aCodePage[lnCodePage, 1], '')
		
		* Pick up the user-defined properties.
		
			lcUser      = ''
			lcProp      = ''
			lcUserProp  = ''
			lcMetaAlias = .oMeta.oSDTMgr.GetMetaAlias()
			select (lcMetaAlias)
			scan for lcType $ OBJECTTYPE and not plStopped
				luValue = evaluate('SDTMETA.' + trim(FIELD_NAME))
				if not isnull(luValue) and not empty(luValue)
					luValue = iif(vartype(luValue) = 'C', alltrim(luValue), luValue)
					lcProp  = iif(empty(lcProp), '', lcProp + ccCR) + ;
						trim(PROPERTY) + ':'
					lcUser  = iif(empty(lcUser), '', lcUser + ccCR) + ;
						transform(luValue, '')
					lcUserProp = iif(empty(lcUserProp), '', lcUserProp + ccCR) + ;
						trim(PROPERTY) + ':' + ccTAB + transform(luValue, '')
				endif not isnull(luValue) ...
			endscan for lcType $ OBJECTTYPE ...
		
		* Get the DBC properties.
		
			if tcType <> 'Free'
				lcComments = dbgetprop(lcTable, tcType, 'Comment')
				lcComments = iif(right(lcComments, 1) = ccCR, ;
					left(lcComments, len(lcComments) - 1), lcComments)
				lcRule     = dbgetprop(lcTable, tcType, 'RuleExpression')
				lcRuleText = dbgetprop(lcTable, tcType, 'RuleText')
				lcViewType = ''
				if tcType = 'Table'
					lcPath       = fullpath(dbgetprop(lcTable, tcType, 'Path'), dbc())
					lcDelTrigger = dbgetprop(lcTable, tcType, 'DeleteTrigger')
					lcInsTrigger = dbgetprop(lcTable, tcType, 'InsertTrigger')
					lcUpdTrigger = dbgetprop(lcTable, tcType, 'UpdateTrigger')
					lcPrimary    = dbgetprop(lcTable, tcType, 'PrimaryKey')
				else
					lcComments   = iif(left(lcComments, 2) = '* ', substr(lcComments, 3), ;
						lcComments)
					lnBatch      = dbgetprop(lcTable, tcType, 'BatchUpdateCount')
					llCompare    = dbgetprop(lcTable, tcType, 'CompareMemo')
					lcConnect    = dbgetprop(lcTable, tcType, 'ConnectName')
					llFetch      = dbgetprop(lcTable, tcType, 'FetchAsNeeded')
					llFetchMemo  = dbgetprop(lcTable, tcType, 'FetchMemo')
					lnFetch      = dbgetprop(lcTable, tcType, 'FetchSize')
					lnMaxRecs    = dbgetprop(lcTable, tcType, 'MaxRecords')
					llOffline    = dbgetprop(lcTable, tcType, 'Offline')
					lcParmList   = dbgetprop(lcTable, tcType, 'ParameterList')
					llPrepared   = dbgetprop(lcTable, tcType, 'Prepared')
					llSendUpdate = dbgetprop(lcTable, tcType, 'SendUpdates')
					llShareConn  = dbgetprop(lcTable, tcType, 'ShareConnection')
					lcViewType   = iif(dbgetprop(lcTable, tcType, ;
						'SourceType') = cnVFP_LOCAL_VIEW, ccLOCAL, ccREMOTE)
					lcSQL        = dbgetprop(lcTable, tcType, 'SQL')
					lcTables     = dbgetprop(lcTable, tcType, 'Tables')
					lnUpdate     = dbgetprop(lcTable, tcType, 'UpdateType')
					lnUseMemo    = dbgetprop(lcTable, tcType, 'UseMemoSize')
					lnWhereType  = dbgetprop(lcTable, tcType, 'WhereType')
				endif tcType = 'Table'
			else
				lcComments = CoreMeta.mComment
				lcComments = iif(right(lcComments, 1) = ccCR, ;
					left(lcComments, len(lcComments) - 1), lcComments)
				lcPath     = fullpath(CoreMeta.mPath, dbf('CoreMeta'))
				store '' to lcViewType, lcDelTrigger, lcInsTrigger, lcUpdTrigger, ;
					lcPrimary
			endif tcType <> 'Free'
		
		* Populate lcPrompt and lcValues with the appropriate row heading and value for
		* each property.
		
			store '' to lcPrompt, lcValues
			if tcType <> 'View'
				lcPrompt = lcPrompt + ccREP_PATH + ccCR
				lcValues = lcValues + lcPath + ccCR
			endif tcType <> 'View'
			lcPrompt = iif(empty(lcCaption), lcPrompt, lcPrompt + ccREP_CAPTION)
			lcValues = iif(empty(lcCaption), lcValues, lcValues + lcCaption)
			lcPrompt = iif(empty(lcComments), lcPrompt, ;
				iif(empty(lcPrompt), '', lcPrompt + .GetLines(lcPrompt, lcValues)) + ;
				ccREP_COMMENTS)
			lcValues = iif(empty(lcComments), lcValues, ;
				iif(empty(lcValues), '', lcValues + ccCR) + lcComments)
			lcPrompt = iif(empty(lcRule), lcPrompt, ;
				iif(empty(lcPrompt), '', lcPrompt + .GetLines(lcPrompt, lcValues)) + ;
				ccREP_VALID_RULE)
			lcValues = iif(empty(lcRule), lcValues, ;
				iif(empty(lcValues), '', lcValues + ccCR) + lcRule)
			lcPrompt = iif(empty(lcRuleText), lcPrompt, ;
				iif(empty(lcPrompt), '', lcPrompt + .GetLines(lcPrompt, lcValues)) + ;
				ccREP_VALID_TEXT)
			lcValues = iif(empty(lcRuleText), lcValues, ;
				iif(empty(lcValues), '', lcValues + ccCR) + lcRuleText)
			if tcType <> 'View'
				lcPrompt = iif(empty(lcInsTrigger), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_INS_TRIGGER)
				lcValues = iif(empty(lcInsTrigger), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcInsTrigger)
				lcPrompt = iif(empty(lcUpdTrigger), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_UPD_TRIGGER)
				lcValues = iif(empty(lcUpdTrigger), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcUpdTrigger)
				lcPrompt = iif(empty(lcDelTrigger), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_DEL_TRIGGER)
				lcValues = iif(empty(lcDelTrigger), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcDelTrigger)
				lcPrompt = iif(empty(lcPrimary), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_PRIMARY_KEY)
				lcValues = iif(empty(lcPrimary), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcPrimary)
				lcPrompt = iif(empty(lcCodePage) or not .lShowInternational, ;
					lcPrompt, iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_CODEPAGE)
				lcValues = iif(empty(lcCodePage) or not .lShowInternational, ;
					lcValues, iif(empty(lcValues), '', lcValues + ccCR) + lcCodePage)
			else
				lcPrompt = iif(lnBatch = 1, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_BATCHUPDATECOUNT)
				lcValues = iif(lnBatch = 1, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ltrim(str(lnBatch)))
				lcPrompt = iif(llCompare, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_COMPAREMEMO)
				lcValues = iif(llCompare, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ccNO)
				lcPrompt = iif(empty(lcConnect), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_CONNECTNAME)
				lcValues = iif(empty(lcConnect), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcConnect)
				lcPrompt = iif(not llFetch, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_FETCHASNEEDED)
				lcValues = iif(not llFetch, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ccYES)
				lcPrompt = iif(llFetchMemo, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_FETCHMEMO)
				lcValues = iif(llFetchMemo, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ccNO)
				lcPrompt = iif(lnFetch = 100, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_FETCHSIZE)
				lcValues = iif(lnFetch = 100, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ltrim(str(lnFetch)))
				lcPrompt = iif(lnMaxRecs = -1, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_MAXRECORDS)
				lcValues = iif(lnMaxRecs = -1, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ltrim(str(lnMaxRecs)))
				lcPrompt = iif(not llOffline, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_OFFLINE)
				lcValues = iif(not llOffline, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ccYES)
				lcPrompt = iif(empty(lcParmList), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_PARAMETERLIST)
				lcValues = iif(empty(lcParmList), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcParmList)
				lcPrompt = iif(not llPrepared, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_PREPARED)
				lcValues = iif(not llPrepared, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ccYES)
				lcPrompt = iif(not llSendUpdate, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_SENDUPDATES)
				lcValues = iif(not llSendUpdate, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ccYES)
				lcPrompt = iif(not llShareConn, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_SHARECONNECTION)
				lcValues = iif(not llShareConn, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ccYES)
				lcPrompt = iif(empty(lcSQL), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_SQL)
				lcValues = iif(empty(lcSQL), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcSQL)
				lcPrompt = iif(empty(lcTables), lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_TABLES)
				lcValues = iif(empty(lcTables), lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + lcTables)
				lcPrompt = iif(not llSendUpdate, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_UPDATETYPE)
				lcValues = iif(not llSendUpdate, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ;
					iif(lnUpdate = 1, ccREP_UPDATE, ccREP_DELETETHENINSERT))
				lcPrompt = iif(lnUseMemo = 255, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_USEMEMOSIZE)
				lcValues = iif(lnUseMemo = 255, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR) + ltrim(str(lnUseMemo)))
				lcPrompt = iif(not llSendUpdate, lcPrompt, ;
					iif(empty(lcPrompt), '', lcPrompt + ;
					.GetLines(lcPrompt, lcValues)) + ccREP_WHERETYPE)
				lcValues = iif(not llSendUpdate, lcValues, ;
					iif(empty(lcValues), '', lcValues + ccCR))
				do case
					case not llSendUpdate
					case lnWhereType = 1
						lcValues = lcValues + ccREP_KEYFIELDSONLY
					case lnWhereType = 2
						lcValues = lcValues + ccREP_KEYANDUPDATABLE
					case lnWhereType = 3
						lcValues = lcValues + ccREP_KEYANDMODIFIED
					case lnWhereType = 4
						lcValues = lcValues + ccREP_KEYANDTIMESTAMP
				endcase
			endif tcType <> 'View'
			lcPrompt = iif(empty(lcProp), lcPrompt, ;
				iif(empty(lcPrompt), '', lcPrompt + ;
				.GetLines(lcPrompt, lcValues)) + lcProp)
			lcValues = iif(empty(lcUser), lcValues, ;
				iif(empty(lcValues), '', lcValues + ccCR) + lcUser)
		
		* Add the information to the cursor.
		
			lcPrompt = iif(empty(lcPrompt), '', lcPrompt + ;
				.GetLines(lcPrompt, lcValues))
			alines(laValues, lcValues)
			for lnI = 1 to alines(laPrompt, lcPrompt)
				insert into (tcCursor) values ;
					(lcDBC, ;
					tcTable, ;
					llAuto, ;
					llUpdate, ;
					llNoUpdate, ;
					lcViewType, ;
					laPrompt[lnI], ;
					laValues[lnI])
			next lnI
		endwith
		return
		
	ENDPROC

	PROCEDURE Init
		lparameters toSDTForm, ;
			tcType, ;
			tcName
		local laTables[1], ;
			lnTables, ;
			laViews[1], ;
			lnViews, ;
			lnCount, ;
			lcDBC, ;
			lnI, ;
			lnFree, ;
			laTypes[1], ;
			laIndexes[1], ;
			laCodePage[1]
		
		* Call the baseclass Init().
		
		dodefault()
		with This
		
		* Initialize properties from the SDT form.
		
			.oSDTForm           = toSDTForm
			.oMeta              = toSDTForm.oMeta
			.oUtility           = toSDTForm.oUtility
			.oError             = toSDTForm.oError
			.oMessage           = toSDTForm.oMessage
			.lShowInternational = toSDTForm.lShowInternational
		
		* Set other properties of the form to defaults.
		
			.Caption          = ccFRM_SYSDOC_CAPTION
			.opgOptions.Value = 1
			.txtFile.Value    = 'REPORT.HTM'
			.txtSysName.Value = toSDTForm.cSystemName
		
		* Get the HTML templates.
		
			.cFieldsTemplate  = toSDTForm.oReg.GetKey(ccREG_KEY, ;
				ccPREF_FIELD_TEMPLATE,   'Fields.html')
			.cTablesTemplate  = toSDTForm.oReg.GetKey(ccREG_KEY, ;
				ccPREF_TABLE_TEMPLATE,   'Tables.html')
			.cIndexesTemplate = toSDTForm.oReg.GetKey(ccREG_KEY, ;
				ccPREF_INDEX_TEMPLATE,   'Indexes.html')
			.cViewsTemplate   = toSDTForm.oReg.GetKey(ccREG_KEY, ;
				ccPREF_VIEW_TEMPLATE,    'Views.html')
			.cSummaryTemplate = toSDTForm.oReg.GetKey(ccREG_KEY, ;
				ccPREF_SUMMARY_TEMPLATE, 'Summary.html')
		
		* Initialize the array of tables and views.
		
			lnTables = .oMeta.DBCXGetAllObjects('All!Table', @laTables)
			lnViews  = .oMeta.DBCXGetAllObjects('All!View',  @laViews)
			lnCount  = lnTables + lnViews + 1
			dimension .aTables[lnCount, 2]
			for lnI = 1 to lnTables
				lcTable = lower(laTables[lnI])
				if left(lcTable, 1) = '!'
					.aTables[lnI, 1] = substr(lcTable, 2)
					.aTables[lnI, 2] = 'F'
				else
					.aTables[lnI, 1] = lower(laTables[lnI])
					.aTables[lnI, 2] = 'T'
				endif left(lcTable, 1) = '!'
			next lnI
			for lnI = 1 to lnViews
				.aTables[lnTables + lnI, 1] = lower(laViews[lnI])
				.aTables[lnTables + lnI, 2] = 'V'
			next lnI
			.aTables[lnCount, 1] = ccLIBRARY
			.aTables[lnCount, 2] = 'X'
		
		* Sort the array.
		
			asort(.aTables)
			.cboTables.Requery()
		
		* Select certain options based on what was selected in the SDT form.
		
			do case
				case tcType = ccLIBRARY
					.cboTables.Value = tcType
					.chkFields.Value = .T.
				case tcType = ccDATABASE_PROPER
					.opgOptions.Value = 2
				case (tcType = 'Table' or tcType = 'View' or ;
					tcType = ccFREE_TABLES) and not empty(tcName)
					.cboTables.Value = tcName
				case tcType = 'Table'
					.opgOptions.Value = 3
				case tcType = 'View'
					.opgOptions.Value = 4
				otherwise
					.cboTables.ListIndex = 1
			endcase
		
		* Get copies of the aDataTypes, aIndexTypes, and aCodePage arrays from SDTMgr.
		
			.oMeta.oSDTMgr.GetDataTypeArray(@laTypes)
			acopy(laTypes, .aDataTypes)
			.oMeta.oSDTMgr.GetIndexTypeArray(@laIndexes)
			acopy(laIndexes, .aIndexTypes)
			.oMeta.oSDTMgr.GetCodePageArray(@laCodePage)
			acopy(laCodePage, .aCodePage)
		endwith
		
	ENDPROC

	PROCEDURE mergeascii
		* Merge the temporary report file into the main file.
		
		lparameters tcTempFile, ;
			tcMainFile, ;
			tlPreview
		local lnMain, ;
			lnTemp, ;
			lcBuffer
		
		* Exit if the temporary file doesn't exist.
		
		if not file(tcTempFile)
			return
		endif not file(tcTempFile)
		
		* Open the main file if it exists or create it if it doesn't.
		
		if file(tcMainFile)
			lnMain = fopen(tcMainFile, 2)
			fseek(lnMain, 0, 2)
		else
			lnMain = fcreate(tcMainFile)
		endif file(tcMainFile)
		
		* Open the temporary file and append it into the main file.
		
		lnTemp = fopen(tcTempFile)
		do while not feof(lnTemp)
			lcBuffer = fread(lnTemp, 2048)
			fwrite(lnMain, lcBuffer)
		enddo while not feof(lnTemp)
		fclose(lnMain)
		fclose(lnTemp)
		
		* Erase the temporary file.
		
		erase (tcTempFile)
		
	ENDPROC

	PROCEDURE outputhtml		&& Outputs to an HTML document
		* Output to the appropriate HTML document.
		
		lparameters tcTemplateClass, ;
			tlPreview, ;
			tlFirst
		private plSingleTable
		local lcFileName, ;
			loTextMerge, ;
			lcTemplate, ;
			lcOutput
		with This
			lcFileName    = alltrim(.txtFile.Value)
			plSingleTable = .opgOptions.Value = 1
			loTextMerge   = MakeObject('SFTextMergeProcessor', 'SFTextMerge')
			lcTemplate    = filetostr(tcTemplateClass)
			with loTextMerge
				.cLeftDelimiter  = '<%'
				.cRightDelimiter = '%>'
				lcOutput         = .Output(lcTemplate)
				if tlFirst
					strtofile(lcOutput, lcFileName)
				else			
					strtofile(lcOutput, lcFileName, .T.)
				endif tlFirst
			endwith
			do case
				case not empty(loTextMerge.cErrorMessage)
					.oMessage.ErrorMessage(loTextMerge.cErrorMessage)
				case tlPreview
					.oUtility.ShellExecute(lcFileName)
			endcase
		endwith
		return
		
	ENDPROC

	PROCEDURE printdoc
		lparameters tlPreview
		local lcCurrCollate, ;
			lcFileName, ;
			llFile, ;
			lcTable, ;
			lcType, ;
			lcCursor, ;
			llIntl, ;
			lcTempFile, ;
			lcCurrEsc, ;
			lcCurrOnEsc, ;
			llFirst, ;
			lcFileType, ;
			lcPrintCmd, ;
			lcCurrPrinter, ;
			lcPrinter, ;
			lnTables, ;
			lnI
		private pcSystem, ;
			plStopped, ;
			poForm
		
		* Give an error if we are printing to a file and a filename wasn't entered.
		
		lcCurrCollate = set('COLLATE')
		set collate to 'MACHINE'
		with This
			lcFileName = alltrim(.txtFile.Value)
			llFile     = .chkFile.Value
			if llFile and empty(lcFileName)
				wait window ccERR_INVALID_FILENAME nowait
				.txtFile.SetFocus()
				return
			endif llFile ...
		
		* Initialize some things.
		
			wait window ccMSG_PRINTING nowait
			lcTable         = .cboTables.DisplayValue
			lcType          = iif(.cboTables.ListIndex = 0, '', ;
				.aTables[.cboTables.ListIndex, 2])
			lcCursor        = .oUtility.CreateUniqueAlias(.DataSessionID)
			pcSystem        = alltrim(.txtSysName.Value)
			llIntl          = .lShowInternational
			lcTempFile      = .oUtility.TempFile('TXT')
			lcCurrEsc       = set('ESCAPE')
			lcCurrOnEsc     = on('ESCAPE')
			plStopped       = .F.
			llFirst         = .T.
			lcFileType      = upper(justext(lcFileName))
			.lCancelProcess = .F.
			set escape on
			on escape plStopped = .T.
		
		* Setup the printer.
		
			do case
		
		* Output to text file.
		
				case llFile
					erase (lcFileName)
					lcPrintCmd = 'to file ' + lcTempFile + ' ascii noconsole'
					_asciicols = 132
		
		* Print preview.
		
				case tlPreview
					lcPrintCmd = 'to printer prompt preview'
		
		* Print.
		
				otherwise
					lcCurrPrinter = set('PRINTER', 3)
					lcPrinter     = getprinter()
					if not empty(lcPrinter)
						set printer to name (lcPrinter)
						lcPrintCmd = 'to printer noconsole'
					else
						plStopped = .T.
					endif not empty(lcPrinter)
			endcase
		
		* Flag that nothing has printed yet. We need this because the user may choose
		* Cancel in the Print dialog of the first of several selected reports, and we
		* don't want to continue if so.
		
			.lPrinted = .F.
			poForm    = This
		
		* Print the Tables report. First, create a cursor to hold the information.
		
			if .chkTables.Value and .chkTables.Enabled and not plStopped
				create cursor (lcCursor) (DATABASE C(128), NAME C(128), AUTOOPEN L, ;
					UPDATABLE L, NOUPDATE L, TYPE C(10), PROMPT M, VALUES M)
				index on NAME tag NAME
		
		* If we're doing all tables, spin through the tables array and add each (except
		* the Field Repository) to the cursor.
		
				do case
					case inlist(.opgOptions.Value, 2, 3)
						lnTables = alen(.aTables, 1)
						for lnI = 1 to lnTables
							if plStopped
								exit
							endif plStopped
							lcTable = .aTables[lnI, 1]
							lcType  = .aTables[lnI, 2]			
							if lcTable <> ccLIBRARY and lcType $ 'TF'
								.GetTables(lcTable, ;
									iif(.aTables[lnI, 2] = 'T', 'Table', 'Free'), ;
									lcCursor)
							endif lcTable <> ccLIBRARY ...
						next lnI
		
		* Handle just a single table.
		
					case lcTable <> ccLIBRARY and lcType $ 'TF' and not plStopped
						.GetTables(lcTable, iif(lcType = 'T', 'Table', 'Free'), ;
							lcCursor)
				endcase
		
		* Print the report from the TABLES cursor.
		
				select (lcCursor)
				go top
				do case
					case eof() or plStopped
					case not llFile or lcFileType = 'TXT'
						report form TABLES &lcPrintCmd while not plStopped
						if not .lPrinted
							plStopped = .T.
						endif not .lPrinted
						if llFile and not plStopped
							.MergeASCII(lcTempFile, lcFileName)
						endif llFile ...
						lcPrintCmd = strtran(lcPrintCmd, ' prompt')
					case lcFileType = 'HTM'
						.OutputHTML(.cTablesTemplate, tlPreview, llFirst)
						llFirst = .F.
				endcase
				use
			endif .chkTables.Value ...
		
		* Print the Views report. First, create a cursor to hold the information.
		
			if .chkViews.Value and .chkViews.Enabled and not plStopped
				create cursor (lcCursor) (DATABASE C(128), NAME C(128), AUTOOPEN L, ;
					UPDATABLE L, NOUPDATE L, TYPE C(10), PROMPT M, VALUES M)
				index on NAME tag NAME
		
		* If we're doing all views, spin through the tables array and add each (except
		* the Field Repository) to the cursor.
		
				do case
					case inlist(.opgOptions.Value, 2, 4)
						lnTables = alen(.aTables, 1)
						for lnI = 1 to lnTables
							if plStopped
								exit
							endif plStopped
							lcTable = .aTables[lnI, 1]
							if .aTables[lnI, 2] = 'V'
								.GetTables(lcTable, 'View', lcCursor)
							endif .aTables[lnI, 2] = 'V'
						next lnI
		
		* Handle just a single view.
		
					case lcTable <> ccLIBRARY and lcType = 'V' and not plStopped
						.GetTables(lcTable, 'View', lcCursor)
				endcase
		
		* Print the report from the VIEW cursor.
		
				select (lcCursor)
				go top
				do case
					case eof() or plStopped
					case not llFile or lcFileType = 'TXT'
						report form VIEWS &lcPrintCmd while not plStopped
						if not .lPrinted
							plStopped = .T.
						endif not .lPrinted
						if llFile and not plStopped
							.MergeASCII(lcTempFile, lcFileName)
						endif llFile ...
						lcPrintCmd = strtran(lcPrintCmd, ' prompt')
					case lcFileType = 'HTM'
						.OutputHTML(.cViewsTemplate, tlPreview, llFirst)
						llFirst = .F.
				endcase
				use
			endif .chkViews.Value ...
		
		* Print the Indexes report.
		
			if .chkIndexes.Value and .chkIndexes.Enabled and not plStopped
				create cursor (lcCursor) (DATABASE C(128), TABLE C(128), TAG C(10), ;
					CAPTION M, TYPE C(10), DESCEND L, SELECT L, PROMPT M, VALUES M)
				index on TABLE + TAG tag INDEXES
		
		* If we're doing all tables, spin through the tables array and add the fields
		* for each to the cursor.
		
				do case
					case inlist(.opgOptions.Value, 2, 3)
						lnTables = alen(.aTables, 1)
						for lnI = 1 to lnTables
							if plStopped
								exit
							endif plStopped
							lcTable = .aTables[lnI, 1]
							lcType  = .aTables[lnI, 2]
							if lcTable <> ccLIBRARY and lcType $ 'TF'
								.GetIndexes(lcTable, lcType, lcCursor)
							endif lcTable <> ccLIBRARY ...
						next lnI
		
		* Handle just a single table.
		
					case lcTable <> ccLIBRARY and not plStopped
						.GetIndexes(lcTable, lcType, lcCursor)
				endcase
		
		* Print the report from the INDEXES cursor.
		
				select (lcCursor)
				go top
				do case
					case eof() or plStopped
					case not llFile or lcFileType = 'TXT'
						report form INDEXES &lcPrintCmd while not plStopped
						if not .lPrinted
							plStopped = .T.
						endif not .lPrinted
						if llFile and not plStopped
							.MergeASCII(lcTempFile, lcFileName)
						endif llFile ...
						lcPrintCmd = strtran(lcPrintCmd, ' prompt')
					case lcFileType = 'HTM'
						.OutputHTML(.cIndexesTemplate, tlPreview, llFirst)
						llFirst = .F.
				endcase
				use
			endif .chkIndexes.Value ...
		
		* Print the Fields report. First, create a cursor to hold the information.
		
			if .chkFields.Value and not plStopped
				create cursor (lcCursor) (DATABASE C(128), TABLE C(120), ;
					CTYPE C(1), FIELD_NUM C(4), FIELD_NAME C(120), FIELD_TYPE C(20), ;
					FIELD_LEN N(3), FIELD_DEC N(3), STEPVALUE I, ISNULL L, KEY L, ;
					UPDATABLE L, PROMPT M, VALUES M, CALCULATED L)
				if .chkAlpha.Value
					index on TABLE + FIELD_NAME tag FIELDS
				else
					index on TABLE + iif(CALCULATED, '9999', FIELD_NUM) tag FIELDS
				endif .chkAlpha.Value
		
		* If we're doing all tables, spin through the tables array and add the fields
		* for each to the cursor.
		
				if .opgOptions.Value <> 1
					lnTables = alen(.aTables, 1)
					for lnI = 1 to lnTables
						if plStopped
							exit
						endif plStopped
						lcTable = .aTables[lnI, 1]
						lcType  = .aTables[lnI, 2]
						if lcTable <> ccLIBRARY and ;
							(.opgOptions.Value = 2 or ;
							(.opgOptions.Value = 3 and lcType $ 'TF') or ;
							(.opgOptions.Value = 4 and lcType = 'V'))
							.GetFields(lcTable, lcType, lcCursor)
						endif .opgOptions.Value = 2 ...
					next lnI
		
		* Handle just a single table.
		
				else
					.GetFields(lcTable, lcType, lcCursor)
				endif .opgOptions.Value <> 1
		
		* Print the report from the FIELDS cursor.
		
				select (lcCursor)
				go top
				do case
					case eof() or plStopped
					case not llFile or lcFileType = 'TXT'
						report form FIELDS &lcPrintCmd while not plStopped
						if not .lPrinted
							plStopped = .T.
						endif not .lPrinted
						if llFile and not plStopped
							.MergeASCII(lcTempFile, lcFileName)
						endif llFile ...
						lcPrintCmd = strtran(lcPrintCmd, ' prompt')
					case lcFileType = 'HTM'
						.OutputHTML(.cFieldsTemplate, tlPreview, llFirst)
						llFirst = .F.
				endcase
				use
			endif .chkFields.Value ...
		
		* Print the Summary report. First, create a cursor to hold fields.
		
			if .chkSummary.Value and .chkSummary.Enabled and not plStopped
				create cursor (lcCursor) (DATABASE C(128), TABLE C(128), NAME C(128), ;
					FIELD_NUM N(4), TYPE C(20), RTYPE C(1), FIELD_LEN N(3), ;
					FIELD_DEC N(3), EXPRESSION M, DESCEND C(1), COMMENT M, ;
					TABLETYPE C(1))
				if .chkAlpha.Value
					index on left(TABLE + RTYPE + NAME, 200) tag SUMMARY
				else
					index on left(TABLE + RTYPE + str(FIELD_NUM, 4) + NAME, 200) ;
						tag SUMMARY
				endif .chkAlpha.Value
		
		* If we're doing all tables, spin through the tables array and add the fields
		* and indexes for each to the cursor.
		
				do case
					case .opgOptions.Value <> 1
						lnTables = alen(.aTables, 1)
						for lnI = 1 to lnTables
							if plStopped
								exit
							endif plStopped
							lcTable = .aTables[lnI, 1]
							lcType  = .aTables[lnI, 2]
							if lcTable <> ccLIBRARY and ;
								(.opgOptions.Value = 2 or ;
								(.opgOptions.Value = 3 and lcType $ 'TF') or ;
								(.opgOptions.Value = 4 and lcType = 'V'))
								.GetSummary(lcTable, lcType, lcCursor)
							endif lcTable <> ccLIBRARY ...
						next lnI
		
		* Handle just a single table.
		
					case lcTable <> ccLIBRARY and not plStopped
						.GetSummary(lcTable, lcType, lcCursor)
				endcase
		
		* Print the report from the SUMMARY cursor.
		
				select (lcCursor)
				go top
				do case
					case eof() or plStopped
					case not llFile or lcFileType = 'TXT'
						report form SUMMARY &lcPrintCmd while not plStopped
						if not .lPrinted
							plStopped = .T.
						endif not .lPrinted
						if llFile and not plStopped
							.MergeASCII(lcTempFile, lcFileName)
						endif llFile ...
						lcPrintCmd = strtran(lcPrintCmd, ' prompt')
					case lcFileType = 'HTM'
						.OutputHTML(.cSummaryTemplate, tlPreview, llFirst)
						llFirst = .F.
				endcase
				use
			endif .chkSummary.Value ...
		
		* Display the file if we're supposed to.
		
			if llFile and lcFileType = 'TXT' and tlPreview
				.oUtility.ShellExecute(lcFileName)
			endif llFile ...
		
		* Cleanup before returning.
		
			.CleanUpAfterPrint(lcCurrCollate, lcCurrEsc, lcCurrOnEsc, lcCurrPrinter)
		endwith
		
	ENDPROC

	PROCEDURE setprint
		local lnTable
		with This
			lnTable = .cboTables.ListIndex
			do case
				case lnTable = 0 and .opgOptions.Value = 1
					store .F. to .cmdPrint.Enabled, .cmdPreview.Enabled
				case .opgOptions.Value = 1 and .cboTables.DisplayValue = ccLIBRARY
					store .chkFields.Value to .cmdPrint.Enabled, .cmdPreview.Enabled
					store .F. to .chkTables.Enabled, .chkIndexes.Enabled, ;
						.chkViews.Enabled, .chkSummary.Enabled
				otherwise
					.chkSummary.Enabled = .T.
					store inlist(.opgOptions.Value, 2, 3) or ;
						(.opgOptions.Value = 1 and .aTables[lnTable, 2] $ 'TF') to ;
						.chkTables.Enabled, .chkIndexes.Enabled
					store inlist(.opgOptions.Value, 2, 4) or ;
						(.opgOptions.Value = 1 and .aTables[lnTable, 2] = 'V') to ;
						.chkViews.Enabled
					store (.chkTables.Value and .chkTables.Enabled) or ;
						(.chkIndexes.Value and .chkIndexes.Enabled) or ;
						.chkFields.Value or ;
						(.chkViews.Value and .chkViews.Enabled) or ;
						(.chkSummary.Value and .chkSummary.Enabled) to ;
						.cmdPrint.Enabled, .cmdPreview.Enabled
			endcase
			if .chkFile.Value
				.cmdPrint.Caption   = 'Create'
				.cmdPreview.Caption = 'View'
			else
				.cmdPrint.Caption   = 'Print'
				.cmdPreview.Caption = 'Preview'
			endif .chkFile.Value
			.RefreshForm()
		endwith
		
	ENDPROC

	PROCEDURE cboTables.anychange
		Thisform.SetPrint()
		
	ENDPROC

	PROCEDURE chkAlpha.Refresh
		* This is only enabled when Fields or summary reports are selected.
		
		This.Enabled = This.Parent.chkFields.Value or This.Parent.chkSummary.Value
		
	ENDPROC

	PROCEDURE chkCalculated.Refresh
		* This is only enabled when Fields report is selected.
		
		This.Enabled = This.Parent.chkFields.Value
		
	ENDPROC

	PROCEDURE chkComments.Refresh
		* This is only enabled when Summary report is selected.
		
		This.Enabled = This.Parent.chkSummary.Value
		
	ENDPROC

	PROCEDURE chkFields.anychange
		Thisform.SetPrint()
		
	ENDPROC

	PROCEDURE chkFile.anychange
		with Thisform
			store This.Value to .txtFile.Enabled, .cmdPutFile.Enabled
			.SetPrint()
		endwith
		
	ENDPROC

	PROCEDURE chkIndexes.anychange
		Thisform.SetPrint()
		
	ENDPROC

	PROCEDURE chkSummary.anychange
		Thisform.SetPrint()
		
	ENDPROC

	PROCEDURE chkTables.anychange
		Thisform.SetPrint()
		
	ENDPROC

	PROCEDURE chkViews.anychange
		Thisform.SetPrint()
		
	ENDPROC

	PROCEDURE cmdPreview.Click
		Thisform.PrintDoc(.T.)
		
	ENDPROC

	PROCEDURE cmdPrint.Click
		Thisform.PrintDoc()
		
	ENDPROC

	PROCEDURE opgOptions.anychange
		with Thisform
			.cboTables.Enabled = This.Value = 1
			.SetPrint()
		endwith
		
	ENDPROC

ENDDEFINE
