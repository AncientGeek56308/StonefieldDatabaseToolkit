*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sdt.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sdtmgr AS basemgr OF "dbcxmgr.vcx" 		&& The SDT manager for DBCX
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*m: arrayscan		&& Find a particular value in a certain column in an array
		*m: clearcdx		&& Clears the CDX byte in a DBF header.
		*m: closeallaliases		&& Close all open copies of a given table in all datasessions
		*m: convertfoxtovfp		&& Converts a FoxBase or FoxPro 2.x table to VFP format
		*m: createtempdbc		&& Create a temporary database that contains the stored procedures of the current one.
		*m: createviewindex		&& Creates the specified view index
		*m: createviewindexes		&& Creates all the defined indexes for a view
		*m: dbcdeleteprop		&& Deletes a property from the PROPERTY memo of the current DBC record
		*m: dbcfindobject		&& Finds an object's record in a DBC.
		*m: dbcgetcdxstructure		&& Get the structure for a table's indexes from the DBC and DBCX and place it into an array.
		*m: dbcgetfield		&& Returns the value from a certain field in the DBC.
		*m: dbcgetprop		&& A method to get a value for a given property from the DBC PROPERTY field.
		*m: dbcgettablestructure		&& A method to get the structure of a table from its records in the DBC and DBCX.
		*m: dbcopen		&& Opens a DBC as a table.
		*m: dbcsetprop		&& A method to set a value for a given property from the DBC PROPERTY field.
		*m: dbcxgetallobjects		&& Find all data objects having a certain property set a certain way.
		*m: decimal2hex		&& Convert a decimal number to a hex string
		*m: diderroroccur		&& Returns the value of the protected lErrorOccurred property.
		*m: displayllfferror		&& Displays an error that occurred during a LLFF.
		*m: enabledbcevents		&& Enables or disables DBC events in the current database and returns the former setting
		*m: fastdoevents		&& Performs a DOEVENTS after creating an event so it performs faster
		*m: fixfptfilesize		&& Corrects the size of an FPT file as a workaround for a VFP bug
		*m: getblocksize		&& Determines what to set BLOCKSIZE to for a given SDTBLOCKSIZE value (obtained from sys(2012)).
		*m: getcodepage		&& Determine the table's code page value from the code page number or vice versa.
		*m: getcodepagearray		&& An exposed method that copies the protected aCodePage array into a specified array.
		*m: getcollatearray		&& An exposed method that copies the protected aCollate array into a specified array.
		*m: getdatatypearray		&& An exposed method that copies the protected aDataType array into a specified array.
		*m: getdbfstructure		&& Reads the structure of a table directly from the DBF header and places it into an array.
		*m: getdrivespace		&& Returns the free space on a drive (workaround for a bug in VFP's DISKSPACE() routine which doesn't handle free space more than 2 GB)
		*m: getfreetablepath		&& Returns the path to the free table stored in CoreMeta.mPath
		*m: getindexstructure		&& Places the structure of a table's indexes into an array.
		*m: getindextypearray		&& An exposed method that copies the protected aIndexType array into a specified array.
		*m: getmemofile		&& Determines the file name for a memo file
		*m: getmetaalias		&& An exposed method that returns the protected cMetaAlias property.
		*m: getstructurearray		&& Copies 18 columns of one array to another
		*m: hex2decimal		&& Converts a value in Intel format to a decimal value
		*m: howtosynctable		&& Creates a ALTER TABLE statement to synchronize a table's structure with that defined in the DBC and DBCX.
		*m: isindexoutofsync		&& Determines if a table's indexes are out of sync with the definitions in the DBC and DBCX.
		*m: istableoutofsync		&& Determines if a table's physical structure is out of sync with the definition in the DBC and DBCX.
		*m: needreindex		&& Determines if Reindex should be used on any table in the DBC.
		*m: needreindexone		&& Determines if Reindex() should be used for a single table.
		*m: needupdate		&& Determines if Update() should be used for any table in a DBC.
		*m: needupdateone		&& Determines if Update() should be used for a single table.
		*m: openalltables		&& Open all tables defining in the DBC with the SDTAutoOpen property .T.
		*m: opendata		&& Opens a database and all of its tables that have the SDTAutoOpen property .T.
		*m: opentable		&& Opens a single table and sets its order to either the primary key (if there is one) or the specified order (if there is one).
		*m: pause		&& Pause to allow caching to catch up
		*m: readbacklink		&& Reads the backlink of a table
		*m: readnextvalue		&& Reads the next value property for a field from the DBF header
		*m: reindex		&& A front-end to the ReindexOneTable() method to recreates table indexes.
		*m: reindexonetable		&& Recreates the indexes for one table.
		*m: repair		&& A front-end to the RepairOneTable() method to repair table headers.
		*m: repairmemo		&& Repairs the memo file of a table.
		*m: repaironetable		&& Repairs a single table's header.
		*m: reseterror		&& An exposed method to reset the values of the protected lErrorOccurred and public aErrorSpecs.
		*m: reversedecimal2hex		&& Convert a decimal number to a hex string in reverse Intel format (most significant byte first)
		*m: reversehex2decimal		&& Converts a word in reverse Intel format (most significant byte first) to a decimal value
		*m: selecttablestoprocess		&& Create an array of tables to process.
		*m: selecttag		&& Allow the user to select a tag for a table.
		*m: setdatabase		&& Does SET DATABASE to the specified database, handling spaces in names
		*m: setrelation		&& Sets temporal relations between tables based on their persistent relations.
		*m: setsuppresserrors		&& An exposed method to set the value of the protected lSuppressErrors.
		*m: stripproperty		&& Removes a row from an array created with DBCXGetRowProp containing the specified property.
		*m: tablehasmemo		&& Returns .T. if a table has at least one memo or general field.
		*m: tempfile		&& Create a temporary filename
		*m: testmetadata		&& Returns .T. if the DBC and meta data are in sync
		*m: update		&& A front-end to the UpdateOneTable() method to update table structures
		*m: updateonetable		&& Updates a table structure to match the definition in the DBC and DBCX.
		*m: writebacklink		&& Writes the name and path of a DBC in the backlink area in a DBF header.
		*m: writecodepage		&& Writes a code page to the appropriate area in a DBF header.
		*m: writedbfheader		&& Writes a complete header for a DBF.
		*p: calias		&& The alias an SDT method was working on
		*p: cmetaalias		&& The alias of the table containing user-defined properties.
		*p: cmetatable		&& The name of the table containing user-defined properties
		*p: cprogressformclass		&& The class to use for the progress form
		*p: cprogressformlibrary		&& The library containing the class specified in cProgressFormClass
		*p: ctodo		&& What update to do in the current table
		*p: lindexerror		&& .T. if an error occurs creating an index
		*p: lneedpause		&& .T. to insert a pause at certain places to minimize caching issues
		*p: lquiet		&& If .T., Update(), Reindex(), and Repair() do not display the progress as tables are processed.
		*p: ltalk		&& .T. to use SET TALK to display the progress of updating and reindexing
		*p: ltestingindex		&& .T. if we're testing an index expression
		*p: npausetime		&& The amount of time to pause for caching catchup
		*p: nwaittoopentime		&& The amount of time to wait for a file to be opened
		*a: acodepage[1,0]		&& An array of code page values and descriptions.
		*a: acollate[1,0]		&& An array of collate sequences.
		*a: adatatypes[1,0]		&& An array of field types and descriptions.
		*a: ahowtosync[1,0]		&& An array of what to alter in an existing table
		*a: aindextypes[1,0]		&& A array of index types and descriptions.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED acodepage,acollate,adatatypes,aindextypes,cmetaalias,lindexerror,ltestingindex
	calias = 		&& The alias an SDT method was working on
	cdbcxalias = SDTMETA
	cmetaalias = SDTUSER		&& The alias of the table containing user-defined properties.
	cmetatable = SDTUSER.DBF		&& The name of the table containing user-defined properties
	cobjecttypeshandled = DTVFIU
	cprefix = SDT
	cprocessfield = Updated
	cproductname = Stonefield Database Toolkit
	cprogressformclass = SDTProgressForm		&& The class to use for the progress form
	cprogressformlibrary = SDT.VCX		&& The library containing the class specified in cProgressFormClass
	ctodo = 		&& What update to do in the current table
	cversion = ("6.2b")
	lindexerror = .F.		&& .T. if an error occurs creating an index
	lneedpause = .F.		&& .T. to insert a pause at certain places to minimize caching issues
	lquiet = .F.		&& If .T., Update(), Reindex(), and Repair() do not display the progress as tables are processed.
	ltalk = .T.		&& .T. to use SET TALK to display the progress of updating and reindexing
	ltestingindex = .F.		&& .T. if we're testing an index expression
	Name = "sdtmgr"
	npausetime = 0.2		&& The amount of time to pause for caching catchup
	nwaittoopentime = 10		&& The amount of time to wait for a file to be opened
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addrow
		*==============================================================================
		* Method:			AddRow
		* Status:			Public
		* Purpose:			Adds a record to the meta data table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/07/2001
		* Parameters:		tiID         - the DBCX ID for the new record
		*					tcDBC        - the database the object belongs to
		*					tcObjectName - the name of the object without the database
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		* Returns:			.T.
		* Environment in:	the meta data table for this manager must be open
		* Environment out:	if a record for the specified object doesn't already exist,
		*						one is created
		*==============================================================================
		
		lparameters tiID, ;
			tcDBC, ;
			tcObjectName, ;
			tcObjectType
		local lcFullPath, ;
			lcDBC, ;
			lcType, ;
			lcAlias, ;
			lcObject, ;
			llFilter, ;
			llSelect, ;
			lnIndex
		with This
			lcFullPath = set('FULLPATH')
			set fullpath on
			lcDBC  = lower(juststem(tcDBC))
			lcType = upper(left(tcObjectType, 1))
			if lcType $ This.cObjectTypesHandled and ;
				not .FindObject(tcObjectName, tcObjectType, tcDBC)
				lcAlias  = .GetParentName(tcObjectName)
				lcObject = .GetObjectName(tcObjectName)
				insert into (.cDBCXAlias) ;
						(ObjectName, ;
						RecType, ;
						DBCName, ;
						Updated) ;
					values ;
						(lower(tcObjectName) , ;
						tcObjectType, ;
						lcDBC, ;
						datetime())
				if not empty(tcDBC) and lcType $ 'TVF'
					llFilter = not ccDIRECTIVE_NOFILTER $ upper(dbgetprop(tcObjectName, ;
						tcObjectType, 'Comment'))
				endif not empty(tcDBC) ...
				do case
					case lcType = 'T'
						replace AutoOpen with .T., ;
							CanUpdate with .T., ;
							Filter with llFilter ;
							in (This.cDBCXAlias)
					case lcType = 'V'
						replace CanUpdate with .T., ;
							UseVD with .T., ;
							Filter with llFilter ;
							in (This.cDBCXAlias)
					case lcType $ 'FU'
						llFilter = llFilter and (not used(lcAlias) or ;
							type(tcObjectName) <> 'G')
						replace Filter with llFilter ;
							in (This.cDBCXAlias)
					case lcType = 'I'
						llSelect = .T.
						if used(lcAlias)
							lnIndex = tagno(lcObject, cdx(1, lcAlias), lcAlias)
							if lnIndex > 0
								llSelect = not primary(lnIndex, lcAlias) and ;
									key(lnIndex, lcAlias) <> 'DELETED()'
							endif lnIndex > 0
						endif used(lcAlias)
						replace Select with llSelect ;
							in (This.cDBCXAlias)
				endcase
			endif lcType $ This.cObjectTypesHandled ...
			if lcFullPath = 'OFF'
				set fullpath off
			endif lcFullPath = 'OFF'
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE arrayscan		&& Find a particular value in a certain column in an array
		*==============================================================================
		* Method:			ArrayScan
		* Status:			Public
		* Purpose:			Find a particular value in a certain column in an array
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last Revision:	11/02/2004
		* Parameters:		taArray    - the array (passed by reference using @) to
		*						search
		*					tuValue    - the value to search for
		*					tnColumn   - the column to search (optional: if it isn't
		*						specified, column 1 is searched)
		*					tnOccur    - the occurrance to search for (optional: if it
		*						isn't specified, the first occurrance is located)
		*					tlNotExact - if .T., an non-exact match will be found
		* Returns:			the row the value was found in if it was found, or 0 if
		*						not
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters taArray, ;
			tuValue, ;
			tnColumn, ;
			tnOccur, ;
			tlNotExact
		external array taArray
		
		* In VFP 7, use the new capabilities of ASCAN.
		
		#if version(5) >= 700
		local lnColumn, ;
			lnOccur, ;
			lnFlags, ;
			lnRows, ;
			lnColumns, ;
			lnStartElement, ;
			lnFound, ;
			lnRow
		#define cnEXACT_OFF   4
		#define cnEXACT_ON    6
		#define cnRETURN_ROW  8
		#define cnCASE_INSENS 1
		lnColumn       = iif(vartype(tnColumn) = 'N', tnColumn, 1)
		lnOccur        = iif(vartype(tnOccur)  = 'N', tnOccur,  1)
		lnFlags        = iif(tlNotExact, cnEXACT_OFF, cnEXACT_ON) + cnCASE_INSENS + ;
			cnRETURN_ROW
		lnRows         = alen(taArray, 1)
		lnColumns      = alen(taArray, 2)
		lnStartElement = 1
		lnFound        = 0
		do while lnStartElement <= lnRows
			lnRow = ascan(taArray, tuValue, lnStartElement, -1, lnColumn, lnFlags)
			if lnRow > 0
				lnFound = lnFound + 1
				if lnFound = lnOccur
					exit
				else
					lnStartElement = lnRow + 1
					lnRow = 0
				endif lnFound = lnOccur
			else
				exit
			endif lnRow > 0
		enddo while lnStartElement <= lnRows
		#else
		
		* In VFP 6, use ASCAN in a loop to find the desired element.
		
		local lnColumn, ;
			lnOccur, ;
			lnRow, ;
			lnStartElement, ;
			lnFound, ;
			lnRows, ;
			lnColumns, ;
			lcType, ;
			luValue, ;
			lnElement, ;
			lnCol, ;
			lnI
		lnColumn       = iif(vartype(tnColumn) = 'N', tnColumn, 1)
		lnOccur        = iif(vartype(tnOccur)  = 'N', tnOccur,  1)
		lnRow          = 0
		lnStartElement = 1
		lnFound        = 0
		lnRows         = alen(taArray, 1)
		lnColumns      = alen(taArray, 2)
		lcType         = vartype(tuValue)
		
		* If we're dealing with a character expression, use ASCAN to find the value in
		* the array, then determine if it's in the correct column. If not, change the
		* starting element number and try again.
		
		if lcType = 'C'
			luValue = upper(tuValue)
			do while lnStartElement <= alen(taArray)
				lnElement = ascan(taArray, luValue, lnStartElement)
				if lnElement <> 0
					lnCol = iif(lnColumns > 1, asubscript(taArray, lnElement, 2), 1)
					if lnCol = lnColumn and (tlNotExact or lcType <> 'C' or ;
						taArray[lnElement] == luValue)
						lnFound = lnFound + 1
						if lnFound = lnOccur
							lnRow = iif(lnColumns > 1, ;
								asubscript(taArray, lnElement, 1), lnElement)
							exit
						endif lnCol = lnColumn ...
					endif lnCol = lnColumn ...
					lnStartElement = lnElement + 1
				else
					exit
				endif lnElement <> 0
			enddo while lnStartElement <= alen(taArray)
		
		* For non-character expressions, we'll use a brute force method because of a
		* bug in ASCAN() which prevents it from working with non-character expressions.
		
		else
			for lnI = 1 to lnRows
				if (lnColumns > 1 and vartype(taArray[lnI, lnColumn]) = lcType and ;
					taArray[lnI, lnColumn] = tuValue) or (lnColumns < 2 and ;
					vartype(taArray[lnI]) = lcType and taArray[lnI] = tuValue)
					lnRow = lnI
					exit
				endif (lnColumns > 1 ...
			next lnI
		endif lcType = 'C'
		#endif
		return lnRow
		
	ENDPROC

	PROCEDURE checkdbcxmeta
		*==============================================================================
		* Method:			CheckDBCXMeta
		* Status:			Public
		* Purpose:			Check the DBCX meta table structure to see if it needs to
		*						be converted to a new format
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	05/24/2001
		* Parameters:		none
		* Returns:			.T. if the structure needs to be converted
		* Environment in:	This.Parent.cRegistryPath contains the path where the table
		*						should exist and This.cDBCXTable contains the table
		*						name
		* Environment out:	none
		*==============================================================================
		
		local llReturn
		with This
			if file(.Parent.cRegistryPath + .cDBCXTable)
				.OpenDBCXMeta()
				llReturn = type(.cDBCXAlias + '.iID') <> 'U'
			endif file(.Parent.cRegistryPath + .cDBCXTable)
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE clearcdx		&& Clears the CDX byte in a DBF header.
		*==============================================================================
		* Method:			ClearCDX
		* Status:			Protected
		* Purpose:			Clear the CDX/FPT bit in a DBF header
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	10/15/2004
		* Parameters:		tuFile - either a handle to the table if it's already
		*						open or the name of the file to open
		* Returns:			.T. if it succeeded
		* Environment in:	the table must already be open using LLFF if a numeric
		*						parameter is passed or not already open if a string is
		*						passed
		* Environment out:	the CDX bit in the specified table is cleared
		*					the table is still open using LLFF if a numeric
		*						parameter is passed or closed if a string is passed
		*==============================================================================
		
		lparameters tuFile
		local lnHandle, ;
			llReturn, ;
			lnCDXFlag
		
		* If the parameter is a string, open the file using LLFF. Otherwise, it must be
		* the handle to use.
		
		lnHandle = iif(vartype(tuFile) = 'C', fopen(tuFile, F_READWRITE), tuFile)
		
		* Clear the CDX bit.
		
		llReturn = lnHandle >= 0
		if llReturn
			fseek(lnHandle, cnDBF_CDX_BIT)
			lnCDXFlag = asc(fread(lnHandle, 1))
			lnCDXFlag = bitclear(lnCDXFlag, 0)
			fseek(lnHandle, cnDBF_CDX_BIT)
			fwrite(lnHandle, chr(lnCDXFlag))
		
		* Close the table if we opened it.
		
			if vartype(tuFile) = 'C'
				fclose(lnHandle)
			endif vartype(tuFile) = 'C'
		endif llReturn
		return llReturn
		
	ENDPROC

	PROCEDURE closeallaliases		&& Close all open copies of a given table in all datasessions
		*==============================================================================
		* Method:			CloseAllAliases
		* Status:			Public
		* Purpose:			Close all open copies of a given table in all datasessions
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
		* Last revision:	03/10/2003
		* Parameters:		tcFile - the DBF name and path of the table or the name of
		*						a view
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	any open copies of the specified table or view are closed
		*==============================================================================
		
		lparameters tcFile
		local lnDataSession, ;
			lcFile, ;
			lcFullPath, ;
			laSessions[1], ;
			lnSessions, ;
			lnSession, ;
			laTables[1], ;
			lnTables, ;
			lnI, ;
			lcTable
		lnDataSession = set('DATASESSION')
		lcFile        = upper(tcFile)
		lcFullPath    = set('FULLPATH')
		set fullpath on
		
		* Close any open instances of the table in private datasessions.
		
		#if version(5) >= 700
		lnSessions = asessions(laSessions)
		for lnSession = lnSessions to 1 step -1
			set datasession to laSessions[lnSession]
			lnTables = aused(laTables)
			for lnI = 1 to lnTables
				lcTable = laTables[lnI, 1]
				if dbf(lcTable) == lcFile or lcTable == lcFile
					use in (lcTable)
				endif dbf(lcTable) == lcFile ...
			next lnI
		next lnSession
		#else
		lnSessions = _screen.FormCount
		for lnSession = 1 to lnSessions
			if _screen.Forms[lnSession].DataSessionID <> 1
				set datasession to _screen.Forms[lnSession].DataSessionID
				lnTables = aused(laTables)
				for lnI = 1 to lnTables
					lcTable = laTables[lnI, 1]
					if dbf(lcTable) == lcFile or lcTable == lcFile
						use in (lcTable)
					endif dbf(lcTable) == lcFile ...
				next lnI
			endif _screen.Forms[lnSession].DataSessionID <> 1
		next lnSession
		
		* Close any instances in the default datasession.
		
		set datasession to 1
		lnTables = aused(laTables)
		for lnI = 1 to lnTables
			lcTable = laTables[lnI, 1]
			if dbf(lcTable) == lcFile or lcTable == lcFile
				use in (lcTable)
			endif dbf(lcTable) == lcFile ...
		next lnI
		#endif
		set datasession to lnDataSession
		
		* Restore things before we exit.
		
		if lcFullPath = 'OFF'
			set fullpath off
		endif lcFullPath = 'OFF'
		return
		
	ENDPROC

	PROCEDURE convertdbcxmeta
		*==============================================================================
		* Method:			ConvertDBCXMeta
		* Status:			Public
		* Purpose:			Converts the DBCX meta table to a new structure
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Copyright:		(c) 1999-2001 Stonefield Systems Group Inc.
		* Last revision:	04/25/2001
		* Parameters:		none
		* Returns:			.T. if it succeeded
		* Environment in:	the DBCX registry table must be open
		* Environment out:	SDTMETA's structure is updated
		*==============================================================================
		
		local llSuccess, ;
			lnSelect, ;
			lcColumn, ;
			llAddFilter, ;
			lcSDTMeta, ;
			lcCollate, ;
			lcPath
		with This
		
		* See if the structure needed to be converted. If so, display a message and
		* open our meta data table exclusively.
		
			llSuccess = .T.
			if .CheckDBCXMeta()
				wait window strtran(ccMSG_CONVERTING, ccMSG_INSERT1, .cDBCXAlias) ;
					nowait
				if used(.cDBCXAlias)
					use in (.cDBCXAlias)
				endif used(.cDBCXAlias)
				if used(.cMetaAlias)
					use in (.cMetaAlias)
				endif used(.cMetaAlias)
				llSuccess = .OpenDBCXMeta(.T.)
				if llSuccess
					lnSelect = select()
					select (.cDBCXAlias)
		
		* Update SDT 3.0 structure: add the columns found in the 5.0 structure.
		
					if type('REPLINK') = 'U'
						lcColumn = iif(type('RECTYPE') = 'U', ;
							' add column RECTYPE C(1)', '')
						alter table (.cDBCXAlias) ;
							add column REPLINK L ;
							add column REPLINKFLD C(cnVF_LONGNAME_LENGTH) ;
							add column BLOCKSIZE N(5) ;
							&lcColumn
						if not empty(lcColumn) and file(.Parent.cRegistryPath + ;
							'CDBKMETA.DBF')
							use (.Parent.cRegistryPath + 'CDBKMETA') order IID again ;
								shared in 0
							select (.cDBCXAlias)
							set relation to IID into CDBKMETA
							replace all RECTYPE with iif(CDBKMETA.CRECTYPE = 'C' and ;
								not empty(CDBKMETA.CTYPE), CDBKMETA.CTYPE, ;
								CDBKMETA.CRECTYPE)
							use in CDBKMETA
						endif not empty(lcColumn) ...
		
		* Cleanup RECTYPE for tables and views and update indexes
		
						replace for RECTYPE = 'C' ;
							RECTYPE with iif(indbc(trim(OBJECTNAME), 'Table'), 'T', ;
							'V')
		
		* Remove the SDT "AutoSize" properties.
		
						if type('AUTOLIB') <> 'U'
							alter table (.cDBCXAlias) ;
								drop column AUTOCLASS ;
								drop column AUTOLIB ;
								drop column AUTOPREFIX ;
								drop column AUTOLABEL
						endif type('AUTOLIB') <> 'U'
		
		* Add former standard properties as extended properties.
		
						insert into SDTUSER values ;
							('Labels', 'F', 'LABELS', 'L', 1, 0)
						insert into SDTUSER values ;
							('Merge', 'F', 'MERGE', 'L', 1, 0)
						insert into SDTUSER values ;
							('Related Reports', 'F', 'RELREPORTS', 'L', 1, 0)
						insert into SDTUSER values ;
							('Reports', 'F', 'REPORTS', 'L', 1, 0)
						insert into SDTUSER values ;
							('Sort', 'F', 'SORT', 'L', 1, 0)
						insert into SDTUSER values ;
							('Auto Filter', 'F', 'AUTOFILT', 'M', 4, 0)
						insert into SDTUSER values ;
							('Auto SQL', 'F', 'AUTOSQL', 'M', 4, 0)
					endif type('REPLINK') = 'U'
		
		* Update SDT 5.0 structure.
		
					alter table (.cDBCXAlias) ;
						add column DBCName C(119) ;
						add column TableType C(3) ;
						add column Updated T ;
						add column UseVD L ;
						alter column ObjectName C(120)
					llAddFilter = type(.cDBCXAlias + '.Filter') = 'U'
					if llAddFilter
						alter table (.cDBCXAlias) ;
							add column Filter L
						replace Filter with .T. for RecType $ 'TVF'
					endif llAddFilter
					replace all DBCName with lower(juststem(DBCPath)), ;
						Updated with datetime()
					replace UseVD with .T. for RecType = 'V'
					replace ObjectName with lower(ObjectName) for RecType <> 'D'
					replace ObjectName with DBCName for RecType = 'D'
					replace RecType with 'R' for RecType = 'J'
		
		* Find the matching CoreMeta record and set certain properties.
		
					lcSDTMeta = .cDBCXAlias
					scan for seek(upper(padr(&lcSDTMeta..DBCName, ;
						len(CoreMeta.cDBCName)) + &lcSDTMeta..RecType + ;
						padr(&lcSDTMeta..ObjectName, len(CoreMeta.cObjectNam))), ;
						'CoreMeta', 'ObjectName')
						replace cCaption with iif(empty(&lcSDTMeta..Caption), ;
							CoreMeta.cCaption, &lcSDTMeta..Caption), ;
							mComment with &lcSDTMeta..Comment ;
							in CoreMeta
					endscan for seek(upper(padr(&lcSDTMeta..DBCName, ...
		
		* Set the correct object name for relations.
		
					replace for RecType = 'R' and ;
						seek(&lcSDTMeta..iID, 'CoreMeta', 'iID') ;
						ObjectName with CoreMeta.cObjectNam
		
		* Now remove fields we don't need and update the indexes.
		
					delete tag all
					alter table (.cDBCXAlias) ;
						drop column iID ;
						drop column Caption ;
						drop column CodePage ;
						drop column Collate ;
						drop column BlockSize ;
						drop column Comment ;
						drop column DBCPath ;
						drop column Extended
					lcCollate = set('COLLATE')
					set collate to 'MACHINE'
					index on upper(DBCName + RecType + ObjectName) tag ObjectName
					index on deleted() tag Deleted
		
		* Update the indexes for SDTUSER.
		
					select (.cMetaAlias)
					delete tag all
					index on upper(PROPERTY) tag PROPERTY for not deleted()
					index on FIELD_NAME tag FIELD candidate for not deleted()
					index on deleted() tag DELETED
		
		* Put the correct path to SDT.VCX in DBCXREG.
		
					= seek('STONEFIELD', .Parent.cRegistryName, 'cProdName')
					lcPath = sys(2014, upper(addbs(justpath(.ClassLibrary))), ;
						dbf(.Parent.cRegistryName))
					replace mLibPath with lcPath in (.Parent.cRegistryName)
		
		* Close the meta data tables and reopen them in shared mode.
		
					use in (.cMetaAlias)
					use in (.cDBCXAlias)
					.OpenDBCXMeta()
		
		* Cleanup and exit.
		
					if not empty(lcCollate)
						set collate to lcCollate
					endif not empty(lcCollate)
					select (lnSelect)
				endif llSuccess
				wait clear
			endif .CheckDBCXMeta()
		endwith
		return llSuccess
		
	ENDPROC

	PROTECTED PROCEDURE convertfoxtovfp		&& Converts a FoxBase or FoxPro 2.x table to VFP format
		*==============================================================================
		* Method:			ConvertFoxToVFP
		* Status:			Protected
		* Purpose:			Converts a FoxBase or FoxPro 2.x table to VFP format
		* Copyright:		(c) 1999-2001 Stonefield Systems Group Inc.
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcFile - the file to convert
		* Returns:			.T. if the conversion worked
		* Environment in:	none
		* Environment out:	the table has been converted to VFP format
		*==============================================================================
		
		lparameters tcFile
		local lcTempFile, ;
			lcDBC, ;
			llReturn, ;
			lcFPT, ;
			lcCDX, ;
			lcTempFPT
		with This
			lcTempFile = addbs(justpath(tcFile)) + .TempFile('DBF')
			lcDBC      = dbc()
			set database to
			select 0
			use (tcFile)
			llReturn = not .DidErrorOccur()
			if llReturn
				copy to (lcTempFile)
				use
				llReturn = not .DidErrorOccur()
			endif llReturn
			if llReturn
				erase (tcFile)
				lcFPT     = .GetMemoFile(tcFile)
				lcCDX     = forceext(tcFile, 'CDX')
				lcTempFPT = .GetMemoFile(lcTempFile)
				erase (lcFPT)
				erase (lcCDX)
				if .lNeedPause
					.Pause()
				endif .lNeedPause
				rename (lcTempFile) to (tcFile)
				if file(lcTempFPT)
					rename (lcTempFPT) to (lcFPT)
				endif file(lcTempFPT)
			endif llReturn
			.SetDatabase(lcDBC)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE createdbcxmeta
		*==============================================================================
		* Method:			CreateDBCXMeta
		* Status:			Public
		* Purpose:			Creates the SDT meta data tables
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Copyright:		(c) 1999-2001 Stonefield Systems Group Inc.
		* Last revision:	05/24/2001
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.Parent.cRegistryPath contains the path where the table
		*						should be created, This.cDBCXTable contains the table
		*						name, This.cDBCXAlias contains the alias,
		*						This.cMetaTable contains the name of the table for
		*						user-defined properties, and This.cMetaAlias contains
		*						its alias
		* Environment out:	the meta data tables were created
		*==============================================================================
		
		local lcMetaFile, ;
			lcUserFile, ;
			lcCollate
		with This
			lcMetaFile = .Parent.cRegistryPath + .cDBCXTable
			lcUserFile = .Parent.cRegistryPath + .cMetaTable
			if not file(lcMetaFile)
				lcCollate = set('COLLATE')
				set collate to 'MACHINE'
		
		* Create SDTUSER.
		
				create table (lcUserFile) free ;
					(PROPERTY C(128), ;
					OBJECTTYPE C(5), ;
					FIELD_NAME C(10), ;
					FIELD_TYPE C(1),;
					FIELD_LEN N(3), ;
					FIELD_DEC N(3))
				index on FIELD_NAME      tag FIELD    for not deleted() candidate
				index on upper(PROPERTY) tag PROPERTY for not deleted()
				index on deleted()       tag DELETED
				use
		
		* Create SDTMETA.
		
				create table (lcMetaFile) free ;
					(DBCNAME C(119), ;
					RECTYPE C(1), ;
					OBJECTNAME C(120), ;
					AUTOOPEN L, ;
					CANUPDATE L, ;
					NOUPDATE L, ;
					SELECT L, ;
					FILTER L, ;
					TABLETYPE C(3), ;
					PREVNAME C(10), ;
					REALNAME C(10), ;
					REPLINK L, ;
					REPLINKFLD C(128), ;
					USEVD L, ;
					UPDATED T)
				index on upper(DBCName + RecType + ObjectName) tag ObjectName
				index on deleted()  tag Deleted
				index on REPLINK    tag REPLINK
				index on REPLINKFLD tag REPLINKFLD
				use
				if not empty(lcCollate)
					set collate to lcCollate
				endif not empty(lcCollate)
			endif not file(lcMetaFile)
			use (lcMetaFile) alias (.cDBCXAlias) shared again in 0
			if cursorgetprop('Buffering', .cDBCXAlias) > 1
				cursorsetprop('Buffering', 1, .cDBCXAlias)
			endif cursorgetprop('Buffering', .cDBCXAlias) > 1
			if file(lcUserFile)
				use (lcUserFile) alias (.cMetaAlias) shared again in 0
				if cursorgetprop('Buffering', .cMetaAlias) > 1
					cursorsetprop('Buffering', 1, .cMetaAlias)
				endif cursorgetprop('Buffering', .cMetaAlias) > 1
			endif file(lcUserFile)
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE createtempdbc		&& Create a temporary database that contains the stored procedures of the current one.
		*==============================================================================
		* Method:			CreateTempDBC
		* Status:			Protected
		* Purpose:			Creates a temporary database with the same stored
		*						procedures of the original database whose name is
		*						passed as a parameter. The stored procedures are needed
		*						to ensure the validation rules work for tables
		* Author:			Doug Hennig
		* Copyright:		(c) 1995-2005 Stonefield Systems Group Inc.
		* Last Revision:	03/22/2005
		* Parameters:		tcDBC - the original database
		* Returns:			the name of the temporary database
		* Environment in:	none
		* Environment out:	a temporary database is created in the same directory as
		*						the original DBC
		*==============================================================================
		
		lparameters tcDBC
		local lcTempDBC, ;
			lcAlias, ;
			llSuccess, ;
			lnStart, ;
			lnElapsed
		with This
		
		* Create a temporary DBC.
		
			lcTempDBC = addbs(justpath(tcDBC)) + .TempFile()
			create database (lcTempDBC)
			close database
			select 0
			if .lNeedPause
				.Pause()
			endif .lNeedPause
			use (lcTempDBC + '.DBC') exclusive
			if cursorgetprop('Buffering') > 1
				cursorsetprop('Buffering', 1)
			endif cursorgetprop('Buffering') > 1
			zap
		
		* Append the stored procedures from the desired DBC. We'll append from a cursor
		* containing the stored procedures rather than directly from the DBC because
		* this seems to be faster under some conditions. Also, we'll open the DBC first
		* because if it has a name that doesn't match an alias (such as "#Smart"), we
		* wouldn't know what alias was used otherwise.
		
			lnSelect = select()
			select 0
			use (tcDBC) again shared
			lcAlias = alias()
			select * from (lcAlias) where OBJECTTYPE = ccVF_OBJ_DATABASE ;
				into cursor StoredProcCursor nofilter
			select (lnSelect)
			append from dbf('StoredProcCursor')
			use in StoredProcCursor
			use
			use in (lcAlias)
		
		* This is a workaround for a caching problem on some systems: although the
		* temporary database has been created, it may not have hit the disk yet, which
		* causes a problem later. Putting a bit of a pause it here allows the database
		* to be written to the disk before we actually try to use it.
		
			if .lNeedPause
				flush
				.Pause()
			endif .lNeedPause
		
		* Open the temporary DBC. We'll try in a loop to ensure caching catches up.
		
			lnStart   = seconds()
			lnElapsed = seconds() - lnStart
			do while not llSuccess and lnElapsed <= .nWaitToOpenTime
				open database (lcTempDBC) exclusive
				llSuccess = dbused(lcTempDBC)  
				if .lNeedPause
					flush
					.Pause()
				endif .lNeedPause
				lnElapsed = seconds() - lnStart
			enddo while not llSuccess ...
			if not llSuccess
				.Error(error(), 'CREATETEMPDBC', 0)
			endif not llSuccess
		endwith
		return lcTempDBC
		
	ENDPROC

	PROCEDURE createviewindex		&& Creates the specified view index
		*==============================================================================
		* Method:			CreateViewIndex
		* Status:			Public
		* Purpose:			Create a single index defined in the meta data for a view
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/19/2001
		* Parameters:		tcView        - the name of the view. tcView can include a
		*						database by specifying <database>!<view>
		*					tcTag         - the name of the tag to create
		*					tnDataSession - the datasession the view is open in
		*						(optional: datasession 1 is used if it isn't passed)
		*					tcAlias       - the alias the view is open with (optional:
		*						if it isn't passed, the default alias is used)
		* Returns:			.T. if the tag was created
		* Environment in:	the meta tables are open
		* Environment out:	if CreateViewIndex returns .T., the tag was created
		*==============================================================================
		
		lparameters tcView, ;
			tcTag, ;
			tnDataSession, ;
			tcAlias
		local llReturn, ;
			lnCurrDataSession, ;
			lnDataSession, ;
			lcDBC, ;
			lcView, ;
			lcAlias, ;
			lnSelect, ;
			lcTag, ;
			lcExpr, ;
			lcFor, ;
			lnBuffering
		with This
		
		* Ensure the parameters are valid.
		
			if vartype(tcView) <> 'C' or empty(tcView) or vartype(tcTag) <> 'C' or ;
				empty(tcTag)
				.Warning(ccERR_INVALID_PARAMETERS)
				return .F.
			endif vartype(tcView) <> 'C' ...
		
		* Figure out which datasessions we'll use.
		
			lnCurrDataSession = set('DATASESSION')
			lnDataSession     = iif(vartype(tnDataSession) = 'N' and ;
				tnDataSession <> 0, tnDataSession, 1)
		
		* Ensure the view is open, then select it.
		
			set datasession to lnDataSession
			lcDBC   = .Parent.GetDatabase(tcView)
			lcView  = .Parent.StripDatabase(tcView)
			lcAlias = iif(vartype(tcAlias) = 'C' and not empty(tcAlias), tcAlias, ;
				lcView)
			lcAlias = strtran(lcAlias, ' ', '_')
			if used(lcAlias)
				lnSelect = select()
				select (lcAlias)
		
		* Get the index information.
		
				set datasession to lnCurrDataSession
				lcTag  = .GetObjectName(tcTag)
				lcExpr = .Parent.DBCXGetProp(lcDBC + '!' + lcView + '.' + lcTag, ;
					'Index', 'CBmTagExpr')
				lcFor  = .Parent.DBCXGetProp('CBmTagFilter')
				if not isnull(lcExpr)
		
		* Turn off table buffering if it's set because we can't create indexes when
		* it's on.
		
					set datasession to lnDataSession
					lnBuffering = cursorgetprop('Buffering')
					if lnBuffering <> DB_BUFOPTRECORD
						cursorsetprop('Buffering', DB_BUFOPTRECORD)
					endif lnBuffering <> DB_BUFOPTRECORD
		
		* Create the index if the information is valid. Give an error if not.
		
					.lTestingIndex = .T.
					luExprValue = evaluate(lcExpr)
					if not empty(lcFor)
						luForValue = evaluate(lcFor)
					endif not empty(lcFor)
					.lTestingIndex = .F.
					llReturn = not .lIndexError and vartype(luExprValue) <> 'U' and ;
						(empty(lcFor) or vartype(luForValue) = 'L')
					.lIndexError = .F.
					if llReturn
						lcFor = iif(empty(lcFor), '', 'for ' + lcFor)
						index on &lcExpr &lcFor tag (lcTag)
						llReturn = tagno(lcTag) > 0
					endif llReturn
					if not llReturn
						.Warning(strtran(ccERR_INDEX_INVALID, ccMSG_INSERT1, lcTag))
					endif not llReturn
		
		* Reset the buffering mode, former workarea, and datasession.
		
					if lnBuffering <> DB_BUFOPTRECORD
						cursorsetprop('Buffering', lnBuffering)
					endif lnBuffering <> DB_BUFOPTRECORD
					select (lnSelect)
					set datasession to lnCurrDataSession
		
		* We can't find the tag in the meta data.
		
				else
					.Warning(strtran(ccERR_TAG_NOT_FOUND, ccMSG_INSERT1, lcTag))
				endif not isnull(lcExpr)
		
		* The view isn't open.
		
			else
				.Warning(strtran(ccERR_TABLE_NOT_OPEN, ccMSG_INSERT1, lcView))
			endif used(lcView)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE createviewindexes		&& Creates all the defined indexes for a view
		*==============================================================================
		* Method:			CreateViewIndexes
		* Status:			Public
		* Purpose:			Create the indexes defined in the meta data for a view
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last Revision:	10/15/2004
		* Parameters:		tcView        - the name of the view. tcView can include a
		*						database by specifying <database>!<view>
		*					tnDataSession - the datasession to open the table in
		*						(optional: datasession 1 is used if it isn't passed)
		*					tcAlias       - the alias the view is open with (optional:
		*						if it isn't passed, the default alias is used)
		* Returns:			.T. if the view's indexes were all created
		* Environment in:	the meta tables are open
		* Environment out:	if CreateViewIndexes returns .T., all the indexes for the
		*						view were created
		*==============================================================================
		
		lparameters tcView, ;
			tnDataSession, ;
			tcAlias
		local llReturn, ;
			lcDBC, ;
			lcView, ;
			laTags[1], ;
			lnTags, ;
			lnI
		with This
		
		* Ensure the parameters are valid.
		
			if vartype(tcView) <> 'C' or empty(tcView)
				.Warning(ccERR_INVALID_PARAMETERS)
				return .F.
			endif vartype(tcView) <> 'C' ...
		
		* Get a list of the tags for the view, then call CreateViewIndex to create
		* them.
		
			lcDBC  = .Parent.GetDatabase(tcView)
			lcView = .Parent.StripDatabase(tcView)
			lnTags = .Parent.DBCXGetAllObjects(lcDBC + '!' + 'Index ' + lcView, ;
				@laTags)
			for lnI = 1 to lnTags
				llReturn = .CreateViewIndex(tcView, laTags[lnI], tnDataSession, ;
					tcAlias)
				if not llReturn
					exit
				endif not llReturn
			next lnI
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcdeleteprop		&& Deletes a property from the PROPERTY memo of the current DBC record
		*==============================================================================
		* Method:			DBCDeleteProp
		* Status:			Public
		* Purpose:			Deletes a property from the PROPERTY memo of a DBC
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tnID          - the ID for the desired property
		*					tcDBCAlias    - the alias of the open DBC (optional: if it
		*						isn't passed, the current table must be the DBC)
		*					tnDataSession - the datasession the database is open in
		*						(optional: the current datasession is used if it isn't
		*						passed)
		* Returns:			.T. if everything is OK, or .F. if not
		* Environment in:	the DBC must be selected if tcDBCAlias isn't passed, and
		*						positioned to the desired record
		* Environment out:	the property has been deleted if it existed
		*==============================================================================
		
		lparameters tnID, ;
			tcDBCAlias, ;
			tnDataSession
		local llReturn, ;
			lnCurrDataSession, ;
			lnCurrSelect, ;
			llDone, ;
			lnPos, ;
			lcLength, ;
			lnLength, ;
			lnIDLength, ;
			lnIDCode
		with This
		
		* Save the current datasession and change datasessions if necessary.
		
			lnCurrDataSession = set('DATASESSION')
			if vartype(tnDataSession) = 'N' and tnDataSession <> 0 and ;
				tnDataSession <> lnCurrDataSession
				set datasession to tnDataSession
			endif vartype(tnDataSession) = 'N' ...
		
		* If the DBC alias is passed, save the current work area and select it.
		
			lnCurrSelect = select()
			if vartype(tcDBCAlias) = 'C' and not empty(tcDBCAlias) and used(tcDBCAlias)
				select (tcDBCAlias)
			endif vartype(tcDBCAlias) = 'C' ...
		
		* Ensure the DBC is open as a table.
		
			if right(dbf(), 3) <> 'DBC' or type(alias() + '.ObjectType') <> 'C'
				.Warning(ccERR_DBC_NOT_OPEN)
				select (lnCurrSelect)
		
		* Try to locate the desired property by looking at all properties one at a
		* time until we find it.
		
			else
				llDone = .F.
				lnPos  = 1
				do while not llDone
		
		* Get the length of this property.
		
					lcLength = substr(PROPERTY, lnPos, 4)
					lnLength = .Hex2Decimal(lcLength)
		
		* Get the length of the property ID.
		
					lcLength   = substr(PROPERTY, lnPos + 4, 2)
					lnIDLength = .Hex2Decimal(lcLength)
		
		* Get the property ID.
		
					lcLength = substr(PROPERTY, lnPos + 6, lnIDLength)
					lnIDCode = .Hex2Decimal(lcLength)
		
		* If this is the property we want, replace the current property value with the
		* new one and flag that we're done.
		
					if lnIDCode = tnID
						replace PROPERTY with stuff(PROPERTY, lnPos, lnLength, '')
						llDone   = .T.
						llReturn = .T.
		
		* Move the pointer to the next property. If we're out of properties, we're
		* done checking.
		
					else
						lnPos = lnPos + lnLength
						if lnPos > len(PROPERTY)
							llDone = .T.
						endif lnPos > len(PROPERTY)
					endif lnIDCode = tnID
				enddo while not llDone
			endif right(dbf(), 3) <> 'DBC' ...
		
		* Restore the datasession if necessary.
		
			if vartype(tnDataSession) = 'N' and tnDataSession <> 0 and ;
				tnDataSession <> lnCurrDataSession
				set datasession to lnCurrDataSession
			endif vartype(tnDataSession) = 'N' ...
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcfindobject		&& Finds an object's record in a DBC.
		*==============================================================================
		* Function:			DBCFindObject
		* Status:			Public
		* Purpose:			Position the DBC table to the record for an abject
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName - the name of the object
		*					tcObjectType - the object's type (must match one of the
		*						types stored in the DBC)
		*					tcDBCAlias   - the alias of the open DBC (optional: if it
		*						isn't passed, the current table must be the DBC)
		*					tnDataSession - the datasession the database is open in
		*						(optional: the current datasession is used if it isn't
		*						passed)
		* Returns:			.T. if the object could be found
		* Environment in:	the DBC must be open and selected
		* Environment out:	if the specified object could be found, the DBC is
		*						positioned to the object's record
		*					if not, the DBC's record pointer isn't changed
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcDBCAlias, ;
			tnDataSession
		local lnCurrDataSession, ;
			lnCurrSelect, ;
			llReturn, ;
			lnRecno, ;
			lcObjectType, ;
			lcAlias, ;
			lcObject
		with This
		
		* Save the current datasession and change datasessions if necessary.
		
			lnCurrDataSession = set('DATASESSION')
			if vartype(tnDataSession) = 'N' and tnDataSession <> 0 and ;
				tnDataSession <> lnCurrDataSession
				set datasession to tnDataSession
			endif vartype(tnDataSession) = 'N' ...
		
		* If the DBC alias is passed, save the current work area and select it.
		
			lnCurrSelect = select()
			if vartype(tcDBCAlias) = 'C' and not empty(tcDBCAlias) and used(tcDBCAlias)
				select (tcDBCAlias)
			endif vartype(tcDBCAlias) = 'C' ...
		
		* Ensure the DBC is open as a table (if not, return .F.). Save its current
		* record pointer.
		
			if right(dbf(), 3) <> 'DBC' or type(alias() + '.ObjectType') <> 'C'
				.Warning(ccERR_DBC_NOT_OPEN)
				select (lnCurrSelect)
				llReturn = .F.
		
		* If the object name has an alias, let's split the name into alias and object.
		
			else
				lnRecno      = recno()
				lcObjectType = padr(proper(tcObjectType),         fsize('ObjectType'))
				lcAlias      = padr(.GetParentName(tcObjectName), fsize('ObjectName'))
				lcObject     = padr(.GetObjectName(tcObjectName), fsize('ObjectName'))
				do case
		
		* Look for a database, table, view, or connection by SEEKing for the object
		* with the database as the parent.
		
					case inlist(trim(lcObjectType), 'Database', 'Table', 'View', ;
						'Connection')
						llReturn = seek(str(cnVF_OBJID_DATABASE) + lcObjectType + ;
							lcObject, alias(), 'ObjectName')
		
		* Look for an index or relation by finding the parent table first, then using
		* it to find the object.
		
					case inlist(trim(lcObjectType), 'Index', 'Relation')
						llReturn = seek(str(cnVF_OBJID_DATABASE) + ;
							padr('Table', fsize('ObjectType')) + lcAlias, alias(), ;
							'ObjectName') and seek(str(ObjectID) + lcObjectType + ;
							lcObject, alias(), 'ObjectName')
		
		* Look for a field by finding the parent (which could be a table or a view)
		* first, then using it to find the object.
		
					case trim(lcObjectType) == 'Field'
						llReturn = (seek(str(cnVF_OBJID_DATABASE) + ;
							padr('Table', fsize('ObjectType')) + lcAlias, alias(), ;
							'ObjectName') or seek(str(1) + padr('View', ;
							fsize('ObjectType')) + lcAlias, alias(), 'ObjectName')) and ;
							seek(str(ObjectID) + lcObjectType + lcObject, alias(), ;
							'ObjectName')
		
		* The object type passed isn't recognized.
		
					otherwise
						.Warning(strtran(ccERR_INVALID_OBJECT_TYPE, ccMSG_INSERT1, ;
							tcObjectType))
						llReturn = .F.
				endcase
		
		* If we didn't find the object, return the DBC record pointer to its former
		* value.
		
				if not llReturn and between(lnRecno, 1, reccount())
					go lnRecno
				endif not llReturn ...
			endif right(dbf(), 3) <> 'DBC' ...
		
		* Clean up before we exit.
		
			select (lnCurrSelect)
			if vartype(tnDataSession) = 'N' and tnDataSession <> 0 and ;
				tnDataSession <> lnCurrDataSession
				set datasession to lnCurrDataSession
			endif vartype(tnDataSession) = 'N' ...
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcgetcdxstructure		&& Get the structure for a table's indexes from the DBC and DBCX and place it into an array.
		*==============================================================================
		* Method:			DBCGetCDXStructure
		* Status:			Protected
		* Purpose:			Put the structure for a table's indexes as defined in the
		*						meta data into an array
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	03/19/2004
		* Parameters:		tcAlias   - the file to get the indexes for
		*					taIndexes - the array to put the indexes into
		*					tlFree    - .T. if this is a free table
		* Returns:			the number of indexes found for the table
		* Environment In:	all meta tables are open
		* Environment Out:	if any indexes are defined for the table, taIndexes will
		*						contain the structure of the indexes with following
		*						columns:
		*						1 = tag name
		*						2 = index expression
		*						3 = filter expression
		*						4 = collate sequence
		*						5 = index type (U = unique, R = regular, P = primary,
		*							B = binary, and C = candidate)
		*						6 = .T. if ascending
		*					if no indexes are defined, taIndexes will consist of a
		*						single blank row
		*==============================================================================
		
		lparameters tcAlias, ;
			taIndexes, ;
			tlFree
		local lcDBC, ;
			lcAlias, ;
			lnPos, ;
			lnIndexes, ;
			lnI
		with This
		
		* Get a list of all indexes for this table from the meta data.
		
			lcDBC   = upper(padr(.Parent.GetDatabase(tcAlias), len(CoreMeta.cDBCName)))
			lcAlias = upper(.Parent.StripDatabase(tcAlias))
			lnPos   = len(lcAlias) + 2
			select substr(cObjectNam, lnPos), ;
					mTagExpr, ;
					mTagFilter, ;
					cCollate, ;
					cTagType, ;
					CoreMeta.lAscending ;
				from CoreMeta ;
				where upper(cDBCName + cRecType + cObjectNam) = lcDBC + 'I' + ;
						lcAlias + '.' and ;
					not deleted() ;
				into array taIndexes
			lnIndexes = iif(empty(taIndexes[1]), 0, alen(taIndexes, 1))
			if lnIndexes > 0
				for lnI = 1 to lnIndexes
					taIndexes[lnI, 1] = upper(trim(taIndexes[lnI, 1]))
					if taIndexes[lnI, 2] = 'PHD('
						taIndexes[lnI, 2] = upper(strtran(taIndexes[lnI, 2], "'", '"'))
					else
						taIndexes[lnI, 2] = normalize(taIndexes[lnI, 2])
					endif taIndexes[lnI, 2] = 'PHD('
					taIndexes[lnI, 3] = iif(empty(taIndexes[lnI, 3]), '', ;
						normalize(taIndexes[lnI, 3]))
					taIndexes[lnI, 4] = iif(empty(taIndexes[lnI, 4]), set('COLLATE'), ;
						trim(taIndexes[lnI, 4]))
				next lnI
			else
				dimension taIndexes[1, 6]
				taIndexes = ''
				taIndexes[1, 6] = .F.
			endif lnIndexes > 0
		endwith
		return lnIndexes
		
	ENDPROC

	PROCEDURE dbcgetfield		&& Returns the value from a certain field in the DBC.
		*==============================================================================
		* Function:			DBCGetField
		* Status:			Public
		* Purpose:			Get a particular field for an object from the DBC
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName  - the name of the object
		*					tcObjectType  - the object's type (must match one of the
		*						types stored in the DBC)
		*					tcField       - the field from the DBC to return (must
		*						match the name of a field in the DBC)
		*					tcDBCAlias    - the alias of the open DBC (optional: if it
		*						isn't passed, the current table must be the DBC)
		*					tnDataSession - the datasession the database is open in
		*						(optional: the current datasession is used if it isn't
		*						passed)
		* Returns:			the contents of the specified field in the DBC for the
		*						object if the object was found and the field exists,
		*						or .NULL. if not
		* Environment in:	see DBCFindObject()
		* Environment out:	see DBCFindObject()
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcField, ;
			tcDBCAlias, ;
			tnDataSession
		local lnCurrDataSession, ;
			lcAlias, ;
			luReturn
		
		* Save the current datasession and change datasessions if necessary.
		
		lnCurrDataSession = set('DATASESSION')
		if vartype(tnDataSession) = 'N' and tnDataSession <> 0 and ;
			tnDataSession <> lnCurrDataSession
			set datasession to tnDataSession
		endif vartype(tnDataSession) = 'N' ...
		
		* If the DBC alias is passed, use it. Otherwise, use the current alias.
		
		with This
			lcAlias = iif(vartype(tcDBCAlias) = 'C' and not empty(tcDBCAlias) and ;
				used(tcDBCAlias), tcDBCAlias, alias())
			do case
				case not .DBCFindObject(tcObjectName, tcObjectType, tcDBCAlias, ;
					tnDataSession)
					luReturn = .NULL.
				case type(lcAlias + '.' + tcField) <> 'U'
					luReturn = evaluate(lcAlias + '.' + tcField)
				otherwise
					.Warning(strtran(ccERR_INVALID_PROPERTY, ccMSG_INSERT1, tcField))
					luReturn = .NULL.
			endcase
		endwith
		
		* Restore the datasession if necessary.
		
		if vartype(tnDataSession) = 'N' and tnDataSession <> 0 and ;
			tnDataSession <> lnCurrDataSession
			set datasession to lnCurrDataSession
		endif vartype(tnDataSession) = 'N' ...
		return luReturn
		
	ENDPROC

	PROCEDURE dbcgetprop		&& A method to get a value for a given property from the DBC PROPERTY field.
		*==============================================================================
		* Method:			DBCGetProp
		* Status:			Public
		* Purpose:			Get the specified property from the DBC PROPERTY field
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tnID          - the ID for the desired property
		*					tcDBCAlias    - the alias of the open DBC (optional: if it
		*						isn't passed, the current table must be the DBC)
		*					tnDataSession - the datasession the database is open in
		*						(optional: the current datasession is used if it isn't
		*						passed)
		* Returns:			the value of the specified property if it's found or .NULL.
		*						if not
		* Environment in:	the DBC must be selected if tcDBCAlias isn't passed, and
		*						positioned to the desired record
		* Environment out:	none
		*==============================================================================
		
		lparameters tnID, ;
			tcDBCAlias, ;
			tnDataSession
		local lnCurrDataSession, ;
			lnCurrSelect, ;
			lcReturn, ;
			llDone, ;
			lnPos, ;
			lcLength, ;
			lnLength, ;
			lnIDLength, ;
			lnIDCode
		with This
		
		* Save the current datasession and change datasessions if necessary.
		
			lnCurrDataSession = set('DATASESSION')
			if vartype(tnDataSession) = 'N' and tnDataSession <> 0 and ;
				tnDataSession <> lnCurrDataSession
				set datasession to tnDataSession
			endif vartype(tnDataSession) = 'N' ...
		
		* If the DBC alias is passed, save the current work area and select it.
		
			lnCurrSelect = select()
			if vartype(tcDBCAlias) = 'C' and not empty(tcDBCAlias) and used(tcDBCAlias)
				select (tcDBCAlias)
			endif vartype(tcDBCAlias) = 'C' ...
		
		* Ensure the DBC is open as a table.
		
			if right(dbf(), 3) <> 'DBC' or type(alias() + '.ObjectType') <> 'C'
				.Warning(ccERR_DBC_NOT_OPEN)
				select (lnCurrSelect)
				lcReturn = .NULL.
		
		* Try to locate the desired property by looking at all properties one at a
		* time until we find it.
		
			else
				llDone = .F.
				lnPos  = 1
				do while not llDone
		
		* Get the length of this property.
		
					lcLength = substr(PROPERTY, lnPos, 4)
					lnLength = .Hex2Decimal(lcLength)
		
		* Get the length of the property ID.
		
					lcLength   = substr(PROPERTY, lnPos + 4, 2)
					lnIDLength = .Hex2Decimal(lcLength)
		
		* Get the property ID.
		
					lcLength = substr(PROPERTY, lnPos + 6, lnIDLength)
					lnIDCode = .Hex2Decimal(lcLength)
		
		* If this is the property we want, get the value and strip off the trailing
		* null if there is one.
		
					if lnIDCode = tnID
						lcReturn = substr(PROPERTY, lnPos + lnIDLength + 6, ;
							lnLength - lnIDLength - 6)
						lcReturn = iif(len(lcReturn) > 1 and ;
							right(lcReturn, 1) = ccNULL, ;
							left(lcReturn, len(lcReturn) - 1), lcReturn)
						llDone   = .T.
		
		* Move the pointer to the next property. If we're out of properties, we're
		* done checking.
		
					else
						lnPos = lnPos + lnLength
						if lnPos > len(PROPERTY)
							lcReturn = .NULL.
							llDone   = .T.
						endif lnPos > len(PROPERTY)
					endif lnIDCode = tnID
				enddo while not llDone
			endif right(dbf(), 3) <> 'DBC' ...
		
		* Restore the datasession if necessary.
		
			if vartype(tnDataSession) = 'N' and tnDataSession <> 0 and ;
				tnDataSession <> lnCurrDataSession
				set datasession to lnCurrDataSession
			endif vartype(tnDataSession) = 'N' ...
		endwith
		return lcReturn
		
	ENDPROC

	PROCEDURE dbcgettablestructure		&& A method to get the structure of a table from its records in the DBC and DBCX.
		*==============================================================================
		* Method:			DBCGetTableStructure
		* Status:			Public
		* Purpose:			Put the structure for a table as defined in the DBC and
		*						DBCX into an array
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2018 Stonefield Systems Group Inc.
		* Last revision:	03/02/2018
		* Parameters:		tcAlias  - the table to get the structure for
		*					taTable  - the array to store the structure in
		*					tlCreate - .T. if we're creating the table
		* Returns:			the number of rows in the array or 0 if it failed
		* Environment in:	all meta tables are open
		* Environment out:	taTable contains the structure of the table in AFIELDS
		*						format, except for two additional columns: 19, which
		*						contains the previous name of the field, and 20, which
		*						contains the long name of the field (column 1 contains
		*						the name as it appears in the DBF header)
		*==============================================================================
		
		lparameters tcAlias, ;
			taTable, ;
			tlCreate
		external array taTable
		local lcDBC, ;
			lcAlias, ;
			lcStepField, ;
			lcNextField, ;
			lcCollate, ;
			laFields[1], ;
			lnFields, ;
			lnI, ;
			lcField, ;
			luValue
		
		* Get a list of all fields for this table from the meta data.
		
		with This
			if '!' $ tcAlias
				lcDBC   = .Parent.GetDatabase(tcAlias)
				lcAlias = upper(.Parent.StripDatabase(tcAlias))
			else
				lcDBC   = .Parent.cCurrentDBC
				lcAlias = upper(tcAlias)
			endif '!' $ tcAlias
			do case
				case empty(lcDBC)
				case dbused(lcDBC)
					.SetDatabase(lcDBC)
				otherwise
					.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
					return .F.
			endcase
			lcDBC       = upper(padr(juststem(lcDBC), len(CoreMeta.cDBCName)))
			lcStepField = iif(type('CoreMeta.nStepValue') = 'U', '0 as nStepValue', ;
				'nStepValue')
			lcNextField = iif(type('CoreMeta.nNextValue') = 'U', '0 as nNextValue', ;
				'nNextValue')
			lcCollate = set('COLLATE')
			set collate to 'MACHINE'
			select SDTMeta.RealName, ;
					cType, ;
					nSize, ;
					nDecimals, ;
					lNull, ;
					lBinary, ;
					'', ;
					'', ;
					'', ;
					'', ;
					'', ;
					'', ;
					'', ;
					'', ;
					'', ;
					'', ;
					&lcNextField, ;
					&lcStepField, ;
					SDTMeta.PrevName, ;
					cObjectNam ;
				from CoreMeta ;
					join SDTMeta ;
						on upper(CoreMeta.cDBCName + CoreMeta.cRecType + ;
							CoreMeta.cObjectNam) = upper(SDTMeta.DBCName + ;
							SDTMeta.RecType + SDTMeta.ObjectName) ;
				where upper(cDBCName + cRecType + cObjectNam) = lcDBC + 'F' + ;
						lcAlias + '.' ;
				into array taTable ;
				order by nField
			set collate to lcCollate
			lnFields = iif(empty(taTable[1]), 0, alen(taTable, 1))
			if lnFields > 0
		
		* Trim the field names.
		
				for lnI = 1 to lnFields
					taTable[lnI,  1] = trim(taTable[lnI,  1])
					taTable[lnI, 19] = trim(taTable[lnI, 19])
					taTable[lnI, 20] = trim(taTable[lnI, 20])
		
		* If this isn't a free table, get some properties from the DBC.
		
					do case
						case not empty(lcDBC)
							lcField = taTable[lnI, 20]
							taTable[lnI, 7] = dbgetprop(lcField, 'Field', 'RuleExpression')
							taTable[lnI, 8] = dbgetprop(lcField, 'Field', 'RuleText')
							taTable[lnI, 9] = dbgetprop(lcField, 'Field', 'DefaultValue')
							if lnI = 1
								taTable[lnI, 10] = dbgetprop(lcAlias, 'Table', ;
									'RuleExpression')
								taTable[lnI, 11] = dbgetprop(lcAlias, 'Table', 'RuleText')
							endif lnI = 1
		
		* If it is a free table and we're updating it, see if we have a DEFAULT
		* extended property. If so, use it for the default value when adding the field.
		
						case not tlCreate
							luValue = This.Parent.DBCXGetProp(taTable[lnI, 20], 'Field', ;
								'SDTDefault')
							if not This.Parent.lErrorOccurred
								taTable[lnI, 9] = luValue
							endif not This.Parent.lErrorOccurred
							This.Parent.lErrorOccurred = .F.
					endcase
				next lnI
		
		* We don't have any fields for the specified table
		
			else
				.Warning(strtran(strtran(ccERR_NO_EXTENSIONS, ccMSG_INSERT1, ;
					lcAlias), ccMSG_INSERT2, 'No fields'))
			endif lnFields > 0
		endwith
		return lnFields
		
	ENDPROC

	PROCEDURE dbcopen		&& Opens a DBC as a table.
		*==============================================================================
		* Method:			DBCOpen
		* Status:			Public
		* Purpose:			Opens the DBC as a table
		* Author:			Doug Hennig
		* Copyright:		(c) 1995-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcDBC   - the path and filename of the DBC (optional: if it
		*						isn't passed, the current DBC is used)
		*					tcAlias - the alias to use (optional: if it isn't passed,
		*						the name of the DBC is used)
		*					tnDataSession - the datasession to use (optional: if it
		*						isn't specified, the current datasession is used)
		* Returns:			the alias used or empty if it couldn't be opened
		* Environment in:	none
		* Environment out:	if the DBC can be found and opened, it's the selected
		*						table
		*==============================================================================
		
		lparameters tcDBC, ;
			tcAlias, ;
			tnDataSession
		local lcAlias, ;
			lnDataSession, ;
			lcDBC
		with This
		
		* Initialize the return alias as an empty string.
		
			lcAlias = ''
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
			lnDataSession = set('DATASESSION')
			if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
				set datasession to tnDataSession
			endif vartype(tnDataSession) = 'N' ...
		
		* If the database to open wasn't specified, let's use the current one.
		
			if vartype(tcDBC) <> 'C' or empty(tcDBC)
				lcDBC = This.Parent.cCurrentDBC
			else
				lcDBC = tcDBC
			endif vartype(tcDBC) <> 'C' ...
			do case
		
		* If a database wasn't specified, give an error.
		
				case empty(lcDBC)
					.Warning(ccERR_NO_DBC_SPECIFIED)
		
		* If we can't find the database, give an error.
		
				case not file(lcDBC)
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, lcDBC))
		
		* Open the database.
		
				otherwise
					do case
		
		* If no alias was specified, create a unique one.
		
						case vartype(tcAlias) <> 'C' or empty(tcAlias)
							lcAlias = sys(2015)
		
		* If there's already a cursor open with that alias, give an error.
		
						case used(tcAlias)
							.Warning(ccERR_ALIAS_IN_USE)
		
		* Use the specified alias.
		
						otherwise
							lcAlias = tcAlias
					endcase
		
		* Try to open the database as a table. If we can, ensure buffering is turned
		* off. If we can't, give an error.
		
					if not empty(lcAlias)
						select 0
						use (lcDBC) alias (lcAlias) again shared
						do case
							case not used(lcAlias)
								.Warning(strtran(ccERR_CANT_OPEN_FILE, ccMSG_INSERT1, ;
									lcDBC))
								lcAlias = ''
							case cursorgetprop('Buffering') > 1
								cursorsetprop('Buffering', 1)
						endcase
					endif not empty(lcAlias)
			endcase
		
		* Restore the former datasession if necessary.
		
			if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
				set datasession to lnDataSession
			endif vartype(tnDataSession) = 'N' ...
		endwith
		return lcAlias
		
	ENDPROC

	PROCEDURE dbcsetprop		&& A method to set a value for a given property from the DBC PROPERTY field.
		*==============================================================================
		* Method:			DBCSetProp
		* Status:			Public
		* Purpose:			Update a property in the PROPERTY field of a DBC
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tnID          - the ID for the desired property
		*					tcValue       - the value to store
		*					tcDBCAlias    - the alias of the open DBC (optional: if it
		*						isn't passed, the current table must be the DBC)
		*					tnDataSession - the datasession the database is open in
		*						(optional: the current datasession is used if it isn't
		*						passed)
		* Returns:			.T. if everything is OK, or .F. if not
		* Environment in:	the DBC must be selected if tcDBCAlias isn't passed, and
		*						positioned to the desired record
		* Environment out:	the property has been updated if it existed or added if not
		*==============================================================================
		
		lparameters tnID, ;
			tcValue, ;
			tcDBCAlias, ;
			tnDataSession
		local llReturn, ;
			lnCurrDataSession, ;
			lnCurrSelect, ;
			llDone, ;
			lnPos, ;
			llGotProp, ;
			lnValueLen, ;
			lcLength, ;
			lnLength, ;
			lnIDLength, ;
			lnIDCode
		with This
		
		* Save the current datasession and change datasessions if necessary.
		
			llReturn = .T.
			lnCurrDataSession = set('DATASESSION')
			if vartype(tnDataSession) = 'N' and tnDataSession <> 0 and ;
				tnDataSession <> lnCurrDataSession
				set datasession to tnDataSession
			endif vartype(tnDataSession) = 'N' ...
		
		* If the DBC alias is passed, save the current work area and select it.
		
			lnCurrSelect = select()
			if vartype(tcDBCAlias) = 'C' and not empty(tcDBCAlias) and used(tcDBCAlias)
				select (tcDBCAlias)
			endif vartype(tcDBCAlias) = 'C' ...
		
		* Ensure the DBC is open as a table.
		
			if right(dbf(), 3) <> 'DBC' or type(alias() + '.ObjectType') <> 'C'
				.Warning(ccERR_DBC_NOT_OPEN)
				select (lnCurrSelect)
				llReturn = .F.
		
		* Try to locate the desired property by looking at all properties one at a
		* time until we find it.
		
			else
				llDone     = .F.
				lnPos      = 1
				llGotProp  = .F.
				lnValueLen = len(tcValue)
				do while not llDone
		
		* Get the length of this property.
		
					lcLength = substr(PROPERTY, lnPos, 4)
					lnLength = .Hex2Decimal(lcLength)
		
		* Get the length of the property ID.
		
					lcLength   = substr(PROPERTY, lnPos + 4, 2)
					lnIDLength = .Hex2Decimal(lcLength)
		
		* Get the property ID.
		
					lcLength = substr(PROPERTY, lnPos + 6, lnIDLength)
					lnIDCode = .Hex2Decimal(lcLength)
		
		* If this is the property we want, replace the current property value with the
		* new one and flag that were done.
		
					if lnIDCode = tnID
						replace PROPERTY with stuff(PROPERTY, lnPos, lnLength, ;
							.Decimal2Hex(lnValueLen + lnIDLength + 6 + ;
							iif(lnValueLen = 1, 0, 1), 4) + ;
							.Decimal2Hex(lnIDLength, 2) + ;
							.Decimal2Hex(tnID, lnIDLength) + tcValue + ;
							iif(lnValueLen = 1, '', ccNULL))
						llGotProp = .T.
						llDone    = .T.
		
		* Move the pointer to the next property. If we're out of properties, we're
		* done checking.
		
					else
						lnPos = lnPos + lnLength
						if lnPos > len(PROPERTY)
							llDone = .T.
						endif lnPos > len(PROPERTY)
					endif lnIDCode = tnID
				enddo while not llDone
		
		* If we didn't find the property, let's add it to the end of PROPERTY.
		
				if not llGotProp
					lnIDLength = int(tnID/256) + 1
					replace PROPERTY with PROPERTY + ;
						.Decimal2Hex(lnValueLen + lnIDLength + ;
						6 + iif(lnValueLen = 1, 0, 1), 4) + ;
						.Decimal2Hex(lnIDLength, 2) + ;
						.Decimal2Hex(tnID, lnIDLength) + tcValue + ;
						iif(lnValueLen = 1, '', ccNULL)
				endif not llGotProp
			endif right(dbf(), 3) <> 'DBC' ...
		
		* Restore the datasession if necessary.
		
			if vartype(tnDataSession) = 'N' and tnDataSession <> 0 and ;
				tnDataSession <> lnCurrDataSession
				set datasession to lnCurrDataSession
			endif vartype(tnDataSession) = 'N' ...
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE dbcxgetallobjects		&& Find all data objects having a certain property set a certain way.
		*==============================================================================
		* Function:			DBCXGetAllObjects
		* Status:			Public
		* Purpose:			Create an array of all objects having a certain property
		*						(included for backwards compatibility only)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	12/01/97
		* Parameters:		see DBCXMgr.DBCXGetAllObjects
		* Returns:			see DBCXMgr.DBCXGetAllObjects
		*==============================================================================
		
		lparameters tcType, ;
			taArray, ;
			tcReturn, ;
			tcProperty, ;
			tuValue
		return This.Parent.DBCXGetAllObjects(tcType, @taArray, tcReturn, tcProperty, ;
			tuValue)
		
	ENDPROC

	PROCEDURE dbcxgetproplist
		*==============================================================================
		* Method:			DBCXGetPropList
		* Status:			Public
		* Purpose:			Update the properties cursor with properties managed by
		*						SDTMgr. Overrides the base class method so we can
		*						insert additional information into the cursor.
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tcCursorName - the name of the properties cursor
		* Returns:			.T.
		*==============================================================================
		
		lparameters tcCursorName
		local laFields[1], ;
			lnFields, ;
			lcAlias, ;
			lnI, ;
			lcField, ;
			lcLongName
		
		* Ensure the parameters are valid.
			
		with This
			if vartype(tcCursorName) <> 'C' or empty(tcCursorName) or ;
				not used(tcCursorName)
				.Warning(ccERR_INVALID_DBCXPROPS)
				return .F.
			endif vartype(tcCursorName) <> 'C' ...
		
		* Ensure our meta data table is open.
		
			if not .OpenDBCXMeta()
				.Warning(strtran(ccERR_CANT_OPEN_FILE, ccMSG_INSERT1, .cDBCXAlias))
				return .F.
			endif not .OpenDBCXMeta()
		
		* Update the properties cursor.
		
			lnFields = afields(laFields, .cDBCXAlias)
			lcAlias  = .cMetaAlias
			for lnI = 1 to lnFields
				lcField    = laFields[lnI, 1]
				lcLongName = iif(used(lcAlias) and seek(lcField, lcAlias, 'FIELD'), ;
					evaluate(lcAlias + '.Property'), lcField)
				if not seek(upper(lcLongName), tcCursorName, 'cLongName')
					insert into (tcCursorName) ;
						(cProperty, ;
						cObject, ;
						cProdName, ;
						cLongName) ;
					values ;
						(.GetPropertyName(lcField), ;
						.Name, ;
						.cProductName, ;
						lcLongName)
				endif not seek(upper(lcLongName), tcCursorName, 'cLongName')
			next lnI
		
		* Now add map properties from the previous version of SDT to their new
		* locations.
		
			insert into (tcCursorName) ;
				(cProperty, ;
				cObject, ;
				cProdName, ;
				cLongName) ;
			values ;
				('CBnCodePage', ;
				'oCoreMgr', ;
				.Parent.oCoreMgr.cProductName, ;
				'SDTCodePage')
			insert into (tcCursorName) ;
				(cProperty, ;
				cObject, ;
				cProdName, ;
				cLongName) ;
			values ;
				('CBnBlockSize', ;
				'oCoreMgr', ;
				.Parent.oCoreMgr.cProductName, ;
				'SDTBlockSize')
			insert into (tcCursorName) ;
				(cProperty, ;
				cObject, ;
				cProdName, ;
				cLongName) ;
			values ;
				('CBcCollate', ;
				'oCoreMgr', ;
				.Parent.oCoreMgr.cProductName, ;
				'SDTCollate')
			insert into (tcCursorName) ;
				(cProperty, ;
				cObject, ;
				cProdName, ;
				cLongName) ;
			values ;
				('CBmComment', ;
				'oCoreMgr', ;
				.Parent.oCoreMgr.cProductName, ;
				'SDTComment')
			insert into (tcCursorName) ;
				(cProperty, ;
				cObject, ;
				cProdName, ;
				cLongName) ;
			values ;
				('CBcCaption', ;
				'oCoreMgr', ;
				.Parent.oCoreMgr.cProductName, ;
				'SDTCaption')
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE dbcxnotify
		*==============================================================================
		* Method:			DBCXNotify
		* Status:			Public
		* Purpose:			Update SDT meta data when a property value is changed in
		*						another extension
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	10/15/99
		* Parameters:		tcObjectName - the name of the object in VFP DBC syntax:
		*						[database!]<alias> for tables, views, and connections
		*						[database!]<alias>.<name> for fields and indexes
		*						[database!]<parent alias>.<tag>,<child alias>.<tag> for
		*							relations
		*					tcObjectType - the type of the object: "table", "view",
		*						"field", "index", "relation", "connection", or
		*						"database"
		*					tcManager    - the name of the manager managing the changed
		*						property (upper-cased)
		*					tcProperty   - the property that was changed (upper-cased)
		*					tuValue      - the value it was changed to
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	certain SDT extended properties may have been updated
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcObjectType, ;
			tcManager, ;
			tcProperty, ;
			tuValue
		with This
			do case
		
		* The VFE lSearch property was changed.
		
				case tcProperty = 'VFELSEARCH'
					.DBCXSetProp(tcObjectName, tcObjectType, 'SDTFilter', tuValue)
		
		* The VFE lDisplay property was changed.
		
				case tcProperty = 'VFELDISPLAY'
					.DBCXSetProp(tcObjectName, tcObjectType, 'SDTSelect', tuValue)
			endcase
		endwith
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE decimal2hex		&& Convert a decimal number to a hex string
		*==============================================================================
		* Method:			Decimal2Hex
		* Status:			Protected
		* Purpose:			Convert a decimal number to a hex string
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tnValue  - the decimal value
		*					tnPlaces - the number of places needed (optional: if it
		*						isn't specified, 4 is used)
		* Returns:			the hex string
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tnValue, ;
			tnPlaces
		local lnPlaces, ;
			lcHex, ;
			lcOut, ;
			lnI
		lnPlaces = iif(pcount() = 1, 4, tnPlaces)
		lcHex    = This.ReverseDecimal2Hex(tnValue, lnPlaces)
		lcOut    = ''
		for lnI = 1 to lnPlaces
			lcOut = lcOut + substr(lcHex, lnPlaces - lnI + 1, 1)
		next lnI
		return lcOut
		
	ENDPROC

	PROCEDURE Destroy
		* Close the SDTUSER table if it's open.
		
		with This
			if used(.cMetaAlias)
				use in (.cMetaAlias)
			endif used(.cMetaAlias)
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE diderroroccur		&& Returns the value of the protected lErrorOccurred property.
		*==============================================================================
		* Method:			DidErrorOccur
		* Status:			Public
		* Purpose:			Returns the value of the protected lErrorOccurred property
		* Author:			Doug Hennig
		* Copyright:		(c) 1995 Stonefield Systems Group Inc.
		* Last revision:	07/31/98
		* Parameters:		none
		* Returns:			the value of lErrorOccurred
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		return This.Parent.lErrorOccurred
		
	ENDPROC

	PROTECTED PROCEDURE displayllfferror		&& Displays an error that occurred during a LLFF.
		*==============================================================================
		* Method:			DisplayLLFFError
		* Status:			Protected
		* Purpose:			Display an error after a low level file function (LLFF)
		*						failed
		* Author:			Doug Hennig
		* Copyright:		(c) 1995 Stonefield Systems Group Inc.
		* Last revision:	03/20/98
		* Parameters:		tcFile - the file being accessed
		* Returns:			.T.
		* Environment in:	an LLFF error occurred
		* Environment out:	the appropriate error message is displayed
		*==============================================================================
		
		lparameters tcFile
		local lcError
		do case
			case ferror() = cnLLFF_ERR_NOT_FOUND
				lcError = strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, tcFile)
			case ferror() = cnLLFF_ERR_TOO_MANY
				lcError = ccERR_TOO_MANY_FILES
			case ferror() = cnLLFF_ERR_NO_ACCESS
				lcError = strtran(ccERR_CANT_OPEN_EXCL, ccMSG_INSERT1, tcFile)
			case ferror() = cnLLFF_ERR_OUT_MEMORY
				lcError = ccERR_OUT_OF_MEMORY
			case ferror() = cnLLFF_ERR_OTHER
				lcError = strtran(ccERR_CANT_OPEN_FILE, ccMSG_INSERT1, tcFile)
		endcase
		This.Warning(lcError)
		
	ENDPROC

	PROTECTED PROCEDURE enabledbcevents		&& Enables or disables DBC events in the current database and returns the former setting
		lparameters tlEnable
		local llEventsOn
		if clVFP7ORLATER
			llEventsOn = dbgetprop(set('DATABASE'), 'Database', 'DBCEvents')
			if llEventsOn <> tlEnable
				dbsetprop(set('DATABASE'), 'Database', 'DBCEvents', tlEnable)
			endif llEventsOn <> tlEnable
		endif clVFP7ORLATER
		return llEventsOn
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handle an error
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	10/21/2002
		* Parameters:		tnError  - the error number
		*					tcMethod - the method the error occurred in
		*					tnLine   - the line number the error occurred on
		* Returns:			.T.
		* Environment In:	This.Parent.nDataSessionID contains the "normal"
		*						datasession number for DBCXMgr
		* Environment Out:	the error may have been handled or passed to DBCXMgr
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lcMethod, ;
			lcReturn
		with This
			lcMethod = upper(tcMethod)
			do case
		
		* When "file access denied" occurs in CreateTempDBC, return so it can retry to
		* open the DBC.
		
				case 'CREATETEMPDBC' $ lcMethod and ;
					inlist(tnError, cnERR_FILE_IN_USE, cnERR_ACCESS_DENIED)
					lcReturn = ccMSG_CONTINUE
		
		* If an error occurs evaluating an index expression, set the lIndexError
		* property to .T. and return.
		
				case .lTestingIndex
					.lIndexError = .T.
					lcReturn     = ccMSG_CONTINUE
		
		* Use the normal error handling mechanism for all other types of errors. Note
		* that we add a period to the method name passed. This tells our parent class
		* to return the error resolution string back to us, which is required for RETRY
		* to work.
		
				otherwise
					lcReturn = dodefault(tnError, '.' + tcMethod, tnLine)
					if not empty(.cAlias)
						.Parent.aErrorInfo[alen(.Parent.aErrorInfo, 1), 3] = .cAlias
					endif not empty(.cAlias)
			endcase
		
		* Handle the return value.
		
			do case
				case lcReturn = ccMSG_RETRY
					retry
				case lcReturn = ccMSG_DEBUG
					debug
					if wexist('Visual FoxPro Debugger')
						keyboard '{SHIFT+F7}' plain
					endif wexist('Visual FoxPro Debugger')
					suspend
				case lcReturn = ccMSG_CANCEL
					cancel
				otherwise
					return
			endcase
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE fastdoevents		&& Performs a DOEVENTS after creating an event so it performs faster
		*==============================================================================
		* Method:			FastDoEvents
		* Status:			Protected
		* Purpose:			Performs a DOEVENTS after creating an event so it performs
		*						faster
		* Author:			Doug Hennig, from ideas publish by David Frankenbach
		* Copyright:		(c) 1999-2003 Stonefield Systems Group Inc.
		* Last revision:	03/04/2003
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	DOEVENTS has been performed
		* Notes:			Since VFP 7 improved the performance of DOEVENTS, most of
		*						the code in this method in only used in VFP 6 or
		*						earlier
		*==============================================================================
		
		if version(5) < 700
			local lcWindow, ;
				lnRow, ;
				lnCol, ;
				lnRowVFP, ;
				lnColVFP
			lcWindow = wontop()
			lnRow    = mrow(lcWindow)
			lnCol    = mcol(lcWindow)
			lnRowVFP = mrow('')
			lnColVFP = mcol('')
			do case
		
		* If the mouse is over a window, keep it there.
		
				case not empty(lcWindow) and lnRow > 0 and lnCol > 0
					mouse at lnRow, lnCol window (lcWindow)
		
		* If the mouse is over the VFP window, keep it there.
		
				case lnRowVFP > 0 and lnColVFP > 0
					mouse at lnRowVFP, lnColVFP
		
		* Generate a keyboard event.
		
				otherwise
					keyboard ' '
					inkey()
			endcase
		endif version(5) < 700
		
		* Issue the DOEVENTS.
		
		doevents
		
	ENDPROC

	PROTECTED PROCEDURE fixfptfilesize		&& Corrects the size of an FPT file as a workaround for a VFP bug
		*==============================================================================
		* Method:			FixFPTFileSize
		* Status:			Protected
		* Purpose:			Corrects the size of an FPT file as a workaround for a VFP
		*						bug
		* Author:			Doug Hennig
		* Copyright:		(c) 2000-2007 Stonefield Systems Group Inc.
		* Last Revision:	01/29/2007
		* Parameters:		tcFile      - the file name of the table or the memo to
		*						correct
		*					tnBlockSize - the block size for the memo file
		*					tnHandle    - a handle to the FPT file (optional: only
		*						passed if the table is already open using LLFF)
		* Returns:			.T. if the FPT file size was OK or was adjusted correctly
		* Environment in:	if tnHandle is passed, the FPT file is already open
		* Environment out:	the memo file size may have been adjusted
		*==============================================================================
		
		lparameters tcFile, ;
			tnBlockSize, ;
			tnHandle
		local lcMemoFile, ;
			lnHandle, ;
			lnActualSize, ;
			lnCalcSize, ;
			lnFinalSize, ;
			llReturn
		
		* If a valid handle was passed, use it. If not and the file can be found,
		* open it. Otherwise, flag an error.
		
		with This
			lcMemoFile = iif(upper(justext(tcFile)) <> 'FPT', .GetMemoFile(tcFile), ;
				tcFile)
			do case
				case vartype(tnHandle) = 'N' and tnHandle >= 0
					lnHandle = tnHandle
				case file(lcMemoFile)
					lnHandle = fopen(lcMemoFile, F_READWRITE)
					if lnHandle < 0
						.DisplayLLFFError(lcMemoFile)
					endif lnHandle < 0
				otherwise
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, lcMemoFile))
					lnHandle = -1
			endcase
		
		* If the file is open, adjust the FPT file size if necessary.
		
			if lnHandle >= 0
				lnActualSize = fseek(lnHandle, 0, 2)
				lnCalcSize   = tnBlockSize * (int(lnActualSize/tnBlockSize) + 1)
				if lnActualSize = lnCalcSize
					llReturn = .T.
				else
					lnFinalSize  = fchsize(lnHandle, lnCalcSize)
					llReturn     = lnFinalSize = lnCalcSize
				endif lnActualSize = lnCalcSize
		
		* Pause to ensure buffers are flushed and close the file.
		
				if .lNeedPause
					fflush(lnHandle)
					.Pause()
				endif .lNeedPause
				fclose(lnHandle)
			endif lnHandle >= 0
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE getblocksize		&& Determines what to set BLOCKSIZE to for a given SDTBLOCKSIZE value (obtained from sys(2012)).
		*==============================================================================
		* Method:			GetBlockSize
		* Status:			Public
		* Purpose:			Determines what to set BLOCKSIZE to for a given
		*						SDT BlockSize value (obtained from sys(2012))
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	09/13/99
		* Parameters:		tnBlockSize - the SDT BlockSize
		* Returns:			the value to set BLOCKSIZE to to obtain the desired block
		*						size (this takes into account the weirdness in the
		*						SET BLOCKSIZE command -- see the VFP help file for
		*						information)
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tnBlockSize
		local lnReturn
		do case
			case isnull(tnBlockSize) or tnBlockSize = 0
				lnReturn = cnFPT_DEFAULT_BLOCK_SIZE
			case tnBlockSize = 1
				lnReturn = 0
			case between(tnBlockSize, 33, cnFPT_BLOCK_SIZE_DIVISOR - 1)
				lnReturn = tnBlockSize
			otherwise
				lnReturn = int(tnBlockSize/cnFPT_BLOCK_SIZE_DIVISOR)
		endcase
		return lnReturn
		
	ENDPROC

	PROTECTED PROCEDURE getcodepage		&& Determine the table's code page value from the code page number or vice versa.
		*==============================================================================
		* Method:			GetCodePage
		* Status:			Protected
		* Purpose:			Determine the table's code page value from the code page
		*						number or vice versa
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	08/04/2004
		* Parameters:		tnCodePage - the code page number (or value if tlValue is
		*						.T.)
		*					tlValue    - .T. if tnCodePage is the code page value and
		*						we want to return the code page number
		* Returns:			the code page value for the DBF header if tlValue is .F. or
		*						the code page number if it's .F.
		*					if an invalid code page name is passed, 0 is returned
		* Environment in:	This.aCodePage exists as defined in Init()
		* Environment out:	none
		*==============================================================================
		
		lparameters tnCodePage, ;
			tlValue
		local lnCodePage, ;
			laCodePage[1], ;
			lnReturn
		with This
		
		* If the code page is 0, use the user's current code page.
		
			if tnCodePage = 0 and not tlValue
				lnCodePage = cpcurrent()
			else
				lnCodePage = tnCodePage
			endif tnCodePage = 0 ...
		
		* Try to find the row in aCodePage that has this code page number.
		
			acopy(.aCodePage, laCodePage)
			lnReturn = .ArrayScan(@laCodePage, lnCodePage, iif(tlValue, 3, 2))
			lnReturn = iif(lnReturn = 0, 0, laCodePage[lnReturn, iif(tlValue, 2, 3)])
		endwith
		return lnReturn
		
	ENDPROC

	PROCEDURE getcodepagearray		&& An exposed method that copies the protected aCodePage array into a specified array.
		*==============================================================================
		* Method:			GetCodePageArray
		* Status:			Public
		* Purpose:			Place the This.aCodePage array into another array (needed
		*						because it's a protected property)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	01/10/97
		* Parameters:		taArray - the array to put the codepage array into
		* Returns:			the number of rows in the the codepage array
		* Environment in:	This.aCodePage exists as defined in Init()
		*					taArray is the name of an array
		* Environment out:	taArray is identical to This.aCodePage 
		*==============================================================================
		
		lparameters taArray
		acopy(This.aCodePage, taArray)
		return alen(taArray, 1)
		
	ENDPROC

	PROCEDURE getcollatearray		&& An exposed method that copies the protected aCollate array into a specified array.
		*==============================================================================
		* Method:			GetCollateArray
		* Status:			Public
		* Purpose:			Place the This.aCollate array into another array (needed
		*						because it's a protected property)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	01/10/97
		* Parameters:		taArray - the array to put the collate array into
		* Returns:			the number of rows in the the collate array
		* Environment in:	This.aCollate exists as defined in Init()
		*					taArray is the name of an array
		* Environment out:	taArray is identical to This.aCollate
		*==============================================================================
		
		lparameters taArray
		acopy(This.aCollate, taArray)
		return alen(taArray, 1)
		
	ENDPROC

	PROCEDURE getdatatypearray		&& An exposed method that copies the protected aDataType array into a specified array.
		*==============================================================================
		* Method:			GetDataTypeArray
		* Status:			Public
		* Purpose:			Place the This.aDataTypes array into another array (needed
		*						because it's a protected property)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	01/10/97
		* Parameters:		taArray - the array to put the data types array into
		* Returns:			the number of rows in the data types array
		* Environment in:	This.aDataTypes exists as defined in Init()
		*					taArray is the name of an array
		* Environment out:	taArray is identical to This.aDataTypes 
		*==============================================================================
		
		lparameters taArray
		acopy(This.aDataTypes, taArray)
		return alen(taArray, 1)
		
	ENDPROC

	PROCEDURE getdbfstructure		&& Reads the structure of a table directly from the DBF header and places it into an array.
		*==============================================================================
		* Method:			GetDBFStructure
		* Status:			Public
		* Purpose:			Read the structure of a table directly from the header
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	01/04/2005
		* Parameters:		tcFile      - the file to get the structure for
		*					taFieldList - the array to put the structure into
		*					tnTableCP   - a variable to contain the table's code page #
		*						(optional: if it isn't passed, it isn't updated)
		*					tnTableType - a variable to contain the table type
		*						(optional: if it isn't passed, it isn't updated)
		*					tnBlockSize - a variable to contain the table's blocksize
		*						(optional: if it isn't passed, it isn't updated)
		*					tlNoClose   - .T. to not call CloseAllAliases
		* Returns:			.T. if the file exists and could be opened
		* Environment in:	none
		* Environment out:	taFieldList contains the structure of the table in 
		*						AFIELDS() format, except column 7 has the step value
		*					tnTableCP contains the table's code page # if it was passed
		*					the table is closed if it was formerly open
		*==============================================================================
		
		lparameters tcFile, ;
			taFieldList, ;
			tnTableCP, ;
			tnTableType, ;
			tnBlockSize, ;
			tlNoClose
		local lnHandle, ;
			lnTableType, ;
			llDBC, ;
			lnHeaderLen, ;
			lnTableFields, ;
			lnCurrPos, ;
			llHaveMemo, ;
			lcField, ;
			lcType, ;
			lnLength, ;
			lnDecimals, ;
			lnType, ;
			lnStep, ;
			lcFile, ;
			lcBlockSize
		
		* Try to open the file.
		
		if not file(tcFile)
			return .F.
		endif not file(tcFile)
		with This
			if not tlNoClose
				.CloseAllAliases(tcFile)
			endif not tlNoClose
			lnHandle = fopen(tcFile)
			do case
				case lnHandle >= 0
		
		* Get the table type for the table if necessary.
		
					lnTableType = asc(fread(lnHandle, 1))
					lnTableType = iif(inlist(lnTableType, cnVFP_TABLE_VFP_8, ;
						cnVFP_TABLE_VFP_9), cnVFP_TABLE_VFP, lnTableType)
					if vartype(tnTableType) <> 'L'
						tnTableType = lnTableType
					endif vartype(tnTableType) <> 'L'
		
		* Get the length of the fields area.
		
					llDBC = lnTableType = cnVFP_TABLE_VFP
					fseek(lnHandle, cnDBF_HEADER_LENGTH)
					lnHeaderLen = asc(fread(lnHandle, 1)) + ;
						256 * asc(fread(lnHandle, 1)) - ;
						iif(llDBC, cnVF_BACKLINK_LENGTH, 0) - 1
		
		* Get the code page for the table if necessary.
		
					if vartype(tnTableCP) <> 'L'
						fseek(lnHandle, cnDBF_CODE_PAGE)
						tnTableCP = .GetCodePage(asc(fread(lnHandle, 1)), .T.)
					endif vartype(tnTableCP) <> 'L'
		
		* Pick up each field defined in the header.
		
					fseek(lnHandle, cnDBF_FIRST_FIELD)
					lnTableFields = 1
					lnCurrPos     = cnDBF_FIRST_FIELD
					llHaveMemo    = .F.
					do while lnCurrPos < lnHeaderLen
						lcField = fread(lnHandle, cnDBF_FIELD_NAME_SIZE)
						if left(lcField, 1) = ccFIELD_TERMINATOR
							exit
						endif left(lcField, 1) = ccFIELD_TERMINATOR
						fseek(lnHandle, 1, 1)
						lcType = fread(lnHandle, 1)
						fseek(lnHandle, 4, 1)
						lnLength   = asc(fread(lnHandle, 1))
						lnDecimals = asc(fread(lnHandle, 1))
						lnType     = asc(fread(lnHandle, 1))
						fseek(lnHandle, 4, 1)
						lnStep = asc(fread(lnHandle, 1))
		
		* If this isn't a System field, save it in the array.
		
						if lnType <> cnDBF_SYSTEM_FIELD
							dimension taFieldList[lnTableFields, 7]
							taFieldList[lnTableFields, 1] = strtran(lcField, ccNULL)
							taFieldList[lnTableFields, 2] = lcType
							taFieldList[lnTableFields, 3] = lnLength
							taFieldList[lnTableFields, 4] = lnDecimals
							taFieldList[lnTableFields, 5] = inlist(lnType, 2, 6)
							taFieldList[lnTableFields, 6] = inlist(lnType, 4, 6) and ;
								lcType $ 'CMV'
							taFieldList[lnTableFields, 7] = lnStep
							llHaveMemo = llHaveMemo or lcType $ 'MGW'
						endif lnType <> cnDBF_SYSTEM_FIELD
						lnTableFields = lnTableFields + 1
						fseek(lnHandle, cnDBF_FIELD_DEFN_SIZE * lnTableFields)
						lnCurrPos = cnDBF_FIELD_DEFN_SIZE * lnTableFields
					enddo while lnCurrPos < lnHeaderLen
					lnTableFields = lnTableFields - 1
		
		* Display an error message if we couldn't open the file and we're supposed to
		* display messages.
		
				case not .Parent.lSuppressErrors
					.DisplayLLFFError(tcFile)
			endcase
		
		* Close the table.
		
			fclose(lnHandle)
			lcFile = forceext(tcFile, 'FPT')
			do case
		
		* Do nothing if we don't care about the blocksize or don't have any memo
		* fields.
		
				case vartype(tnBlockSize) = 'L' or not llHaveMemo
		
		* If we have a memo file, open it and read the blocksize.
		
				case file(lcFile)
					tnBlockSize = 0
					lnHandle    = fopen(lcFile)
					do case
						case lnHandle >= 0
							fseek(lnHandle, 4)
							lcBlockSize = fread(lnHandle, 4)
							tnBlockSize = .ReverseHex2Decimal(lcBlockSize)
		
		* Display an error message if we couldn't open the file and we're supposed to
		* display messages.
		
						case not .Parent.lSuppressErrors
							.DisplayLLFFError(lcFile)
					endcase
					fclose(lnHandle)
		
		* We're supposed to have a memo file but don't so display an error.
		
				otherwise
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, lcFile))
			endcase
		endwith
		return lnHandle >= 0
		
	ENDPROC

	PROTECTED PROCEDURE getdrivespace		&& Returns the free space on a drive (workaround for a bug in VFP's DISKSPACE() routine which doesn't handle free space more than 2 GB)
		*==============================================================================
		* Method:			GetDriveSpace
		* Status:			Protected
		* Purpose:			Returns the total or free space on a drive; workaround for
		*						a bug in VFP's DISKSPACE() routine which doesn't handle
		*						free space more than 2 GB
		* Author:			Doug Hennig, from code written by George Tasker
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	09/06/2001
		* Parameters:		tcDirectory - any directory on the drive to check space for
		*						(optional: if it isn't specified, the current drive is
		*						used)
		*					tlTotal     - .T. to return the total space on the drive or
		*						.F. to return the free space
		* Returns:			the amount of free or total space, depending on tlTotal, or
		*						-1 if an error occurred (such as drive not ready)
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcDirectory, ;
			tlTotal
		local lcDir, ;
			lnResult, ;
			lcDLL, ;
			lnFunction, ;
			lnHandle, ;
			lcCaller, ;
			lcTotal, ;
			lcFree
		
		* Declare Win32API functions to determine if the GetDiskFreeSpaceEx function is
		* available.
		
		declare integer GetModuleHandle in Win32API ;
			string @lpModuleName
		declare integer GetProcAddress in Win32API ;
			integer hModule, string @lpProcName
		
		* If the path wasn't specified, use the current drive. Otherwise, get the drive
		* for the specified path, handling UNC paths specially.
		
		do case
			case vartype(tcDirectory) <> 'C' or empty(tcDirectory)
				lcDir = addbs(sys(5))
			case left(tcDirectory, 2) = '\\'
				lcDir = addbs(tcDirectory)
				lcDir = left(lcDir, at('\', lcDir, 4))
			case len(tcDirectory) = 1
				lcDir = tcDirectory + ':'
			otherwise
				lcDir = addbs(justdrive(tcDirectory))
		endcase
		lnResult = -1
		
		* See if the GetDiskFreeSpaceEx Win32API function is available; if so, call it
		* to get the drive space.
		
		lcDLL      = 'kernel32.dll'
		lcFunction = 'GetDiskFreeSpaceExA'
		lnHandle   = GetModuleHandle(@lcDLL)
		if GetProcAddress(lnHandle, @lcFunction) > 0
			declare short GetDiskFreeSpaceEx in Win32API ;
				string @lpDirectoryName, string @lpFreeBytesAvailableToCaller, ;
				string @lpTotalNumberOfBytes, string @lpTotalNumberOfFreeBytes
			store replicate(ccNULL, 8) to lcCaller, lcTotal, lcFree
			if GetDiskFreeSpaceEx(@lcDir, @lcCaller, @lcTotal, @lcFree) <> 0
				lnResult = This.Hex2Decimal(iif(tlTotal, lcTotal, lcFree))
			endif GetDiskFreeSpaceEx(@lcDir, ...
		
		* Since we can't use GetDiskFreeSpaceEx, just use DISKSPACE.
		
		else
			lnResult = diskspace(lcDir)
		endif GetProcAddress(lnHandle, @lcFunction) > 0
		return lnResult
		
	ENDPROC

	PROCEDURE getfreetablepath		&& Returns the path to the free table stored in CoreMeta.mPath
		lparameters tcTable
		local llEvaluate, ;
			lnRecno, ;
			lcTable, ;
			lcPath
		with This
			llEvaluate = .Parent.lEvaluate
			.Parent.lEvaluate = .F.
			lnRecno = recno('CoreMeta')
			lcTable = iif(left(tcTable, 1) <> '!', '!', '') + tcTable
			lcPath  = .Parent.DBCXGetProp(lcTable, 'Table', 'CBmPath')
			if vartype(lcPath) = 'C'
				lcPath = iif(left(lcPath, 1) = '=', ;
					fullpath(evaluate(substr(lcPath, 2))), ;
					fullpath(lcPath, .Parent.cRegistryPath))
			else
				lcPath = ''
			endif vartype(lcPath) = 'C'
			.Parent.lEvaluate = llEvaluate
			if lnRecno <> recno('CoreMeta') and lnRecno > 0 and ;
				lnRecno <= reccount('CoreMeta')
				go lnRecno in CoreMeta
			endif lnRecno <> recno('CoreMeta') ...
		endwith
		return lcPath
		
	ENDPROC

	PROCEDURE getindexstructure		&& Places the structure of a table's indexes into an array.
		*==============================================================================
		* Method:			GetIndexStructure
		* Status:			Public
		* Purpose:			Read the structure of a table's indexes
		* Author:			Doug Hennig
		* Copyright:		(c) 1995-2004 Stonefield Systems Group Inc.
		* Last revision:	10/20/2004
		* Parameters:		tcAlias   - the file to get the indexes for
		*					taIndexes - the array to put the indexes into
		* Returns:			.T. if extensions were defined for the table
		* Environment in:	the table whose name is in tcAlias must be open
		*					This.aIndexTypes exists as defined in Init()
		* Environment out:	taIndexes contains the structure of the indexes with the
		*						following columns:
		*					1 = tag name
		*					2 = index expression
		*					3 = filter expression
		*					4 = collate sequence
		*					5 = index type (U = unique, R = regular, P = primary,
		*						B = binary, and C = candidate)
		*					6 = .T. if ascending
		*==============================================================================
		
		lparameters tcAlias, ;
			taIndexes
		local lcFullPath, ;
			lcAlias, ;
			lcFile, ;
			lnSelect, ;
			lnI
		
		* Create a blank array first.
		
		with This
			dimension taIndexes[1, 6]
			taIndexes = ''
			taIndexes[1, 6] = .F.
		
		* Get a list of all indexes for this table.
		
			lcFullPath = set('FULLPATH')
			set fullpath on
			lcAlias  = strtran(tcAlias, ' ', '_')
			lcFile   = juststem(dbf(lcAlias))
			lnSelect = select()
			for lnI = 1 to tagcount(lcFile, lcAlias)
				dimension taIndexes[lnI, 6]
				taIndexes[lnI, 1] = tag(lnI, lcAlias)
				if upper(taIndexes[lnI, 1]) = 'PHD'
					select (lcAlias)
					taIndexes[lnI, 2] = 'phd("index ' + ;
						upper(alltrim(evaluate('phd("key")'))) + '")'
					select (lnSelect)
				else
					taIndexes[lnI, 2] = key(lnI, lcAlias)
				endif upper(taIndexes[lnI, 1]) = 'PHD'
				taIndexes[lnI, 3] = sys(2021, lnI, lcAlias)
				taIndexes[lnI, 4] = idxcollate(lnI, lcAlias)
				taIndexes[lnI, 6] = not descending(lnI, lcAlias)
				do case
					case primary(lnI, lcAlias)
						taIndexes[lnI, 5] = left(.aIndexTypes[1], 1)
					case candidate(lnI, lcAlias)
						taIndexes[lnI, 5] = left(.aIndexTypes[2], 1)
					case unique(lnI, lcAlias)
						taIndexes[lnI, 5] = left(.aIndexTypes[4], 1)
					case version(5) >= 900 and .Parent.Binary(lnI, lcAlias)
						taIndexes[lnI, 5] = left(.aIndexTypes[5], 1)
					otherwise
						taIndexes[lnI, 5] = left(.aIndexTypes[3], 1)
				endcase
			next lnI
			if lcFullPath = 'OFF'
				set fullpath off
			endif lcFullPath = 'OFF'
		endwith
		return
		
	ENDPROC

	PROCEDURE getindextypearray		&& An exposed method that copies the protected aIndexType array into a specified array.
		*==============================================================================
		* Method:			GetIndexTypeArray
		* Status:			Public
		* Purpose:			Place the This.aIndexTypes array into another array (needed
		*						because it's a protected property)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	01/10/97
		* Parameters:		taArray - the array to put the index types array into
		* Returns:			the number of rows in the index types array
		* Environment in:	This.aIndexTypes exists as defined in Init()
		*					taArray is the name of an array
		* Environment out:	taArray is identical to This.aIndexTypes
		*==============================================================================
		
		lparameters taArray
		acopy(This.aIndexTypes, taArray)
		return alen(taArray, 1)
		
	ENDPROC

	PROTECTED PROCEDURE getmemofile		&& Determines the file name for a memo file
		*==============================================================================
		* Method:			GetMemoFile
		* Status:			Protected
		* Purpose:			Determines the file name for a memo file
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2007 Stonefield Systems Group Inc.
		* Last Revision:	01/29/2007
		* Parameters:		tcFile - the file name of the table
		* Returns:			the file name of the memo file
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcFile
		local lcExt, ;
			lcMemoExt, ;
			lcMemoFile
		lcExt = upper(justext(tcFile))
		do case
			case lcExt = 'VCX'
				lcMemoExt = 'VCT'
			case lcExt = 'SCX'
				lcMemoExt = 'SCT'
			case lcExt = 'FRX'
				lcMemoExt = 'FRT'
			case lcExt = 'MNX'
				lcMemoExt = 'MNT'
			case lcExt = 'PJX'
				lcMemoExt = 'PJT'
			case lcExt = 'DBC'
				lcMemoExt = 'DCT'
			otherwise
				lcMemoExt = 'FPT'
		endcase
		lcMemoFile = forceext(tcFile, lcMemoExt)
		return lcMemoFile
		
	ENDPROC

	PROCEDURE getmetaalias		&& An exposed method that returns the protected cMetaAlias property.
		*==============================================================================
		* Method:			GetMetaAlias
		* Status:			Public
		* Purpose:			Return the This.cMetaAlias property (needed because it's
		*						protected)
		* Author:			Doug Hennig
		* Copyright:		(c) 1995 Stonefield Systems Group Inc.
		* Last revision:	12/12/95
		* Parameters:		none
		* Returns:			the value of This.cMetaAlias
		* Environment in:	This.cMetaAlias exists as defined in Init()
		* Environment out:	none
		*==============================================================================
		
		return This.cMetaAlias
		
	ENDPROC

	PROCEDURE getstructurearray		&& Copies 18 columns of one array to another
		lparameters taTable, ;
			taCreate
		local lnFields, ;
			lnColumns, ;
			lnI, ;
			lnJ
		lnFields  = alen(taTable, 1)
		lnColumns = iif(version(5) >= 800, 18, 16)
		dimension taCreate[lnFields, lnColumns]
		for lnI = 1 to lnFields
			for lnJ = 1 to lnColumns
				taCreate[lnI, lnJ] = taTable[lnI, lnJ]
			next lnJ
		next lnI
		return
		
	ENDPROC

	PROTECTED PROCEDURE hex2decimal		&& Converts a value in Intel format to a decimal value
		*==============================================================================
		* Method:			Hex2Decimal
		* Status:			Protected
		* Purpose:			Converts a value in Intel format to a decimal value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
		* Last Revision:	09/03/2003
		* Parameters:		tcValue  - the value to convert
		*					tlSigned - .T. if the value is signed
		* Returns:			the numeric value
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcValue, ;
			tlSigned
		local lnDecimal, ;
			lnLen, ;
			lnI, ;
			lnMSB, ;
			lnMax
		lnDecimal = 0
		lnLen     = len(tcValue)
		for lnI = 1 to lnLen
			lnDecimal = lnDecimal + asc(substr(tcValue, lnI, 1)) * 256 ^ (lnI - 1)
		next lnI
		if tlSigned
			lnMSB = (lnLen * 8) - 1
			if bittest(lnDecimal, lnMSB)
				lnMax     = 2 ^ (lnMSB + 1)
				lnDecimal = lnDecimal - lnMax
			endif bittest(lnDecimal, lnMSB)
		endif tlSigned
		return lnDecimal
		
	ENDPROC

	PROCEDURE howtosynctable		&& Creates a ALTER TABLE statement to synchronize a table's structure with that defined in the DBC and DBCX.
		*==============================================================================
		* Method:			HowToSyncTable
		* Status:			Public
		* Purpose:			Determine how to update the table to match the meta data
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	04/13/2004
		* Parameters:		taDBFFields - a array (in AFIELDS() format) containing the
		*						structure of the table as defined in the header
		*					taDBCFields - a array (in AFIELDS() format) containing the
		*						structure of the table as defined in the meta data
		*					tlFree      - .T. if this is a free table
		* Returns:			a string containing the clauses of an ALTER TABLE command
		*						to make the table match the meta data
		* Environment in:	none
		* Environment out:	if invalid parameters were passed, an error message is
		*						displayed and the return value is a blank string
		* Note:				This method handles dropping columns, renaming columns,
		*						changing column properties (such as type or size), and
		*						adding columns at the end of the table. It does not
		*						handle rearranging the order of columns or adding
		*						columns in the middle of the table, since ALTER TABLE
		*						doesn't support that. The "create and append" mechanism
		*						must be used for those types of changes
		*==============================================================================
		
		lparameters taDBFFields, ;
			taDBCFields, ;
			tlFree
		local lnDBCFields, ;
			lnDBFFields, ;
			lnDBFColumns, ;
			lnDBCColumns, ;
			llStepColumn, ;
			lnStepColumn, ;
			lnOldNameCol, ;
			lnDBCStepCol, ;
			lnToDo, ;
			lnDropFields, ;
			lnI, ;
			lnPos, ;
			lnOld, ;
			laToDo[1], ;
			llCreate, ;
			llAlter, ;
			llDidField, ;
			lcStep, ;
			lnNext, ;
			lcToDo
		
		* Parameter checking.
		
		with This
			if pcount() < 2 or type('taDBFFields[1, 1]') <> 'C' or ;
				type('taDBCFields[1, 1]') <> 'C'
				.Warning(ccERR_INVALID_PARAMETERS)
				return ''
			endif pcount() < 2 ...
		
		* Determine how many fields are in the table and how many defined in the DBC.
		
			lnDBCFields  = alen(taDBCFields, 1)
			lnDBFFields  = alen(taDBFFields, 1)
			lnDBFColumns = alen(taDBFFields, 2)
			lnDBCColumns = alen(taDBCFields, 2)
			llStepColumn = inlist(lnDBFColumns, 7, 18)
			lnStepColumn = iif(lnDBFColumns = 18, 18, 7)
			lnOldNameCol = iif(lnDBCColumns = 20, 19, 17)
			lnDBCStepCol = iif(lnDBCColumns = 20, 18, 0)
		
		* Check every field defined in the table to see if it's defined in the meta
		* data. lcToDo will contain ALTER TABLE commands to remove fields as necessary.
		
			lnToDo = 0
			lnDropFields = 0
			for lnI = 1 to lnDBFFields
				lnPos = .ArrayScan(@taDBCFields, taDBFFields[lnI, 1],  1)
				lnOld = .ArrayScan(@taDBCFields, taDBFFields[lnI, 1], lnOldNameCol)
				if lnPos = 0 and lnOld = 0
					lnToDo = lnToDo + 1
					dimension laToDo[lnToDo]
					laToDo[lnToDo] = 'drop column ' + trim(taDBFFields[lnI, 1])
					lnDropFields   = lnDropFields + 1
				endif lnPos = 0 ...
			next lnI
		
		* Check every field defined in the meta data to see if it exists in the table
		* and if its structure is the same. lcToDo will contain ALTER TABLE commands to
		* add or change fields as necessary.
		
			llCreate = .F.
			llAlter  = .F.
			for lnI = 1 to lnDBCFields
				lnPos = .ArrayScan(@taDBFFields, taDBCFields[lnI, 1], 1)
				lnOld = .ArrayScan(@taDBFFields, taDBCFields[lnI, lnOldNameCol], 1)
		
		* If this is a renamed field, create code to rename it (handle it here rather
		* than in the CASE statement, since we may have other structural changes as
		* well). Set the "use ALTER TABLE" flag.
		
				if lnPos = 0 and lnOld <> 0
					lnToDo = lnToDo + 1
					dimension laToDo[lnToDo]
					laToDo[lnToDo] = 'rename column ' + ;
						trim(taDBCFields[lnI, lnOldNameCol]) + ' to ' + ;
						trim(taDBCFields[lnI, 1])
					lnPos   = lnOld
					llAlter = .T.
				endif lnPos = 0 ...
				llDidField = .F.
				do case
		
		* If this is a new field added in the middle of the table, set a flag that we
		* can't use ALTER TABLE for that step, since it doesn't support that.
		
					case lnPos = 0 and lnOld = 0 and lnI <= lnDBFFields - lnDropFields
						llCreate = .T.
		
		* If this is a new field added to the end of the table and we're not already
		* using the CREATE TABLE mechanism, create code to add it to the table.
		
					case lnPos = 0 and lnOld = 0 and not llCreate
						lnToDo = lnToDo + 1
						dimension laToDo[lnToDo]
						laToDo[lnToDo] = 'add column ' + trim(taDBCFields[lnI, 1]) + ;
							' ' + taDBCFields[lnI, 2]
						do case
							case taDBCFields[lnI, 2] = 'B'
								laToDo[lnToDo] = laToDo[lnToDo] + '(' + ;
									ltrim(str(taDBCFields[lnI, 4])) + ')'
							case taDBCFields[lnI, 2] $ 'CNFVQ'
								laToDo[lnToDo] = laToDo[lnToDo] + '(' + ;
									ltrim(str(taDBCFields[lnI, 3])) + ;
									iif(taDBCFields[lnI, 4] = 0, '', ',' + ;
									ltrim(str(taDBCFields[lnI, 4]))) + ')'
						endcase
						laToDo[lnToDo] = laToDo[lnToDo] + iif(taDBCFields[lnI, 5], ;
							' null', ' not null')
						if taDBCFields[lnI, 6] and taDBCFields[lnI, 2] $ 'CMV'
							laToDo[lnToDo] = laToDo[lnToDo] + ' nocptrans'
						endif taDBCFields[lnI, 6] ...
						if not empty(taDBCFields[lnI, 7])
							laToDo[lnToDo] = laToDo[lnToDo] + ' check ' + ;
								taDBCFields[lnI, 7] + ;
								iif(empty(taDBCFields[lnI, 8]), '', ' error ' + ;
								taDBCFields[lnI, 8])
						endif not empty(taDBCFields[lnI, 7])
						if not empty(taDBCFields[lnI, 9]) and ;
							(lnDBCStepCol = 0 or empty(taDBCFields[lnI, 18]))
							laToDo[lnToDo] = laToDo[lnToDo] + ' default ' + ;
								taDBCFields[lnI, 9]
						endif not empty(taDBCFields[lnI, 9]) ...
						if lnDBCStepCol > 0 and not empty(taDBCFields[lnI, 18])
							lcStep = transform(taDBCFields[lnI, 18])
							lnNext = taDBCFields[lnI, 17]
							laToDo[lnToDo] = laToDo[lnToDo] + ' autoinc '
							if not tlFree
								laToDo[lnToDo] = laToDo[lnToDo] + ;
									'nextvalue reccount() + ' + transform(lnNext) + ;
									' step ' + lcStep + ;
									' default (recno() - 1)' + ;
									iif(lcStep = '1', '', ' * ' + lcStep) + ;
									' + ' + transform(lnNext)
							endif not tlFree
						endif lnDBCStepCol > 0 ...
		
		* If this field exists but the structure is different, create code to alter
		* the field. Set the "use ALTER TABLE" flag if the data type was changed.
		
					case lnPos > 0 and ;
						(taDBFFields[lnPos, 2] <> taDBCFields[lnI, 2] or ;
						iif(not taDBCFields[lnI, 2] $ 'CNFVQ', .F., ;
						taDBFFields[lnPos, 3] <> taDBCFields[lnI, 3]) or ;
						iif(not taDBCFields[lnI, 2] $ 'NFB', .F., ;
						taDBFFields[lnPos, 4] <> taDBCFields[lnI, 4]) or ;
						taDBFFields[lnPos, 5] <> taDBCFields[lnI, 5] or ;
						iif(not taDBCFields[lnI, 2] $ 'CMV', .F., ;
						taDBFFields[lnPos, 6] <> taDBCFields[lnI, 6]) or ;
						(llStepColumn and ;
						taDBFFields[lnPos, lnStepColumn] <> taDBCFields[lnI, 18]))
						lnToDo = lnToDo + 1
						dimension laToDo[lnToDo]
						laToDo[lnToDo] = 'alter column ' + ;
							trim(taDBCFields[lnI, 1]) + ' ' + taDBCFields[lnI, 2]
						do case
							case taDBCFields[lnI, 2] = 'B'
								laToDo[lnToDo] = laToDo[lnToDo] + '(' + ;
									ltrim(str(taDBCFields[lnI, 4])) + ')'
							case taDBCFields[lnI, 2] $ 'CNFVQ'
								laToDo[lnToDo] = laToDo[lnToDo] + '(' + ;
									ltrim(str(taDBCFields[lnI, 3])) + ;
									iif(taDBCFields[lnI, 4] = 0, '', ',' + ;
									ltrim(str(taDBCFields[lnI, 4]))) + ')'
						endcase
						laToDo[lnToDo] = laToDo[lnToDo] + iif(taDBCFields[lnI, 5], ;
							' null', ' not null')
						if taDBCFields[lnI, 6] and taDBCFields[lnI, 2] $ 'CMV'
							laToDo[lnToDo] = laToDo[lnToDo] + ' nocptrans'
						endif taDBCFields[lnI, 6] ...
						if llStepColumn and ;
							taDBFFields[lnPos, lnStepColumn] <> taDBCFields[lnI, 18] and ;
							taDBCFields[lnI, 18] > 0
							lcStep = transform(taDBCFields[lnI, 18])
							laToDo[lnToDo] = laToDo[lnToDo] + ' autoinc '
							if not tlFree
								laToDo[lnToDo] = laToDo[lnToDo] + ;
									'nextvalue -909090 step ' + lcStep	&& -909090 is a flag that
																		&& indicates we have to calc next
																		&& value
							endif not tlFree
						endif llStepColumn ...
						llDidField = .T.
						llAlter    = llAlter or ;
							taDBFFields[lnPos, 2] <> taDBCFields[lnI, 2]
				endcase
		
		* If the DBF array has information for the field-level rule and default,
		* handle it.
		
				if lnPos > 0 and lnDBFColumns > 7 and not llCreate
					do case
		
		* Neither the table nor the meta data have a field-level rule, so we have
		* nothing to do.
		
						case empty(taDBFFields[lnPos, 7]) and ;
							empty(taDBCFields[lnI, 7])
		
		* If we're supposed to have a rule and we either already handled the field (in
		* which case we have to specifically add it again or else it'll get lost) or
		* the existing table has a different one, we need to add a CHECK clause.
		
						case not empty(taDBCFields[lnI, 7]) and (llDidField or ;
							not taDBFFields[lnPos, 7] == taDBCFields[lnI, 7] or ;
							not taDBFFields[lnPos, 8] == taDBCFields[lnI, 8])
							if llDidField
								laToDo[lnToDo] = laToDo[lnToDo] + ' check '
							else
								lnToDo = lnToDo + 1
								dimension laToDo[lnToDo]
								laToDo[lnToDo] = 'alter column ' + ;
									trim(taDBCFields[lnI, 1]) + ' set check '
							endif llDidField
							laToDo[lnToDo] = laToDo[lnToDo] + taDBCFields[lnI, 7] + ;
								iif(empty(taDBCFields[lnI, 8]), '', ' error ' + ;
								taDBCFields[lnI, 8])
		
		* We no longer have a rule. If we've already handled this field, we don't need
		* to do anything since the rule will get dropped unless we specifically add it
		* again. If we didn't already handle the field, though, we need to remove the
		* rule using DROP CHECK.
		
						case empty(taDBCFields[lnI, 7]) and not llDidField
							lnToDo = lnToDo + 1
							dimension laToDo[lnToDo]
							laToDo[lnToDo] = 'alter column ' + ;
								trim(taDBCFields[lnI, 1])
							laToDo[lnToDo] = laToDo[lnToDo] + ' drop check'
					endcase
					do case
		
		* Neither the table nor the meta data have a DefaultValue, so we have nothing
		* to do.
		
						case empty(taDBFFields[lnPos, 9]) and ;
							empty(taDBCFields[lnI, 9])
		
		* If we're supposed to have a DefaultValue property and we either already
		* handled the field (in which case we have to specifically add it again or else
		* it'll get lost) or the existing table has a different one, we need to add a
		* DEFAULT clause.
		
						case not empty(taDBCFields[lnI, 9]) and (llDidField or ;
							not taDBFFields[lnPos, 9] == taDBCFields[lnI, 9])
							if llDidField
								laToDo[lnToDo] = laToDo[lnToDo] + ' default '
							else
								lnToDo = lnToDo + 1
								dimension laToDo[lnToDo]
								laToDo[lnToDo] = 'alter column ' + ;
									trim(taDBCFields[lnI, 1]) + ' set default '
							endif llDidField
							laToDo[lnToDo] = laToDo[lnToDo] + taDBCFields[lnI, 9]
		
		* We no longer have a DefaultValue property. If we've already handled this
		* field, we don't need to do anything since the property will get dropped
		* unless we specifically add it again. If we didn't already handle the field,
		* though, we need to remove the property using DROP DEFAULT.
		
						case empty(taDBCFields[lnI, 9]) and not llDidField
							lnToDo = lnToDo + 1
							dimension laToDo[lnToDo]
							laToDo[lnToDo] = 'alter column ' + ;
								trim(taDBCFields[lnI, 1])
							laToDo[lnToDo] = laToDo[lnToDo] + ' drop default'
					endcase
				endif lnPos > 0 ...
			next lnI
			do case
		
		* If we need to use the CREATE TABLE mechanism and we're not doing something
		* that requires an additional ALTER TABLE (like renaming a field or changing a
		* data type), let's wipe out the ALTER TABLE instructions. 
		
				case llCreate and not llAlter
					lnToDo = 0
		
		* If the DBF array has information for the table-level rule, handle it now.
		
				case lnDBFColumns <= 7 or (lnDBFColumns > 7 and ;
					empty(taDBFFields[1, 10]) and empty(taDBCFields[1, 10]))
				case empty(taDBFFields[1, 10]) or (not empty(taDBCFields[1, 10]) and ;
					(not taDBFFields[1, 10] == taDBCFields[1, 10] or ;
					not taDBFFields[1, 11] == taDBCFields[1, 11]))
					lnToDo = lnToDo + 1
					dimension laToDo[lnToDo]
					laToDo[lnToDo] = 'set check ' + taDBCFields[1, 10] + ;
						iif(empty(taDBCFields[1, 11]), '', ' error ' + ;
						taDBCFields[1, 11])
				case empty(taDBCFields[1, 10])
					lnToDo = lnToDo + 1
					dimension laToDo[lnToDo]
					laToDo[lnToDo] = 'drop check'
			endcase
		
		* If we have anything to do, fill the aHowToSync array with the individual
		* steps and create the ALTER TABLE statement, treating DROP COLUMN at the end
		* to eliminate a problem if all the fields in the table are being replaced:
		* all fields would be dropped before new fields are added.
		
			lcToDo = ''
			if lnToDo > 0
				dimension .aHowToSync[lnToDo]
				acopy(laToDo, .aHowToSync)
				for lnI = 1 to lnToDo
		*** ADD SUPPORT FOR lDropBeforeAdd SWITCH: IF .F., CHECK FOR 'add column' INSTEAD
					if laToDo[lnI] <> 'drop column'
						lcToDo = lcToDo + ' ' + laToDo[lnI]
						laToDo[lnI] = ''
					endif laToDo[lnI] <> 'drop column'
				next lnI
				for lnI = 1 to lnToDo
					if not empty(laToDo[lnI])
						lcToDo = lcToDo + ' ' + laToDo[lnI]
						laToDo[lnI] = ''
					endif not empty(laToDo[lnI])
				next lnI
			endif lnToDo > 0
		endwith
		return lcToDo
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Initialize the manager and various properties
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	08/23/2004
		* Parameters:		none
		* Returns:			see BaseMgr::Init()
		* Environment In:	see BaseMgr::Init()
		* Environment Out:	see BaseMgr::Init()
		*==============================================================================
		
		* Use the BaseMgr's Init method to do most of the work.
		
		local llReturn, ;
			lcPath
		with This
			llReturn = dodefault()
		
		* Define collate sequences. This information comes from the Microsoft
		* KnowledgeBase article Q199778, except Hebrew and Arabic aren't listed because
		* I can't determine the value for the DBF header for these code pages.
		
			dimension .aCollate[22, 3]
			.aCollate[ 1, 1] = 'Baltic'
			.aCollate[ 1, 2] = 'BALTIC'
			.aCollate[ 1, 3] = '1257'
			.aCollate[ 2, 1] = 'Czech'
			.aCollate[ 2, 2] = 'CZECH'
			.aCollate[ 2, 3] = '852,895,1250'
			.aCollate[ 3, 1] = 'Dutch'
			.aCollate[ 3, 2] = 'DUTCH'
			.aCollate[ 3, 3] = '437,850,1252'
			.aCollate[ 4, 1] = 'General'
			.aCollate[ 4, 2] = 'GENERAL'
			.aCollate[ 4, 3] = '437,620,850,852,861,865,895,1250,1252'
			.aCollate[ 5, 1] = 'German - Phone Book'
			.aCollate[ 5, 2] = 'GERMAN'
			.aCollate[ 5, 3] = '437,1252'
			.aCollate[ 6, 1] = 'Greek'
			.aCollate[ 6, 2] = 'GREEK'
			.aCollate[ 6, 3] = '737,1253'
			.aCollate[ 7, 1] = 'Hungarian'
			.aCollate[ 7, 2] = 'HUNGARY'
			.aCollate[ 7, 3] = '852,1250'
			.aCollate[ 8, 1] = 'Icelandic'
			.aCollate[ 8, 2] = 'ICELAND'
			.aCollate[ 8, 3] = '437,850,861,1252'
			.aCollate[ 9, 1] = 'Japanese'
			.aCollate[ 9, 2] = 'JAPANESE'
			.aCollate[ 9, 3] = '932'
			.aCollate[10, 1] = 'Korean'
			.aCollate[10, 2] = 'KOREAN'
			.aCollate[10, 3] = '949'
			.aCollate[11, 1] = 'Machine'
			.aCollate[11, 2] = 'MACHINE'
			.aCollate[11, 3] = '*'
			.aCollate[12, 1] = 'Norwegian/Danish'
			.aCollate[12, 2] = 'NORDAN'
			.aCollate[12, 3] = '437,850,865,1252'
			.aCollate[13, 1] = 'PinYin (Simplified Chinese)'
			.aCollate[13, 2] = 'PINYIN'
			.aCollate[13, 3] = '936'
			.aCollate[14, 1] = 'Polish'
			.aCollate[14, 2] = 'POLISH'
			.aCollate[14, 3] = '620,852,1250'
			.aCollate[15, 1] = 'Russian'
			.aCollate[15, 2] = 'RUSSIAN'
			.aCollate[15, 3] = '866,1251'
			.aCollate[16, 1] = 'Slovak'
			.aCollate[16, 2] = 'SLOVAK'
			.aCollate[16, 3] = '852,895,1250'
			.aCollate[17, 1] = 'Spanish'
			.aCollate[17, 2] = 'SPANISH'
			.aCollate[17, 3] = '437,850,1252'
			.aCollate[18, 1] = 'Stroke (Simp. and Trad. Chinese)'
			.aCollate[18, 2] = 'STROKE'
			.aCollate[18, 3] = '936,950'
			.aCollate[19, 1] = 'Swedish/Finnish'
			.aCollate[19, 2] = 'SWEFIN'
			.aCollate[19, 3] = '437,850,1252'
			.aCollate[20, 1] = 'Thai'
			.aCollate[20, 2] = 'THAI'
			.aCollate[20, 3] = '874'
			.aCollate[21, 1] = 'Turkish'
			.aCollate[21, 2] = 'TURKISH'
			.aCollate[21, 3] = '1254,857'
			.aCollate[22, 1] = 'Unique Weight'
			.aCollate[22, 2] = 'UNIQWT'
			.aCollate[22, 3] = '437,850,1252'
		
		* Define code pages. This information comes from the VFP help file and
		* Microsoft KnowledgeBase article Q199778, except Hebrew and Arabic aren't
		* listed because I can't determine the value for the DBF header for these
		* code pages.
		
			dimension .aCodePage[23, 3]
			.aCodePage[ 1, 1] = '    0 - No Code Page'
			.aCodePage[ 1, 2] = 0
			.aCodePage[ 1, 3] = 0
			.aCodePage[ 2, 1] = '  437 - U.S. MS-DOS'
			.aCodePage[ 2, 2] = 437
			.aCodePage[ 2, 3] = 1
			.aCodePage[ 3, 1] = '  620 - Mazovia (Polish) MS-DOS'
			.aCodePage[ 3, 2] = 620
			.aCodePage[ 3, 3] = 105
			.aCodePage[ 4, 1] = '  737 - Greek MS-DOS (437G)'
			.aCodePage[ 4, 2] = 737
			.aCodePage[ 4, 3] = 106
			.aCodePage[ 5, 1] = '  850 - International MS-DOS'
			.aCodePage[ 5, 2] = 850
			.aCodePage[ 5, 3] = 2
			.aCodePage[ 6, 1] = '  852 - EE MS-DOS (Latin II)'
			.aCodePage[ 6, 2] = 852
			.aCodePage[ 6, 3] = 100
			.aCodePage[ 7, 1] = '  857 - Turkish MS-DOS'
			.aCodePage[ 7, 2] = 857
			.aCodePage[ 7, 3] = 107
			.aCodePage[ 8, 1] = '  861 - Icelandic MS-DOS'
			.aCodePage[ 8, 2] = 861
			.aCodePage[ 8, 3] = 103
			.aCodePage[ 9, 1] = '  863 - French-Canadian MS-DOS'
			.aCodePage[ 9, 2] = 863
			.aCodePage[ 9, 3] = 108
			.aCodePage[10, 1] = '  865 - Nordic MS-DOS'
			.aCodePage[10, 2] = 865
			.aCodePage[10, 3] = 102
			.aCodePage[11, 1] = '  866 - Russian MS-DOS'
			.aCodePage[11, 2] = 866
			.aCodePage[11, 3] = 101
			.aCodePage[12, 1] = '  874 - Thai Windows/MS-DOS'
			.aCodePage[12, 2] = 874
			.aCodePage[12, 3] = 124
			.aCodePage[13, 1] = '  895 - Kamenicky (Czech) MS-DOS'
			.aCodePage[13, 2] = 895
			.aCodePage[13, 3] = 104
			.aCodePage[14, 1] = '  932 - Japanese'
			.aCodePage[14, 2] = 932
			.aCodePage[14, 3] = 123
			.aCodePage[15, 1] = '  936 - Chinese (PRC, Hong Kong, Singapore)'
			.aCodePage[15, 2] = 936
			.aCodePage[15, 3] = 122
			.aCodePage[16, 1] = '  949 - Korean'
			.aCodePage[16, 2] = 949
			.aCodePage[16, 3] = 121
			.aCodePage[17, 1] = '  950 - Chinese (Taiwan)'
			.aCodePage[17, 2] = 950
			.aCodePage[17, 3] = 120
			.aCodePage[18, 1] = ' 1250 - Windows EE'
			.aCodePage[18, 2] = 1250
			.aCodePage[18, 3] = 200
			.aCodePage[19, 1] = ' 1251 - Russian Windows'
			.aCodePage[19, 2] = 1251
			.aCodePage[19, 3] = 201
			.aCodePage[20, 1] = ' 1252 - Windows ANSI'
			.aCodePage[20, 2] = 1252
			.aCodePage[20, 3] = 3
			.aCodePage[21, 1] = ' 1253 - Greek Windows'
			.aCodePage[21, 2] = 1253
			.aCodePage[21, 3] = 203
			.aCodePage[22, 1] = ' 1254 - Turkish Windows'
			.aCodePage[22, 2] = 1254
			.aCodePage[22, 3] = 202
			.aCodePage[23, 1] = ' 1257 - Baltic Windows'
			.aCodePage[23, 2] = 1257
			.aCodePage[23, 3] = 204
		
		* Define an array of data types: column 1 is the data type name, column 2 is
		* the data type code, and column 3 is .T. if  is data type is new to VFP.
		
			dimension .aDataTypes[13, 3]
			.aDataTypes[ 1, 1] = 'Character'
			.aDataTypes[ 1, 2] = 'C'
			.aDataTypes[ 1, 3] = .F.
			.aDataTypes[ 2, 1] = 'Character (Binary)'
			.aDataTypes[ 2, 2] = 'C'
			.aDataTypes[ 2, 3] = .T.
			.aDataTypes[ 3, 1] = 'Currency'
			.aDataTypes[ 3, 2] = 'Y'
			.aDataTypes[ 3, 3] = .T.
			.aDataTypes[ 4, 1] = 'Date'
			.aDataTypes[ 4, 2] = 'D'
			.aDataTypes[ 4, 3] = .F.
			.aDataTypes[ 5, 1] = 'DateTime'
			.aDataTypes[ 5, 2] = 'T'
			.aDataTypes[ 5, 3] = .T.
			.aDataTypes[ 6, 1] = 'Double'
			.aDataTypes[ 6, 2] = 'B'
			.aDataTypes[ 6, 3] = .T.
			.aDataTypes[ 7, 1] = 'Float'
			.aDataTypes[ 7, 2] = 'F'
			.aDataTypes[ 7, 3] = .F.
			.aDataTypes[ 8, 1] = 'General'
			.aDataTypes[ 8, 2] = 'G'
			.aDataTypes[ 8, 3] = .F.
			.aDataTypes[ 9, 1] = 'Integer'
			.aDataTypes[ 9, 2] = 'I'
			.aDataTypes[ 9, 3] = .T.
			.aDataTypes[10, 1] = 'Logical'
			.aDataTypes[10, 2] = 'L'
			.aDataTypes[10, 3] = .F.
			.aDataTypes[11, 1] = 'Memo'
			.aDataTypes[11, 2] = 'M'
			.aDataTypes[11, 3] = .F.
			.aDataTypes[12, 1] = 'Memo (Binary)'
			.aDataTypes[12, 2] = 'M'
			.aDataTypes[12, 3] = .T.
			.aDataTypes[13, 1] = 'Numeric'
			.aDataTypes[13, 2] = 'N'
			.aDataTypes[13, 3] = .F.
			if version(5) >= 800
				dimension .aDataTypes[14, 3]
				.aDataTypes[14, 1] = 'Integer (Auto-Inc)'
				.aDataTypes[14, 2] = 'I'
				.aDataTypes[14, 3] = .T.
				asort(.aDataTypes)
			endif version(5) >= 800
			if version(5) >= 900
				dimension .aDataTypes[18, 3]
				.aDataTypes[15, 1] = 'Varchar'
				.aDataTypes[15, 2] = 'V'
				.aDataTypes[15, 3] = .T.
				.aDataTypes[16, 1] = 'Varchar (Binary)'
				.aDataTypes[16, 2] = 'V'
				.aDataTypes[16, 3] = .T.
				.aDataTypes[17, 1] = 'Varbinary'
				.aDataTypes[17, 2] = 'Q'
				.aDataTypes[17, 3] = .T.
				.aDataTypes[18, 1] = 'Blob'
				.aDataTypes[18, 2] = 'W'
				.aDataTypes[18, 3] = .T.
				asort(.aDataTypes)
			endif version(5) >= 900
		
		* Create an array of index types.
		
			dimension .aIndexTypes[4]
			.aIndexTypes[1] = ccPRIMARY
			.aIndexTypes[2] = ccCANDIDATE
			.aIndexTypes[3] = ccREGULAR
			.aIndexTypes[4] = ccUNIQUE
			if version(5) >= 900
				dimension .aIndexTypes[5]
				.aIndexTypes[5] = ccBINARY
			endif version(5) >= 900
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE isindexoutofsync		&& Determines if a table's indexes are out of sync with the definitions in the DBC and DBCX.
		*==============================================================================
		* Method:			IsIndexOutOfSync
		* Status:			Public
		* Purpose:			Determine if a table's indexes and DBC are out of sync
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
		* Last revision:	03/06/2003
		* Parameters:		taCDXIndexes - a array (see This.GetIndexStructure for the
		*						format of the array) containing the structure of the
		*						indexes as defined in the table
		*					taDBCIndexes - a array containing the structure of the
		*						indexes as defined in the DBC
		* Returns:			.T. if the table's indexes are out of sync with the DBC
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters taCDXIndexes, ;
			taDBCIndexes
		external array taCDXIndexes, ;
			taDBCIndexes
		local lnDBCIndexes, ;
			lnCDXIndexes, ;
			lnColumns, ;
			llReturn, ;
			lnI, ;
			lnIndex, ;
			lnJ
		
		* Parameter checking.
		
		with This
			if pcount() <> 2 or type('taCDXIndexes[1, 1]') <> 'C' or ;
				type('taDBCIndexes[1, 1]') <> 'C'
				.Warning(ccERR_INVALID_PARAMETERS)
				return .F.
			endif pcount() <> 2 ...
		
		* Determine how many indexes are in the table and how many defined in the DBC.
		
			lnDBCIndexes = alen(taDBCIndexes, 1)
			lnCDXIndexes = alen(taCDXIndexes, 1)
			lnColumns    = min(alen(taDBCIndexes, 2), alen(taCDXIndexes, 2))
			llReturn     = lnDBCIndexes <> lnCDXIndexes
		
		* Check every index defined in the DBC to see if it exists in the table and if
		* it's the same (we'll ignore PhDbase expressions because they might be
		* different than what's stored in the meta data).
		
			if not llReturn
				for lnI = 1 to lnDBCIndexes
					lnIndex = .ArrayScan(@taCDXIndexes, taDBCIndexes[lnI, 1], 1)
					do case
						case lnIndex = 0
							llReturn = .T.
							exit
						case upper(taDBCIndexes[lnI, 2]) = 'PHD(' or ;
							upper(taCDXIndexes[lnIndex, 2]) = 'PHD('
						otherwise
							for lnJ = 2 to lnColumns
								if not taDBCIndexes[lnI, lnJ] == taCDXIndexes[lnIndex, lnJ]
									llReturn = .T.
									exit
								endif not taDBCIndexes[lnI, lnJ] == taCDXIndexes[lnIndex, lnJ]
							next lnJ
							if llReturn
								exit
							endif llReturn
					endcase
				next lnI
			endif not llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE istableoutofsync		&& Determines if a table's physical structure is out of sync with the definition in the DBC and DBCX.
		*==============================================================================
		* Method:			IsTableOutOfSync
		* Status:			Public
		* Purpose:			Determine if a table and DBC are out of sync
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	08/18/2004
		* Parameters:		taDBFFields  - a array (in AFIELDS() format) containing the
		*						structure of the table as defined in the header
		*					taDBCFields  - a array (in AFIELDS() format) containing the
		*						structure of the table as defined in the meta data
		*					tnTableCP    - the code page # defined for the table 
		*						(optional: if it isn't passed, no code page comparison
		*						is done)
		*					tnCodePage   - the code page # defined in the meta data
		*						(optional: if it isn't passed, no code page comparison
		*						is done)
		*					tnTableBlock - the blocksize defined for the table 
		*						(optional: if it isn't passed, no blocksize comparison
		*						is done)
		*					tnBlockSize  - the blocksize defined in the meta data
		*						(optional: if it isn't passed, no blocksize comparison
		*						is done)
		* Returns:			0 if the table and DBC are in sync
		*					1 if the table is out of sync structurally
		*					2 if the table is out of sync but just needs a new header
		*						(because of renamed fields or a code page difference)
		*					-1 if something went wrong
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters taDBFFields, ;
			taDBCFields, ;
			tnTableCP, ;
			tnCodePage, ;
			tnTableBlock, ;
			tnBlockSize
		external array taDBFFields, ;
			taDBCFields
		local lnDBCFields, ;
			lnDBFFields, ;
			llCheckCP, ;
			llCheckBlock, ;
			lnDBFColumns, ;
			llStepColumn, ;
			lnStepColumn, ;
			lnDBCColumns, ;
			lnOldNameCol, ;
			lnBlockSize, ;
			llNeedUpdate, ;
			llJustRename, ;
			lnI
		
		* Parameter checking.
		
		with This
			if pcount() < 2 or type('taDBFFields[1, 1]') <> 'C' or ;
				type('taDBCFields[1, 1]') <> 'C'
				.Warning(ccERR_INVALID_PARAMETERS)
				return -1
			endif pcount() < 2 ...
		endwith
		
		* Determine how many fields are in the table and how many defined in the meta
		* data.
		
		lnDBCFields  = alen(taDBCFields, 1)
		lnDBFFields  = alen(taDBFFields, 1)
		llCheckCP    = pcount() >= 4
		llCheckBlock = pcount() = 6
		lnDBFColumns = alen(taDBFFields, 2)
		llStepColumn = inlist(lnDBFColumns, 7, 18)
		lnStepColumn = iif(lnDBFColumns = 18, 18, 7)
		lnDBCColumns = alen(taDBCFields, 2)
		lnOldNameCol = iif(lnDBCColumns = 20, 19, 17)
		
		* Check the file structure against the data dictionary. First, let's just do a
		* quick check: if the number of fields doesn't match or the blocksize isn't
		* correct, flag that the table is out of sync and it's not just a renamed
		* field.
		
		lnBlockSize  = iif(This.TableHasMemo(@taDBCFields), tnBlockSize, 0)
		llNeedUpdate = lnDBCFields <> lnDBFFields or (llCheckBlock and ;
			tnTableBlock <> lnBlockSize)
		llJustRename = .F.
		
		* If the number of fields matches, check each field for a difference.
		
		if not llNeedUpdate
			for lnI = 1 to lnDBCFields
				do case
		
		* If the field type, length, decimals, binary, null, or step value settings are
		* different, flag that the table is out of sync and it's not just a renamed
		* field.
		
					case taDBCFields[lnI, 2] <> taDBFFields[lnI, 2] or ;
						iif(not taDBCFields[lnI, 2] $ 'CNFVQ', .F., ;
						taDBCFields[lnI, 3] <> taDBFFields[lnI, 3]) or ;
						iif(not taDBCFields[lnI, 2] $ 'NFB', .F., ;
						taDBCFields[lnI, 4] <> taDBFFields[lnI, 4]) or ;
						taDBCFields[lnI, 5] <> taDBFFields[lnI, 5] or ;
						iif(not taDBCFields[lnI, 2] $ 'CMV', .F., ;
						taDBCFields[lnI, 6] <> taDBFFields[lnI, 6]) or ;
						(llStepColumn and ;
						taDBCFields[lnI, 18] <> taDBFFields[lnI, lnStepColumn])
						llNeedUpdate = .T.
						exit
		
		* If the structural information is the same but the field was renamed, flag
		* that.
		
					case not upper(taDBCFields[lnI, 1]) == upper(taDBFFields[lnI, 1]) and ;
						upper(taDBCFields[lnI, lnOldNameCol]) == upper(taDBFFields[lnI, 1])
						llJustRename = .T.
		
		* If the field names don't match and we don't know what the former name was,
		* flag that the table is out of sync and it's not just a renamed field.
		
					case not upper(taDBCFields[lnI, 1]) == upper(taDBFFields[lnI, 1])
						llNeedUpdate = .T.
						exit
		
		* If the DBF array has information for the field-level rule and default,
		* handle it.
		
					case alen(taDBFFields, 2) > 7 and ;
						not (((not empty(taDBCFields[lnI, 7]) and ;
						normalize(taDBCFields[lnI, 7]) == upper(taDBFFields[lnI, 7])) or ;
						upper(taDBFFields[lnI, 7]) == upper(taDBCFields[lnI, 7])) and ;
						((not empty(taDBCFields[lnI, 8]) and ;
						normalize(taDBCFields[lnI, 8]) == upper(taDBFFields[lnI, 8])) or ;
						upper(taDBFFields[lnI, 8]) == upper(taDBCFields[lnI, 8])) and ;
						((llStepColumn and taDBCFields[lnI, 18] <> 0) or ;
						((not empty(taDBCFields[lnI, 9]) and ;
						normalize(taDBCFields[lnI, 9]) == upper(taDBFFields[lnI, 9])) or ;
						upper(taDBFFields[lnI, 9]) == upper(taDBCFields[lnI, 9]))))
						llNeedUpdate = .T.
						exit
				endcase
			next lnI
		endif not llNeedUpdate
		
		* If the DBF array has information for the table-level rule, check it now.
		
		if not llNeedUpdate and alen(taDBFFields, 2) > 7 and ;
			not (((not empty(taDBCFields[1, 10]) and ;
			normalize(taDBCFields[1, 10]) == upper(taDBFFields[1, 10])) or ;
			upper(taDBFFields[1, 10]) == upper(taDBCFields[1, 10])) and ;
			((not empty(taDBCFields[1, 11]) and ;
			normalize(taDBCFields[1, 11]) == upper(taDBFFields[1, 11])) or ;
			upper(taDBFFields[1, 11]) == upper(taDBCFields[1, 11])))
			llNeedUpdate = .T.
		endif not llNeedUpdate ...
		
		* If we're supposed to check the code page and the table's code page isn't the
		* same as the one defined in the DBC but everything else is OK, we'll need a
		* new header.
		
		do case
			case llNeedUpdate
				llJustRename = .F.
			case llCheckCP and tnTableCP <> tnCodePage and tnCodePage <> 0
				llJustRename = .T.
		endcase
		
		* Return the proper value based on what we found.
		
		return iif(llNeedUpdate, 1, 0) + iif(llJustRename, 2, 0)
		
	ENDPROC

	PROCEDURE needreindex		&& Determines if Reindex should be used on any table in the DBC.
		*==============================================================================
		* Method:			NeedReindex
		* Status:			Public
		* Purpose:			Determine if any table's indexes and DBC are out of sync
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	08/17/2005
		* Parameters:		tcAlias    - the name of a table to check (optional: if
		*						blank or not passed, all tables are checked). tcAlias
		*						can include a database by specifying
		*						<database>!<table>; specify "ALL" for <database> to
		*						handle all tables in all databases and free tables
		*					toProgress - a reference to a progress window (optional:
		*						if it isn't passed and lQuiet is .F., a new progress
		*						window will be created)
		* Returns:			.T. if any table's indexes are out of sync with the DBC
		* Environment in:	if a database isn't specified, a database is selected
		* Environment out:	none
		*==============================================================================
		
		lparameters tcAlias, ;
			toProgress
		local lcDBC, ;
			lcCurrDBC, ;
			lcAlias, ;
			llAll, ;
			lcFullPath, ;
			llReturn, ;
			laTables[1], ;
			lnTables, ;
			loProgress, ;
			lnI, ;
			lcTable, ;
			lcDescription
		
		* If a database was specified and it's open, select it.
		
		with This
			lcDBC     = .Parent.GetDatabase()
			lcCurrDBC = dbc()
			do case
				case vartype(tcAlias) = 'C' and '!' $ tcAlias
					lcDBC = .Parent.GetDatabase(tcAlias)
					do case
						case not empty(lcDBC) or upper(alltrim(tcAlias)) == '!' + ccALL
							lcAlias = .Parent.StripDatabase(tcAlias)
						case right(alltrim(tcAlias), 1) = '!'
							lcAlias = ''
						otherwise
							lcAlias = .Parent.StripDatabase(tcAlias)
					endcase
					do case
						case empty(lcDBC) or upper(lcDBC) == ccALL
						case not dbused(lcDBC)
							.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
							return .F.
						case not upper(lcDBC) == set('DATABASE')
							.SetDatabase(lcDBC)
					endcase
		
		* If no alias was specified, set it to ALL. Otherwise, use the one specified.
		
				case vartype(tcAlias) <> 'C' or empty(tcAlias)
					lcAlias = ccALL
				otherwise
					lcAlias = tcAlias
			endcase
		
		* Flag if we're doing all databases and free tables.
		
			if upper(lcDBC) == ccALL
				llAll = .T.
			endif upper(lcDBC) == ccALL
		
		* Save the current settings.
		
			lcFullPath = set('FULLPATH')
			set fullpath on
		
		* Finalize the alias.
		
			lcAlias = alltrim(upper(lcAlias))
			lcAlias = iif(lcAlias == ccALL, '', lcAlias)
			do case
		
		* If no table was specified, do them all.
		
				case empty(lcAlias)
					llReturn = .F.
					lnTables = .Parent.DBCXGetAllObjects(lcDBC + '!Table', @laTables, ;
						'Caption', 'SDTCanUpdate', .T.)
		
		* Display a progress meter if necessary.
		
					if not .lQuiet
						do case
							case vartype(toProgress) = 'O'
								loProgress = toProgress
							case '\' + justfname(.cProgressFormLibrary) $ upper(set('CLASSLIB'))
								loProgress = createobject(.cProgressFormClass, .T.)
								loProgress.Caption = strtran(ccMSG_CHECKING, ccMSG_INSERT1, ;
									ccTABLES)
							otherwise
								loProgress = newobject(.cProgressFormClass, ;
									.cProgressFormLibrary, '', .T.)
								loProgress.Caption = strtran(ccMSG_CHECKING, ccMSG_INSERT1, ;
									ccTABLES)
						endcase
						lnMax = 100/lnTables
						loProgress.Show()
					endif not .lQuiet
		
		* Check each table.
		
					asort(laTables)
					for lnI = 1 to lnTables
						lcAlias = laTables[lnI, 2]
						.cAlias = lcAlias
						lcTable = iif(llAll, '', lcDBC + '!') + lcAlias
						if not .lQuiet
							lcDescription = laTables[lnI, 1]
							lcDescription = iif(empty(lcDescription), ;
								proper(lcAlias), lcDescription)
							loProgress.SetCaptions(strtran(ccMSG_CHECKING, ;
								ccMSG_INSERT1, lcDescription))
						endif not .lQuiet
						llReturn = .NeedReindexOne(lcTable)
						do case
							case llReturn
								exit
							case not .lQuiet
								loProgress.Update(lnI * lnMax)
								.FastDoEvents()
						endcase
					next lnI
					if not .lQuiet
						loProgress.Update(100)
						.FastDoEvents()
					endif not .lQuiet
		
		* If the specified table doesn't in the database, display an error.
		
				case not empty(lcDBC) and not indbc(lcAlias, 'Table')
					.Warning(strtran(ccERR_TABLE_NOT_FOUND, ccMSG_INSERT1, lcAlias))
					llReturn = .F.
		
		* Process the specified table.
		
				otherwise
					.cAlias  = lcAlias
					llReturn = .NeedReindexOne(lcDBC + '!' + lcAlias, not .lQuiet)
					if not .lQuiet
						wait clear
					endif not .lQuiet
			endcase
		
		* Cleanup and return.
		
			.SetDatabase(lcCurrDBC)
			if lcFullPath = 'OFF'
				set fullpath off
			endif lcFullPath = 'OFF'
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE needreindexone		&& Determines if Reindex() should be used for a single table.
		*==============================================================================
		* Method:			NeedReindexOne
		* Status:			Protected
		* Purpose:			Determine if a table's indexes and DBC are out of sync
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	03/30/2004
		* Parameters:		tcAlias   - the name of a table to check
		*					tlDisplay - .T. to display a WAIT WINDOW
		* Returns:			.T. if any of the table's indexes are out of sync with the
		*						DBC
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcAlias, ;
			tlDisplay
		local lcDBC, ;
			lcAlias, ;
			llReturn, ;
			llFree, ;
			lcFile, ;
			llError, ;
			llUsed, ;
			llSuppress, ;
			laTableIndexes[1], ;
			laIndexes[1]
		with This
		
		* Get the database and alias.
		
			if '!' $ tcAlias
				lcDBC   = .Parent.GetDatabase(tcAlias)
				lcAlias = .Parent.StripDatabase(tcAlias)
			else
				lcDBC   = .Parent.GetDatabase()
				lcAlias = tcAlias
			endif '!' $ tcAlias
		
		* Display a message about the table we're checking if necessary.
		
			if tlDisplay
				wait window strtran(ccMSG_CHECKING, ccMSG_INSERT1, lcAlias) nowait
			endif tlDisplay
		
		* Get the full path to the table.
		
			llReturn = .T.
			llFree   = empty(lcDBC)
			do case
				case llFree
					lcFile = .GetFreeTablePath(lcDBC + '!' + lcAlias)
					if empty(lcFile)
						.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
							lcAlias))
						llReturn = .F.
					endif empty(lcFile)
				case dbused(lcDBC)
					set database to (lcDBC)
					lcFile = fullpath(dbgetprop(lcAlias, 'Table', 'Path'), dbc())
				otherwise
					.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
					llReturn = .F.
			endcase
			do case
		
		* If we already have an error, we have nothing else to do.
		
				case not llReturn
		
		* If we can find the table and it isn't already open, try to open it. If we get
		* an error and it's an index related one, return .T.
		
				case file(lcFile)
					llError = .F.
					lcAlias = strtran(lcAlias, ' ', '_')
					llUsed  = used(lcAlias)
					if not llUsed
						.Parent.ResetError()
						llSuppress = .SetSuppressErrors(.T.)
						use (lcFile) alias (lcAlias) again in 0 shared
						.SetSuppressErrors(llSuppress)
						llError = .DidErrorOccur()
						if llError and ;
							inlist(.Parent.aErrorInfo[alen(.Parent.aErrorInfo, 1), 1], ;
							cnERR_CDX_NOT_FOUND, cnERR_PRIM_KEY_INVALID, ;
							cnERR_INDEX_FILE_TABLE, cnERR_INDEX_MATCH_TABLE)
							.Parent.ResetError()
						endif llError ...
					endif not llUsed
		
		* Compare the indexes and set the return flag to .T. if they're out of sync.
		
					llReturn = not llError
					llReturn = llReturn and .GetIndexStructure(lcAlias, ;
						@laTableIndexes)
					llReturn = llReturn and .DBCGetCDXStructure(tcAlias, @laIndexes, ;
						llFree) >= 0
					llReturn = llReturn and not .IsIndexOutOfSync(@laTableIndexes, ;
						@laIndexes)
					llReturn = not llReturn
					if not llUsed and used(lcAlias)
						use in (lcAlias)
					endif not llUsed ...
		
		* If the file doesn't exist, give an error and return .F.
		
				otherwise
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, lcAlias))
					llReturn = .F.
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE needupdate		&& Determines if Update() should be used for any table in a DBC.
		*==============================================================================
		* Method:			NeedUpdate
		* Status:			Public
		* Purpose:			Determine if DBC and the structure of its tables are out
		*						of sync
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	08/17/2005
		* Parameters:		tcAlias    - the name of a table to check (optional: if
		*						blank or not passed, all tables are checked). tcAlias
		*						can include a database by specifying
		*						<database>!<table>; specify "ALL" for <database> to
		*						handle all tables in all databases and free tables
		*					toProgress - a reference to a progress window (optional:
		*						if it isn't passed and lQuiet is .F., a new progress
		*						window will be created)
		* Returns:			.T. if the structure of any table in the database is out of
		*						sync with the DBC
		* Environment in:	if a database isn't specified, a database is selected
		* Environment out:	none
		*==============================================================================
		
		lparameters tcAlias, ;
			toProgress
		local lcDBC, ;
			lcCurrDBC, ;
			lcAlias, ;
			llAll, ;
			lcFullPath, ;
			llReturn, ;
			laTables[1], ;
			lnTables, ;
			loProgress, ;
			lnI, ;
			lcTable, ;
			lcDescription
		
		* If a database was specified and it's open, select it.
		
		with This
			lcDBC     = .Parent.GetDatabase()
			lcCurrDBC = dbc()
			do case
				case vartype(tcAlias) = 'C' and '!' $ tcAlias
					lcDBC = .Parent.GetDatabase(tcAlias)
					do case
						case not empty(lcDBC) or upper(alltrim(tcAlias)) == '!' + ccALL
							lcAlias = .Parent.StripDatabase(tcAlias)
						case right(alltrim(tcAlias), 1) = '!'
							lcAlias = ''
						otherwise
							lcAlias = .Parent.StripDatabase(tcAlias)
					endcase
					do case
						case empty(lcDBC) or upper(lcDBC) == ccALL
						case not dbused(lcDBC)
							.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
							return .F.
						case not upper(lcDBC) == set('DATABASE')
							.SetDatabase(lcDBC)
					endcase
		
		* If no alias was specified, set it to ALL. Otherwise, use the one specified.
		
				case vartype(tcAlias) <> 'C' or empty(tcAlias)
					lcAlias = ccALL
				otherwise
					lcAlias = tcAlias
			endcase
		
		* Flag if we're doing all databases and free tables.
		
			if upper(lcDBC) == ccALL
				llAll = .T.
			endif upper(lcDBC) == ccALL
		
		* Save the current settings.
		
			lcFullPath = set('FULLPATH')
			set fullpath on
		
		* Finalize the alias.
		
			lcAlias = alltrim(upper(lcAlias))
			lcAlias = iif(lcAlias == ccALL, '', lcAlias)
			do case
		
		* If no table was specified, do them all.
		
				case empty(lcAlias)
					llReturn = .F.
					lnTables = .Parent.DBCXGetAllObjects(lcDBC + '!Table', @laTables, ;
						'Caption', 'SDTCanUpdate', .T.)
		
		* Display a progress meter if necessary.
		
					if not .lQuiet
						do case
							case vartype(toProgress) = 'O'
								loProgress = toProgress
							case '\' + justfname(.cProgressFormLibrary) $ upper(set('CLASSLIB'))
								loProgress = createobject(.cProgressFormClass, .T.)
								loProgress.Caption = strtran(ccMSG_CHECKING, ccMSG_INSERT1, ;
									ccTABLES)
							otherwise
								loProgress = newobject(.cProgressFormClass, ;
									.cProgressFormLibrary, '', .T.)
								loProgress.Caption = strtran(ccMSG_CHECKING, ccMSG_INSERT1, ;
									ccTABLES)
						endcase
						lnMax = 100/lnTables
						loProgress.Show()
					endif not .lQuiet
		
		* Check each table.
		
					asort(laTables)
					for lnI = 1 to lnTables
						lcAlias = laTables[lnI, 2]
						.cAlias = lcAlias
						lcTable = iif(llAll, '', lcDBC + '!') + lcAlias
						if not .lQuiet
							lcDescription = laTables[lnI, 1]
							lcDescription = iif(empty(lcDescription), ;
								proper(lcAlias), lcDescription)
							loProgress.SetCaptions(strtran(ccMSG_CHECKING, ;
								ccMSG_INSERT1, lcDescription))
						endif not .lQuiet
						llReturn = .NeedUpdateOne(lcTable) or .NeedReindexOne(lcTable)
						do case
							case llReturn
								exit
							case not .lQuiet
								loProgress.Update(lnI * lnMax)
								.FastDoEvents()
						endcase
					next lnI
					if not .lQuiet
						loProgress.Update(100)
						.FastDoEvents()
					endif not .lQuiet
		
		* If the specified table doesn't in the database, display an error.
		
				case not empty(lcDBC) and not indbc(lcAlias, 'Table')
					.Warning(strtran(ccERR_TABLE_NOT_FOUND, ccMSG_INSERT1, lcAlias))
					llReturn = .F.
		
		* Process the specified table.
		
				otherwise
					.cAlias  = lcAlias
					llReturn = .NeedUpdateOne(lcDBC + '!' + lcAlias, not .lQuiet) or ;
						.NeedReindexOne(lcDBC + '!' + lcAlias, not .lQuiet)
					if not .lQuiet
						wait clear
					endif not .lQuiet
			endcase
		
		* Clean up and return.
		
			.SetDatabase(lcCurrDBC)
			if lcFullPath = 'OFF'
				set fullpath off
			endif lcFullPath = 'OFF'
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE needupdateone		&& Determines if Update() should be used for a single table.
		*==============================================================================
		* Method:			NeedUpdateOne
		* Status:			Protected
		* Purpose:			Determine if the DBC and the structure of a table are out
		*						of sync
		* Author:			Doug Hennig
		* Copyright:		(c) 1995-2005 Stonefield Systems Group Inc.
		* Last revision:	01/04/2005
		* Parameters:		tcAlias   - the name of a table to check
		*					tlDisplay - .T. to display a WAIT WINDOW
		* Returns:			.T. if the structure of the table is out of sync with the
		*						DBC or if the table doesn't exist
		* Environment in:	a database is selected
		* Environment out:	none
		*==============================================================================
		
		lparameters tcAlias, ;
			tlDisplay
		local lcDBC, ;
			lcAlias, ;
			llFree, ;
			lcFile, ;
			lnCodePage, ;
			lnBlockSize, ;
			lcTableType, ;
			lnTableType, ;
			llFox2X, ;
			lnTableCP, ;
			lnTableBlock, ;
			laFieldList[1], ;
			laTable[1], ;
			llReturn, ;
			lcBackLink
		with This
		
		* Get the database and alias.
		
			if '!' $ tcAlias
				lcDBC   = .Parent.GetDatabase(tcAlias)
				lcAlias = .Parent.StripDatabase(tcAlias)
			else
				lcDBC   = .Parent.GetDatabase()
				lcAlias = tcAlias
			endif '!' $ tcAlias
		
		* Display a message about the table we're checking if necessary.
		
			if tlDisplay
				wait window strtran(ccMSG_CHECKING, ccMSG_INSERT1, lcAlias) nowait
			endif tlDisplay
		
		* Get the full path to the table.
		
			llReturn = .T.
			llFree   = empty(lcDBC)
			do case
				case llFree
					lcFile = .GetFreeTablePath(tcAlias)
					if empty(lcFile)
						.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
							tcAlias))
						llReturn = .F.
					endif empty(lcFile)
				case dbused(lcDBC)
					set database to (lcDBC)
					lcFile = fullpath(dbgetprop(lcAlias, 'Table', 'Path'), dbc())
				otherwise
					.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
					llReturn = .F.
			endcase
			do case
		
		* If we already have an error, we have nothing else to do.
		
				case not llReturn
		
		* If the file exists, get information about it.
		
				case file(lcFile)
					lnCodePage   = .Parent.DBCXGetProp(tcAlias, 'Table', 'CBnCodePage')
					lnBlockSize  = .Parent.DBCXGetProp('CBnBlockSize')
					lcTableType  = .Parent.DBCXGetProp('SDTTableType')
					lcTableType  = iif(isnull(lcTableType) or empty(lcTableType), ;
						ccVFP_TABLE_VFP, lcTableType)
					lnTableType  = iif(inlist(val(lcTableType), cnVFP_TABLE_VFP_8, ;
						cnVFP_TABLE_VFP_9), cnVFP_TABLE_VFP, val(lcTableType))
					llFox2X      = lnTableType <> cnVFP_TABLE_VFP
					lnTableCP    = 0
					lnTableType  = 0
					lnTableBlock = 0
		
		* Get the DBF structure, get the table structure as defined in the DBC, then
		* compare them and return the results (whew! <g>).
		
					llReturn = .GetDBFStructure(lcFile, @laFieldList, @lnTableCP, ;
						@lnTableType, @lnTableBlock)
					llReturn = llReturn and .DBCGetTableStructure(tcAlias, @laTable) > 0
					llReturn = llReturn and .IsTableOutOfSync(@laFieldList, @laTable, ;
						lnTableCP, lnCodePage, lnTableBlock, lnBlockSize) = 0
					if llReturn
						lcBackLink = iif(llFox2X, '', .ReadBackLink(lcFile))
						llReturn   = llFox2X or (llFree and empty(lcBackLink)) or ;
							dbc() == lcBackLink
					endif llReturn
					llReturn = not llReturn
		
		* If the specified table doesn't exist, return .T.
		
				otherwise
					llReturn = .T.
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE openalltables		&& Open all tables defining in the DBC with the SDTAutoOpen property .T.
		*==============================================================================
		* Method:			OpenAllTables
		* Status:			Public
		* Purpose:			Open all tables and views in the database defined as
		*						AutoOpen
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/08/2001
		* Parameters:		tlExclusive   - .T. to open the tables exclusively
		*					tlDisplay     - .T. to display the names as they're opened
		*					tlGetData     - .T. to get the data for a view (ie. not to
		*						use the NODATA clause)
		*					tnDataSession - the datasession to open the table in
		*						(optional: datasession 1 is used if it isn't passed)
		* Returns:			.T. if all tables and views were successfully opened
		* Environment in:	the database being managed by DBCXMgr is selected
		* Environment out:	an error is displayed if no database is being managed by
		*						DBCXMgr
		*==============================================================================
		
		lparameters tlExclusive, ;
			tlDisplay, ;
			tlGetData, ;
			tnDataSession
		local lcDBC, ;
			llReturn, ;
			lcFullPath, ;
			lcCurrDBC, ;
			laTables[1], ;
			lnTables, ;
			laViews[1], ;
			lnViews, ;
			lnI, ;
			lcAlias, ;
			lcDAlias, ;
			lcDescription, ;
			lcPath
		with This
		
		* Get the current database and give an error if it's not open.
		
			lcDBC = .Parent.cCurrentDBC
			if not empty(lcDBC) and not dbused(lcDBC)
				.Warning(ccERR_DB_NOT_OPEN)
				return .F.
			endif not empty(lcDBC) ...
		
		* Ensure FULLPATH is on.
		
			llReturn   = .T.
			lcFullPath = set('FULLPATH')
			set fullpath on
		
		* Create an array of tables and views from the database.
		
			lcCurrDBC = dbc()
			.SetDatabase(lcDBC)
			if not empty(lcDBC)
				lnTables = adbobject(laTables, 'Table')
				lnViews  = adbobject(laViews,  'View')
			else
				lnTables = .Parent.DBCXGetAllObjects(lcDBC + '!Table', @laTables)
				lnViews  = 0
			endif not empty(lcDBC)
		
		* Sort the arrays.
		
			if lnTables > 0
				asort(laTables)
			endif lnTables > 0
			if lnViews > 0
				asort(laViews)
			endif lnViews > 0
		
		* Open all tables that are supposed to be "auto opened" by calling OpenTable()
		* with the alias to open. If it fails, return .F.
		
			for lnI = 1 to lnTables
				lcAlias  = laTables[lnI]
				lcDAlias = lcDBC + '!' + lcAlias
				if .Parent.DBCXGetProp(lcDAlias, 'Table', 'SDTAutoOpen')
					if tlDisplay
						lcDescription = .Parent.DBCXGetProp('CBcCaption')
						lcDescription = iif(empty(lcDescription), lcAlias, ;
							lcDescription)
						wait window strtran(ccMSG_OPENING, ccMSG_INSERT1, ;
							lcDescription) nowait
					endif tlDisplay
					if empty(lcDBC)
						lcPath = .GetFreeTablePath(lcDAlias)
					else
						lcPath = lcDAlias
					endif empty(lcDBC)
					if not .OpenTable(lcPath, '', tlExclusive, , , tnDataSession)
						llReturn = .F.
						exit
					endif not .OpenTable(lcDAlias ...
				endif .Parent.DBCXGetProp(lcDAlias ...
			next lnI
		
		* Open all views that are supposed to be "auto opened" by calling OpenTable()
		* with the alias to open. If it fails, return .F.
		
			for lnI = 1 to lnViews
				lcAlias  = laViews[lnI]
				lcDAlias = lcDBC + '!' + lcAlias
				if .Parent.DBCXGetProp(lcDAlias, 'View', 'SDTAutoOpen')
					if tlDisplay
						lcDescription = .Parent.DBCXGetProp('CBcCaption')
						lcDescription = iif(empty(lcDescription), lcAlias, ;
							lcDescription)
						wait window strtran(ccMSG_OPENING, ccMSG_INSERT1, ;
							lcDescription) nowait
					endif tlDisplay
					if not .OpenTable(lcDAlias, '', tlExclusive, , tlGetData, ;
						tnDataSession)
						llReturn = .F.
						exit
					endif not .OpenTable(lcDAlias ...
				endif .Parent.DBCXGetProp(lcDAlias ...
			next lnI
			if tlDisplay
				wait clear
			endif tlDisplay
		
		* Clean up and return.
		
			.SetDatabase(lcCurrDBC)
			if lcFullPath = 'OFF'
				set fullpath off
			endif lcFullPath = 'OFF'
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE opendata		&& Opens a database and all of its tables that have the SDTAutoOpen property .T.
		*==============================================================================
		* Method:			OpenData
		* Status:			Public
		* Purpose:			Open a database and all "auto open" tables and views
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
		* Last revision:	03/06/2003
		* Parameters:		tcDatabase    - the name of the database to open, including
		*						the path if necessary (optional: if it isn't specified,
		*						the database managed by DBCXMgr is opened)
		*					tlDataOnly    - .T. to open only the database
		*					tlExclusive   - .T. if the database and tables should be
		*						opened exclusively
		*					tlDisplay     - .T. to display the table names as they are
		*						opened
		*					tlGetData     - .T. to get the data for a view (ie. not to
		*						use the NODATA clause)
		*					tnDataSession - the datasession to open the database in
		*						(optional: datasession 1 is used if it isn't passed)
		* Returns:			.T. if the database and all "auto open" tables and views
		*						could be opened, or .F. if not
		* Environment in:	none
		* Environment out:	the specified database is open and DBCXMgr.cDatabase is set
		*						to it
		*					if tlDataOnly is .F., all "auto open" tables and views are
		*						open and the active order set to the primary one for
		*						the table
		*==============================================================================
		
		lparameters tcDatabase, ;
			tlDataOnly, ;
			tlExclusive, ;
			tlDisplay, ;
			tlGetData, ;
			tnDataSession
		local lcDBC, ;
			lcDatabase, ;
			llOpen, ;
			lnCurrDataSession, ;
			llReturn
		
		* Do parameter checking.
		
		with This
			do case
				case pcount() = 0 and empty(.Parent.cCurrentDBC)
					.Warning(ccERR_INVALID_PARAMETERS)
					return .F.
				case pcount() = 0
					lcDBC = upper(.Parent.cCurrentDBC)
				case vartype(tcDatabase) <> 'C' or empty(tcDatabase)
					.Warning(ccERR_INVALID_PARAMETERS)
					return .F.
				otherwise
					lcDBC = upper(alltrim(tcDatabase))
			endcase
			lcDBC      = forceext(lcDBC, 'DBC')
			lcDatabase = juststem(lcDBC)
			llOpen     = dbused(lcDBC)
		
		* Save the current datasession and figure out which one we'll use.
		
			lnCurrDataSession = set('DATASESSION')
			set datasession to iif(vartype(tnDataSession) = 'N' and ;
				tnDataSession <> 0, tnDataSession, 1)
			do case
		
		* The specified database doesn't exist.
		
				case not file(lcDBC) and not llOpen
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, ;
						lcDatabase))
		
		* If the database is already open with the same exclusive status that we
		* want, select it.
		
				case llOpen and isexclusive(lcDatabase, 2) = tlExclusive
					.SetDatabase(lcDatabase)
		
		* If the database is already open but with a different exclusive status than
		* we want, select it, close it, and reopen it with the correct status.
		
				case llOpen
					.SetDatabase(lcDatabase)
					close database
					if tlExclusive
						open database (lcDBC) exclusive
					else
						open database (lcDBC) shared
					endif tlExclusive
		
		* Open the database using the specified status.
		
				case tlExclusive
					open database (lcDBC) exclusive
				otherwise
					open database (lcDBC) shared
			endcase
		
		* Set a flag if we successfully opened the database.
		
			llReturn = set('DATABASE') = lcDatabase
		
		* Restore the former datasession if necessary.
		
			set datasession to lnCurrDataSession
		
		* If the database is open, point DBCXMgr to it. If we're supposed to open
		* tables too, call OpenAllTables to open them and set the return code to .T.
		* if everything worked.
		
			if llReturn
				.Parent.SetDatabase(lcDatabase)
				llReturn = tlDataOnly or .OpenAllTables(tlExclusive, tlDisplay, ;
					tlGetData, tnDataSession)
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE opendbcxmeta
		*==============================================================================
		* Method:			OpenDBCXMeta
		* Status:			Public
		* Purpose:			Opens the SDT meta data tables
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Last revision:	05/24/2001
		* Parameters:		tlExclusive - .T. to open the table exclusively
		* Returns:			.T. if the meta data table is open
		* Environment in:	the meta data table must be open or available to be opened
		*					This.cMetaTable contains the name of the table for user-
		*						defined properties and This.cMetaAlias contains its
		*						alias
		* Environment out:	the meta data table is open
		*==============================================================================
		
		lparameters tlExclusive
		local lcUserFile, ;
			llReturn, ;
			lcMode
		with This
			lcUserFile = .Parent.cRegistryPath + .cMetaTable
			llReturn   = dodefault(tlExclusive)
			if llReturn and not used(.cMetaAlias) and file(lcUserFile)
				lcMode = iif(tlExclusive, 'exclusive', 'shared')
				use (lcUserFile) alias (.cMetaAlias) again in 0 &lcMode
				if cursorgetprop('Buffering', .cMetaAlias) > 1
					cursorsetprop('Buffering', 1, .cMetaAlias)
				endif cursorgetprop('Buffering', .cMetaAlias) > 1
			endif llReturn ...
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE opentable		&& Opens a single table and sets its order to either the primary key (if there is one) or the specified order (if there is one).
		*==============================================================================
		* Method:			OpenTable
		* Status:			Public
		* Purpose:			Open a single table or view
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last Revision:	04/27/2005
		* Parameters:		tcTable       - the name of the table to open (if the table
		*						is a free table, specify the complete path if the table
		*						isn't in the current directory or the VFP path).
		*						tcTable can include a database by specifying
		*						<database>!<table>
		*					tcOrder       - the order to use:
		*						not passed		the primary order for the table
		*						"PRIMARY"		the primary order for the table
		*						blank			no order
		*						not blank		specified order
		*						.NULL.			don't create view indexes
		*					tlExclusive   - .T. if the table should be opened
		*						exclusively
		*					tcAlias       - the alias to use for the table (optional:
		*						if it isn't passed, no alias is specified when the
		*						table is opened)
		*					tlGetData     - .T. to get the data for a view (ie. not to
		*						use the NODATA clause)
		*					tnDataSession - the datasession to open the table in
		*						(optional: datasession 1 is used if it isn't passed)
		* Returns:			.T. if the table was opened as desired
		* Environment in:	the meta tables are open
		* Environment out:	if OpenTable returns .T., the table was either opened in a
		*						new workarea using the alias specified, either 
		*						exclusively or not, or was already in use as desired.
		*						The desired order is selected and the table is in the
		*						current workarea
		* Notes:			tlGetData is ignored for everything but views
		*==============================================================================
		
		lparameters tcTable, ;
			tcOrder, ;
			tlExclusive, ;
			tcAlias, ;
			tlGetData, ;
			tnDataSession
		local lnCurrDataSession, ;
			lnDataSession, ;
			lcDBC, ;
			lcCurrDBC, ;
			lcTable, ;
			lcDBCTable, ;
			llReturn, ;
			llGotTable, ;
			llGotView, ;
			llFreeTable, ;
			llNoUpdate, ;
			lcType, ;
			lcOrder, ;
			lcAlias, ;
			lcParms, ;
			lcDatabase, ;
			lcPath, ;
			llStatus, ;
			lnError, ;
			laTags[1], ;
			lnTags, ;
			lcSetOrder, ;
			lnBuffering, ;
			lnI, ;
			lcIndex, ;
			lcTag, ;
			lcExpr, ;
			lcFor
		with This
		
		* Flag that we haven't had an error, then do parameter and other error
		* checking.
		
			.Parent.ResetError()
			do case
				case pcount() < 1 or (pcount() > 2 and vartype(tlExclusive) <> 'L')
					.Warning(ccERR_INVALID_PARAMETERS)
					return .F.
				case isnull(tcTable) or empty(tcTable) or vartype(tcTable) <> 'C'
					.Warning(ccERR_INVALID_PARAMETERS)
					return .F.
			endcase
		
		* Save the current datasession and figure out which one we'll use.
		
			lnCurrDataSession = set('DATASESSION')
			lnDataSession     = iif(vartype(tnDataSession) = 'N' and ;
				tnDataSession <> 0, tnDataSession, 1)
		
		* If a database was specified and it's open, select it. Note: cCurrentDBC is
		* used here rather than GetDatabase() because that method strips the path off
		* the DBC, which can be a problem if two DBCs with the same name are open.
		
			lcDBC     = .Parent.cCurrentDBC
			lcCurrDBC = dbc()
			store upper(alltrim(tcTable)) to lcTable, lcDBCTable
			if '!' $ lcTable
				lcDBC   = .Parent.GetDatabase(lcTable)
				lcTable = .Parent.StripDatabase(lcTable)
				do case
					case empty(lcDBC)
					case not dbused(lcDBC)
						.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
						return .F.
					case not upper(lcDBC) == set('DATABASE')
						.SetDatabase(lcDBC)
						lcDBC = dbc()
					otherwise
						lcDBC = dbc()
				endcase
			endif '!' $ lcTable
		
		* Try to find the desired alias in the database if there is one. If found, flag
		* that this isn't a free table.
		
			llReturn = .T.
			if not empty(lcDBC)
				llGotTable  = indbc(lcTable, 'Table')
				llGotView   = indbc(lcTable, 'View')
				llFreeTable = not llGotTable and not llGotView
			endif not empty(lcDBC)
		
		* If we didn't find it in the database, try to find it as a free table.
		
			if not llGotTable and not llGotView
				lcTable     = forceext(lcTable, 'DBF')
				llGotTable  = file(lcTable)
				llFreeTable = .T.
			endif not llGotTable ...
		
		* If we found the table, flag that the table isn't being opened NOUPDATE.
		
			.cAlias = lcTable
			do case
				case llGotTable or llGotView
					if llFreeTable
						llNoUpdate = .F.
					else
		
		* If the table was found in the database, get its default noupdate status.
		
						lcType     = iif(llGotView, 'View', 'Table')
						llNoUpdate = nvl(.Parent.DBCXGetProp(lcDBCTable, lcType, ;
							'SDTNoUpdate'), .F.)
						.Parent.ResetError()
					endif llFreeTable
		
		* Initialize the other values we'll need to open the table.
		
					do case
						case llGotView and isnull(tcOrder)
							lcOrder = tcOrder
						case vartype(tcOrder) = 'C' and not empty(tcOrder)
							lcOrder = upper(trim(tcOrder))
						case llGotView or llFreeTable
							lcOrder = ''
						otherwise
							lcOrder = 'PRIMARY'
					endcase
					lcAlias = strtran(iif(empty(tcAlias) or isnull(tcAlias), ;
						juststem(lcTable), tcAlias), ' ', '_')
					lcParms = iif(tlExclusive, 'exclusive', 'shared') + ;
						iif(llNoUpdate, ' noupdate', '') + ;
						iif(llGotView and not tlGetData, ' nodata', '')
		
		* Set the datasession where the table is to be opened and ensure the database
		* is selected there.
		
					set datasession to lnDataSession
					lcDatabase = dbc()
					if not empty(lcDBC) and lcDatabase <> lcDBC
						.SetDatabase(lcDBC)
					endif not empty(lcDBC) ...
		
		* If there's already a table open with the desired alias, check to see that
		* it's the correct table and open with the proper exclusive status. If not,
		* close it and open it again with the desired alias.
		
					if used(lcAlias)
						select (lcAlias)
						lcPath   = iif(llFreeTable or llGotView, lcTable, ;
							fullpath(dbgetprop(lcTable, 'Table', 'Path'), lcDBC))
						llStatus = isexclusive()
						if llNoUpdate <> isreadonly() or (not llGotView and ;
							(not dbf() == lcPath or tlExclusive <> llStatus))
							use (lcTable) again alias (lcAlias) &lcParms
						endif llNoUpdate <> isreadonly() ...
		
		* If the view was already open and we're supposed to get data for it, let's
		* requery it.
		
						if llGotView and tlGetData
							requery()
						endif llGotView ...
		
		* The table wasn't open or was open with a different alias, so open it using
		* the desired alias.
		
					else
						select 0
						use (lcTable) again alias (lcAlias) &lcParms
					endif used(lcAlias)
					llReturn = not .DidErrorOccur()
					lnError  = alen(.Parent.aErrorInfo, 1)
					do case
		
		* If the table wasn't opened, show why if necessary.
		
						case not llReturn and ;
							.Parent.aErrorInfo[lnError, 1] <> cnERR_EXECUTION_CANCELED and ;
							not .Parent.lSuppressErrors
							.Warning(strtran(ccERR_CANT_OPEN_FILE, ccMSG_INSERT1, ;
								lcTable) + ccCR + .Parent.aErrorInfo[lnError, 2])
						case not llReturn
		
		* If this is a view, automatically create any indexes defined for the view and
		* set the current order to the one specified.
		
						case llGotView and not isnull(lcOrder)
							set datasession to lnCurrDataSession
							.CreateViewIndexes(lcTable, lnDataSession, lcAlias)
							set datasession to lnDataSession
							if not empty(lcOrder) and tagno(lcOrder) > 0
								set order to (lcOrder)
							endif not empty(lcSetOrder) ...
						case llGotView
		
		* Set the order to the primary order for the table.
		
						case lcOrder == 'PRIMARY' and not llFreeTable
							lcOrder = dbgetprop(lcTable, 'Table', 'PrimaryKey')
							if not empty(lcOrder)
								set order to (lcOrder)
							endif not empty(lcOrder)
		
		* A blank order was passed, so set the order off (in case the table was
		* already open and an order set).
		
						case empty(lcOrder)
							set order to
		
		* If the tag exists, set it. If not and none was actually specified, do
		* nothing. Otherwise, display an error message (if necessary), but reset the
		* error flag because the file was successfully opened.
		
						case tagno(lcOrder) > 0
							set order to (lcOrder)
						case vartype(tcOrder) <> 'C'
						case not .Parent.lSuppressErrors
							.Warning(strtran(ccERR_TAG_NOT_FOUND, ccMSG_INSERT1, ;
								lcOrder))
							.Parent.ResetError()
						otherwise
							.Parent.ResetError()
					endcase
		
		* Restore the database and former datasession.
		
					if lcDatabase <> lcDBC
						.SetDatabase(lcDatabase)
					endif lcDatabase <> lcDBC
					set datasession to lnCurrDataSession
		
		* We couldn't find the table, so give an error message if necessary.
		
				case not .Parent.lSuppressErrors
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, lcTable))
					llReturn = .F.
				otherwise
					llReturn = .F.
			endcase
		
		* Reselect the former database.
		
			.SetDatabase(lcCurrDBC)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE pause		&& Pause to allow caching to catch up
		*==============================================================================
		* Method:			Pause
		* Status:			Public
		* Purpose:			Pause to allow caching to catch up
		* Author:			Doug Hennig
		* Copyright:		(c) 2000 Stonefield Systems Group Inc.
		* Last revision:	01/21/2000
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.nPauseTime contains the number of seconds to pause
		* Environment out:	execution has been delayed for This.nPauseTime seconds
		*==============================================================================
		
		inkey(This.nPauseTime, 'H')  
		
	ENDPROC

	PROCEDURE readbacklink		&& Reads the backlink of a table
		*==============================================================================
		* Method:			ReadBackLink
		* Status:			Public
		* Purpose:			Read the database backlink of a DBF header
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcFile - the full pathname of the file
		* Returns:			the full path of the database backlink of the DBF header
		* Environment in:	none
		* Environment out:	if the file couldn't be found or opened exclusively, an 
		*						error is displayed
		*==============================================================================
		
		lparameters tcFile
		local lcDBC, ;
			lnHandle, ;
			lnHeader
		
		* If the file can be found, open it. Otherwise, flag an error.
		
		with This
			lcDBC = ''
			if file(tcFile)
				lnHandle = fopen(tcFile)
				if lnHandle < 0
					.DisplayLLFFError(tcFile)
				endif lnHandle < 0
			else
				.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, tcFile))
				lnHandle = -1
			endif file(tcFile)
		
		* If the file is open, read the backlink from the header, then close it.
		
			if lnHandle >= 0
				fseek(lnHandle, cnDBF_HEADER_LENGTH)
				lnHeader = .Hex2Decimal(fread(lnHandle, 2))
				fseek(lnHandle, lnHeader - cnVF_BACKLINK_LENGTH)
				lcDBC = strtran(fread(lnHandle, cnVF_BACKLINK_LENGTH), ccNULL)
				fclose(lnHandle)
				lcDBC = iif(empty(lcDBC), '', fullpath(lcDBC, tcFile))
			endif lnHandle >= 0
		endwith
		return lcDBC
		
	ENDPROC

	PROCEDURE readnextvalue		&& Reads the next value property for a field from the DBF header
		*==============================================================================
		* Method:			ReadNextValue
		* Status:			Public
		* Purpose:			Reads the next value property for a field from the DBF
		*						header
		* Author:			Doug Hennig
		* Copyright:		(c) 2003-2005 Stonefield Systems Group Inc.
		* Last Revision:	01/04/2005
		* Parameters:		tcFile   - the file to update
		*					taFields - an array containing the table structure
		*					tnHandle - the handle of the file if it's already open
		*						using LLFF (optional: if it isn't passed, the table
		*						will be opened)
		* Returns:			.T. if everything went OK
		* Environment in:	none
		* Environment out:	if the file couldn't be opened exclusively, an error is
		*						displayed
		*					taFields is updated with the next value for the field
		*					the table is closed upon exit if we opened it
		*==============================================================================
		
		lparameters tcFile, ;
			taFields, ;
			tnHandle
		external array taFields
		local lnHandle, ;
			lnTableType, ;
			llDBC, ;
			lnHeaderLen, ;
			lnCurrPos, ;
			lnTableFields, ;
			lcField, ;
			lnNext, ;
			lnStep, ;
			lnPos, ;
			lnI
		with This
		
		* Try to open the file. Give an error and exit if we can't.
		
			if vartype(tnHandle) = 'N' and tnHandle >= 0
				lnHandle = tnHandle
			else
				lnHandle = fopen(tcFile)
				if lnHandle < 0
					.DisplayLLFFError(tcFile)
					return .F.
				endif lnHandle < 0
			endif vartype(tnHandle) = 'N' ...
		
		* Get the table type for the table.
		
			lnTableType = asc(fread(lnHandle, 1))
			lnTableType = iif(inlist(lnTableType, cnVFP_TABLE_VFP_8, ;
				cnVFP_TABLE_VFP_9), cnVFP_TABLE_VFP, lnTableType)
		
		* Get the length of the fields area.
		
			llDBC = lnTableType = cnVFP_TABLE_VFP
			fseek(lnHandle, cnDBF_HEADER_LENGTH)
			lnHeaderLen = asc(fread(lnHandle, 1)) + ;
				256 * asc(fread(lnHandle, 1)) - ;
				iif(llDBC, cnVF_BACKLINK_LENGTH, 0) - 1
		
		* Read the field name, next value, and step value for all auto-inc fields.
		
			fseek(lnHandle, cnDBF_FIRST_FIELD)
			lnCurrPos     = cnDBF_FIRST_FIELD
			lnTableFields = 1
			do while lnCurrPos < lnHeaderLen
				lcField = fread(lnHandle, cnDBF_FIELD_NAME_SIZE)
				if left(lcField, 1) = ccFIELD_TERMINATOR
					exit
				endif left(lcField, 1) = ccFIELD_TERMINATOR
				lcField = strtran(lcField, ccNULL)
				fseek(lnHandle, cnDBF_NEXTVALUE_OFFSET, 1)
				lnNext = .Hex2Decimal(fread(lnHandle, 4))
				lnStep = asc(fread(lnHandle, 1))
				if lnStep <> 0
		
		* Try to find the field in the array. If the array has long field names, we may
		* not find a match, so try to find a field with a close name and the same step
		* value.
		
					lnPos = .ArrayScan(@taFields, lcField, 1)
					if lnPos = 0
						for lnI = 1 to alen(taFields, 1)
							if (taFields[lnI, 1] = lcField or ;
								taFields[lnI, 1] = left(lcField, 9) or ;
								taFields[lnI, 1] = left(lcField, 8)) and ;
								taFields[lnI, 18] = lnStep
								lnPos = lnI
								exit
							endif (taFields[lnI, 1] = lcField ...
						next lnI
					endif lnPos = 0
		
		* If we found the field, update the next value in the array.
		
					if lnPos > 0
						taFields[lnPos, 17] = lnNext
					endif lnPos > 0
				endif lnStep <> 0
		
		* Move to the next field.
		
				lnTableFields = lnTableFields + 1
				fseek(lnHandle, cnDBF_FIELD_DEFN_SIZE * lnTableFields)
				lnCurrPos = cnDBF_FIELD_DEFN_SIZE * lnTableFields
			enddo while lnCurrPos < lnHeaderLen
		
		* Close the table if we opened it.
		
			if vartype(tnHandle) <> 'N' or tnHandle = 0
				fclose(lnHandle)
			endif vartype(tnHandle) <> 'N' ...
		endwith
		return .T.
		
	ENDPROC

	PROCEDURE reindex		&& A front-end to the ReindexOneTable() method to recreates table indexes.
		*==============================================================================
		* Method:			Reindex
		* Status:			Public
		* Purpose:			Reindex tables
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2007 Stonefield Systems Group Inc.
		* Last revision:	12/18/2007
		* Parameters:		tcAlias       - the table to reindex, or "ALL" to reindex
		*						all tables, or blank or not passed to display a dialog
		*						so the user can select the table(s) to reindex. tcAlias
		*						can include a database by specifying
		*						<database>!<table>; specify "ALL" for <database> to
		*						handle all tables in all databases and free tables
		*					tlPack        - .T. to pack the table(s)
		*					tlUseMetaData - backwards compatibility only; the meta data
		*						is now always used
		*					tlWarnCancel  - .T. to provide a warning if the user
		*						chooses Cancel in the dialog
		*					toProgress    - a reference to a progress window (optional:
		*						if it isn't passed and lQuiet is .F., a new progress
		*						window will be created)
		* Returns:			.T. if everything went OK
		* Environment in:	if a database isn't specified, a database is selected
		* Environment out:	selected tables may have been reindexed
		*==============================================================================
		
		lparameters tcAlias, ;
			tlPack, ;
			tlUseMetaData, ;
			tlWarnCancel, ;
			toProgress
		local lcDBC, ;
			lcCurrDBC, ;
			lcAlias, ;
			llAll, ;
			llPack, ;
			lnValidate, ;
			lcTableValidateCommand, ;
			laTables[1], ;
			lnTables, ;
			lcDBCName, ;
			lnI, ;
			lcTable, ;
			lnPos, ;
			lnProcess, ;
			llReturn, ;
			loProgress, ;
			lnMax, ;
			llOK
		with This
		
		* If a database was specified and it's open, select it.
		
			lcDBC     = .Parent.GetDatabase()
			lcCurrDBC = set('DATABASE')
			do case
				case vartype(tcAlias) = 'C' and '!' $ tcAlias
					lcDBC = .Parent.GetDatabase(tcAlias)
					do case
						case not empty(lcDBC) or left(alltrim(tcAlias), 1) = '!'
							lcAlias = .Parent.StripDatabase(tcAlias)
						case right(alltrim(tcAlias), 1) = '!'
							lcAlias = ''
						otherwise
							lcAlias = tcAlias
					endcase
					do case
						case empty(lcDBC) or upper(lcDBC) == ccALL
						case dbused(lcDBC)
							.SetDatabase(lcDBC)
						otherwise
							.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
							return .F.
					endcase
		
		* If no alias was specified, blank it. Otherwise, use the one specified.
		
				case vartype(tcAlias) <> 'C'
					lcAlias = ''
				otherwise
					lcAlias = tcAlias
			endcase
		
		* Flag if we're doing all databases and free tables.
		
			if upper(lcDBC) == ccALL
				llAll = .T.
			endif upper(lcDBC) == ccALL
		
		* Process any parameters.
		
			llPack  = tlPack
			lcAlias = juststem(alltrim(lcAlias))
			.Parent.ResetError(.T.)
		
		* Create a progress object if one wasn't specified.
		
			do case
				case .lQuiet
				case vartype(toProgress) = 'O'
					loProgress = toProgress
				case '\' + justfname(.cProgressFormLibrary) $ upper(set('CLASSLIB'))
					loProgress = createobject(.cProgressFormClass, .T.)
					loProgress.Caption = strtran(ccMSG_UPDATING, ccMSG_INSERT1, ;
						ccTABLES)
				otherwise
					loProgress = newobject(.cProgressFormClass, ;
						.cProgressFormLibrary, '', .T.)
					loProgress.Caption = strtran(ccMSG_UPDATING, ccMSG_INSERT1, ;
						ccTABLES)
			endcase
		
		* Save the current TABLEVALIDATE setting and set it to 0 so we don't get an
		* error when we open tables.
		
			if version(5) >= 800
				lnValidate = set('TABLEVALIDATE')
				lcTableValidateCommand = 'set tablevalidate to 0'
				&lcTableValidateCommand
			endif version(5) >= 800
			do case
		
		* No alias was passed or we're supposed to do all tables, so get an array of
		* tables to process.
		
				case empty(lcAlias) or upper(lcAlias) == ccALL
					lnTables = This.Parent.DBCXGetAllObjects(lcDBC + '!Table', ;
						@laTables, 'CBcCaption', 'SDTCanUpdate', .T.)
					lcDBCName = upper(padr(lcDBC, fsize('cDBCName', 'CoreMeta')))
					for lnI = lnTables to 1 step -1
						lcTable = upper(laTables[lnI, 2])
						lnPos   = at('!', lcTable)
						if lnPos > 0
							lcDBCName = padr(left(lcTable, lnPos - 1), ;
								fsize('cDBCName', 'CoreMeta'))
							lcTable   = substr(lcTable, lnPos + 1)
						endif lnPos > 0
						if not seek(lcDBCName + 'I' + lcTable + '.', 'CoreMeta', ;
							'ObjectName')
							adel(laTables, lnI)
							if alen(laTables, 1) > 1
								dimension laTables[alen(laTables, 1) - 1, ;
									alen(laTables, 2)]
							endif alen(laTables, 1) > 1
						endif not seek(lcDBCName ...
					next lnI
					if alen(laTables, 1) > 1 or not empty(laTables[1])
						lnProcess = .SelectTablesToProcess(ccMSG_REINDEX, ;
							ccMSG_REINDEX, @laTables, not empty(lcAlias), ;
							'SDTCanUpdate', .T., ccPACK, llPack, lcDBC)
					else
						lnProcess = 0
					endif alen(laTables, 1) > 1 ...
					do case
						case lnProcess < 0
							.Warning(ccERR_NO_TABLES)
							llReturn = .F.
						case lnProcess = 0 and tlWarnCancel
							.Warning(ccERR_REQUEST_CANCELED)
							llReturn = .F.
						case lnProcess = 0
							llReturn = .T.
		
		* If we're going to reindex the tables, reindex each table that's tagged.
		
						otherwise
							lnMax    = 100/alen(laTables, 1)
							llPack   = lnProcess = 2
							llReturn = .T.
							asort(laTables)
							for lnI = 1 to alen(laTables, 1)
								lcAlias = laTables[lnI, 2]
								.cAlias = lcAlias
								lcTable = iif(llAll, '', lcDBC + '!') + lcAlias
								llOK    = .ReindexOneTable(lcTable, llPack, loProgress)
								if not llOK
									llReturn = .F.
								endif not llOK
								if not .lQuiet
									loProgress.Update(lnI * lnMax)
									.FastDoEvents()
								endif not .lQuiet
							next lnI
							if not .lQuiet
								loProgress.Update(100)
								.FastDoEvents()
							endif not .lQuiet
					endcase
		
		* An alias was passed, so reindex just that table if we can find it in the DBC
		* or it's a free table.
		
				case empty(lcDBC) or indbc(lcAlias, 'Table')
					.cAlias  = lcAlias
					llReturn = .ReindexOneTable(lcDBC + '!' + lcAlias, tlPack, ;
						loProgress)
		
		* The specified table wasn't found in the DBC.
		
				otherwise
					.Warning(strtran(ccERR_TABLE_NOT_FOUND, ccMSG_INSERT1, lcAlias))
					llReturn = .F.
			endcase
		
		* Restore the TABLEVALIDATE setting and select the former database.
		
			if version(5) >= 800
				lcTableValidateCommand = 'set tablevalidate to lnValidate'
				&lcTableValidateCommand
			endif version(5) >= 800
			.SetDatabase(lcCurrDBC)
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE reindexonetable		&& Recreates the indexes for one table.
		*==============================================================================
		* Method:			ReindexOneTable
		* Status:			Protected
		* Purpose:			Create all of the indexes for a single file
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last Revision:	06/07/2005
		* Parameters:		tcAlias    - the alias of the table to reindex
		*					tlPack     - .T. if the table should be packed
		*					toProgress - an object reference to the progress form
		* Returns:			.T. if the table was reindexed or is built into the APP
		* Environment in:	This.lQuiet is .T. if progress shouldn't be displayed
		* Environment out:	if the table could be opened, all its indexes were created
		*==============================================================================
		
		lparameters tcAlias, ;
			tlPack, ;
			toProgress
		local llReturn, ;
			llProgress, ;
			loProgress, ;
			lnCurrSelect, ;
			lcDBC, ;
			lcCurrDBC, ;
			lcAlias, ;
			lcFile, ;
			llEventsOn, ;
			llFree, ;
			laTemp[1], ;
			lcDescription, ;
			lnBlockSize, ;
			lcTableType, ;
			lnTableType, ;
			lnCurrBlock, ;
			lcDBCAlias, ;
			liParent, ;
			lnPos, ;
			lcDatabase, ;
			laFix[1], ;
			laIndexes[1], ;
			lnIndexes, ;
			lnI, ;
			lcIndex, ;
			lcExpression, ;
			llReindex, ;
			laFields[1], ;
			lnFields, ;
			llSuppress, ;
			lcMessage, ;
			lcFPT, ;
			lnSize, ;
			laFPT[1], ;
			lnSpace, ;
			llPack, ;
			llPHD, ;
			lcCurrTalk, ;
			lcCurrCollate, ;
			lcTemp, ;
			lnSort, ;
			lcKeyFields, ;
			lcField, ;
			lcSort, ;
			llFoxPlus, ;
			llFox2X, ;
			lcTempAlias, ;
			lnStep, ;
			lnNext, ;
			lnDoingIndex, ;
			lcTag, ;
			lcCollate, ;
			llAscending, ;
			lcTagType, ;
			llUnique, ;
			llCandidate, ;
			lcOptions, ;
			lcPHD, ;
			llPrimary, ;
			llBinary, ;
			lcForExpr, ;
			llIndexOK, ;
			luValue, ;
			luForValue, ;
			llCollate, ;
			lnRecno
		
		* Define the progress window if we are displaying the reindex progress and it
		* hasn't already been defined.
		
		with This
			llReturn   = .T.
			llProgress = vartype(toProgress) = 'O'
			do case
				case .lQuiet
				case llProgress
					loProgress = toProgress
				case '\' + justfname(.cProgressFormLibrary) $ upper(set('CLASSLIB'))
					loProgress = createobject(.cProgressFormClass)
					loProgress.Caption = strtran(ccMSG_REINDEXING, ccMSG_INSERT1, ;
						ccTABLES)
				otherwise
					loProgress = newobject(.cProgressFormClass, .cProgressFormLibrary)
					loProgress.Caption = strtran(ccMSG_REINDEXING, ccMSG_INSERT1, ;
						ccTABLES)
			endcase
		
		* Find the complete path to the table and the name of its primary key.
		
			lnCurrSelect = select()
			lcDBC        = .Parent.cCurrentDBC
			lcCurrDBC    = dbc()
			if '!' $ tcAlias
				lcDBC   = .Parent.GetDatabase(tcAlias)
				lcAlias = lower(.Parent.StripDatabase(tcAlias))
				do case
					case empty(lcDBC)
					case not dbused(lcDBC)
						.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
						return .F.
					case not upper(lcDBC) == set('DATABASE')
						.SetDatabase(lcDBC)
						lcDBC = dbc()
					otherwise
						lcDBC = dbc()
				endcase
			else
				lcAlias = tcAlias
			endif '!' $ tcAlias
			if empty(lcDBC)
				lcFile = lower(.GetFreeTablePath(tcAlias))
				if empty(lcFile)
					.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
						tcAlias))
					.SetDatabase(lcCurrDBC)
					return .F.
				endif empty(lcFile)
				llFree = .T.
			else
				llEventsOn = .EnableDBCEvents(.F.)
				lcFile = lower(fullpath(dbgetprop(lcAlias, 'Table', 'Path'), lcDBC))
				llFree = .F.
			endif empty(lcDBC)
		
		* The file exists, but it's built into the app, or it doesn't exist, so ignore
		* it.
		
			if not file(lcFile) or (file(lcFile) and adir(laTemp, lcFile) = 0)
				.SetDatabase(lcCurrDBC)
				return .T.
			endif not file(lcFile) ...
		
		* Get the table's caption and block size.
		
			lcDescription = .Parent.DBCXGetProp(tcAlias, 'Table', 'CBcCaption')
			lcDescription = iif(empty(lcDescription) or isnull(lcDescription), ;
				proper(tcAlias), lcDescription)
			lnBlockSize   = CoreMeta.nBlockSize
			lnBlockSize   = .GetBlockSize(lnBlockSize)
			lcTableType   = .Parent.DBCXGetProp('SDTTableType')
			lcTableType   = iif(isnull(lcTableType) or empty(lcTableType), ;
				ccVFP_TABLE_VFP, lcTableType)
			lnTableType   = iif(inlist(val(lcTableType), cnVFP_TABLE_VFP_8, ;
				cnVFP_TABLE_VFP_9), cnVFP_TABLE_VFP, val(lcTableType))
			lnCurrBlock   = set('BLOCKSIZE')
		
		* Display what we are doing in the progress window if necessary.
		
			if not .lQuiet
				loProgress.Show()
				if tlPack
					loProgress.Clear()
					loProgress.SetCaptions(strtran(ccMSG_PACKING, ccMSG_INSERT1, ;
						lcDescription), '', '')
				else
					loProgress.SetCaptions(strtran(ccMSG_REINDEXING, ccMSG_INSERT1, ;
						lcDescription))
				endif tlPack
			endif not .lQuiet
		
		* Open the DBC and get the Object ID for the table if we're doing a DBC table.
		
			if not llFree
				lcDBCAlias = .DBCOpen(dbc())
				if empty(lcDBCAlias)
					.SetDatabase(lcCurrDBC)
					return .F.
				endif empty(lcDBCAlias)
				liParent = .DBCGetField(tcAlias, 'Table', 'ObjectID')
			endif not llFree
		
		* Create an array of indexes for the table from the meta data.
		
			lnIndexes = .DBCGetCDXStructure(tcAlias, @laIndexes, llFree)
		
		* Create an array of records we made need to undelete in the DBC if reindexing
		* fails.
		
			laFix[1] = 0
			if not llFree
				select recno(), ;
						OBJECTTYPE + OBJECTNAME ;
					from (lcDBCAlias) ;
					where ((PARENTID = liParent and ;
						inlist(OBJECTTYPE, ccVF_OBJ_INDEX, ccVF_OBJ_RELATION)) or ;
						(OBJECTTYPE = ccVF_OBJ_RELATION and ;
						atc(lcAlias, PROPERTY) > 0)) and ;
						not deleted() ;
					into array laFix
			endif not llFree
		
		* Set a flag that we don't have to reindex the table if we didn't find any
		* indexes. Convert the alias into what would actually be used for the table.
		
			llReindex = lnIndexes > 0
			lcAlias   = strtran(lcAlias, ' ', '_')
		
		* Close the table if it's already open. Nuke the CDX bit so VFP doesn't try to
		* open the CDX when the table gets opened. Clear the primary key for the table
		* in the DBC.
		
			.CloseAllAliases(lcFile)
			llReturn = .ClearCDX(lcFile)
			if llReturn
				if not llFree
					select (lcDBCAlias)
					.DBCFindObject(tcAlias, 'Table')
					.DBCDeleteProp(cnVF_TABLE_PRIMARYTAG)
				endif not llFree
		
		* Get an array of fields so we can restore auto-inc values if we pack.
		
				lnFields = .DBCGetTableStructure(tcAlias, @laFields)
				.ReadNextValue(lcFile, @laFields)
		
		* Nuke the CDX, then try to open the table exclusively. Return .F. if something
		* went wrong.
		
				.Parent.ResetError()
				llSuppress = .SetSuppressErrors(.T.)
				select 0
				erase (forceext(lcFile, 'CDX'))
				if .lNeedPause
					.Pause()
				endif .lNeedPause
				use (lcFile) alias (lcAlias) exclusive
		* Dan Freeman found that after several thousand repetitions, a table can get
		* opened with no alias. So, in that case, try it again.
				if empty(alias())
					use (lcFile) alias (lcAlias) exclusive
				endif empty(alias())
				lcMessage = message()
				.SetSuppressErrors(llSuppress)
				llReturn = not .DidErrorOccur()
			else
				lcMessage = strtran(ccERR_CANT_OPEN_EXCL, ccMSG_INSERT1, ;
					trim(lcDescription))
			endif llReturn
			if not llReturn
				if not .lQuiet and not llProgress
					loProgress.Hide()
				endif not .lQuiet ...
				if not llFree
					use in (lcDBCAlias)
				endif not llFree
				.Warning(strtran(strtran(ccERR_CANT_REINDEX, ccMSG_INSERT1, ;
					trim(lcDescription)), ccMSG_INSERT2, lcMessage), '', .cAlias)
				.SetDatabase(lcCurrDBC)
				return .F.
			endif not llReturn
		
		* If we're supposed to pack the file, see if we have enough space. If not, flag
		* that we won't pack after all.
		
			if tlPack
				lcFPT  = .GetMemoFile(lcFile)
				lnSize = 2 * (header() + recsize() * reccount() + 1)
				if file(lcFPT)
					adir(laFPT, lcFPT)
					lnSize = lnSize + laFPT[1, 2]
				endif file(lcFPT)
				if clVFP7ORLATER
					lnSpace = diskspace(justpath(lcFile))
				else
					lnSpace = .GetDriveSpace(lcFile)
				endif clVFP7ORLATER
				llPack = lnSpace > lnSize
			endif tlPack
		
		* Delete all tags.
		
			if not llFree
				delete from (lcDBCAlias) ;
					where PARENTID = liParent and ;
					OBJECTTYPE = ccVF_OBJ_INDEX
			endif not llFree
		
		* Prepare to handle PHD if necessary.
		
			llPHD = '\PHDBASE.' $ upper(set('LIBRARY'))
		
		* Create the indexes.
		
			if llReindex
		
		* Save current settings.
		
				lcCurrTalk    = set('TALK', 1)
				lcCurrCollate = set('COLLATE')
				if not .lQuiet and .lTalk
					set talk window (loProgress.Name)
				endif not .lQuiet ...
		
		* If we're supposed to pack the file, start by seeing if there's a primary key
		* for the table, and it consists of a single field. If so, we'll use that for
		* the ORDER BY clause for the SQL SELECT.
		
				if llPack
					if not .lQuiet
						loProgress.SetCaptions(, strtran(ccMSG_RECORDS_TOTAL, ;
							ccMSG_INSERT1, str(reccount(), 9)))
					endif not .lQuiet
					lcTemp = addbs(justpath(lcFile)) + .TempFile('DBF')
					lnSort = .ArrayScan(@laIndexes, 'P', 5)
					if lnSort > 0
						lcKeyFields = ''
						for lnI = 1 to fcount()
							lcField = field(lnI)
							do case
								case lcField == laIndexes[lnSort, 2]
									lcKeyFields = lcField
									exit
								case lcField $ laIndexes[lnSort, 2]
									lcKeyFields = lcKeyFields + ;
										iif(empty(lcKeyFields), '', ',') + lcField
							endcase
						next lnI
						lcSort = iif(',' $ lcKeyFields or empty(lcKeyFields), '', ;
							' order by ' + lcKeyFields)
					else
						lcSort = ''
					endif lnSort > 0
		
		* Use a SQL SELECT (or COPY TO for non-VFP tables) to create a temporary table
		* with all non-deleted records. If it worked, delete the table and rename the
		* temporary table to it.
		
					.Parent.ResetError()
					set blocksize to lnBlockSize
					llFoxPlus = lnTableType = cnVFP_TABLE_FOXPLUS
					llFox2X   = lnTableType <> cnVFP_TABLE_VFP
					if llFox2X and not .lQuiet and .lTalk
						set talk on
					endif llFox2X ...
					do case
						case llFoxPlus
							select (lcAlias)
							copy to (lcTemp) for not deleted() type foxplus
						case llFox2X
							select (lcAlias)
							copy to (lcTemp) for not deleted() type fox2x
						otherwise
							select * from (lcAlias) where not deleted() ;
								into table (lcTemp) &lcSort
					endcase
					if llFox2X and not .lQuiet
						set talk off
						.FastDoEvents()
					endif llFox2X ...
					set blocksize to lnCurrBlock
					if .DidErrorOccur()
						lcTempAlias = juststem(lcTemp)
						if used(lcTempAlias)
							use in (lcTempAlias)
						endif used(lcTempAlias)
						erase (lcTemp)
						erase (.GetMemoFile(lcTemp))
						.Parent.ResetError()
					else
						use
						if used(lcAlias)
							use in (lcAlias)
						endif used(lcAlias)
						erase (lcFile)
						if .lNeedPause
							.Pause()
						endif .lNeedPause
						rename (lcTemp) to (lcFile)
						if file(lcFPT)
							erase (lcFPT)
							if .lNeedPause
								.Pause()
							endif .lNeedPause
							rename (.GetMemoFile(lcTemp)) to (lcFPT)
						endif file(lcFPT)
						if not llFree
							.WriteBackLink(lcFile, sys(2014, lcDBC, lcFile))
						endif not llFree
						if .lNeedPause
							.Pause()
						endif .lNeedPause
						use (lcFile) alias (lcAlias) exclusive
		
		* If there were any auto-inc fields in the table, restore them.
		
						if version(5) >= 800
							for lnI = 1 to lnFields
								lnStep = laFields[lnI, 18]
								if lnStep <> 0
									lcField = justext(laFields[lnI, 20])
									lnNext  = laFields[lnI, 17]
									alter table (lcFile) alter column &lcField I ;
										autoinc nextvalue lnNext step lnStep novalidate
								endif lnStep <> 0
							next lnI
						endif version(5) >= 800
					endif .DidErrorOccur()
				endif llPack
				if not .lQuiet and tlPack
					loProgress.SetCaptions(strtran(ccMSG_REINDEXING, ccMSG_INSERT1, ;
						lcDescription))
				endif not .lQuiet ...
		
		* Main loop: create each index defined.
		
				lnDoingIndex = 1
				for lnI = 1 to lnIndexes
		
		* Update the progress display if necessary.
		
					if not .lQuiet
						loProgress.Clear()
						loProgress.SetCaptions(, strtran(strtran(ccMSG_DOING_INDEX, ;
							ccMSG_INSERT1, str(lnDoingIndex, 2)), ccMSG_INSERT2, ;
							str(lnIndexes, 2)), strtran(ccMSG_RECORDS_TOTAL, ;
							ccMSG_INSERT1, str(reccount(), 9)))
						.FastDoEvents()
					endif not .lQuiet
		
		* Get the index attributes.
		
					lcTag        = laIndexes[lnI, 1]
					lcExpression = laIndexes[lnI, 2]
					lcForExpr    = laIndexes[lnI, 3]
					lcCollate    = laIndexes[lnI, 4]
					lcTagType    = laIndexes[lnI, 5]
					llAscending  = laIndexes[lnI, 6]
					llUnique     = lcTagType = 'U'
					llCandidate  = lcTagType $ 'CP'
					llPrimary    = lcTagType = 'P'
					llBinary     = lcTagType = 'B'
					lcOptions    = iif(llBinary, ' binary', ;
						iif(empty(lcForExpr), '', ' for ' + lcForExpr) + ;
						iif(llAscending, '', ' descending') + ;
						iif(llUnique, ' unique', '') + ;
						iif(llCandidate, ' candidate', ''))
		
		* Load PhDBase if necessary.
		
					do case
						case upper(left(lcExpression, 4)) <> 'PHD(' or llPHD or ;
							'\PHDBASE.' $ upper(set('LIBRARY'))
						case file('PHDBASE.V50')
							set library to ('PHDBASE.V50') additive
							lcPHD = 'PHDBASE.V50'
						case file('PHDBASE.FLL')
							set library to ('PHDBASE') additive
							lcPHD = 'PHDBASE'
					endcase
		
		* Test the index expressions.
		
					if upper(left(lcExpression, 4)) <> 'PHD('
						llIndexOK      = .F.
						.lTestingIndex = .T.
						luValue        = evaluate(lcExpression)
						luForValue     = iif(empty(lcForExpr), '.T.', evaluate(lcForExpr))
						.lTestingIndex = .F.
					else
						store .T. to luValue, luForValue
					endif upper(left(lcExpression, 4)) <> 'PHD('
					do case
		
		* If any of the expressions are invalid, give an error.
		
						case .lIndexError or vartype(luValue) = 'U' or ;
							vartype(luForValue) = 'U'
							.Warning(strtran(ccERR_INDEX_INVALID, ccMSG_INSERT1, ;
								lcTag), '', .cAlias)
							llReturn = .F.
		
		* If this is a PhDbase index, create the index if we can by evaluating the
		* PHD() function. If we couldn't create the index, give an error message.
		
						case upper(left(lcExpression, 4)) = 'PHD(' and ;
							'PHDBASE' $ upper(set('LIBRARY'))
							if not .lQuiet and .lTalk
								set talk on
							endif not .lQuiet ...
							if .lNeedPause
								.Pause()
							endif .lNeedPause
							= evaluate(lcExpression)
							= evaluate('phd("flush")')
							if .lNeedPause
								.Pause()
							endif .lNeedPause
							if not .lQuiet
								set talk off
							endif not .lQuiet
							llIndexOK = tagno(lcTag) > 0
							llReturn  = iif(llIndexOK, llReturn, .F.)
		
		* PhDBase wasn't loaded, so give an error.
		
						case upper(left(lcExpression, 4)) = 'PHD('
							.Warning(strtran(strtran(ccERR_NO_PHDBASE, ccMSG_INSERT1, ;
								lcTag), ccMSG_INSERT2, tcAlias), '', .cAlias)
							llReturn = .F.
		
		* If all of the expressions are valid, display the number of records to do
		* and a count of the number of records done so far (if necessary).
		
						otherwise
							llCollate = cpcurrent() <> 0 and cpdbf() <> 0 and ;
								upper(lcCollate) <> lcCurrCollate
							if llCollate
								set collate to lcCollate
							endif llCollate
							if not .lQuiet and .lTalk
								set talk on
							endif not .lQuiet ...
		
		* Create the tag, then set TALK off and reset the collate sequence if
		* necessary.
		
							llSuppress = .SetSuppressErrors(.T.)
							index on &lcExpression tag (lcTag) &lcOptions
							.SetSuppressErrors(llSuppress)
							if not .lQuiet
								set talk off
							endif not .lQuiet
							if llCollate
								set collate to lcCurrCollate
							endif llCollate
							llIndexOK = tagno(lcTag) > 0
							llReturn  = iif(llIndexOK, llReturn, .F.)
					endcase
		
		* If the index was created, blank out its entry in the "fix" array. If it was
		* the primary tag, set it in the database (creating it as CANDIDATE above sets
		* it correctly in the CDX file but unmarks it as PRIMARY in the DBC).
		
					.lIndexError = .F.
					if llIndexOK
						lnDoingIndex = lnDoingIndex + 1
						if not llFree
							if laFix[1] <> 0
								lnPos = .ArrayScan(@laFix, ccVF_OBJ_INDEX + ;
									padr(lcTag, fsize('OBJECTNAME', lcDBCAlias)), 2)
								if lnPos > 0
									laFix[lnPos, 1] = 0
								endif lnPos > 0
							endif laFix[1] <> 0
							select (lcDBCAlias)
							if llPrimary
								.DBCFindObject(tcAlias, 'Table')
								.DBCSetProp(cnVF_TABLE_PRIMARYTAG, lcTag)
							endif llPrimary
							select (lcAlias)
						endif not llFree ...
					endif llIndexOK
				next lnI
		
		* Update the progress meter and reset TALK.
		
				if not .lQuiet
					.FastDoEvents()
					set talk &lcCurrTalk
				endif not .lQuiet
			endif llReindex
		
		* If we had a problem creating any index for a table in a DBC, undelete the
		* records for it and any related relations in the DBC. Then close the DBC table
		* and the file.
		
			if not llFree
				if not llReturn
					select (lcDBCAlias)
					for lnI = 1 to alen(laFix, 1)
						lnRecno = laFix[lnI, 1]
						if lnRecno > 0
							go lnRecno
							if deleted()
								recall
							endif deleted()
						endif lnRecno > 0
					next lnI
				endif not llReturn
				use in (lcDBCAlias)
			endif not llFree
			use in (lcAlias)
		
		* Cleanup and exit.
		
			if not llFree
				.EnableDBCEvents(llEventsOn)
			endif not llFree
			if '\PHDBASE.' $ upper(set('LIBRARY')) and not llPHD
				release library (lcPHD)
			endif '\PHDBASE.' $ upper(set('LIBRARY')) ...
			.SetDatabase(lcCurrDBC)
			select (lnCurrSelect)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE repair		&& A front-end to the RepairOneTable() method to repair table headers.
		*==============================================================================
		* Method:			Repair
		* Status:			Public
		* Purpose:			Repair tables
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	08/17/2005
		* Parameters:		tcAlias       - the table to repair, or "ALL" to repair all
		*						tables, or blank or not passed to display a dialog so
		*						the user can select the table(s) to repair. tcAlias
		*						can include a database by specifying
		*						<database>!<table>; specify "ALL" for <database> to
		*						handle all tables in all databases and free tables
		*					tlPack        - .T. to pack the table(s)
		*					tlUseMetaData - backwards compatibility only; the meta data
		*						is now always used
		*					toProgress    - a reference to a progress window (optional:
		*						if it isn't passed and lQuiet is .F., a new progress
		*						window will be created)
		* Returns:			.T. if everything went OK
		* Environment in:	if a database isn't specified, a database is selected
		* Environment out:	selected tables may have been repaired
		*==============================================================================
		
		lparameters tcAlias, ;
			tlPack, ;
			tlUseMetaData, ;
			toProgress
		local lcDBC, ;
			lcCurrDBC, ;
			lcAlias, ;
			llAll, ;
			lnValidate, ;
			lcTableValidateCommand, ;
			laTables[1], ;
			lnProcess, ;
			llReturn, ;
			loProgress, ;
			lnMax, ;
			lnI, ;
			lcTable, ;
			llOK
		with This
		
		* If a database was specified and it's open, select it.
		
			lcDBC     = .Parent.GetDatabase()
			lcCurrDBC = set('DATABASE')
			do case
				case vartype(tcAlias) = 'C' and '!' $ tcAlias
					lcDBC = .Parent.GetDatabase(tcAlias)
					do case
						case not empty(lcDBC) or left(alltrim(tcAlias), 1) = '!'
							lcAlias = .Parent.StripDatabase(tcAlias)
						case right(alltrim(tcAlias), 1) = '!'
							lcAlias = ''
						otherwise
							lcAlias = tcAlias
					endcase
					do case
						case empty(lcDBC) or upper(lcDBC) == ccALL
						case dbused(lcDBC)
							.SetDatabase(lcDBC)
						otherwise
							.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
							return .F.
					endcase
		
		* If no alias was specified, blank it. Otherwise, use the one specified.
		
				case vartype(tcAlias) <> 'C'
					lcAlias = ''
				otherwise
					lcAlias = tcAlias
			endcase
		
		* Flag if we're doing all databases and free tables.
		
			if upper(lcDBC) == ccALL
				llAll = .T.
			endif upper(lcDBC) == ccALL
		
		* Save the current TABLEVALIDATE setting and set it to 0 so we don't get an
		* error when we open tables.
		
			if version(5) >= 800
				lnValidate = set('TABLEVALIDATE')
				lcTableValidateCommand = 'set tablevalidate to 0'
				&lcTableValidateCommand
			endif version(5) >= 800
		
		* Handle the various cases.
		
			lcAlias = juststem(lcAlias)
			.Parent.ResetError(.T.)
			do case
		
		* No alias was passed or we're supposed to do all tables, so get an array of
		* tables to process.
		
				case empty(lcAlias) or upper(lcAlias) == ccALL
					lnProcess = .SelectTablesToProcess(ccMSG_REPAIR, ccMSG_REPAIR, ;
						@laTables, not empty(lcAlias), 'SDTCanUpdate', .T., , , lcDBC)
					do case
						case lnProcess < 0
							.Warning(ccERR_NO_TABLES)
							llReturn = .F.
						case lnProcess = 0
							llReturn = .T.
		
		* If we're going to repair the tables, repair each table that's tagged.
		
						otherwise
							if not .lQuiet
								do case
									case vartype(toProgress) = 'O'
										loProgress = toProgress
									case '\' + justfname(.cProgressFormLibrary) $ upper(set('CLASSLIB'))
										loProgress = createobject(.cProgressFormClass, .T.)
										loProgress.Caption = strtran(ccMSG_REPAIRING, ;
											ccMSG_INSERT1, ccTABLES)
									otherwise
										loProgress = newobject(.cProgressFormClass, ;
											.cProgressFormLibrary, '', .T.)
										loProgress.Caption = strtran(ccMSG_REPAIRING, ;
											ccMSG_INSERT1, ccTABLES)
								endcase
								lnMax = 100/alen(laTables, 1)
							endif not .lQuiet
							llReturn = .T.
							asort(laTables)
							for lnI = 1 to alen(laTables, 1)
								lcAlias = laTables[lnI, 2]
								.cAlias = lcAlias
								lcTable = iif(llAll, '', lcDBC + '!') + lcAlias
								llOK    = .RepairOneTable(lcTable, loProgress, tlPack)
								if not llOK
									llReturn = .F.
								endif not llOK
								if not .lQuiet
									loProgress.Update(lnI * lnMax)
									.FastDoEvents()
								endif not .lQuiet
							next lnI
							if not .lQuiet
								loProgress.Update(100)
								.FastDoEvents()
							endif not .lQuiet
					endcase
		
		* An alias was passed, so reindex just that table if we can find it in the DBC
		* or it's a free table.
		
				case empty(lcDBC) or indbc(lcAlias, 'Table')
					.cAlias  = lcAlias
					llReturn = .RepairOneTable(lcDBC + '!' + lcAlias, , tlPack)
		
		* The specified table wasn't found in the DBC.
		
				otherwise
					.Warning(strtran(ccERR_TABLE_NOT_FOUND, ccMSG_INSERT1, lcAlias))
					llReturn = .F.
			endcase
		
		* Restore the TABLEVALIDATE setting and select the former database.
		
			if version(5) >= 800
				lcTableValidateCommand = 'set tablevalidate to lnValidate'
				&lcTableValidateCommand
			endif version(5) >= 800
			.SetDatabase(lcCurrDBC)
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE repairmemo		&& Repairs the memo file of a table.
		*==============================================================================
		* Method:			RepairMemo
		* Status:			Protected
		* Purpose:			Repair the memo file of a table
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tcFile      - the file name of the table to repair
		*					tnBlockSize - the block size for the memo file
		* Returns:			.T. if the memo was repaired
		* Environment in:	none
		* Environment out:	the memo file was repaired if it exists and could be opened
		*						or is created if it doesn't exist
		*==============================================================================
		
		lparameters tcFile, ;
			tnBlockSize
		local lcMemoFile, ;
			llExists, ;
			lnHandle, ;
			llReturn, ;
			lnSize
		
		* If the memo file exists, open it. Otherwise, create it.
		
		with This
			lcMemoFile = .GetMemoFile(tcFile)
			llExists   = file(lcMemoFile)
			if llExists
				if .lNeedPause
					.Pause()
				endif .lNeedPause
				lnHandle = fopen(lcMemoFile, F_READWRITE)
			else
				lnHandle = fcreate(lcMemoFile)
			endif llExists
		
		* If we could open or create the file, get the size of the file (the actual
		* size if it exists, the size of the header if not) and write the next block
		* pointer and block size.
		
			llReturn = lnHandle >= 0
			if llReturn
				lnSize = iif(llExists, fseek(lnHandle, 0, 2), cnFPT_HEADER_SIZE)
				fseek(lnHandle, 0)
				fwrite(lnHandle, ;
					.ReverseDecimal2Hex(ceiling(lnSize/tnBlockSize), 4))
				fwrite(lnHandle, .ReverseDecimal2Hex(tnBlockSize, 4))
				if not llExists
					fwrite(lnHandle, .ReverseDecimal2Hex(0, lnSize - 8))
				endif not llExists
		
		* Fix (if necessary) and close the FPT file size.
		
				llReturn = .FixFPTFileSize(lcMemoFile, tnBlockSize, lnHandle)
		
		* If we couldn't open or create the file, give an error.
		
			else
				.DisplayLLFFError(lcMemoFile)
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE repaironetable		&& Repairs a single table's header.
		*==============================================================================
		* Method:			RepairOneTable
		* Status:			Protected
		* Purpose:			Repair a single file
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last Revision:	06/07/2005
		* Parameters:		tcAlias    - the alias of the table to repair
		*					toProgress - an object reference to the progress form
		*					tlPack     - .T. to pack the table(s)
		* Returns:			.T. if the table was repaired or is built into the APP
		* Environment in:	none
		* Environment out:	if the table could be opened, a new header is written out
		*==============================================================================
		
		lparameters tcAlias, ;
			toProgress, ;
			tlPack
		local llProgress, ;
			loProgress, ;
			lnCurrSelect, ;
			lcDBC, ;
			lcCurrDBC, ;
			lcAlias, ;
			lcFile, ;
			llFree, ;
			laTemp[1], ;
			lcDescription, ;
			lnCodePage, ;
			lnBlockSize, ;
			lcTableType, ;
			lnHandle, ;
			llReturn, ;
			laTable[1]
		
		* Define the progress window if we are displaying the repair progress and it
		* hasn't already been defined.
		
		with This
			llProgress = vartype(toProgress) = 'O'
			do case
				case .lQuiet
				case llProgress
					loProgress = toProgress
					loProgress.SetCaptions(, '', '')
					loProgress.Clear()
				case '\' + justfname(.cProgressFormLibrary) $ upper(set('CLASSLIB'))
					loProgress = createobject(.cProgressFormClass)
					loProgress.Caption = strtran(ccMSG_REPAIRING, ccMSG_INSERT1, ;
						ccTABLES)
				otherwise
					loProgress = newobject(.cProgressFormClass, .cProgressFormLibrary)
					loProgress.Caption = strtran(ccMSG_REPAIRING, ccMSG_INSERT1, ;
						ccTABLES)
			endcase
		
		* Find the complete path to the table.
		
			lnCurrSelect = select()
			lcDBC        = .Parent.cCurrentDBC
			lcCurrDBC    = dbc()
			if '!' $ tcAlias
				lcDBC   = .Parent.GetDatabase(tcAlias)
				lcAlias = lower(.Parent.StripDatabase(tcAlias))
				do case
					case empty(lcDBC)
					case not dbused(lcDBC)
						.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
						return .F.
					case not upper(lcDBC) == set('DATABASE')
						.SetDatabase(lcDBC)
						lcDBC = dbc()
					otherwise
						lcDBC = dbc()
				endcase
			else
				lcAlias = tcAlias
			endif '!' $ tcAlias
			if empty(lcDBC)
				lcFile = lower(.GetFreeTablePath(tcAlias))
				if empty(lcFile)
					.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
						tcAlias))
					.SetDatabase(lcCurrDBC)
					return .F.
				endif empty(lcFile)
				llFree = .T.
			else
				lcFile = lower(fullpath(dbgetprop(lcAlias, 'Table', 'Path'), lcDBC))
				llFree = .F.
			endif empty(lcDBC)
		
		* The file exists, but it's built into the app, or it doesn't exist, so ignore
		* it.
		
			if not file(lcFile) or (file(lcFile) and adir(laTemp, lcFile) = 0)
				.SetDatabase(lcCurrDBC)
				return .T.
			endif not file(lcFile) ...
		
		* Get the table's caption.
		
			lcDescription = .Parent.DBCXGetProp(tcAlias, 'Table', 'CBcCaption')
			lcDescription = iif(empty(lcDescription) or isnull(lcDescription), ;
				proper(tcAlias), lcDescription)
			lnCodePage    = CoreMeta.nCodePage
			lnBlockSize   = CoreMeta.nBlockSize
			lnBlockSize   = iif(isnull(lnBlockSize) or lnBlockSize = 0, ;
				cnFPT_DEFAULT_BLOCK_SIZE, lnBlockSize)
			lcTableType   = .Parent.DBCXGetProp('SDTTableType')
			lcTableType   = iif(isnull(lcTableType) or empty(lcTableType), ;
				ccVFP_TABLE_VFP, lcTableType)
		
		* Display what we are doing in the progress window if necessary.
		
			if not .lQuiet
				loProgress.Show()
				loProgress.SetCaptions(strtran(ccMSG_REPAIRING, ccMSG_INSERT1, ;
					lcDescription))
				.FastDoEvents()
			endif not .lQuiet
		
		* Close the table if it's already open. Then see if it can be opened for read
		* and write. If not, give an error.
		
			.CloseAllAliases(lcFile)
			lnHandle = fopen(lcFile, F_READWRITE)
			if lnHandle < 0
				if not .lQuiet
					loProgress.Hide()
				endif not .lQuiet
				.DisplayLLFFError(lcAlias)
				.SetDatabase(lcCurrDBC)
				return .F.
			endif lnHandle < 0
		
		* Repair the table: put the definition of all of the fields for the table into
		* laTable. Use WriteDBFHeader() to write the header, RepairMemo() to repair the
		* memo file, then reindex the file.
		
			if .DBCGetTableStructure(tcAlias, @laTable) > 0
				lnCodePage = .GetCodePage(lnCodePage)
				.ReadNextValue(lcFile, @laTable, lnHandle)
				llReturn = .WriteDBFHeader(lcFile, lcDBC, @laTable, lnCodePage, ;
					lnHandle, llFree, lcTableType, .T.)
				if llReturn and .TableHasMemo(@laTable)
					llReturn = .RepairMemo(lcFile, lnBlockSize)
				endif llReturn ...
				llReturn = llReturn and .ReindexOneTable(tcAlias, tlPack, ;
					loProgress)
		
		* If DBCGetTableStructure() fails, we can't repair the table, so just close it.
		
			else
				fclose(lnHandle)
				llReturn = .F.
			endif .DBCGetTableStructure(tcAlias, @laTable) > 0
		
		* Restore the former database.
		
			.SetDatabase(lcCurrDBC)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE reseterror		&& An exposed method to reset the values of the protected lErrorOccurred and public aErrorSpecs.
		*==============================================================================
		* Function:			ResetError
		* Status:			Public
		* Purpose:			Resets error information (for backward compatibility only)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	07/31/98
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	see DBCXMgr.ResetError()
		*==============================================================================
		
		This.Parent.ResetError()
		
	ENDPROC

	PROTECTED PROCEDURE reversedecimal2hex		&& Convert a decimal number to a hex string in reverse Intel format (most significant byte first)
		*==============================================================================
		* Method:			ReverseDecimal2Hex
		* Status:			Protected
		* Purpose:			Convert a decimal number to a hex string in reverse Intel
		*						format (most significant byte first)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tnValue  - the decimal value
		*					tnPlaces - the number of places needed (optional: if it
		*						isn't specified, 4 is used)
		* Returns:			the hex string
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tnValue, ;
			tnPlaces
		local lnDecimal, ;
			lcHex, ;
			lnCurrDecimals, ;
			lnPlaces, ;
			lnI, ;
			lnExponent, ;
			lnTemp
		lnDecimal      = tnValue
		lcHex          = ''
		lnCurrDecimals = set('DECIMALS')
		lnPlaces       = iif(pcount() = 1, 4, tnPlaces)
		set decimals to 17
		for lnI = lnPlaces to 1 step -1
			lnExponent = 256 ^ (lnI - 1)
			lnTemp     = int(lnDecimal/lnExponent)
			lcHex      = lcHex + chr(lnTemp)
			lnDecimal  = lnDecimal - lnTemp * lnExponent
		next lnI
		set decimals to lnCurrDecimals
		return lcHex
		
	ENDPROC

	PROTECTED PROCEDURE reversehex2decimal		&& Converts a word in reverse Intel format (most significant byte first) to a decimal value
		*==============================================================================
		* Method:			ReverseHex2Decimal
		* Status:			Protected
		* Purpose:			Converts a word in reverse Intel format (most significant
		*						byte first) to a decimal value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tcWord - the word to convert
		* Returns:			the numeric value
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcWord
		local lnDecimal, ;
			lnI
		lnDecimal = 0
		for lnI = len(tcWord) to 1 step -1
			lnDecimal = lnDecimal + asc(substr(tcWord, lnI, 1)) * 256^(len(tcWord) - lnI)
		next lnI
		return lnDecimal
		
	ENDPROC

	PROCEDURE selecttablestoprocess		&& Create an array of tables to process.
		*==============================================================================
		* Method:			SelectTablesToProcess
		* Status:			Public
		* Purpose:			Create an array of tables to process
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcFormCaption   - the caption for the Process form
		*					tcButtonCaption - the caption for the Process button
		*					taTables        - an array to contain the tables selected
		*						by the user to be processed. The array will have one
		*						row per table selected, with the first column
		*						containing the caption of the table and the second
		*						containing the name of the table. NOTE: this should be
		*						passed with an "@" prefix to force FoxPro to pass the
		*						array by reference
		*					tlAll           - .T. to automatically select all matching
		*						tables
		*					tcProperty      - the name of a DBCX property to check (see
		*						tuValue below). If it isn't passed, all tables are used
		*					tuValue         - the value to compare to the property
		*						specified in tcProperty. If tcProperty and tuValue are
		*						passed, only tables having the specified value in the
		*						specified DBCX property are selected for processing.
		*						See DBCXGetAllObjects for information on tcProperty and
		*						tuValue values
		*					tcOtherCheckboxCaption -  the caption to use for an
		*						optional checkbox. If it isn't specified, the checkbox
		*						doesn't appear
		*					tlOtherCheckboxDefault - the default value for the optional
		*						checkbox
		*					tcDBC                  - the database to select tables from
		*						(database name, empty for current database, '!' for
		*						free tables, or "ALL" for all databases and free tables)
		* Returns:			-1 if there are no tables that match the specified property
		*						and value, 0 if the process is not to proceed, 1 if the
		*						process is to proceed, and 2 if the process is to
		*						proceed and the second checkbox value is .T.
		* Environment in:	none
		* Environment out:	the process form may have been displayed to allow the user
		*						to select which tables to process
		*					taArray contains the captions and names of the tables the
		*						user selected (or all tables if tlAll is .T.)
		*==============================================================================
		
		lparameters tcFormCaption, ;
			tcButtonCaption, ;
			taTables, ;
			tlAll, ;
			tcProperty, ;
			tuValue, ;
			tcOtherCheckboxCaption, ;
			tlOtherCheckboxDefault, ;
			tcDBC
		local lcDBC, ;
			laTables[1], ;
			lnTables, ;
			lnReturn, ;
			oProcess, ;
			oProcessForm
		
		* Create an array of updatable tables from the database that match the desired
		* specification.
		
		do case
			case vartype(tcDBC) <> 'C'
				lcDBC = This.Parent.GetDatabase()
			case tcDBC == '!'
				lcDBC = ''
			otherwise
				lcDBC = tcDBC
		endcase
		
		* If we weren't passed any tables, get all tables matching the specified
		* conditions. Otherwise, we'll use those already in the array.
		
		if empty(taTables[1])
			lnTables = This.Parent.DBCXGetAllObjects(lcDBC + '!Table', @laTables, ;
				'CBcCaption', tcProperty, tuValue)
		else
			acopy(taTables, laTables)
			lnTables = alen(laTables, 1)
		endif empty(taTables[1])
		do case
			case lnTables = 0
				lnReturn = -1
		
		* If we're not automatically processing all specified tables, allow the user to
		* specify which tables to process interactively.
		
			case not tlAll
				if '\SDT.VCX' $ upper(set('CLASSLIB'))
					oProcess = createobject('SDTPassParameters')
				else
					oProcess = newobject('SDTPassParameters', 'SDT.VCX')
				endif '\SDT.VCX' $ upper(set('CLASSLIB'))
				dimension oProcess.aParameters[1]
				acopy(laTables, oProcess.aArray)
				if '\SDT.VCX' $ upper(set('CLASSLIB'))
					oProcessForm = createobject('SDTProcessForm', oProcess)
				else
					oProcessForm = newobject('SDTProcessForm', 'SDT.VCX', '', oProcess)
				endif '\SDT.VCX' $ upper(set('CLASSLIB'))
				if vartype(tcFormCaption) = 'C' and not empty(tcFormCaption)
					oProcessForm.Caption = tcFormCaption
				endif vartype(tcFormCaption) = 'C' ...
				if vartype(tcButtonCaption) = 'C' and not empty(tcButtonCaption)
					oProcessForm.cmdProcess.Caption = tcButtonCaption
				endif vartype(tcButtonCaption) = 'C' ...
				if vartype(tcOtherCheckboxCaption) = 'C' and ;
					not empty(tcOtherCheckboxCaption)
					oProcessForm.chkOther.Caption = tcOtherCheckboxCaption
					oProcessForm.chkOther.Value   = tlOtherCheckboxDefault
				else
					oProcessForm.chkOther.Visible   = .F.
				endif type(tcOtherCheckboxCaption) = 'C' ...
				oProcessForm.Show(1)
				dimension taTables[alen(oProcess.aArray, 1), alen(oProcess.aArray, 2)]
				acopy(oProcess.aArray, taTables)
				lnReturn = iif(oProcess.aParameters[1], 1, 0) + ;
					iif(oProcess.aParameters[1] and oProcess.aParameters[2], 1, 0)
		
		* We are processing all tables, so we're done.
		
			otherwise
				dimension taTables[alen(laTables, 1), alen(laTables, 2)]
				acopy(laTables, taTables)
				lnReturn = 1 + iif(tlOtherCheckboxDefault, 1, 0)
		endcase
		return lnReturn
		
	ENDPROC

	PROCEDURE selecttag		&& Allow the user to select a tag for a table.
		*==============================================================================
		* Method:			SelectTag
		* Status:			Public
		* Purpose:			Select a tag from a list of selectable tags for a table
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcAlias       - the table to select the tag for (optional:
		*						if it isn't passed, the current table is used). tcAlias
		*						can include a database by specifying <database>!<table>
		*					tnDataSession - the datasession the table is open in
		*						(optional: datasession 1 is used if it isn't passed)
		* Returns:			.T. if everything went OK
		* Environment in:	the specified table is open
		* Environment out:	the specified table's index order may have changed
		*==============================================================================
		
		lparameters tcAlias, ;
			tnDataSession
		local lnCurrDataSession, ;
			lnDataSession, ;
			lcAlias, ;
			lcTable, ;
			llReturn, ;
			lnCurrSelect, ;
			lcDBC, ;
			lnTags, ;
			lnTag, ;
			lcOrder, ;
			llDesc, ;
			lnI, ;
			lcTag, ;
			llSelect, ;
			laTags[1], ;
			loSelect, ;
			loSelectForm, ;
			lcDesc
		
		* Save the current settings.
		
		with This
		
		* Save the current datasession and figure out which one we'll use, then set the
		* datasession to it.
		
			lnCurrDataSession = set('DATASESSION')
			lnDataSession     = iif(vartype(tnDataSession) = 'N' and ;
				tnDataSession <> 0, tnDataSession, 1)
			set datasession to lnDataSession
		
		* Get the alias of the table. If no alias was specified, use the current one.
		
			lcAlias  = iif(vartype(tcAlias) <> 'C', '', tcAlias)
			lcAlias  = iif('!' $ lcAlias, .Parent.StripDatabase(lcAlias), lcAlias)
			lcTable  = iif(empty(lcAlias), alias(), upper(alltrim(lcAlias)))
			lcAlias  = strtran(lcTable, ' ', '_')
			llReturn = .F.
			do case
		
		* Give an error if no alias is available or the alias isn't open.
		
				case empty(lcAlias)
					.Warning(ccERR_NO_TABLE_SELECTED)
				case not used(lcAlias)
					.Warning(strtran(ccERR_TABLE_NOT_OPEN, ccMSG_INSERT1, lcTable))
		
		* Create an array of selectable tags from the database.
		
				otherwise
					lnCurrSelect = select()
					select (lcAlias)
					lcDBC   = cursorgetprop('Database')
					lcTable = juststem(cursorgetprop('SourceName'))
					lnTags  = tagcount()
					lnTag   = 0
					lcOrder = order()
					llDesc  = not empty(lcOrder) and (' DESCENDING' $ set('ORDER') or ;
						descending(tagno(lcOrder)))
					for lnI = 1 to lnTags
						lcTag = tag(lnI)
						set datasession to lnCurrDataSession
						llSelect = nvl(.Parent.DBCXGetProp(lcDBC + '!' + lcTable + ;
							'.' + lcTag, 'Index', 'SDTSelect'), .T.)
						if llSelect
							lnTag = lnTag + 1
							dimension laTags[lnTag, 2]
							laTags[lnTag, 1] = nvl(.Parent.DBCXGetProp(lcDBC + '!' + ;
								lcTable + '.' + lcTag, 'Index', 'CBcCaption'), ;
								proper(strtran(lcTag, '_', ' ')))
							laTags[lnTag, 2] = lcTag
						endif llSelect
						set datasession to lnDataSession
					next lnI
		
		* If there's more than one selectable tag, create a SelectTagForm form and
		* pass it the correct parameters.
		
					if lnTag > 1
						if '\SDT.VCX' $ upper(set('CLASSLIB'))
							loSelect = createobject('SDTPassParameters')
						else
							loSelect = newobject('SDTPassParameters', 'SDT.VCX')
						endif '\SDT.VCX' $ upper(set('CLASSLIB'))
						dimension loSelect.aParameters[3]
						loSelect.aParameters[1] = .F.
						loSelect.aParameters[2] = lcOrder
						loSelect.aParameters[3] = llDesc
						acopy(laTags, loSelect.aArray)
						if '\SDT.VCX' $ upper(set('CLASSLIB'))
							loSelectForm = createobject('SDTSelectTagForm', loSelect, ;
								This)
						else
							loSelectForm = newobject('SDTSelectTagForm', 'SDT.VCX', ;
								'', loSelect, This)
						endif '\SDT.VCX' $ upper(set('CLASSLIB'))
						loSelectForm.Show(1)
						llReturn = loSelect.aParameters[1]
						lcOrder  = loSelect.aParameters[2]
						lcDesc   = iif(loSelect.aParameters[3], 'descending', ;
							'ascending')
						if llReturn
							set order to (lcOrder) in (lcAlias) &lcDesc
						endif llReturn
					endif lnTag > 1
					select (lnCurrSelect)
			endcase
		endwith
		
		* Cleanup and exit.
		
		set datasession to lnCurrDataSession
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE setdatabase		&& Does SET DATABASE to the specified database, handling spaces in names
		*==============================================================================
		* Method:			SetDatabase
		* Status:			Protected
		* Purpose:			Does SET DATABASE to the specified database, handling
		*						spaces in names
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	06/17/98
		* Parameters:		tcDatabase - the desired database
		* Returns:			.T.
		* Environment in:	the specified database must be open
		* Environment out:	the specified database is the current one
		*==============================================================================
		
		lparameters tcDatabase
		local lcDBC
		lcDBC = iif(empty(tcDatabase), '', '"' + tcDatabase + '"')
		set database to &lcDBC
		return
		
	ENDPROC

	PROCEDURE setrelation		&& Sets temporal relations between tables based on their persistent relations.
		*==============================================================================
		* Method:			SetRelation
		* Status:			Public
		* Purpose:			Sets temporal relations from a table into related tables
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2003 Stonefield Systems Group Inc.
		* Last revision:	03/06/2003
		* Parameters:		tcTable       - the name of the table to set relations from
		*					tnDataSession - the datasession to work with (optional:
		*						datasession 1 is used if it isn't passed)
		*					tcOrder       - the order to use for the table (optional:
		*						if it isn't specified, the primary key is used if there
		*						is one)
		*					tlAll         - .T. to set relations into all tables
		*						(optional: if it isn't specified, relations are only
		*						set into parent tables)
		*					tcFiles       - a list of file already processed (internal
		*						use only)
		* Returns:			.F. if there was a problem opening any table
		* Environment in:	the specified table and all related tables must either be
		*						open or available to be opened
		* Environment out:	all related tables are open and their orders set to the
		*						ones used for the relationship
		*					the specified table is open and a relationship set into all
		*						parent tables (if tlAll is .F.) or all tables (if tlAll
		*						is .T.)
		*==============================================================================
		
		lparameters tcTable, ;
			tnDataSession, ;
			tcOrder, ;
			tlAll, ;
			tcFiles
		local lnCurrDataSession, ;
			lcTable, ;
			lcAlias, ;
			lcOrder, ;
			laRelations[1], ;
			lnRelations, ;
			llReturn, ;
			lnI, ;
			lcRelated, ;
			lcRelTag, ;
			lcMainTag, ;
			lcExpr, ;
			lnJ, ;
			llGotIt
		
		* Parameter checking.
		
		with This
			if pcount() > 0 and vartype(tcTable) <> 'C'
				.Warning(ccERR_INVALID_PARAMETERS)
				return .F.
			endif pcount() > 0 ...
		
		* Save the current datasession and figure out which one we'll use.
		
			lnCurrDataSession = set('DATASESSION')
			set datasession to iif(vartype(tnDataSession) = 'N' and ;
				tnDataSession <> 0, tnDataSession, 1)
		
		* Get the table.
		
			lcTable = iif(vartype(tcTable) = 'C', upper(alltrim(tcTable)), alias())
			lcAlias = strtran(lcTable, ' ', '_')
			if empty(lcTable)
				.Warning(ccERR_NO_TABLE_SELECTED)
				set datasession to lnCurrDataSession
				return .F.
			endif empty(lcTable)
			lcOrder = iif(vartype(tcOrder) = 'C', upper(trim(tcOrder)), 'PRIMARY')
		
		* Select the specified table (open it first if necessary).
		
			do case
				case used(lcAlias)
					set order to (lcOrder) in (lcAlias)
				case not used(lcAlias) and ;
					not .OpenTable(lcTable, lcOrder, .F., '', .F., tnDataSession)
					if empty(tcFiles)
						set datasession to lnCurrDataSession
					endif empty(tcFiles)
					return .F.
			endCase
		
		* Get all relationships from the database.
		
			lnRelations = adbobjects(laRelations, 'Relation')
			llReturn    = .T.
			tcFiles     = iif(vartype(tcFiles) = 'C', tcFiles, '') + lcTable + ','
			for lnI = 1 to lnRelations
		
		* We only want relationships for the table we're interested in. Set up any
		* relationships into parent tables and, if tlAll is .T., child tables.
		
				if laRelations[lnI, 1] == lcTable or ;
					(tlAll and laRelations[lnI, 2] == lcTable)
					lcRelated = laRelations[lnI, iif(laRelations[lnI, 1] == lcTable, ;
						2, 1)]
		
		* Don't process any relationship that's already been processed.
		
					if lcRelated + ',' $ tcFiles
						loop
					endif lcRelated + ',' $ tcFiles
		
		* Get the tags to use and call ourselves recursively to set relations for this table.
		
					lcRelTag  = laRelations[lnI, iif(laRelations[lnI, 1] == lcTable, ;
						4, 3)]
					lcMainTag = laRelations[lnI, iif(laRelations[lnI, 1] == lcTable, ;
						3, 4)]
					if not .SetRelation(lcRelated, tnDataSession, lcRelTag, tlAll, ;
						tcFiles)
						llReturn = .F.
						exit
					endif not .SetRelation ...
		
		* The relationship expression to use is the index expression for the tag for
		* specified table as defined in the relationship.
		
					select (lcAlias)
					lcExpr = key(tagno(lcMainTag))
		
		* If we don't already have a relationship into this table, set it.
		
					lnJ     = 1
					llGotIt = .F.
					do while not empty(target(lnJ)) and not llGotIt
						llGotIt = target(lnJ) == lcRelated
						lnJ     = lnJ + 1
					enddo while not empty(target(lnJ)) ...
					if not llGotIt
						set relation to &lcExpr into (lcRelated) additive
					endif not llGotIt
				endif laRelations[lnI, 1] == lcTable
			next lnI
		
		* Restore the former datasession if necessary.
		
			if empty(tcFiles)
				set datasession to lnCurrDataSession
			endif empty(tcFiles)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE setsuppresserrors		&& An exposed method to set the value of the protected lSuppressErrors.
		*==============================================================================
		* Method:			SetSuppressErrors
		* Status:			Public
		* Purpose:			Sets This.Parent.lSuppressErrors and returns its former
		*						value
		* Author:			Doug Hennig
		* Copyright:		(c) 1995-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tlSuppress - .T. to suppress errors or .F. to show them
		* Returns:			the former value of This.Parent.lSuppressErrors
		* Environment in:	none
		* Environment out:	This.Parent.lSuppressErrors is set as desired as long as
		*						the passed value is logical and not null. Otherwise, it
		*						isn't changed
		*==============================================================================
		
		lparameters tlSuppress
		local llSuppress
		with This
			llSuppress = .Parent.lSuppressErrors
			.Parent.lSuppressErrors = iif(vartype(tlSuppress) = 'L', tlSuppress, ;
				.Parent.lSuppressErrors)
		endwith
		return llSuppress
		
	ENDPROC

	PROCEDURE stripproperty		&& Removes a row from an array created with DBCXGetRowProp containing the specified property.
		*==============================================================================
		* Method:			StripProperty
		* Status:			Public
		* Purpose:			Strip the specified property from a properties array
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		taProperty - the array to process (passed by reference)
		*					tcProperty - the property (including extension manager
		*						prefix to remove)
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the row for the specified property is removed from the
		*						array if it exists
		*==============================================================================
		
		lparameters taProperty, ;
			tcProperty
		local lcProperty, ;
			lnProp
		lcProperty = upper(tcProperty)
		lnProp = This.ArrayScan(@taProperty, lcProperty, 2)
		if lnProp <> 0
			adel(taProperty, lnProp)
			dimension taProperty[alen(taProperty, 1) - 1, alen(taProperty, 2)]
		endif lnProp <> 0
		return
		
	ENDPROC

	PROTECTED PROCEDURE tablehasmemo		&& Returns .T. if a table has at least one memo or general field.
		*==============================================================================
		* Method:			TableHasMemo
		* Status:			Protected
		* Purpose:			Determines if a table has at least one memo or general
		*						field
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last Revision:	03/19/2004
		* Parameters:		taFieldList - a list of fields in the table
		* Returns:			.T. if the table has at least one memo or general field
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters taFieldList
		local llHasMemo, ;
			lnNumFields, ;
			lnI
		llHasMemo   = .F.
		lnNumFields = alen(taFieldList, 1)
		for lnI = 1 to lnNumFields
			llHasMemo = taFieldList[lnI, 2] $ 'MGW'
			if llHasMemo
				exit
			endif llHasMemo
		next lnI
		return llHasMemo
		
	ENDPROC

	PROTECTED PROCEDURE tempfile		&& Create a temporary filename
		*==============================================================================
		* Method:			TempFile
		* Status:			Protected
		* Purpose:			Create a temporary filename
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tcExtension - the file extension
		* Returns:			a temporary filename; the first four characters of the
		*						filename contain "TEMP"
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcExtension
		local lcPrefix, ;
			lnLen
		lcPrefix = 'TEMP'
		lnLen    = min(len(trim(lcPrefix)), 4)
		return stuff(sys(3), 1, lnLen, left(lcPrefix, lnLen)) + ;
			iif(vartype(tcExtension) = 'L' or empty(tcExtension), '', '.' + ;
			tcExtension)
		
	ENDPROC

	PROCEDURE testmetadata		&& Returns .T. if the DBC and meta data are in sync
		*==============================================================================
		* Method:			TestMetaData
		* Status:			Public
		* Purpose:			Returns .T. if the meta data and the DBC are in sync
		* Author:			Doug Hennig
		* Copyright:		(c) 1996, 2001 Stonefield Systems Group Inc.
		* Last revision:	02/19/2001
		* Parameters:		tcDatabase - the database to test (optional: if it isn't
		*						specified, the default DBCX database is used)
		* Returns:			.T. if every table, view, field, and index in the meta data
		*						are in the specified DBC (this assumes the meta data is
		*						correct but the DBC may not be)
		* Environment in:	the specified database must be open
		* Environment out:	none
		*==============================================================================
		
		lparameters tcDatabase
		local llReturn, ;
			lcDatabase, ;
			lcDBC, ;
			lnSelect, ;
			lcDBCNameField, ;
			lcType
		with This
		
		* Get the database to test.
		
			llReturn = .T.
			if empty(tcDatabase)
				lcDatabase = .Parent.GetDatabase()
			else
				lcDatabase = juststem(tcDatabase)
			endif empty(tcDatabase)
		
		* We can't operate on free tables, so give an error and return.
		
			if empty(lcDatabase)
				.Warning(ccERR_CANT_PROCESS_FREE)
				return .F.
			endif empty(lcDatabase)
		
		* Try to open our meta data table and return .F. if we can't.
		
			if not .OpenDBCXMeta()
				return .F.
			endif not .OpenDBCXMeta()
		
		* Select the specified database.
		
			lcDBC = dbc()
			.SetDatabase(lcDatabase)
		
		* Select our meta data table and initialize some variables.
		
			lnSelect = select()
			select (.cDBCXAlias)
			lcDBCNameField = .cDBCNameField
			lcDatabase     = padr(lower(lcDatabase), fsize(lcDBCNameField))
		
		* Check each object in our meta data table for the specified database.
		
			scan for &lcDBCNameField == lcDatabase
				lcType = evaluate(.cRecTypeField)
				do case
					case lcType = 'F'
						lcType = 'Field'
					case lcType = 'T'
						lcType = 'Table'
					case lcType = 'I'
						lcType = 'Index'
					case lcType = 'V'
						lcType = 'View'
					otherwise
						lcType = ''
				endcase
				if not empty(lcType) and not indbc(evaluate(.cObjectNameField), lcType)
					llReturn = .F.
					exit
				endif not empty(lcType) ...
			endscan for &lcDBCNameField == lcDBC
		
		* Restore the things we changed.
		
			select (lnSelect)
			.SetDatabase(lcDBC)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE update		&& A front-end to the UpdateOneTable() method to update table structures
		*==============================================================================
		* Method:			Update
		* Status:			Public
		* Purpose:			Update tables to match their database definition
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2007 Stonefield Systems Group Inc.
		* Last Revision:	12/18/2007
		* Parameters:		tcAlias       - "ALL" to update all tables (the default if
		*						no parameter is passed) or the alias of a single
		*						table to update. tcAlias can include a database by
		*						specifying <database>!<table>; specify "ALL" for
		*						<database> to handle all tables in all databases and
		*						free tables
		*					tlPack        - .T. to pack the table(s)
		*					tlUseMetaData - backwards compatibility only; the meta data
		*						is now always used
		*					toProgress    - a reference to a progress window (optional:
		*						if it isn't passed and lQuiet is .F., a new progress
		*						window will be created)
		* Returns:			.T. if all the specified tables could be updated
		* Environment in:	if a database isn't specified, a database is selected
		* Environment out:	selected tables may have been updated
		*==============================================================================
		
		lparameters tcAlias, ;
			tlPack, ;
			tlUseMetaData, ;
			toProgress
		local lcDBC, ;
			lcCurrDBC, ;
			lcAlias, ;
			llAll, ;
			lnValidate, ;
			lcTableValidateCommand, ;
			laTables[1], ;
			lnTables, ;
			loProgress, ;
			lnMax, ;
			llReturn, ;
			lnI, ;
			lcTable, ;
			llOK
		with This
		
		* If a database was specified and it's open, select it.
		
			lcDBC     = .Parent.GetDatabase()
			lcCurrDBC = set('DATABASE')
			do case
				case vartype(tcAlias) = 'C' and '!' $ tcAlias
					lcDBC = .Parent.GetDatabase(tcAlias)
					do case
						case not empty(lcDBC) or left(alltrim(tcAlias), 1) = '!'
							lcAlias = .Parent.StripDatabase(tcAlias)
						case right(alltrim(tcAlias), 1) = '!'
							lcAlias = ccALL
						otherwise
							lcAlias = tcAlias
					endcase
					do case
						case empty(lcDBC) or upper(lcDBC) == ccALL
						case dbused(lcDBC)
							.SetDatabase(lcDBC)
						otherwise
							.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
							return .F.
					endcase
		
		* If no alias was specified, set it to ALL. Otherwise, use the one specified.
		
				case vartype(tcAlias) <> 'C'
					lcAlias = ccALL
				otherwise
					lcAlias = tcAlias
			endcase
		
		* Flag if we're doing all databases and free tables.
		
			if upper(lcDBC) == ccALL
				llAll = .T.
			endif upper(lcDBC) == ccALL
		
		* Save the current TABLEVALIDATE setting and set it to 0 so we don't get an
		* error when we open tables.
		
			if version(5) >= 800
				lnValidate = set('TABLEVALIDATE')
				lcTableValidateCommand = 'set tablevalidate to 0'
				&lcTableValidateCommand
			endif version(5) >= 800
		
		* Create a progress object if one wasn't specified.
		
			do case
				case .lQuiet
				case vartype(toProgress) = 'O'
					loProgress = toProgress
				case '\' + justfname(.cProgressFormLibrary) $ upper(set('CLASSLIB'))
					loProgress = createobject(.cProgressFormClass, .T.)
					loProgress.Caption = strtran(ccMSG_UPDATING, ccMSG_INSERT1, ;
						ccTABLES)
				otherwise
					loProgress = newobject(.cProgressFormClass, ;
						.cProgressFormLibrary, '', .T.)
					loProgress.Caption = strtran(ccMSG_UPDATING, ccMSG_INSERT1, ;
						ccTABLES)
			endcase
		
		* Handle the various cases.
		
			lcAlias = juststem(alltrim(lcAlias))
			.Parent.ResetError(.T.)
			do case
		
		* Handle all tables.
		
				case empty(lcAlias) or upper(lcAlias) == ccALL
					lnTables = .Parent.DBCXGetAllObjects(lcDBC + '!Table', @laTables, ;
						, 'SDTCanUpdate', .T.)
					lnMax    = 100/lnTables
					llReturn = .T.
					asort(laTables)
					for lnI = 1 to lnTables
						lcAlias = laTables[lnI]
						.cAlias = lcAlias
						lcTable = iif(llAll, '', lcDBC + '!') + lcAlias
						llOK    = .UpdateOneTable(lcTable, loProgress, tlPack)
						if not llOK
							llReturn = .F.
						endif not llOK
						if not .lQuiet
							loProgress.Update(lnI * lnMax)
							.FastDoEvents()
						endif not .lQuiet
					next lnI
					if not .lQuiet
						loProgress.Update(100)
						.FastDoEvents()
					endif not .lQuiet
		
		* An alias was passed, so update just that table if we can find it in the DBC
		* or it's a free table.
		
				case empty(lcDBC) or indbc(lcAlias, 'Table')
					.cAlias  = lcAlias
					llReturn = .UpdateOneTable(lcDBC + '!' + lcAlias, loProgress, ;
						tlPack)
		
		* The specified table wasn't found in the DBC.
		
				otherwise
					.Warning(strtran(ccERR_TABLE_NOT_FOUND, ccMSG_INSERT1, lcAlias))
					llReturn = .F.
			endcase
		
		* Restore the TABLEVALIDATE setting and select the former database.
		
			if version(5) >= 800
				lcTableValidateCommand = 'set tablevalidate to lnValidate'
				&lcTableValidateCommand
			endif version(5) >= 800
			.SetDatabase(lcCurrDBC)
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE updateonetable		&& Updates a table structure to match the definition in the DBC and DBCX.
		*==============================================================================
		* Method:			UpdateOneTable
		* Status:			Protected
		* Purpose:			Update a single table to match its database definition
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2018 Stonefield Systems Group Inc.
		* Last Revision:	03/02/2018
		* Parameters:		tcAlias    - the alias of the table to update
		*					toProgress - an object reference to the progress form
		*					tlPack     - .T. to pack the table(s)
		* Returns:			.T. if the update was successful
		* Environment in:	This.lQuiet is .T. if progress shouldn't be displayed
		* Environment out:	if the table could be opened, its structure is updated
		*						and any defined indexes are recreated
		*==============================================================================
		
		lparameters tcAlias, ;
			toProgress, ;
			tlPack
		local llProgress, ;
			loProgress, ;
			lcDBC, ;
			lcAlias, ;
			lcFile, ;
			llFree, ;
			llEventsOn, ;
			lcDirectory, ;
			lcDescription, ;
			lnCodePage, ;
			lnBlockSize, ;
			lnBlockSet, ;
			lcTableType, ;
			lnTableType, ;
			llFoxPlus, ;
			llFox2X, ;
			lnCurrBlock, ;
			lnTableCP, ;
			lnTableBlock, ;
			llReindex, ;
			lnCurrSelect, ;
			llReturn, ;
			laTemp[1], ;
			laTable[1], ;
			lnFields, ;
			lnI, ;
			lnTemp, ;
			lnRename, ;
			lcTempDBC, ;
			laCreate[1], ;
			lcRename, ;
			lcTemp, ;
			lcFPT, ;
			lnHandle, ;
			laFieldList[1], ;
			llWasFox2X, ;
			lnSync, ;
			llHasMemo, ;
			lcToDo, ;
			lcToReplace, ;
			lcTask, ;
			lnPos1, ;
			lnPos2, ;
			lnPos3, ;
			lcField, ;
			lcNewTask, ;
			lcCurrTalk, ;
			lnPos, ;
			lcToDo1, ;
			lcToDo2, ;
			lnNextValue, ;
			lnRow, ;
			lnStep, ;
			lnStart, ;
			lcTempFile, ;
			lcTempAlias, ;
			lcLongFieldName, ;
			lnNext, ;
			lcCDX, ;
			lcTempCDX, ;
			lcTempFPT, ;
			llFixMemo, ;
			llQuiet
		
		* Define the progress window if we are displaying the update progress and it
		* hasn't already been defined.
		
		with This
			.cToDo = ''
			llProgress = vartype(toProgress) = 'O'
			do case
				case .lQuiet
				case llProgress
					loProgress = toProgress
					loProgress.SetCaptions(, '', '')
					loProgress.Clear()
				case '\' + justfname(.cProgressFormLibrary) $ upper(set('CLASSLIB'))
					loProgress = createobject(.cProgressFormClass)
					loProgress.Caption = strtran(ccMSG_UPDATING, ccMSG_INSERT1, ;
						ccTABLES)
				otherwise
					loProgress = newobject(.cProgressFormClass, .cProgressFormLibrary)
					loProgress.Caption = strtran(ccMSG_UPDATING, ccMSG_INSERT1, ;
						ccTABLES)
			endcase
		
		* Find the complete path to the table, the table's caption, and its codepage.
		* Set a flag that we don't need to reindex yet.
		
			lcDBC = .Parent.cCurrentDBC
			if '!' $ tcAlias
				lcDBC   = .Parent.GetDatabase(tcAlias)
				lcAlias = lower(.Parent.StripDatabase(tcAlias))
				do case
					case empty(lcDBC)
					case not dbused(lcDBC)
						.Warning(strtran(ccERR_DB_NOT_OPEN, ccMSG_INSERT1, lcDBC))
						return .F.
					case not upper(lcDBC) == set('DATABASE')
						.SetDatabase(lcDBC)
						lcDBC = dbc()
					otherwise
						lcDBC = dbc()
				endcase
			else
				lcAlias = tcAlias
			endif '!' $ tcAlias
			if empty(lcDBC)
				lcFile = lower(.GetFreeTablePath(tcAlias))
				if empty(lcFile)
					.Warning(strtran(ccERR_INVALID_OBJECT_NAME, ccMSG_INSERT1, ;
						tcAlias))
					.SetDatabase(lcDBC)
					return .F.
				endif empty(lcFile)
				llFree = .T.
			else
				llEventsOn = .EnableDBCEvents(.F.)
				lcFile = lower(fullpath(dbgetprop(lcAlias, 'Table', 'Path'), lcDBC))
				llFree = .F.
			endif empty(lcDBC)
			lcDirectory   = addbs(justpath(lcFile))
			lcDescription = .Parent.DBCXGetProp(tcAlias, 'Table', 'CBcCaption')
			lcDescription = iif(empty(lcDescription) or isnull(lcDescription), ;
				proper(tcAlias), lcDescription)
			lnCodePage    = CoreMeta.nCodePage
			lnBlockSize   = CoreMeta.nBlockSize
			lnBlockSet    = .GetBlockSize(lnBlockSize)
			lcTableType   = .Parent.DBCXGetProp('SDTTableType')
			lcTableType   = iif(isnull(lcTableType) or empty(lcTableType), ;
				ccVFP_TABLE_VFP, lcTableType)
			lnTableType   = iif(inlist(val(lcTableType), cnVFP_TABLE_VFP_8, ;
				cnVFP_TABLE_VFP_9), cnVFP_TABLE_VFP, val(lcTableType))
			llFoxPlus     = lnTableType = cnVFP_TABLE_FOXPLUS
			llFox2X       = lnTableType <> cnVFP_TABLE_VFP
			lnCurrBlock   = set('BLOCKSIZE')
			lnTableCP     = 0
			lnTableBlock  = 0
			llReindex     = .F.
			lnCurrSelect  = select()
			llReturn      = .T.
		
		* Reset any previous errors and then decide what to do.
		
			.Parent.ResetError()
			do case
		
		* The file exists, but it's built into the app, so ignore it.
		
				case file(lcFile) and adir(laTemp, lcFile) = 0
		
		* The table doesn't exist, so create it if we can. First, display the progress
		* window if necessary.
		
				case not file(lcFile)
					.cToDo = 'Create table ' + tcAlias
					if not .lQuiet
						loProgress.Show()
						loProgress.SetCaptions(strtran(ccMSG_CREATING, ccMSG_INSERT1, ;
							lcDescription))
						.FastDoEvents()
					endif not .lQuiet
		
		* Put the definition of all of the fields for the table into laTable. Then
		* remove any rules for the table (we don't need them and using them might
		* cause a problem with long field names, which we aren't using when creating
		* the table).
		
					if .DBCGetTableStructure(tcAlias, @laTable, .T.) > 0
						laTable[1, 10] = ''
						lnFields = alen(laTable, 1)
						for lnI = 1 to lnFields
							laTable[lnI, 7] = ''
						next lnI
						
		* Rename any fields that begin with an "_", since these can't be created using
		* CREATE TABLE .. FROM ARRAY. These names will be restored after the table is
		* created.
		
						lnTemp   = 1
						lnRename = 0
						for lnI = 1 to lnFields
							if left(laTable[lnI, 1], 1) = '_'
								do while ascan(laTable, 'TMPFLD' + ;
									padl(lnTemp, 4, '0')) <> 0
									lnTemp = lnTemp + 1
								enddo while ascan(laTable, ...
								lnRename = lnRename + 1
								dimension laTemp[lnRename, 2]
								laTemp[lnRename, 1] = laTable[lnI, 1]
								laTable[lnI, 1] = 'TMPFLD' + padl(lnTemp, 4, '0')
								laTemp[lnRename, 2] = laTable[lnI, 1]
							endif left(laTable[lnI, 1], 1) = '_'
						next lnI
		
		* Create a temporary database to create the table for (we can't create the
		* table for the selected database since it's already defined there). Create the
		* directory the table should be in if necessary. Set the block size as desired
		* for this table
		
						if llFree
							set database to
						else
							lcTempDBC = .CreateTempDBC(lcDBC)
						endif llFree
						if not empty(lcDirectory) and not directory(lcDirectory)
							md (lcDirectory)
						endif not empty(lcDirectory) ...
						set blocksize to lnBlockSet
		
		* Due to what looks like a bug in VFP in which auto-inc fields aren't created
		* properly if the structure array has more than 18 columns, create an array
		* with the proper number of columns. Then create the table and reset the block
		* size.
		
						.GetStructureArray(@laTable, @laCreate)
						create table (lcFile) from array laCreate
						set blocksize to lnCurrBlock
		
		* Now that the table is created, change any temporary field names back.
		
						if lnRename > 0
							lcRename = ''
							for lnI = 1 to lnRename
								lcRename = lcRename + ' rename column ' + ;
									laTemp[lnI, 2] + ' to ' + laTemp[lnI, 1]
							next lnI
							alter table (lcFile) &lcRename
						endif lnRename > 0
		
		* One complication here: if we're supposed to create a non-VFP table (eg.
		* Fox2x), we need to use COPY TO to put it into the desired format.
		
						if llFox2X
							lcTemp = lcDirectory + .TempFile('DBF')
							if llFoxPlus
								copy to (lcTemp) type foxplus
							else
								copy to (lcTemp) type fox2x
							endif llFoxPlus
							use
							erase (lcFile)
							rename (lcTemp) to (lcFile)
							lcFPT = .GetMemoFile(lcFile)
							if file(lcFPT)
								erase (lcFPT)
								rename (.GetMemoFile(lcTemp)) to (lcFPT)
							endif file(lcFPT)
						else
							use
						endif llFox2X
						if not llFree
							close database
						endif not llFree
						lnCodePage = .GetCodePage(lnCodePage)
						do case
							case .DidErrorOccur()
								llReturn = .F.
							case llFree
								if .lNeedPause
									.Pause()
								endif .lNeedPause
								.WriteCodePage(lnCodePage, , lcFile)
							otherwise
								erase (lcTempDBC + '.DBC')
								erase (lcTempDBC + '.DCX')
								erase (lcTempDBC + '.DCT')
		
		* Write the name of the database and the code page into the file header.
		
								if .lNeedPause
									.Pause()
								endif .lNeedPause
								lnHandle = .WriteBacklink(lcFile, ;
									sys(2014, lcDBC, lcFile), , .T.)
								.WriteCodePage(lnCodePage, lnHandle, lcFile)
						endcase
		
		* Reselect the database and set a flag that we need to index the table.
		
						.SetDatabase(lcDBC)
						llReindex = .T.
					else
						llReturn = .F.
					endif not .DBCGetTableStructure ...
		
		* Update the file's structure.
		
				otherwise
		
		* Display what we are doing in the progress window if necessary.
		
					if not .lQuiet
						loProgress.Show()
						loProgress.SetCaptions(strtran(ccMSG_UPDATING, ccMSG_INSERT1, ;
							lcDescription))
						.FastDoEvents()
					endif not .lQuiet
		
		* Close all open copies of the table and try to get the structure from the
		* table. Put the definition of all of the fields for the table into laTable.
		
					.CloseAllAliases(lcFile)
					lnTableType = 0
					if .GetDBFStructure(lcFile, @laFieldList, @lnTableCP, ;
						@lnTableType, @lnTableBlock) and ;
						.DBCGetTableStructure(tcAlias, @laTable) > 0
						llWasFox2X = lnTableType <> cnVFP_TABLE_VFP
		
		* Use the IsTableOutOfSync method to determine if the table is out of sync
		* with the DBC. Determine if the table has any Memo or General fields.
		
						lnSync    = .IsTableOutOfSync(@laFieldList, @laTable, ;
							lnTableCP, lnCodePage, lnTableBlock, lnBlockSize)
						llHasMemo = .TableHasMemo(@laTable)
		
		* If we just need to rename some fields, write a new header for the table and
		* flag that we need to reindex the table. First, if this is a formerly FoxPro
		* 2.x table but shouldn't be, we need to make it into a VFP table.
		
						do case
							case lnSync = 2
								.cToDo = 'Write new header for ' + tcAlias + ;
									' (fields renamed, codepage changed, or other ' + ;
									'header differences)'
								if not llFox2X and llWasFox2X
									llReturn = .ConvertFoxToVFP(lcFile)
								endif not llFox2X ...
								llReindex  = .T.
								lnCodePage = .GetCodePage(lnCodePage)
								.WriteDBFHeader(lcFile, lcDBC, @laTable, lnCodePage, ;
									, llFree, lcTableType)
		
		* If the file isn't in sync with the data dictionary, use the HowToSyncTable
		* method to determine how to synchronize them. First, remove any rules for the
		* table (we don't need them and using them might cause a problem with long
		* field names, which we aren't using when creating the table).
		
							case lnSync = 1
								laTable[1, 10] = ''
								for lnI = 1 to alen(laTable, 1)
									laTable[lnI, 7] = ''
								next lnI
								lcToDo = .HowToSyncTable(@laFieldList, @laTable, ;
									llFree)
								.cToDo = lcToDo
		
		* If this is a Fox2x table, open it. If not, use WriteBackLink() to clear the
		* backlink in the DBF header. Then call ClearCDX() to clear the CDX bit.
		* Return .F. if something went wrong.
		
								if .lNeedPause
									.Pause()
								endif .lNeedPause
								if llWasFox2X
									lnHandle = fopen(lcFile, 2)
								else
									lnHandle = .WriteBacklink(lcFile, '',, .T.)
								endif llWasFox2X
								if lnHandle >= 0
									.ClearCDX(lnHandle)
									fclose(lnHandle)
								else
									select (lnCurrSelect)
									return .F.
								endif lnHandle >= 0
		
		* If this is a formerly FoxPro 2.x table but shouldn't be, we need to make it
		* into a VFP table.
		
								if not llFox2X and llWasFox2X
									llReturn = .ConvertFoxToVFP(lcFile)
								endif not llFox2X ...
		
		* If we're going to alter the table structure using ALTER TABLE, create a
		* temporary database and add the table to it; we can't alter the table in the
		* selected database since its definition has already been changed there, but we
		* need a database of some kind because ALTER TABLE might have some clauses not
		* supported in free tables. Open the table, and alter its structure as
		* necessary.
		
								if not empty(lcToDo)
									if llFree
										set database to
									else
										lcTempDBC = .CreateTempDBC(lcDBC)
										add table (lcFile)
									endif llFree
		
		* If we're adding any fields with a DEFAULT clause, we need to create a REPLACE
		* statement to execute later and strip the DEFAULT clause from lcToDo. The
		* reason for this is that the DEFAULT expression may reference a long field
		* name, but we don't have any long field names in the temporary DBC. The
		* REPLACE statement will need to include the long field name, so we'll have to
		* find that, given the real field name, in SDTMETA.
		
									lcToReplace = ''
									if ' default ' $ lcToDo
										for lnI = 1 to alen(.aHowToSync)
											lcTask = .aHowToSync[lnI]
											if lcTask = 'add column' and ;
												' default ' $ lcTask and ;
												not ' autoinc ' $ lcTask
												lnPos1  = at(' default ', lcTask)
												lnPos2  = at(' ', lcTask, 2)
												lnPos3  = at(' ', lcTask, 3)
												lcField = substr(lcTask, ;
													lnPos2 + 1, ;
													lnPos3 - lnPos2 - 1)
												select (.cDBCXAlias)
												locate for DBCNAME = lower(juststem(lcDBC)) and ;
													RECTYPE = 'F' and ;
													OBJECTNAME = lcAlias and ;
													REALNAME == padr(lcField, ;
													len(REALNAME))
												lcField = trim(substr(OBJECTNAME, ;
													at('.', OBJECTNAME) + 1))
												lcToReplace = lcToReplace + ;
													iif(empty(lcToReplace), '', ;
													', ') + lcField + ' with ' + ;
													substr(lcTask, lnPos1 + 9)
												lcNewTask = strtran(lcTask, ;
													substr(lcTask, lnPos1))
												lcToDo    = strtran(lcToDo, ;
													lcTask, lcNewTask)
											endif lcTask = 'add column' ...
										next lnI
									endif ' default ' $ lcToDo
							        if .lNeedPause
							        	.Pause()
							        endif .lNeedPause
									lcAlias = strtran(lcAlias, ' ', '_')
									select 0
									use (lcFile) alias (lcAlias) exclusive
									if not .lQuiet
										lcCurrTalk = set('TALK', 1)
										if .lTalk
											set talk window (loProgress.Name)
											set talk on
										endif .lTalk
										loProgress.Clear()
										loProgress.SetCaptions(, , ;
											strtran(ccMSG_RECORDS_TOTAL, ;
											ccMSG_INSERT1, str(reccount(), 9)))
									endif not .lQuiet
		
		* If this is a free table, remove any AUTOINC setting because we'll handle it
		* later.
		
									if llFree
										lcToDo = strtran(lcToDo, ' autoinc ', ' ')
									endif llFree
		
		* Perform the update. we need to drop columns first in case we are at or near
		* the 254 field limit.
		
									if 'drop column ' $ lcToDo
										lnPos   = at('drop column ', lcToDo)
										lcToDo1 = substr(lcToDo, lnPos)
										lcToDo2 = left(lcToDo, lnPos - 1)
										alter table (lcAlias) &lcToDo1 novalidate
										alter table (lcAlias) &lcToDo2 novalidate
									else
										alter table (lcAlias) &lcToDo novalidate
									endif 'drop column ' $ lcToDo
		
		* If we added an auto-incrementing field to a free table, it isn't auto-inc
		* yet since we have to assign values to the field.
		
									if llFree
										for lnI = 1 to alen(.aHowToSync)
											lcTask = .aHowToSync[lnI]
											if 'add column ' $ lcTask and ;
												' autoinc ' $ lcTask
												lnPos1  = at(' column ', lcTask)
												lnPos2  = at(' ', lcTask, 2)
												lnPos3  = at(' ', lcTask, 3)
												lcField = substr(lcTask, ;
													lnPos2 + 1, ;
													lnPos3 - lnPos2 - 1)
												lnRow   = This.ArrayScan(@laTable, ;
													lcField, 1)
												lnStep  = laTable[lnRow, 18]
												lnStart = laTable[lnRow, 17]
												replace all &lcField with ;
													(recno() - 1) * lnStep + lnStart
											endif 'add column ' $ lcTask ...
										next lnI
									endif llFree
		
		* Reset talk.
			
									if not .lQuiet
										set talk off
										set talk &lcCurrTalk
										.FastDoEvents()
									endif not .lQuiet
		
		* If an existing field was converted to an auto-inc field, or we just added an
		* auto-inc field to a free table, assign the NEXTVALUE property.
		
									if ' nextvalue -909090' $ lcToDo or llFree
										for lnI = 1 to alen(.aHowToSync)
											lcTask = .aHowToSync[lnI]
											if ' nextvalue -909090' $ lcTask or ;
												(llFree and ' autoinc ' $ lcTask)
												lnPos1  = at(' column ', lcTask)
												lnPos2  = at(' ', lcTask, 2)
												lnPos3  = at(' ', lcTask, 3)
												lcField = substr(lcTask, ;
													lnPos2 + 1, ;
													lnPos3 - lnPos2 - 1)
												lnRow   = This.ArrayScan(@laTable, ;
													lcField, 1)
												lnStep  = laTable[lnRow, 18]
												calculate max(&lcField) to lnNextValue
												if llFree
													lcTask = lcTask + ' nextvalue ' + ;
														transform(lnNextValue + lnStep) + ;
														' step ' + transform(lnStep)
												endif llFree
												lcTask = strtran(strtran(lcTask, ;
													'add column ', 'alter column '), ;
													'-909090', transform(lnNextValue + lnStep))
												alter table (lcAlias) &lcTask novalidate
											endif ' nextvalue -909090' $ lcTask ...
										next lnI
									endif ' nextvalue -909090' $ lcToDo ...
									use
		
		* Now update the laFieldList array with the new structure and see if there
		* are more changes to make yet (changes we couldn't do with ALTER TABLE, such
		* as rearranging fields or adding fields in the middle of the structure).
		
									if .DidErrorOccur()
										llReturn = .F.
									else
										.GetDBFStructure(lcFile, @laFieldList, ;
											@lnTableCP, @lnTableType, @lnTableBlock)
										if inlist(val(lcTableType), cnVFP_TABLE_VFP, ;
											cnVFP_TABLE_VFP_8, cnVFP_TABLE_VFP_9)
											lnSync = .IsTableOutOfSync(@laFieldList, ;
												@laTable, lnTableCP, lnCodePage)
										else
											lnSync = .IsTableOutOfSync(@laFieldList, ;
												@laTable)
										endif inlist(val(lcTableType) ...
									endif .DidErrorOccur()
								endif not empty(lcToDo)
		
		* If there's more to do, use the "create and append" method. Start by creating
		* a temporary database to create a temporary file with the new structure if it
		* hasn't already been created; we can't create the table for the selected
		* database since it's already defined there).
		
								if not .DidErrorOccur() and lnSync > 0
									do case
										case llFree
											set database to
										case empty(lcTempDBC)
											lcTempDBC = .CreateTempDBC(lcDBC)
									endcase
		
		* Now create a copy of the table with the new structure, ensuring that the
		* block size is set as appropriate for the table. First, we need to change the
		* structure of the array so it's in the format VFP expects. Then we need to
		* read the next value for any auto-inc fields from the DBF header so we can use
		* it later. Then zero the step value for all auto-inc fields so they're not
		* auto-inc in the copy, otherwise the APPEND FROM can't import values for them.
		* Finally, create the table and reset the blocksize.
		
									lcTempFile = addbs(justpath(lcFile)) + ;
										.TempFile('DBF')
									set blocksize to lnBlockSet
									.GetStructureArray(@laTable, @laCreate)
									if version(5) >= 800
										.ReadNextValue(lcFile, @laTable)
										for lnI = 1 to alen(laCreate, 1)
											laCreate[lnI, 18] = 0
										next lnI
									endif version(5) >= 800
									.cToDo = .cToDo + iif(empty(.cToDo), '', ccCRLF) + ;
										'Creating new table for ' + tcAlias + ;
										' and appending from former table (fields ' + ;
										'rearranged or fields added in the middle ' + ;
										'of the structure)'
									create table (lcTempFile) from array laCreate
									set blocksize to lnCurrBlock
									lcTempAlias = alias()
		
		* Append into the new table from the current one.
		
									if not .lQuiet
										lcCurrTalk = set('TALK', 1)
										if .lTalk
											set talk window (loProgress.Name)
											set talk on
										endif .lTalk
										loProgress.Clear()
									endif not .lQuiet
									append from (lcFile)
									if not .lQuiet
										set talk off
										set talk &lcCurrTalk
										.FastDoEvents()
									endif not .lQuiet
		
		* Now make any auto-inc fields auto-inc again. Assign values for any fields we
		* added.
		
									if version(5) >= 800
										for lnI = 1 to alen(laTable, 1)
											lnStep = laTable[lnI, 18]
											if lnStep <> 0
												lcField = laTable[lnI, 1]
												lnNext  = laTable[lnI, 17]
												go bottom
												if evaluate(lcField) = 0
													lcLongFieldName = laTable[lnI, 20]
													lnNext = .Parent.DBCXGetProp(lcDBC + ;
														'!' + lcLongFieldName, ;
														'Field', 'NextValue')
													replace all &lcField with ;
														(recno() - 1) * lnStep + lnNext
													lnNext = reccount() * lnStep + ;
														lnNext
												endif evaluate(lcField) = 0
												alter table (lcTempFile) ;
													alter column &lcField I autoinc ;
													nextvalue lnNext step lnStep ;
													novalidate
											endif laTable[lnI, 18] <> 0
										next lnI
										erase (forceext(lcTempFile, 'BAK'))
										erase (forceext(lcTempFile, 'TBK'))
									endif version(5) >= 800
		
		* One complication here: if we're supposed to create a non-VFP table (eg.
		* Fox2x), we need to use COPY TO to put it into the desired format.
		
									if llFox2X
										lcTemp = lcDirectory + .TempFile('DBF')
										if llFoxPlus
											copy to (lcTemp) type foxplus
										else
											copy to (lcTemp) type fox2x
										endif llFoxPlus
										use
										erase (lcTempFile)
										erase (.GetMemoFile(lcTempFile))
										lcTempFile = lcTemp
									else
										use
									endif llFox2X
		
		* If everything went OK, delete the original file and rename the new file to
		* it.
		
									if .DidErrorOccur()
										llReturn = .F.
									else
										erase (lcFile)
										lcFPT     = .GetMemoFile(lcFile)
										lcCDX     = forceext(lcFile, 'CDX')
										lcTempCDX = forceext(lcTempFile, ;
											'CDX')
										lcTempFPT = .GetMemoFile(lcTempFile)
										erase (lcFPT)
										erase (lcCDX)
										rename (lcTempFile) to (lcFile)
										if file(lcTempCDX)
											rename (lcTempCDX) to (lcCDX)
										endif file(lcTempCDX)
										if file(lcTempFPT)
											rename (lcTempFPT) to (lcFPT)
										endif file(lcTempFPT)
									endif .DidErrorOccur()
								endif not .DidErrorOccur() ...
		
		* Nuke the temporary database.
		
								if not empty(lcTempDBC)
									close database
									erase (lcTempDBC + '.DBC')
									erase (lcTempDBC + '.DCX')
									erase (lcTempDBC + '.DCT')
								endif not empty(lcTempDBC)
		
		* Write the name of the database and the code page into the file header.
		* Reselect the database and flag that we need to reindex the table.
		
								lnCodePage = .GetCodePage(lnCodePage)
								if .lNeedPause
									.Pause()
								endif .lNeedPause
								if llFree
									.WriteCodePage(lnCodePage, , lcFile)
								else
									lnHandle = .WriteBacklink(lcFile, ;
										sys(2014, lcDBC, lcFile), , .T.)
									.WriteCodePage(lnCodePage, lnHandle, lcFile)
									.SetDatabase(lcDBC)
								endif llFree
								llReindex = llReturn
								llFixMemo = llReturn and llHasMemo
		
		* If there are no structural changes but this is a formerly FoxPro 2.x table,
		* we need to make it into a VFP table.
		
							case not llFox2X and llWasFox2X
								llReturn = .ConvertFoxToVFP(lcFile)
								if llReturn
									.cToDo = 'Converting ' + tcAlias + ' from 2.x ' + ;
										'to VFP'
									.WriteBacklink(lcFile, iif(empty(lcDBC), '', ;
										sys(2014, lcDBC, lcFile)))
									llReindex = .T.
									llFixMemo = llHasMemo
								endif llReturn
		
		* If the table hasn't changed but it doesn't have the correct backlink (for
		* example, it's supposed to belong to a database but has no backlink or it's
		* supposed to be free but has a backlink), we'll write the correct backlink.
		* Then, see if the indexes are in sync.
		
							case not llFox2X and not lcDBC == .ReadBackLink(lcFile)
								.cToDo = 'Fixing backlink for ' + tcAlias
								if .lNeedPause
									.Pause()
								endif .lNeedPause
								.WriteBacklink(lcFile, iif(empty(lcDBC), '', ;
									sys(2014, lcDBC, lcFile)))
								llQuiet   = .lQuiet
								.lQuiet   = .T.
								llReindex = .NeedReindex(tcAlias) and ;
									not .DidErrorOccur()
								.lQuiet   = llQuiet
		
		* The table appears to be in sync with the database, so see if the indexes are
		* too.
		
							otherwise
								llQuiet   = .lQuiet
								.lQuiet   = .T.
								llReindex = .NeedReindex(tcAlias) and ;
									not .DidErrorOccur()
								.lQuiet   = llQuiet
						endcase
					else
						llReturn = .F.
					endif .GetDBFStructure(lcFile, ...
			endcase
			select (lnCurrSelect)
		
		* Fix the memo file for the table if necessary.
		
			if llFixMemo
				llReturn = .FixFPTFileSize(lcFile, lnBlockSize)
			endif llFixMemo
		
		* If everything went OK and we have to insert a value into new fields, do so.
		* First, remove all indexes in the DBC for the table if necessary or else we'll
		* get an error when we try to open it.
		
			if llReturn and not empty(lcToReplace)
				if not llFree
					lcDBCAlias = .DBCOpen(dbc())
					liParent   = .DBCGetField(tcAlias, 'Table', 'ObjectID')
					.DBCDeleteProp(cnVF_TABLE_PRIMARYTAG)
					delete from (lcDBCAlias) where PARENTID = liParent and ;
						OBJECTTYPE = ccVF_OBJ_INDEX
					use
				endif not llFree
				.ClearCDX(lcFile)
				select 0
				use (lcFile) alias (lcAlias) exclusive
				if not .lQuiet
					lcCurrTalk = set('TALK', 1)
					if .lTalk
						set talk window (loProgress.Name)
						set talk on
					endif .lTalk
					loProgress.Clear()
				endif not .lQuiet
				replace all &lcToReplace
				if not .lQuiet
					set talk off
					set talk &lcCurrTalk
					.FastDoEvents()
				endif not .lQuiet
				use
			endif llReturn ...
		
		* Reindex the file if necessary.
		
			if (llReindex or tlPack) and llReturn
				.cToDo = .cToDo + iif(empty(.cToDo), '', ccCRLF) + ;
					'Recreating indexes for ' + tcAlias
				llReturn = .ReindexOneTable(tcAlias, tlPack, loProgress)
			endif (llReindex ...
		
		* If everything went OK, delete any BAK and TBK files.
		
			if llReturn
				erase (forceext(lcFile, 'BAK'))
				erase (forceext(lcFile, 'TBK'))
			endif llReturn
		
		* Re-enable DBC events if necessary.
		
			if not llFree
				.EnableDBCEvents(llEventsOn)
			endif not llFree
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE validatefield
		*==============================================================================
		* Method:			ValidateField
		* Status:			Protected
		* Purpose:			Validates the specified field
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcParent - the name of the table or view
		*					tcAlias  - the alias the table is open with
		*					tcField  - the name of the field
		*					tlFree   - .T. if the table is free
		* Returns:			.T.
		* Environment in:	the table is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the table
		* Environment out:	the table's record is populated with appropriate
		*						information for the table
		*==============================================================================
		
		lparameters tcParent, ;
			tcAlias, ;
			tcField, ;
			tlFree
		local laFields[1], ;
			lnField, ;
			llReturn, ;
			lcField, ;
			lcDBF, ;
			laRealFields[1], ;
			llOK, ;
			llError, ;
			llFilter
		with This
		
		* Get an array of fields for the table and find the specified field in it.
		
			afields(laFields, tcAlias)
			lnField  = .ArrayScan(@laFields, tcField)
			llReturn = lnField > 0
			if llReturn
		
		* Get the "real" fieldname if this is a table.
		
				if cursorgetprop('SourceType', tcAlias) = 3
					lcField = upper(left(tcField, 10))
					lcDBF   = dbf(tcAlias)
					use in (tcAlias)
					llOK    = .GetDBFStructure(lcDBF, @laRealFields)
					llError = .SetSuppressErrors(.T.)
					use (lcDBF) again alias (tcAlias) shared in 0
					.SetSuppressErrors(llError)
					if llOK
						lcField = laRealFields[lnField, 1]
					endif llOK
					replace RealName with lcField in (.cDBCXAlias)
				endif cursorgetprop('SourceType', tcAlias) = 3
		
		* Update the Filter property based on the current setting, the field type, and
		* whether the SFQuery "no filter" comment is used, and the Updated property.
		
				lcField  = tcParent + '.' + tcField
				llFilter = evaluate(This.cDBCXAlias + '.FILTER')
				if not tlFree
					llFilter = llFilter and ;
						not ccDIRECTIVE_NOFILTER $ upper(dbgetprop(lcField, 'Field', ;
						'Comment'))
				endif not tlFree
				replace Filter with iif(laFields[lnField, 2] = 'G', .F., llFilter), ;
					Updated with datetime() ;
					in (This.cDBCXAlias)
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE validatetable
		*==============================================================================
		* Method:			ValidateTable
		* Status:			Protected
		* Purpose:			Validates the specified table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName - the name of the table
		*					tcAlias      - the alias the table is open with
		*					tlFree       - .T. if the table is free
		* Returns:			.T.
		* Environment in:	the table is open using the alias specified in tcAlias
		*					the manager's meta data table is positioned to the record
		*						for the table
		* Environment out:	the table's record is populated with appropriate
		*						information for the table
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcAlias, ;
			tlFree
		local llFilter
		llFilter = evaluate(This.cDBCXAlias + '.FILTER')
		if not tlFree
			llFilter = llFilter and ;
				not ccDIRECTIVE_NOFILTER $ upper(dbgetprop(tcObjectName, 'Table', ;
				'Comment'))
		endif not tlFree
		replace TableType with sys(2029, tcAlias), ;
			Filter with llFilter, ;
			Updated with datetime() ;
			in (This.cDBCXAlias)
		return .T.
		
	ENDPROC

	PROCEDURE validateview
		*==============================================================================
		* Method:			ValidateView
		* Status:			Protected
		* Purpose:			Validates the specified table
		* Author:			Doug Hennig, Stonefield Systems Group Inc.
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcObjectName - the name of the table
		*					tcAlias      - the alias the table is open with
		* Returns:			.T.
		* Environment in:	the manager's meta data table is positioned to the record
		*						for the view
		* Environment out:	the view's record is populated with appropriate
		*						information for the view
		*==============================================================================
		
		lparameters tcObjectName, ;
			tcAlias
		local llFilter
		llFilter = evaluate(This.cDBCXAlias + '.FILTER') and ;
			not ccDIRECTIVE_NOFILTER $ upper(dbgetprop(tcObjectName, 'View', ;
			'Comment'))
		replace Filter with llFilter, ;
			Updated with datetime() ;
			in (This.cDBCXAlias)
		return .T.
		
	ENDPROC

	PROCEDURE writebacklink		&& Writes the name and path of a DBC in the backlink area in a DBF header.
		*==============================================================================
		* Method:			WriteBackLink
		* Status:			Public
		* Purpose:			Write out the database backlink into a DBF header
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2000
		* Parameters:		tcFile     - the full pathname of the file (optional:
		*						if tnHandle is passed, this parameter is ignored)
		*					tcDBC      - the full pathname of the DBC
		*					tnHandle   - a handle to the table (optional: only
		*						passed if the table is already open using LLFF)
		*					tlKeepOpen - .T. if the table should be left open as a
		*						LLFF file upon exit
		* Returns:			the handle used to open the file, or -1 if it couldn't
		*						be opened
		* Environment in:	none
		* Environment out:	if the file couldn't be found or opened exclusively, an 
		*						error is displayed
		*					if tnHandle wasn't passed and tlKeepOpen is .T., the file
		*						is still open exclusively using the handle returned to
		*						the calling routine
		*					the backlink has been written to the specified DBF
		*==============================================================================
		
		lparameters tcFile, ;
			tcDBC, ;
			tnHandle, ;
			tlKeepOpen
		local lnHandle, ;
			lnHeader
		
		* If a valid handle was passed, use it. If not and the file can be found,
		* open it. Otherwise, flag an error.
		
		with This
			do case
				case vartype(tnHandle) = 'N' and tnHandle >= 0
					lnHandle = tnHandle
				case file(tcFile)
					lnHandle = fopen(tcFile, F_READWRITE)
					if lnHandle < 0
						.DisplayLLFFError(tcFile)
					endif lnHandle < 0
				otherwise
					.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, tcFile))
					lnHandle = -1
			endcase
		
		* If the file is open, write the backlink to the header.
		
			if lnHandle >= 0
				fseek(lnHandle, cnDBF_HEADER_LENGTH)
				lnHeader = .Hex2Decimal(fread(lnHandle, 2))
				fseek(lnHandle, lnHeader - cnVF_BACKLINK_LENGTH)
				fwrite(lnHandle, tcDBC)
				if len(tcDBC) < cnVF_BACKLINK_LENGTH
					fwrite(lnHandle, replicate(ccNULL, cnVF_BACKLINK_LENGTH - ;
						len(tcDBC)))
				endif len(tcDBC) < cnVF_BACKLINK_LENGTH
		
		* Pause to ensure buffers are flushed and close the file if we're not supposed
		* to leave it open.
		
				if not tlKeepOpen
					if .lNeedPause
						fflush(lnHandle)
						.Pause()
					endif .lNeedPause
					fclose(lnHandle)
				endif not tlKeepOpen
			endif lnHandle >= 0
		endwith
		return lnHandle
		
	ENDPROC

	PROCEDURE writecodepage		&& Writes a code page to the appropriate area in a DBF header.
		*==============================================================================
		* Method:			WriteCodePage
		* Status:			Public
		* Purpose:			Write out the code page into a DBF header
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tnCodePage - the code page value to write to the file (not
		*						the same as the code page number; see GetCodePage())
		*					tnHandle   - a handle to the table (optional: only passed
		*						if the table is already open using LLFF)
		*					tcFile     - the full pathname of the file (optional: if
		*						tnHandle is passed, this parameter is ignored)
		*					tlKeepOpen - .T. if the table should be left open as a LLFF
		*						file upon exit
		* Returns:			the handle used to open the file, or -1 if it couldn't be
		*						opened
		* Environment in:	none
		* Environment out:	if the file couldn't be found or opened exclusively, an
		*						error is displayed
		*					if tnHandle wasn't passed and tlKeepOpen is .T., the file
		*						is still open exclusively using the handle returned to
		*						the calling routine
		*					the code page # has been written to the specified DBF
		*==============================================================================
		
		lparameters tnCodePage, ;
			tnHandle, ;
			tcFile, ;
			tlKeepOpen
		local lnHandle
		
		* If a valid handle was passed, use it. If not and the file can be found,
		* open it. Otherwise, flag an error.
		
		do case
			case vartype(tnHandle) = 'N' and tnHandle >= 0
				lnHandle = tnHandle
			case file(tcFile)
				lnHandle = fopen(tcFile, F_READWRITE)
				if lnHandle < 0
					This.DisplayLLFFError(tcFile)
				endif lnHandle < 0
			otherwise
				This.Warning(strtran(ccERR_FILE_NOT_EXIST, ccMSG_INSERT1, tcFile))
				lnHandle = -1
		endcase
		
		* If the file is open, write the code page to the header.
		
		if lnHandle >= 0
			fseek(lnHandle, cnDBF_CODE_PAGE)
			fwrite(lnHandle, chr(tnCodePage)) 
		
		* Close the file if we're not supposed to leave it open.
		
			if not tlKeepOpen
				fclose(lnHandle)
			endif not tlKeepOpen
		endif lnHandle >= 0
		return lnHandle
		
	ENDPROC

	PROTECTED PROCEDURE writedbfheader		&& Writes a complete header for a DBF.
		*==============================================================================
		* Method:			WriteDBFHeader
		* Status:			Protected
		* Purpose:			Write out the fields portion of a file header
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last Revision:	05/27/2005
		* Parameters:		tcFile       - the file to update
		*					tcDBC        - the database the table belongs to
		*					taFields     - an array containing the table structure
		*					tnCodePage   - the code page value to write to the file
		*						(not the same as the code page number; see
		*						GetCodePage())
		*					tnHandle     - the handle of the file if it's already open
		*						using LLFF (optional: if it isn't passed, the table
		*						will be opened)
		*					tlFree       - .T. if this is a free table
		*					tcTableType  - the table type (value returned by SYS(2029))
		*					tlAdjustSize - .T. to adjust the file size if necessary
		* Returns:			.T. if everything went OK
		* Environment in:	none
		* Environment out:	if the file couldn't be opened exclusively, an error is
		*						displayed
		*					a new header was written to it
		*					the table is closed upon exit
		*==============================================================================
		
		lparameters tcFile, ;
			tcDBC, ;
			taFields, ;
			tnCodePage, ;
			tnHandle, ;
			tlFree, ;
			tcTableType, ;
			tlAdjustSize
		external array taFields
		local lnHandle, ;
			lnNumFields, ;
			lnRecordSize, ;
			lnNullFields, ;
			llHasMemo, ;
			lnI, ;
			llNullFields, ;
			lnNullSize, ;
			lnHeaderSize, ;
			lnFileSize, ;
			lnNumRecords, ;
			lnCDXFlag, ;
			lnDisplace, ;
			lnFieldFlag, ;
			lnCalcSize
		with This
		
		* Try to open the file exclusively if necessary. Give an error and exit if we
		* can't.
		
			if vartype(tnHandle) = 'N' and tnHandle >= 0
				lnHandle = tnHandle
			else
				lnHandle = fopen(tcFile, F_READWRITE)
				if lnHandle < 0
					.DisplayLLFFError(tcFile)
					return .F.
				endif lnHandle < 0
			endif vartype(tnHandle) = 'N' ...
		
		* Calculate the number of fields, record size (total size of each field + 1
		* byte for the deleted flag + a variable number of bytes for the null flag),
		* number of fields supporting nulls and/or Varchar/Varbinary, header size,
		* file size, and number of records. Also, set a flag if this table has any
		* memo or general fields.
		
			lnNumFields  = alen(taFields, 1)
			lnRecordSize = 1	&& to account for the DELETED flag
			lnNullFields = 0
			llHasMemo    = .F.
			for lnI = 1 to lnNumFields
				lnRecordSize = lnRecordSize + taFields[lnI, 3]
				lnNullFields = lnNullFields + iif(taFields[lnI, 5], 1, 0) + ;
					iif(taFields[lnI, 2] $ 'VQ', 1, 0)
				llHasMemo    = taFields[lnI, 2] $ 'MGW' or llHasMemo
			next lnI
			llNullFields = lnNullFields > 0
			lnNullSize   = iif(llNullFields, int((lnNullFields - 1)/8) + 1, 0)
			lnRecordSize = lnRecordSize + lnNullSize
			lnHeaderSize = iif(inlist(val(tcTableType), cnVFP_TABLE_VFP, ;
				cnVFP_TABLE_VFP_8, cnVFP_TABLE_VFP_9), cnVF_BACKLINK_LENGTH, 0) + ;
				cnDBF_FIRST_FIELD + cnDBF_FIELD_DEFN_SIZE * (lnNumFields + ;
				iif(llNullFields, 1, 0)) + 1
			lnFileSize   = fseek(lnHandle, 0, 2)
			lnNumRecords = (lnFileSize - lnHeaderSize)/lnRecordSize
		
		* Output the VFP signature byte, today's date, the number of records, the
		* position of the first record, and the record size.
		
			fseek(lnHandle, 0)
			fwrite(lnHandle, chr(val(tcTableType)) + ;
				chr(val(right(str(year(date()), 4), 2))) + chr(month(date())) + ;
				chr(day(date())) + .Decimal2Hex(lnNumRecords, 4) + ;
				.Decimal2Hex(lnHeaderSize, 2) + ;
				.Decimal2Hex(lnRecordSize, 2))
		
		* Output some reserved bytes, the CDX/FPT flag, the code page, and more
		* reserved bytes.
		
			lnCDXFlag = iif(llHasMemo and inlist(val(tcTableType), cnVFP_TABLE_VFP, ;
				cnVFP_TABLE_VFP_8, cnVFP_TABLE_VFP_9), ;
				cnDBF_HAS_MEMO, 0)
			fwrite(lnHandle, replicate(ccNULL, cnDBF_RESERVED_BYTES1) + ;
				chr(lnCDXFlag) + chr(tnCodePage) + ;
				replicate(ccNULL, cnDBF_RESERVED_BYTES2))
		
		* Output a record for each field.
		
			lnDisplace = 1
			for lnI = 1 to lnNumFields
				lnFieldFlag = iif(taFields[lnI, 5], cnDBF_FIELDFLAG_NULL, 0) + ;
					iif((taFields[lnI, 6] or taFields[lnI, 2] $ ccDBF_NEW_TYPES) and ;
					taFields[lnI, 18] = 0, cnDBF_FIELDFLAG_BINARY, 0) + ;
					iif(taFields[lnI, 18] <> 0, cnDBF_FIELDFLAG_AUTOINC, 0)
				fwrite(lnHandle, padr(taFields[lnI, 1], ;
					cnDBF_FIELD_NAME_SIZE, ccNULL) + ccNULL + taFields[lnI, 2] + ;
					.Decimal2Hex(lnDisplace, 4) + chr(taFields[lnI, 3]) + ;
					chr(taFields[lnI, 4]) + chr(lnFieldFlag) + ;
					.Decimal2Hex(taFields[lnI, 17], 4) + chr(taFields[lnI, 18]) + ;
					replicate(ccNULL, cnDBF_RESERVED_BYTES3))
				lnDisplace = lnDisplace + taFields[lnI, 3]
			next lnI
		
		* If there are any fields that support null values, output a _NullFlags field.
		
			if llNullFields
				fwrite(lnHandle, padr(ccDBF_NULL_FLAGS, ;
					cnDBF_FIELD_NAME_SIZE, ccNULL) + ccNULL + ccDBF_NULL_FLAGS_TYPE + ;
					.Decimal2Hex(lnDisplace, 4) + chr(lnNullSize) + ccNULL + ;
					chr(cnDBF_FIELDFLAG_SYSTEM + cnDBF_FIELDFLAG_BINARY) + ;
					replicate(ccNULL, cnDBF_RESERVED_BYTES3))
			endif llNullFields
		
		* Output a CR.
		
			fwrite(lnHandle, ccCR)
		
		* Adjust the file size if necessary.
		
			if tlAdjustSize
				lnCalcSize = int(lnNumRecords) * lnRecordSize + lnHeaderSize
				if lnFileSize <> lnCalcSize
					fchsize(lnHandle, lnCalcSize)
				endif lnActualSize = lnCalcSize
			endif tlAdjustSize
		
		* use WriteBackLink to write the backlink to the DBC (if it isn't a free
		* table) and close the file.
		
			if tlFree
				fclose(lnHandle)
			else
				.WriteBackLink(, sys(2014, tcDBC, tcFile), lnHandle)
			endif tlFree
		endwith
		return .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtpassparameters AS custom 		&& A class used so multiple values can be returned from a called object.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*a: aarray[1,0]		&& An array that can be passed to and from the called object.
		*a: aparameters[1,0]		&& An array of individual values that can be passed to and from the called object.
	*</DefinedPropArrayMethod>

	Name = "passparameters"
	Width = 17

ENDDEFINE

DEFINE CLASS sdtprocessform AS form 		&& A form used to display which tables the user can reindex or repair.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="chkAllTables" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkOther" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTables" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTables.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTables.Column1.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTables.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTables.Column2.Text1" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*p: oprocess		&& A copy of a reference to the PassParameters object passed to this form.
	*</DefinedPropArrayMethod>

	BorderStyle = 2
	Caption = "Process"
	DataSession = 2
	Desktop = .T.
	DoCreate = .T.
	Height = 237
	Left = 0
	MaxButton = .F.
	MinButton = .F.
	Name = "sdtprocessform"
	oprocess = .NULL.		&& A copy of a reference to the PassParameters object passed to this form.
	ShowWindow = 1
	Top = 0
	Width = 613
	WindowType = 1

	ADD OBJECT 'chkAllTables' AS checkbox WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "All Tables", ;
		Left = 510, ;
		Name = "chkAllTables", ;
		TabIndex = 2, ;
		Top = 30, ;
		Value = .F., ;
		Width = 72
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkOther' AS checkbox WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Other", ;
		Height = 17, ;
		Left = 510, ;
		Name = "chkOther", ;
		TabIndex = 3, ;
		Top = 60, ;
		Value = .F., ;
		Width = 48
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Height = 29, ;
		Left = 500, ;
		Name = "cmdCancel", ;
		TabIndex = 5, ;
		Top = 160, ;
		Width = 94
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdProcess' AS commandbutton WITH ;
		Caption = "Process", ;
		Height = 29, ;
		Left = 500, ;
		Name = "cmdProcess", ;
		TabIndex = 4, ;
		Top = 120, ;
		Width = 94
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'grdTables' AS grid WITH ;
		AllowHeaderSizing = .F., ;
		AllowRowSizing = .F., ;
		ColumnCount = 2, ;
		DeleteMark = .F., ;
		GridLines = 0, ;
		HeaderHeight = 0, ;
		Height = 217, ;
		Highlight = .F., ;
		HighlightRow = .F., ;
		HighlightRowLineWidth = 0, ;
		Left = 10, ;
		Name = "grdTables", ;
		Panel = 1, ;
		RecordMark = .F., ;
		RecordSource = "tables", ;
		ScrollBars = 2, ;
		SplitBar = .F., ;
		Top = 10, ;
		Width = 460, ;
		Column1.ControlSource = "tables.selected", ;
		Column1.Name = "Column1", ;
		Column1.Sparse = .F., ;
		Column1.Width = 15, ;
		Column2.ControlSource = "tables.caption", ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 408
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'grdTables.Column1.Check1' AS checkbox WITH ;
		Caption = "", ;
		Height = 17, ;
		Left = 19, ;
		Name = "Check1", ;
		Top = 29, ;
		Width = 60
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'grdTables.Column1.Header1' AS header WITH ;
		Caption = "", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTables.Column2.Header1' AS header WITH ;
		Caption = "Table", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTables.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Init
		*==============================================================================
		* Function:			Init
		* Status:			Public
		* Purpose:			Initialize this class
		* Author:			Doug Hennig
		* Copyright:		(c) 1995-2002 Stonefield Systems Group Inc.
		* Last revision:	04/19/2002
		* Parameters:		toProcess - a reference to a PassParameters object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.oProcess contains the passed parameters
		*					the TABLES cursor contains a list of tables to display
		*					the form's icon is set to the icon for the screen
		*					the form is centered and set to a double wide border
		*==============================================================================
		
		lparameters toProcess
		local lnI
		with This
			.oProcess = toProcess
			for lnI = 1 to alen(toProcess.aArray, 1)
				insert into TABLES (CAPTION, NAME) values ;
					(toProcess.aArray[lnI, 1], toProcess.aArray[lnI, 2])
			next lnI
			go top
			.Icon        = _screen.Icon
			.AutoCenter  = .T.
			.BorderStyle = 2
		endwith
		
	ENDPROC

	PROCEDURE Load
		* Create a cursor to hold the tables to process.
		
		set talk off
		set deleted on
		set exact off
		create cursor TABLES ;
			(NAME C(128), ;
			CAPTION C(120), ;
			SELECTED L)
		index on CAPTION tag CAPTION
		
	ENDPROC

	PROCEDURE Refresh
		*==============================================================================
		* Function:			Refresh
		* Status:			Public
		* Purpose:			Ensure controls are properly displayed
		* Author:			Doug Hennig
		* Copyright:		(c) 1995 Stonefield Systems Group Inc.
		* Last revision:	11/23/96
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.chkAllTables is checked if all tables are selected
		*					This.cmdReindex is enabled is any tables are selected
		*==============================================================================
		
		local llAllFiles, ;
			llAnyFiles, ;
			lnRecno
		llAllFiles = .T.
		llAnyFiles = .F.
		
		* If any tables are unselected, set llAllFiles to .F. and if any tables are
		* selected, set llAnyFiles to .T.
		
		lnRecno = recno()
		scan
			if SELECTED
				llAnyFiles = .T.
			else
				llAllFiles = .F.
			endif SELECTED
		endscan
		go lnRecno
		
		* Check the All Tables checkbox if all tables are selected. Enabled the Process
		* button if any tables are selected.
		
		with This
			.chkAllTables.Value = llAllFiles
			.cmdProcess.Enabled = llAnyFiles
		endwith
		
	ENDPROC

	PROCEDURE chkAllTables.Init
		This.Caption = ccALL_TABLES
		
	ENDPROC

	PROCEDURE chkAllTables.InteractiveChange
		* Add or remove the check mark in front of all tables and the refresh the form
		* to ensure other controls are properly displayed.
		
		local lnRecno
		lnRecno = recno()
		replace all SELECTED with This.Value
		go lnRecno
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		* Set the first element in the aParameters property of the PassParameters
		* object to .F. indicating the user chose this button. Release the form.
		
		local lnI
		with Thisform.oProcess
			dimension .aParameters[2]
			.aParameters[1] = .F.
			.aParameters[2] = .F.
		endwith
		Thisform.Release()
		
	ENDPROC

	PROCEDURE cmdCancel.Init
		This.Caption = ccCANCEL
		
	ENDPROC

	PROCEDURE cmdProcess.Click
		* Copy the list of tables to process to the aArray property of the
		* PassParameters object so the calling function can process them. Set the first
		* element in the aParameters property of the PassParameters object to .T.
		* indicating the user chose this button and the second to the value of the
		* chkOther checkbox. Release the form.
		
		local lnI
		with Thisform.oProcess
			lnI = 1
			dimension .aArray[1, 2]
			.aArray = ''
			scan for SELECTED
				dimension .aArray[lnI, 2]
				.aArray[lnI, 1] = trim(CAPTION)
				.aArray[lnI, 2] = trim(NAME)
				lnI = lnI + 1
			endscan for SELECTED
			dimension .aParameters[2]
			.aParameters[1] = .T.
			.aParameters[2] = Thisform.chkOther.Value
		endwith
		Thisform.Release()
		
	ENDPROC

	PROCEDURE grdTables.Column1.Check1.InteractiveChange
		replace SELECTED with This.Value
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE grdTables.Column2.Text1.Click
		replace TABLES.SELECTED with not TABLES.SELECTED
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE grdTables.Column2.Text1.When
		return .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtprogressbar AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpBar" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape17" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape18" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape19" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape20" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape21" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape22" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape23" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape24" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape25" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape26" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape27" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Sfshape28" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: update		&& Updates the progress bar
		*p: nmaxwidth		&& The initial width of the bar
		*p: npercent		&& The last percentage of the progress meter
	*</DefinedPropArrayMethod>

	PROTECTED nmaxwidth,npercent
	BackStyle = 0
	BorderWidth = 0
	Height = 22
	Name = "sdtprogressbar"
	nmaxwidth = 0		&& The initial width of the bar
	npercent = 0		&& The last percentage of the progress meter
	Width = 346

	ADD OBJECT 'Sfshape1' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 10, ;
		Name = "Sfshape1", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape10' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 118, ;
		Name = "Sfshape10", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape11' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 130, ;
		Name = "Sfshape11", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape12' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 142, ;
		Name = "Sfshape12", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape13' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 154, ;
		Name = "Sfshape13", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape14' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 166, ;
		Name = "Sfshape14", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape15' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 178, ;
		Name = "Sfshape15", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape16' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 190, ;
		Name = "Sfshape16", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape17' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 202, ;
		Name = "Sfshape17", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape18' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 214, ;
		Name = "Sfshape18", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape19' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 226, ;
		Name = "Sfshape19", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape2' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 22, ;
		Name = "Sfshape2", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape20' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 238, ;
		Name = "Sfshape20", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape21' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 250, ;
		Name = "Sfshape21", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape22' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 262, ;
		Name = "Sfshape22", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape23' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 274, ;
		Name = "Sfshape23", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape24' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 286, ;
		Name = "Sfshape24", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape25' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 298, ;
		Name = "Sfshape25", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape26' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 310, ;
		Name = "Sfshape26", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape27' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 322, ;
		Name = "Sfshape27", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape28' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 334, ;
		Name = "Sfshape28", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape3' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 34, ;
		Name = "Sfshape3", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape4' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 46, ;
		Name = "Sfshape4", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape5' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 58, ;
		Name = "Sfshape5", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape6' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 70, ;
		Name = "Sfshape6", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape7' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 82, ;
		Name = "Sfshape7", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape8' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 94, ;
		Name = "Sfshape8", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Sfshape9' AS shape WITH ;
		BorderColor = 192,192,192, ;
		Height = 22, ;
		Left = 106, ;
		Name = "Sfshape9", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'shpBar' AS shape WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		FillColor = 0,0,128, ;
		FillStyle = 0, ;
		Height = 20, ;
		Left = 0, ;
		Name = "shpBar", ;
		Top = 1, ;
		Width = 346
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE Init
		* Save the bar width and then set it to 0.
		
		local loControl
		with This
			.nMaxWidth    = .shpBar.Width
			.shpBar.Width = 0
		
		* Set the border color of the lines to match the form's background.
		
			for each loControl in .Controls
				if upper(loControl.Name) = 'SFSHAPE'
					loControl.BorderColor = Thisform.BackColor
				endif upper(loControl.Name) = 'SFSHAPE'
			next loControl
		endwith
		
	ENDPROC

	PROCEDURE update		&& Updates the progress bar
		* Update the progress bar with a new value.
		
		lparameters tnCurrent
		local lnPercent, ;
			lnWidth
		
		* Don't let the percentage go over 100% or under 0%.
		
		with This
			lnPercent = max(min(tnCurrent, 100), 0)
		
		* If the percentage has changed, store it and adjust the bar width.
		
			if lnPercent <> .nPercent
				.nPercent     = lnPercent
				lnWidth       = lnPercent/100 * .nMaxWidth
				.shpBar.Width = int((lnWidth - 1)/12) * 12 + 1
			endif lnPercent = .nPercent
		
		* Use a DOEVENTS and Thisform.Draw to ensure the window is updated.
		
			Thisform.Draw()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtprogressform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblProcess1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblProcess2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblProcess3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oProgress" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*m: clear		&& Clears the display
		*m: setcaptions		&& Sets the captions for the labels
		*m: update		&& Updates the progress meter
		*p: ccursor		&& The setting of SET CURSOR
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	Caption = "Progress"
	ccursor = 		&& The setting of SET CURSOR
	Closable = .F.
	ControlBox = .F.
	Desktop = .T.
	DoCreate = .T.
	FontName = "Courier New"
	Height = 128
	MaxButton = .F.
	MinButton = .F.
	Name = "sdtprogressform"
	ShowWindow = 1
	Width = 376

	ADD OBJECT 'lblProcess1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Process1", ;
		Height = 17, ;
		Left = 15, ;
		Name = "lblProcess1", ;
		Top = 10, ;
		Width = 55
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblProcess2' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Process2", ;
		Height = 17, ;
		Left = 15, ;
		Name = "lblProcess2", ;
		Top = 30, ;
		Width = 55
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblProcess3' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Process3", ;
		FontName = "Courier New", ;
		Height = 17, ;
		Left = 0, ;
		Name = "lblProcess3", ;
		Top = 50, ;
		Width = 58
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'oProgress' AS sdtprogressbar WITH ;
		Left = 15, ;
		Name = "oProgress", ;
		Top = 95, ;
		Sfshape1.Name = "Sfshape1", ;
		Sfshape10.Name = "Sfshape10", ;
		Sfshape11.Name = "Sfshape11", ;
		Sfshape12.Name = "Sfshape12", ;
		Sfshape13.Name = "Sfshape13", ;
		Sfshape14.Name = "Sfshape14", ;
		Sfshape15.Name = "Sfshape15", ;
		Sfshape16.Name = "Sfshape16", ;
		Sfshape17.Name = "Sfshape17", ;
		Sfshape18.Name = "Sfshape18", ;
		Sfshape19.Name = "Sfshape19", ;
		Sfshape2.Name = "Sfshape2", ;
		Sfshape20.Name = "Sfshape20", ;
		Sfshape21.Name = "Sfshape21", ;
		Sfshape22.Name = "Sfshape22", ;
		Sfshape23.Name = "Sfshape23", ;
		Sfshape24.Name = "Sfshape24", ;
		Sfshape25.Name = "Sfshape25", ;
		Sfshape26.Name = "Sfshape26", ;
		Sfshape27.Name = "Sfshape27", ;
		Sfshape28.Name = "Sfshape28", ;
		Sfshape3.Name = "Sfshape3", ;
		Sfshape4.Name = "Sfshape4", ;
		Sfshape5.Name = "Sfshape5", ;
		Sfshape6.Name = "Sfshape6", ;
		Sfshape7.Name = "Sfshape7", ;
		Sfshape8.Name = "Sfshape8", ;
		Sfshape9.Name = "Sfshape9", ;
		shpBar.Name = "shpBar"
		*< END OBJECT: ClassLib="sdt.vcx" BaseClass="container" />
	
	PROCEDURE clear		&& Clears the display
		This.Cls()
		
	ENDPROC

	PROCEDURE Destroy
		if This.cCursor = 'ON'
			set cursor on
		endif This.cCursor = 'ON'
		
	ENDPROC

	PROCEDURE Init
		lparameters tlShowMeter
		with This
			.BorderStyle = 2
			if not tlShowMeter
				.oProgress.Visible = .F.
				.Height = .oProgress.Top
			endif not tlShowMeter
			.Caption = ccMSG_PROGRESS
			.cCursor = set('CURSOR')
			set cursor off
		endwith
		
	ENDPROC

	PROCEDURE setcaptions		&& Sets the captions for the labels
		lparameters tcMessage1, ;
			tcMessage2, ;
			tcMessage3
		if vartype(tcMessage1) = 'C'
			This.lblProcess1.Caption = tcMessage1
		endif vartype(tcMessage1) = 'C'
		if vartype(tcMessage2) = 'C'
			This.lblProcess2.Caption = tcMessage2
		endif vartype(tcMessage2) = 'C'
		if vartype(tcMessage3) = 'C'
			This.lblProcess3.Caption = tcMessage3
		endif vartype(tcMessage3) = 'C'
		
	ENDPROC

	PROCEDURE update		&& Updates the progress meter
		lparameters tnCurrent
		This.oProgress.Update(tnCurrent)
		
	ENDPROC

	PROCEDURE lblProcess1.Init
		This.Caption = ''
		
	ENDPROC

	PROCEDURE lblProcess2.Init
		This.Caption = ''
		
	ENDPROC

	PROCEDURE lblProcess3.Init
		This.Caption = ''
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sdtselecttagform AS form 		&& A form used to select a tag for a table.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lstTags" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDescending" UniqueID="" Timestamp="" />

	#INCLUDE "sdt.h"
	*<DefinedPropArrayMethod>
		*p: oselect		&& A reference to a PassParameters object
		*a: atags[1,0]		&& An array of tags to display.
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	Caption = "Sort Order"
	Desktop = .T.
	DoCreate = .T.
	Height = 205
	MaxButton = .F.
	MinButton = .F.
	Name = "sdtselecttagform"
	ShowWindow = 1
	Width = 491
	WindowType = 1

	ADD OBJECT 'chkDescending' AS checkbox WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Descending", ;
		Height = 17, ;
		Left = 395, ;
		Name = "chkDescending", ;
		TabIndex = 2, ;
		Top = 25, ;
		Value = .F., ;
		Width = 85
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Height = 29, ;
		Left = 390, ;
		Name = "cmdCancel", ;
		TabIndex = 4, ;
		Top = 140, ;
		Width = 94
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelect' AS commandbutton WITH ;
		Caption = "Select", ;
		Height = 29, ;
		Left = 390, ;
		Name = "cmdSelect", ;
		TabIndex = 3, ;
		Top = 100, ;
		Width = 94
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'lstTags' AS listbox WITH ;
		ControlSource = "", ;
		Height = 181, ;
		Left = 10, ;
		Name = "lstTags", ;
		RowSource = "Thisform.aTags", ;
		RowSourceType = 5, ;
		TabIndex = 1, ;
		Top = 10, ;
		Width = 370
		*< END OBJECT: BaseClass="listbox" />
	
	PROCEDURE Init
		*==============================================================================
		* Function:			Init
		* Status:			Public
		* Purpose:			Initialize this class
		* Author:			Doug Hennig
		* Copyright:		(c) 1995-2001 Stonefield Systems Group Inc.
		* Last revision:	06/06/2001
		* Parameters:		toParameters - a reference to a SDTPassParameters object
		*					toSDTMgr     - a reference to an SDTMgr object
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.aTags contains an array of tags to display (stored
		*						in the aArray property of the PassParameters object)
		*					the tags list is requeried and the current order is
		*						highlighted
		*					the form's icon is set to the icon for the screen
		*					the form is centered and set to a double wide border
		*==============================================================================
		
		lparameters toParameters, ;
			toSDTMgr
		local laTags[1], ;
			lcOrder, ;
			lnTag
		with This
			asort(toParameters.aArray)
			.oSelect = toParameters
			acopy(toParameters.aArray, .aTags)
			acopy(toParameters.aArray, laTags)
			lcOrder = toParameters.aParameters[2]
			.lstTags.Requery()
		
		* Highlight the current order.
		
			lnTag = iif(empty(lcOrder), 0, ;
				toSDTMgr.ArrayScan(@laTags, lcOrder, 2))
			.lstTags.ListIndex = max(lnTag, 1)
			.chkDescending.Value = toParameters.aParameters[3]
		
		* Change the icon to match the screen's, use the desired border style, and set
		* the caption.
		
			.Icon        = _screen.Icon
			.BorderStyle = 2
			.Caption     = ccFRM_SORT_ORDER
		endwith
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		* Cancel was chosen, so release the form.
		
		Thisform.Release()
		
	ENDPROC

	PROCEDURE cmdCancel.Init
		This.Caption = ccCANCEL
		
	ENDPROC

	PROCEDURE cmdSelect.Click
		* Save the selected tag and release the form.
		
		with Thisform
			.oSelect.aParameters[1] = .T.
			.oSelect.aParameters[2] = .aTags[.lstTags.ListIndex, 2]
			.oSelect.aParameters[3] = .chkDescending.Value
			.Release()
		endwith
	ENDPROC

	PROCEDURE cmdSelect.Init
		This.Caption = ccSELECT
		
	ENDPROC

	PROCEDURE lstTags.DblClick
		* Double-clicking in the list is like selecting a tag and clicking Select.
		
		Thisform.cmdSelect.Click()
		
	ENDPROC

ENDDEFINE
