*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="td.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
#INCLUDE "sdt.h"

DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	DataSource = .NULL.
	Height = 157
	Left = 36
	Name = "Dataenvironment"
	Top = 424
	Width = 512

ENDDEFINE

DEFINE CLASS frmtd AS sdtform OF "sdtcontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="pgfTable" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.boxDisplay" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.boxValid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblDec" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.txtDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.txtCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.cboType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.spnWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.spnDecimals" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.chkNull" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.cmdExprValid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.cmdExprText" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.cmdExprDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.cmdExprCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.txtName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblRule" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblMessage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.txtValidRule" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.txtValidText" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblInputMask" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.txtInputMask" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.cmdExprInput" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.txtFormat" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.cmdExprFormat" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblFormat" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.chkLinked" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.boxAutoInc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.spnStepValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblStepValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.spnNextValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page1.lblNextValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.shpCalculated" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.edtComment" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.lblComment" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.boxIntellidrop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.lblClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.lblLibrary" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.txtAutoLib" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.cboClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.cmdGetLib" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.chkFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.chkCalculated" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.edtExpr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.cmdExprExpr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.Page2.lblExpr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagFields3.cntExtProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.lblType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.txtExpression" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.lblComment" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.txtName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.cmdDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.lblName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.lblCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.edtComment" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.cmdExprCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.chkSelect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.chkDescend" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.lblFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.txtCaption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.cmdExprFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.cboCollate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.cboType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.lblExpression" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.txtFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.cmdExprExpr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.lblCollate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex.cmdWizard" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagIndex2.cntExtProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.boxStats" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.boxTriggers" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.boxValid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.lblRule" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.lblMessage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.txtTblValidRule" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.txtTblValidText" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.edtTblComment" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.lblComment" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.lblInsert" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.txtInsert" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.lblUpdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.txtUpdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.lblDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.txtDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.cmdExprRule" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.cmdExprText" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.cmdExprInsert" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.cmdExprUpdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.cmdExprDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.txtPath" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.txtRecords" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.txtFields" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.lblTableName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.txtLength" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.lblPath" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.txtTableName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.lblBlockSize" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.spnBlockSize" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.lblCodePage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable.cboCodePage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfTable.pagTable2.cntExtProps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstFields" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGet" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCopy" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstIndexes" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oPersist" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addfield		&& Adds a new field to FIELDS.
		*m: addhotkey		&& Adds a new field or index (fired from a hot key)
		*m: addindex		&& Adds a new index to INDEXES.
		*m: calctablesize
		*m: checkindexexpression		&& Checks the index expression
		*m: createindexes
		*m: createtable
		*m: exitwithoutsave		&& Returns .T. if the user wants to exit the form without saving.
		*m: getcollate
		*m: getfieldtype		&& Returns the full-text field type for a given field type.
		*m: getindexes
		*m: getlibraryclasses
		*m: gettablestructure
		*m: handleblankfield
		*m: handleblankindex
		*m: handletype
		*m: indexerror		&& Display an error regarding an invalid index.
		*m: indexinrelation
		*m: opentable		&& Opens the table being maintained
		*m: pgdnhotkey		&& Move to the next field or index (fired from a hotkey)
		*m: pguphotkey		&& Move to the previous field or index (fired from a hotkey)
		*m: refreshcollate		&& Ensure the collate combobox only shows collate sequences available for the selected codepage.
		*m: removefield
		*m: renamefield
		*m: renamefieldinmetadata
		*m: resethotkeys		&& Clears hot keys
		*m: selectfield
		*m: selectindex
		*m: showbuttons
		*m: updateindexes
		*m: updatetable
		*p: calias		&& The alias of the table being maintained.
		*p: cclasslib		&& The last class library accessed
		*p: ccurrenttag		&& The name of the current tag.
		*p: ccurrobject
		*p: ccurrobjecttype
		*p: ccurrparenttype
		*p: cdatabase		&& The database name without path or extension
		*p: cdbc		&& The database the table belongs to.
		*p: cdragicon		&& A cursor used when a dragged object can be dropped.
		*p: cfieldrepdir		&& The directory where the Field Repository files are located
		*p: cmetapath		&& The directory where the meta data tables were opened.
		*p: cnewalias		&& The new name of the table if it was changed.
		*p: cnodropicon		&& A cursor used when a dragged object cannot be dropped.
		*p: cuniqueid		&& A unique ID so TD instances can distinguish themselves.
		*p: inewtableid		&& The new OBJECTID for the table in the DBC
		*p: itableid		&& The OBJECTID for the table in the DBC
		*p: lnew		&& .T. if this is a new table.
		*p: lselecteditemoninit		&& .T. if an item is selected upon startup
		*p: lshowinternational		&& .T. to show codepages and collate sequences.
		*p: lusefieldrep		&& .T. to use the Field Repository
		*p: lviewinheritance		&& .T. if view field inherit properties from their source fields
		*p: nblocksize		&& The blocksize of the table.
		*p: ncodepage		&& The code page for the table as it would be written to the DBF header.
		*p: ndragthreshold		&& The number of pixels the user must move the mouse with the button held down to start a drag.
		*p: nmousex		&& The starting mouse X position to determine if a drag has started.
		*p: nmousey		&& The starting mouse Y position to determine if a drag has started.
		*p: ntablecp		&& The code page for table.
		*p: ometa		&& A reference to the MetaMgr object.
		*p: osdtform		&& A reference to the SDT form that called this form.
		*a: acodepage[1,0]		&& An array of code pages.
		*a: acollate[1,0]		&& An array of collate sequences.
		*a: adatatypes[1,0]		&& An array of data types.
		*a: aindextypes[1,0]		&& An array of index types.
		*a: arelations[1,0]		&& An array of relations this table belongs to.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	calias = 		&& The alias of the table being maintained.
	Caption = "Stonefield Extended Table Designer"
	cclasslib = 		&& The last class library accessed
	ccurrenttag = 		&& The name of the current tag.
	ccurrobject = 
	ccurrobjecttype = 
	ccurrparenttype = 
	cdatabase = 		&& The database name without path or extension
	cdbc = 		&& The database the table belongs to.
	cdragicon = source\dragmove.cur		&& A cursor used when a dragged object can be dropped.
	cfieldrepdir = 		&& The directory where the Field Repository files are located
	cmetapath = 		&& The directory where the meta data tables were opened.
	cnewalias = 		&& The new name of the table if it was changed.
	cnodropicon = source\nodrop01.cur		&& A cursor used when a dragged object cannot be dropped.
	cuniqueid = 		&& A unique ID so TD instances can distinguish themselves.
	DataSession = 2
	DoCreate = .T.
	Height = 455
	HelpContextID = 22
	inewtableid = 0		&& The new OBJECTID for the table in the DBC
	itableid = 0		&& The OBJECTID for the table in the DBC
	KeyPreview = .T.
	lselecteditemoninit = .F.		&& .T. if an item is selected upon startup
	lshowinternational = .F.		&& .T. to show codepages and collate sequences.
	lusefieldrep = .T.		&& .T. to use the Field Repository
	lviewinheritance = .F.		&& .T. if view field inherit properties from their source fields
	MaxButton = .F.
	MinButton = .F.
	Name = "frmTD"
	nblocksize = 64		&& The blocksize of the table.
	ncodepage = 0		&& The code page for the table as it would be written to the DBF header.
	ndragthreshold = 4		&& The number of pixels the user must move the mouse with the button held down to start a drag.
	nmousex = 0		&& The starting mouse X position to determine if a drag has started.
	nmousey = 0		&& The starting mouse Y position to determine if a drag has started.
	ometa = .NULL.		&& A reference to the MetaMgr object.
	osdtform = .NULL.		&& A reference to the SDT form that called this form.
	Width = 625
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'cmdAdd' AS sdtpicturebutton WITH ;
		Comment = "Don't move this object!", ;
		Left = 285, ;
		Name = "cmdAdd", ;
		Picture = add.bmp, ;
		StatusBarText = "Add field to end of list", ;
		TabIndex = 8, ;
		ToolTipText = "Add field to end of list", ;
		Top = 405
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdCancel' AS sdtpicturebutton WITH ;
		Cancel = .T., ;
		Left = 596, ;
		Name = "cmdCancel", ;
		Picture = undo.bmp, ;
		StatusBarText = "Cancel changes", ;
		TabIndex = 6, ;
		ToolTipText = "Cancel changes", ;
		Top = 7
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdCopy' AS sdtpicturebutton WITH ;
		Comment = "Don't move this object!", ;
		Left = 375, ;
		Name = "cmdCopy", ;
		Picture = copy.bmp, ;
		StatusBarText = "Copy field", ;
		TabIndex = 11, ;
		ToolTipText = "Copy field", ;
		Top = 405
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdDelete' AS sdtpicturebutton WITH ;
		Comment = "Don't move this object!", ;
		lcancel = .T., ;
		Left = 315, ;
		Name = "cmdDelete", ;
		Picture = delete.bmp, ;
		StatusBarText = "Remove field", ;
		TabIndex = 9, ;
		ToolTipText = "Remove field", ;
		Top = 405
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdGet' AS sdtpicturebutton WITH ;
		Comment = "Don't move this object!", ;
		Left = 345, ;
		Name = "cmdGet", ;
		Picture = library.bmp, ;
		StatusBarText = "Get field from Field Repository", ;
		TabIndex = 10, ;
		ToolTipText = "Get field from Field Repository", ;
		Top = 405
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdHelp' AS sdthelpbutton WITH ;
		Height = 23, ;
		Left = 548, ;
		Name = "cmdHelp", ;
		Picture = help.bmp, ;
		TabIndex = 4, ;
		Top = 7, ;
		Width = 23
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS sdtpicturebutton WITH ;
		Left = 572, ;
		Name = "cmdOK", ;
		Picture = save.bmp, ;
		StatusBarText = "Save changes and update table structure", ;
		TabIndex = 5, ;
		ToolTipText = "Save changes and update table structure", ;
		Top = 7
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lstFields' AS sdtlistbox WITH ;
		Comment = "Don't move this object!", ;
		Height = 16, ;
		IntegralHeight = .F., ;
		Left = 15, ;
		MoverBars = .T., ;
		Name = "lstFields", ;
		RowSource = "", ;
		RowSourceType = 0, ;
		TabIndex = 3, ;
		Top = 45, ;
		Value = , ;
		Width = 200
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="listbox" />

	ADD OBJECT 'lstIndexes' AS sdtlistbox WITH ;
		Height = 373, ;
		IntegralHeight = .F., ;
		Left = 15, ;
		Name = "lstIndexes", ;
		RowSource = "", ;
		RowSourceType = 0, ;
		TabIndex = 2, ;
		Top = 45, ;
		Value = , ;
		Width = 126
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="listbox" />

	ADD OBJECT 'oPersist' AS sfpersistentform WITH ;
		Left = 520, ;
		lrestoreoninit = .F., ;
		Name = "oPersist", ;
		Top = 10
		*< END OBJECT: ClassLib="..\..\sfcommon\sfpersist.vcx" BaseClass="custom" />

	ADD OBJECT 'pgfTable' AS sdtpageframe WITH ;
		ErasePage = .T., ;
		Height = 440, ;
		Left = 5, ;
		Name = "pgfTable", ;
		PageCount = 7, ;
		TabIndex = 1, ;
		Top = 5, ;
		Width = 615, ;
		Page1.Caption = "Fields 1", ;
		Page1.Name = "Page1", ;
		Page2.Caption = "Fields 2", ;
		Page2.Name = "Page2", ;
		Page3.Caption = "Field Props", ;
		Page3.Name = "pagFields3", ;
		Page4.Caption = "Indexes", ;
		Page4.Name = "pagIndex", ;
		Page5.Caption = "Index Props", ;
		Page5.Name = "pagIndex2", ;
		Page6.Caption = "Table", ;
		Page6.Name = "pagTable", ;
		Page7.Caption = "Table Props", ;
		Page7.Name = "pagTable2"
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="pageframe" />

	ADD OBJECT 'pgfTable.Page1.boxAutoInc' AS sdtlabelledbox WITH ;
		Height = 55, ;
		Left = 229, ;
		Name = "boxAutoInc", ;
		TabIndex = 31, ;
		Top = 307, ;
		Width = 375, ;
		lblLabel.Caption = " Auto-increment: ", ;
		lblLabel.Name = "lblLabel", ;
		shpBox.Height = 49, ;
		shpBox.Name = "shpBox", ;
		shpBox.Width = 375
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'pgfTable.Page1.boxDisplay' AS sdtlabelledbox WITH ;
		Height = 105, ;
		Left = 229, ;
		Name = "boxDisplay", ;
		TabIndex = 11, ;
		Top = 87, ;
		Width = 375, ;
		lblLabel.Caption = " Display: ", ;
		lblLabel.Name = "lblLabel", ;
		shpBox.Height = 99, ;
		shpBox.Name = "shpBox", ;
		shpBox.Width = 375
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'pgfTable.Page1.boxValid' AS sdtlabelledbox WITH ;
		Height = 105, ;
		Left = 229, ;
		Name = "boxValid", ;
		TabIndex = 21, ;
		Top = 197, ;
		Width = 375, ;
		lblLabel.Caption = " Field validation: ", ;
		lblLabel.Name = "lblLabel", ;
		shpBox.Height = 99, ;
		shpBox.Name = "shpBox", ;
		shpBox.Width = 375
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'pgfTable.Page1.cboType' AS sdtcombobox WITH ;
		ControlSource = "_fields.xtype", ;
		Left = 272, ;
		Name = "cboType", ;
		RowSource = "thisform.adatatypes", ;
		RowSourceType = 5, ;
		Style = 2, ;
		TabIndex = 4, ;
		Top = 32, ;
		Width = 138
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'pgfTable.Page1.chkLinked' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Linked to Field Repository", ;
		ControlSource = "_fields.replink", ;
		Left = 289, ;
		Name = "chkLinked", ;
		TabIndex = 10, ;
		Top = 62
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'pgfTable.Page1.chkNull' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Null", ;
		ControlSource = "_fields.lnull", ;
		Left = 229, ;
		Name = "chkNull", ;
		TabIndex = 9, ;
		Top = 62, ;
		Width = 40
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'pgfTable.Page1.cmdExprCaption' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Caption:, ;
		cdefaultexpression = This.Parent.txtCaption.Value, ;
		cexpressiontype = C, ;
		cresult = This.Parent.txtCaption.Value, ;
		Left = 574, ;
		lliteral = .T., ;
		Name = "cmdExprCaption", ;
		TabIndex = 20, ;
		Top = 157
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.Page1.cmdExprDefault' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Default value:, ;
		cdefaultexpression = This.Parent.txtDefault.Value, ;
		cexpressiontype = Thisform.aTypes[This.Parent.cboType.ListIndex, 2], ;
		cresult = This.Parent.txtDefault.Value, ;
		Left = 574, ;
		Name = "cmdExprDefault", ;
		TabIndex = 30, ;
		Top = 267
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.Page1.cmdExprFormat' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Format:, ;
		cdefaultexpression = This.Parent.txtFormat.Value, ;
		cexpressiontype = C, ;
		cresult = This.Parent.txtFormat.Value, ;
		Left = 574, ;
		lliteral = .T., ;
		Name = "cmdExprFormat", ;
		TabIndex = 14, ;
		Top = 107
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.Page1.cmdExprInput' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Input mask:, ;
		cdefaultexpression = This.Parent.txtInputMask.Value, ;
		cexpressiontype = C, ;
		cresult = This.Parent.txtInputMask.Value, ;
		Left = 574, ;
		lliteral = .T., ;
		Name = "cmdExprInput", ;
		TabIndex = 17, ;
		Top = 132
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.Page1.cmdExprText' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Validation text:, ;
		cdefaultexpression = This.Parent.txtValidText.Value, ;
		cexpressiontype = C, ;
		cresult = This.Parent.txtValidText.Value, ;
		Left = 574, ;
		Name = "cmdExprText", ;
		TabIndex = 27, ;
		Top = 242
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.Page1.cmdExprValid' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Validation rule:, ;
		cdefaultexpression = This.Parent.txtValidRule.Value, ;
		cexpressiontype = , ;
		cresult = This.Parent.txtValidRule.Value, ;
		Left = 574, ;
		Name = "cmdExprValid", ;
		TabIndex = 24, ;
		Top = 217
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.Page1.lblCaption' AS sdtlabel WITH ;
		Caption = "Caption", ;
		Left = 239, ;
		Name = "lblCaption", ;
		TabIndex = 18, ;
		Top = 160, ;
		Width = 45
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblDec' AS sdtlabel WITH ;
		Caption = "Dec", ;
		Left = 525, ;
		Name = "lblDec", ;
		TabIndex = 7, ;
		Top = 35, ;
		Width = 24
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblDefault' AS sdtlabel WITH ;
		Caption = "Default Value", ;
		Left = 239, ;
		Name = "lblDefault", ;
		TabIndex = 28, ;
		Top = 270, ;
		Width = 75
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblFormat' AS sdtlabel WITH ;
		Caption = "Format", ;
		Left = 239, ;
		Name = "lblFormat", ;
		TabIndex = 12, ;
		Top = 110, ;
		Width = 41
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblInputMask' AS sdtlabel WITH ;
		Caption = "Input Mask", ;
		Left = 239, ;
		Name = "lblInputMask", ;
		TabIndex = 15, ;
		Top = 135, ;
		Width = 61
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblMessage' AS sdtlabel WITH ;
		Caption = "Message", ;
		Left = 239, ;
		Name = "lblMessage", ;
		TabIndex = 25, ;
		Top = 245, ;
		Width = 53
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblName' AS sdtlabel WITH ;
		Caption = "Name", ;
		Left = 229, ;
		Name = "lblName", ;
		TabIndex = 1, ;
		Top = 10, ;
		Width = 36
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblNextValue' AS sdtlabel WITH ;
		Caption = "Start Value", ;
		Left = 409, ;
		Name = "lblNextValue", ;
		TabIndex = 34, ;
		Top = 331, ;
		Width = 61
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblRule' AS sdtlabel WITH ;
		Caption = "Rule", ;
		Left = 239, ;
		Name = "lblRule", ;
		TabIndex = 22, ;
		Top = 220, ;
		Width = 28
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblStepValue' AS sdtlabel WITH ;
		Caption = "Step Value", ;
		Left = 239, ;
		Name = "lblStepValue", ;
		TabIndex = 32, ;
		Top = 331, ;
		Width = 61
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblType' AS sdtlabel WITH ;
		Caption = "Type", ;
		Left = 229, ;
		Name = "lblType", ;
		TabIndex = 3, ;
		Top = 35, ;
		Width = 28
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.lblWidth' AS sdtlabel WITH ;
		Caption = "Width", ;
		Left = 421, ;
		Name = "lblWidth", ;
		TabIndex = 5, ;
		Top = 35, ;
		Width = 33
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page1.spnDecimals' AS sdtspinner WITH ;
		ControlSource = "_fields.ndecimals", ;
		InputMask = "999", ;
		KeyboardHighValue = 1, ;
		KeyboardLowValue = 0, ;
		Left = 555, ;
		Name = "spnDecimals", ;
		SelectOnEntry = .T., ;
		SpinnerLowValue = 0.00, ;
		TabIndex = 8, ;
		Top = 32, ;
		Width = 49
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="spinner" />

	ADD OBJECT 'pgfTable.Page1.spnNextValue' AS sdtspinner WITH ;
		ControlSource = "_fields.nnextvalue", ;
		Height = 24, ;
		Left = 479, ;
		Name = "spnNextValue", ;
		nhighvalue = 2147483647, ;
		nlowvalue = -2147483647, ;
		TabIndex = 35, ;
		Top = 327, ;
		Width = 115
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="spinner" />

	ADD OBJECT 'pgfTable.Page1.spnStepValue' AS sdtspinner WITH ;
		ControlSource = "_fields.nstepvalue", ;
		Height = 24, ;
		Left = 319, ;
		Name = "spnStepValue", ;
		nhighvalue = 255, ;
		nlowvalue = 0, ;
		TabIndex = 33, ;
		Top = 327, ;
		Width = 53
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="spinner" />

	ADD OBJECT 'pgfTable.Page1.spnWidth' AS sdtspinner WITH ;
		ControlSource = "_fields.nsize", ;
		InputMask = "999", ;
		KeyboardLowValue = 1, ;
		Left = 462, ;
		Name = "spnWidth", ;
		SelectOnEntry = .T., ;
		SpinnerLowValue = 1.00, ;
		TabIndex = 6, ;
		Top = 32, ;
		Width = 55
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="spinner" />

	ADD OBJECT 'pgfTable.Page1.txtCaption' AS sdttextbox WITH ;
		ControlSource = "_fields.xcaption", ;
		Height = 23, ;
		Left = 319, ;
		Name = "txtCaption", ;
		TabIndex = 19, ;
		Top = 157, ;
		Width = 255
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.Page1.txtDefault' AS sdttextbox WITH ;
		ControlSource = "_fields.xdefault", ;
		Height = 23, ;
		Left = 319, ;
		Name = "txtDefault", ;
		TabIndex = 29, ;
		Top = 267, ;
		Width = 255
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.Page1.txtFormat' AS sdttextbox WITH ;
		ControlSource = "_fields.xformat", ;
		Height = 23, ;
		Left = 319, ;
		Name = "txtFormat", ;
		TabIndex = 13, ;
		Top = 107, ;
		Width = 255
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.Page1.txtInputMask' AS sdttextbox WITH ;
		ControlSource = "_fields.xinput", ;
		Height = 23, ;
		Left = 319, ;
		Name = "txtInputMask", ;
		TabIndex = 16, ;
		Top = 132, ;
		Width = 255
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.Page1.txtName' AS sdtfilterinput WITH ;
		ccharvalid = isalpha(<key>) or isdigit(<key>) or <key> = '_', ;
		cfirstcharvalid = isalpha(<key>), ;
		Format = "!", ;
		Height = 23, ;
		laudiblealert = .T., ;
		Left = 272, ;
		Name = "txtName", ;
		TabIndex = 2, ;
		Top = 7, ;
		Width = 332
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.Page1.txtValidRule' AS sdttextbox WITH ;
		ControlSource = "_fields.xvalid", ;
		Height = 23, ;
		Left = 319, ;
		Name = "txtValidRule", ;
		TabIndex = 23, ;
		Top = 217, ;
		Width = 255
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.Page1.txtValidText' AS sdttextbox WITH ;
		ControlSource = "_fields.xerror", ;
		Height = 23, ;
		Left = 319, ;
		Name = "txtValidText", ;
		TabIndex = 26, ;
		Top = 242, ;
		Width = 255
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.Page2.boxIntellidrop' AS sdtlabelledbox WITH ;
		Height = 80, ;
		Left = 229, ;
		Name = "boxIntellidrop", ;
		TabIndex = 1, ;
		Top = 7, ;
		Width = 375, ;
		ZOrderSet = 3, ;
		lblLabel.Caption = " Map field to class: ", ;
		lblLabel.Name = "lblLabel", ;
		shpBox.Height = 74, ;
		shpBox.Name = "shpBox", ;
		shpBox.Width = 375
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'pgfTable.Page2.cboClass' AS sdtcombobox WITH ;
		ControlSource = "_fields.xautoclass", ;
		Height = 24, ;
		Left = 284, ;
		Name = "cboClass", ;
		Style = 2, ;
		TabIndex = 6, ;
		Top = 52, ;
		Width = 290, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'pgfTable.Page2.chkCalculated' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		BackStyle = 1, ;
		Caption = "Calculated", ;
		Left = 244, ;
		Name = "chkCalculated", ;
		TabIndex = 11, ;
		Top = 185, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'pgfTable.Page2.chkFilter' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Filter", ;
		ControlSource = "_fields.filter", ;
		Left = 229, ;
		Name = "chkFilter", ;
		TabIndex = 10, ;
		Top = 162, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'pgfTable.Page2.cmdExprExpr' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Calculation:, ;
		cdefaultexpression = This.Parent.edtExpr.Value, ;
		cexpressiontype = , ;
		cresult = This.Parent.edtExpr.Value, ;
		Left = 574, ;
		Name = "cmdExprExpr", ;
		TabIndex = 13, ;
		Top = 207, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.Page2.cmdGetLib' AS sfgetfile WITH ;
		cafterdone = Thisform.GetLibraryClasses(This.Parent.txtAutoLib.Value), ;
		cdefault = Thisform.cClassLib, ;
		cextensions = 'Class library (*.vcx),*.VCX', ;
		cresult = This.Parent.txtAutoLib.Value, ;
		Left = 574, ;
		lusecommondialog = .T., ;
		Name = "cmdGetLib", ;
		TabIndex = 4, ;
		Top = 27, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.Page2.edtComment' AS sdteditbox WITH ;
		ControlSource = "_fields.xcomment", ;
		czoomformcaption = Comment, ;
		Height = 53, ;
		Left = 294, ;
		MaxLength = 255, ;
		Name = "edtComment", ;
		TabIndex = 9, ;
		Top = 97, ;
		Width = 310, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'pgfTable.Page2.edtExpr' AS sdteditbox WITH ;
		ControlSource = "_fields.xexpr", ;
		czoomformcaption = Calculation, ;
		Height = 53, ;
		Left = 309, ;
		MaxLength = 255, ;
		Name = "edtExpr", ;
		TabIndex = 12, ;
		Top = 207, ;
		Width = 260, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'pgfTable.Page2.lblClass' AS sdtlabel WITH ;
		Caption = "Class", ;
		Left = 239, ;
		Name = "lblClass", ;
		TabIndex = 5, ;
		Top = 55, ;
		Width = 35, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page2.lblComment' AS sdtlabel WITH ;
		Caption = "Comment", ;
		Left = 229, ;
		Name = "lblComment", ;
		TabIndex = 8, ;
		Top = 97, ;
		Width = 57, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page2.lblExpr' AS sdtlabel WITH ;
		Caption = "Calculation", ;
		Left = 239, ;
		Name = "lblExpr", ;
		TabIndex = 7, ;
		Top = 207, ;
		Width = 64, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page2.lblLibrary' AS sdtlabel WITH ;
		Caption = "Library", ;
		Left = 239, ;
		Name = "lblLibrary", ;
		TabIndex = 2, ;
		Top = 30, ;
		Width = 39, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.Page2.shpCalculated' AS sdtshape WITH ;
		Height = 85, ;
		Left = 229, ;
		Name = "shpCalculated", ;
		Top = 192, ;
		Width = 375, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="shape" />

	ADD OBJECT 'pgfTable.Page2.txtAutoLib' AS sdttextbox WITH ;
		ControlSource = "_fields.xautolib", ;
		Height = 23, ;
		Left = 284, ;
		Name = "txtAutoLib", ;
		TabIndex = 3, ;
		Top = 27, ;
		Width = 290, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagFields3.cntExtProps' AS sdtextendedprops WITH ;
		ccurrobjecttype = Field, ;
		Left = 229, ;
		Name = "cntExtProps", ;
		Top = 7, ;
		cntValues.chkValue.Alignment = 0, ;
		cntValues.chkValue.Name = "chkValue", ;
		cntValues.cmdDelete.Name = "cmdDelete", ;
		cntValues.cmdEdit.Name = "cmdEdit", ;
		cntValues.cmdNew.Name = "cmdNew", ;
		cntValues.edtValue.Name = "edtValue", ;
		cntValues.lblValue.Name = "lblValue", ;
		cntValues.ltd = .T., ;
		cntValues.Name = "cntValues", ;
		cntValues.spnValue.Name = "spnValue", ;
		cntValues.txtDValue.Name = "txtDValue", ;
		cntValues.txtTValue.Name = "txtTValue", ;
		cntValues.txtValue.Name = "txtValue", ;
		grdProperty.grcField.grhField.Name = "grhField", ;
		grdProperty.grcField.Name = "grcField", ;
		grdProperty.grcField.txtField.Name = "txtField", ;
		grdProperty.grcName.grhName.Name = "grhName", ;
		grdProperty.grcName.Name = "grcName", ;
		grdProperty.grcName.txtName.Name = "txtName", ;
		grdProperty.grcType.grhType.Name = "grhType", ;
		grdProperty.grcType.Name = "grcType", ;
		grdProperty.grcType.txtType.Name = "txtType", ;
		grdProperty.Name = "grdProperty"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'pgfTable.pagIndex.cboCollate' AS sdtcombobox WITH ;
		ControlSource = "_indexes.collate", ;
		Left = 224, ;
		Name = "cboCollate", ;
		RowSource = "Thisform.aCollate", ;
		RowSourceType = 5, ;
		Style = 2, ;
		TabIndex = 17, ;
		Top = 182, ;
		Width = 173
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'pgfTable.pagIndex.cboType' AS sdtcombobox WITH ;
		ControlSource = "_indexes.type", ;
		Left = 389, ;
		Name = "cboType", ;
		RowSource = "Thisform.aIndexTypes", ;
		RowSourceType = 5, ;
		Style = 2, ;
		TabIndex = 4, ;
		Top = 12, ;
		Width = 100
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'pgfTable.pagIndex.chkDescend' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Descending", ;
		ControlSource = "_indexes.descend", ;
		Left = 431, ;
		Name = "chkDescend", ;
		TabIndex = 18, ;
		Top = 182, ;
		Width = 85
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'pgfTable.pagIndex.chkSelect' AS sdtcheckbox WITH ;
		Alignment = 0, ;
		Caption = "User Selectable", ;
		ControlSource = "_indexes.select", ;
		Left = 431, ;
		Name = "chkSelect", ;
		TabIndex = 19, ;
		Top = 202, ;
		Width = 106
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'pgfTable.pagIndex.cmdAdd' AS sdtpicturebutton WITH ;
		Left = 281, ;
		Name = "cmdAdd", ;
		Picture = add.bmp, ;
		StatusBarText = "Add index to end of list", ;
		TabIndex = 20, ;
		ToolTipText = "Add index to end of list", ;
		Top = 281
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagIndex.cmdDelete' AS sdtpicturebutton WITH ;
		lcancel = .T., ;
		Left = 311, ;
		Name = "cmdDelete", ;
		Picture = delete.bmp, ;
		StatusBarText = "Remove index", ;
		TabIndex = 21, ;
		ToolTipText = "Remove index", ;
		Top = 281
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagIndex.cmdExprCaption' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Caption:, ;
		cdefaultexpression = This.Parent.txtCaption.Value, ;
		cexpressiontype = C, ;
		cresult = This.Parent.txtCaption.Value, ;
		Left = 576, ;
		lliteral = .T., ;
		Name = "cmdExprCaption", ;
		TabIndex = 13, ;
		Top = 87
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagIndex.cmdExprExpr' AS sfgetexpression WITH ;
		cafterdone = Thisform.CheckIndexExpression(trim(This.Parent.txtExpression.Value)), ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Expression:, ;
		cdefaultexpression = This.Parent.txtExpression.Value, ;
		cexpressiontype = , ;
		cresult = This.Parent.txtExpression.Value, ;
		Left = 576, ;
		Name = "cmdExprExpr", ;
		TabIndex = 7, ;
		Top = 37
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagIndex.cmdExprFilter' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Filter:, ;
		cdefaultexpression = This.Parent.txtFilter.Value, ;
		cexpressiontype = L, ;
		cresult = This.Parent.txtFilter.Value, ;
		Left = 576, ;
		Name = "cmdExprFilter", ;
		TabIndex = 10, ;
		Top = 62
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagIndex.cmdWizard' AS sdtpicturebutton WITH ;
		Left = 341, ;
		Name = "cmdWizard", ;
		Picture = wizard.bmp, ;
		StatusBarText = "Index Wizard", ;
		TabIndex = 22, ;
		ToolTipText = "Index Wizard", ;
		Top = 281
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagIndex.edtComment' AS sdteditbox WITH ;
		ControlSource = "_indexes.comment", ;
		czoomformcaption = Comment, ;
		Height = 68, ;
		Left = 224, ;
		Name = "edtComment", ;
		TabIndex = 15, ;
		Top = 112, ;
		Width = 376
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'pgfTable.pagIndex.lblCaption' AS sdtlabel WITH ;
		Caption = "Caption", ;
		Left = 149, ;
		Name = "lblCaption", ;
		TabIndex = 11, ;
		Top = 90, ;
		Width = 45
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagIndex.lblCollate' AS sdtlabel WITH ;
		Caption = "Collate", ;
		Left = 149, ;
		Name = "lblCollate", ;
		TabIndex = 16, ;
		Top = 185, ;
		Width = 41
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagIndex.lblComment' AS sdtlabel WITH ;
		Caption = "Comment", ;
		Left = 149, ;
		Name = "lblComment", ;
		TabIndex = 14, ;
		Top = 115, ;
		Width = 57
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagIndex.lblExpression' AS sdtlabel WITH ;
		Caption = "Expression", ;
		Left = 149, ;
		Name = "lblExpression", ;
		TabIndex = 5, ;
		Top = 40, ;
		Width = 64
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagIndex.lblFilter' AS sdtlabel WITH ;
		Caption = "Filter", ;
		Left = 149, ;
		Name = "lblFilter", ;
		TabIndex = 8, ;
		Top = 65, ;
		Width = 29
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagIndex.lblName' AS sdtlabel WITH ;
		Caption = "Name", ;
		Left = 149, ;
		Name = "lblName", ;
		TabIndex = 1, ;
		Top = 15, ;
		Width = 36
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagIndex.lblType' AS sdtlabel WITH ;
		Caption = "Type", ;
		Left = 354, ;
		Name = "lblType", ;
		TabIndex = 3, ;
		Top = 15, ;
		Width = 28
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagIndex.txtCaption' AS sdttextbox WITH ;
		ControlSource = "_indexes.caption", ;
		Left = 224, ;
		Name = "txtCaption", ;
		TabIndex = 12, ;
		Top = 87, ;
		Width = 350
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagIndex.txtExpression' AS sdttextbox WITH ;
		ControlSource = "_indexes.expression", ;
		Left = 224, ;
		Name = "txtExpression", ;
		TabIndex = 6, ;
		Top = 37, ;
		Width = 350
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagIndex.txtFilter' AS sdttextbox WITH ;
		ControlSource = "_indexes.filter", ;
		Left = 224, ;
		Name = "txtFilter", ;
		TabIndex = 9, ;
		Top = 62, ;
		Width = 350
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagIndex.txtName' AS sdtfilterinput WITH ;
		ccharvalid = isalpha(<key>) or isdigit(<key>) or <key> = '_', ;
		cfirstcharvalid = isalpha(<key>) or <key>='_', ;
		Format = "!", ;
		laudiblealert = .T., ;
		Left = 224, ;
		MaxLength = 10, ;
		Name = "txtName", ;
		TabIndex = 2, ;
		Top = 12, ;
		Width = 101
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagIndex2.cntExtProps' AS sdtextendedprops WITH ;
		ccurrobjecttype = Index, ;
		Left = 229, ;
		Name = "cntExtProps", ;
		Top = 7, ;
		cntValues.chkValue.Alignment = 0, ;
		cntValues.chkValue.Name = "chkValue", ;
		cntValues.cmdDelete.Name = "cmdDelete", ;
		cntValues.cmdEdit.Name = "cmdEdit", ;
		cntValues.cmdNew.Name = "cmdNew", ;
		cntValues.edtValue.Name = "edtValue", ;
		cntValues.lblValue.Name = "lblValue", ;
		cntValues.ltd = .T., ;
		cntValues.Name = "cntValues", ;
		cntValues.spnValue.Name = "spnValue", ;
		cntValues.txtDValue.Name = "txtDValue", ;
		cntValues.txtTValue.Name = "txtTValue", ;
		cntValues.txtValue.Name = "txtValue", ;
		grdProperty.grcField.grhField.Name = "grhField", ;
		grdProperty.grcField.Name = "grcField", ;
		grdProperty.grcField.txtField.Name = "txtField", ;
		grdProperty.grcName.grhName.Name = "grhName", ;
		grdProperty.grcName.Name = "grcName", ;
		grdProperty.grcName.txtName.Name = "txtName", ;
		grdProperty.grcType.grhType.Name = "grhType", ;
		grdProperty.grcType.Name = "grcType", ;
		grdProperty.grcType.txtType.Name = "txtType", ;
		grdProperty.Name = "grdProperty"
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />

	ADD OBJECT 'pgfTable.pagTable.boxStats' AS sdtlabelledbox WITH ;
		Height = 70, ;
		Left = 9, ;
		Name = "boxStats", ;
		TabIndex = 3, ;
		Top = 42, ;
		Width = 395, ;
		lblLabel.Caption = " Statistics: ", ;
		lblLabel.Name = "lblLabel", ;
		shpBox.Height = 64, ;
		shpBox.Name = "shpBox", ;
		shpBox.Width = 395
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'pgfTable.pagTable.boxTriggers' AS sdtlabelledbox WITH ;
		Height = 105, ;
		Left = 294, ;
		Name = "boxTriggers", ;
		TabIndex = 20, ;
		Top = 117, ;
		Width = 310, ;
		lblLabel.Caption = " Triggers: ", ;
		lblLabel.Name = "lblLabel", ;
		shpBox.Height = 99, ;
		shpBox.Name = "shpBox", ;
		shpBox.Width = 310
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'pgfTable.pagTable.boxValid' AS sdtlabelledbox WITH ;
		Height = 80, ;
		Left = 9, ;
		Name = "boxValid", ;
		TabIndex = 13, ;
		Top = 117, ;
		Width = 265, ;
		lblLabel.Caption = " Record validation: ", ;
		lblLabel.Name = "lblLabel", ;
		shpBox.Height = 74, ;
		shpBox.Name = "shpBox", ;
		shpBox.Width = 265
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="container" />

	ADD OBJECT 'pgfTable.pagTable.cboCodePage' AS sdtcombobox WITH ;
		BoundTo = .F., ;
		Left = 436, ;
		Name = "cboCodePage", ;
		RowSource = "Thisform.aCodePage", ;
		RowSourceType = 5, ;
		Style = 2, ;
		TabIndex = 12, ;
		Top = 92, ;
		Width = 166
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'pgfTable.pagTable.cmdExprDelete' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = DELETE trigger:, ;
		cdefaultexpression = This.Parent.txtDelete.Value, ;
		cexpressiontype = , ;
		cresult = This.Parent.txtDelete.Value, ;
		Left = 574, ;
		Name = "cmdExprDelete", ;
		TabIndex = 29, ;
		Top = 187
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagTable.cmdExprInsert' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = INSERT trigger:, ;
		cdefaultexpression = This.Parent.txtInsert.Value, ;
		cexpressiontype = , ;
		cresult = This.Parent.txtInsert.Value, ;
		Left = 574, ;
		Name = "cmdExprInsert", ;
		TabIndex = 23, ;
		Top = 137
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagTable.cmdExprRule' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Validation rule:, ;
		cdefaultexpression = This.Parent.txtTblValidRule.Value, ;
		cexpressiontype = , ;
		cresult = This.Parent.txtTblValidRule.Value, ;
		Left = 244, ;
		Name = "cmdExprRule", ;
		TabIndex = 16, ;
		Top = 137
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagTable.cmdExprText' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = Validation text:, ;
		cdefaultexpression = This.Parent.txtTblValidText.Value, ;
		cexpressiontype = C, ;
		cresult = This.Parent.txtTblValidText.Value, ;
		Left = 244, ;
		Name = "cmdExprText", ;
		TabIndex = 19, ;
		Top = 161
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagTable.cmdExprUpdate' AS sfgetexpression WITH ;
		calias = Thisform.cAlias, ;
		ccaptiontext = UPDATE trigger:, ;
		cdefaultexpression = This.Parent.txtUpdate.Value, ;
		cexpressiontype = , ;
		cresult = This.Parent.txtUpdate.Value, ;
		Left = 574, ;
		Name = "cmdExprUpdate", ;
		TabIndex = 26, ;
		Top = 162
		*< END OBJECT: ClassLib="..\..\sfcommon\sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfTable.pagTable.edtTblComment' AS sdteditbox WITH ;
		czoomformcaption = Comment, ;
		Height = 53, ;
		Left = 9, ;
		MaxLength = 255, ;
		Name = "edtTblComment", ;
		TabIndex = 31, ;
		Top = 232, ;
		Width = 595
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'pgfTable.pagTable.lblBlockSize' AS sdtlabel WITH ;
		Caption = "Block size:", ;
		Left = 436, ;
		Name = "lblBlockSize", ;
		TabIndex = 9, ;
		Top = 51
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagTable.lblCodePage' AS sdtlabel WITH ;
		Caption = "Code page:", ;
		Left = 436, ;
		Name = "lblCodePage", ;
		TabIndex = 11, ;
		Top = 72
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagTable.lblComment' AS sdtlabel WITH ;
		Caption = "Table comment", ;
		Left = 9, ;
		Name = "lblComment", ;
		TabIndex = 30, ;
		Top = 212, ;
		Width = 88
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagTable.lblDelete' AS sdtlabel WITH ;
		Caption = "Delete trigger", ;
		Left = 304, ;
		Name = "lblDelete", ;
		TabIndex = 27, ;
		Top = 190, ;
		Width = 76
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagTable.lblInsert' AS sdtlabel WITH ;
		Caption = "Insert trigger", ;
		Left = 304, ;
		Name = "lblInsert", ;
		TabIndex = 21, ;
		Top = 140, ;
		Width = 71
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagTable.lblMessage' AS sdtlabel WITH ;
		Caption = "Message", ;
		Left = 19, ;
		Name = "lblMessage", ;
		TabIndex = 17, ;
		Top = 164, ;
		Width = 53
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagTable.lblPath' AS sdtlabel WITH ;
		Caption = "Table file:", ;
		Left = 24, ;
		Name = "lblPath", ;
		TabIndex = 4, ;
		Top = 63
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagTable.lblRule' AS sdtlabel WITH ;
		Caption = "Rule", ;
		Left = 19, ;
		Name = "lblRule", ;
		TabIndex = 14, ;
		Top = 140, ;
		Width = 28
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagTable.lblTableName' AS sdtlabel WITH ;
		Caption = "Name:", ;
		Left = 9, ;
		Name = "lblTableName", ;
		TabIndex = 1, ;
		Top = 15, ;
		Width = 39
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagTable.lblUpdate' AS sdtlabel WITH ;
		Caption = "Update trigger", ;
		Left = 304, ;
		Name = "lblUpdate", ;
		TabIndex = 24, ;
		Top = 165, ;
		Width = 80
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfTable.pagTable.spnBlockSize' AS sdtspinner WITH ;
		Height = 24, ;
		KeyboardHighValue = 99999, ;
		KeyboardLowValue = 1, ;
		Left = 499, ;
		Name = "spnBlockSize", ;
		SelectOnEntry = .T., ;
		SpinnerHighValue = 99999.00, ;
		SpinnerLowValue = 1.00, ;
		TabIndex = 10, ;
		Top = 47, ;
		Width = 65
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="spinner" />

	ADD OBJECT 'pgfTable.pagTable.txtDelete' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 389, ;
		MaxLength = 254, ;
		Name = "txtDelete", ;
		TabIndex = 28, ;
		Top = 187, ;
		Width = 185
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagTable.txtFields' AS sdtreadonlytextbox WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		Left = 159, ;
		Margin = 0, ;
		Name = "txtFields", ;
		TabIndex = 7, ;
		Top = 82, ;
		Width = 86
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagTable.txtInsert' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 389, ;
		MaxLength = 254, ;
		Name = "txtInsert", ;
		TabIndex = 22, ;
		Top = 137, ;
		Width = 185
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagTable.txtLength' AS sdtreadonlytextbox WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		Left = 259, ;
		Margin = 0, ;
		Name = "txtLength", ;
		TabIndex = 8, ;
		Top = 82, ;
		Width = 86
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagTable.txtPath' AS sdtreadonlytextbox WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		Left = 84, ;
		Name = "txtPath", ;
		TabIndex = 5, ;
		Top = 62, ;
		Width = 311
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagTable.txtRecords' AS sdtreadonlytextbox WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		Left = 24, ;
		Margin = 0, ;
		Name = "txtRecords", ;
		TabIndex = 6, ;
		Top = 82, ;
		Width = 121
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagTable.txtTableName' AS sdtfilterinput WITH ;
		ccharvalid = isalpha(<key>) or isdigit(<key>) or <key> $ ' _', ;
		cfirstcharvalid = isalpha(<key>) or <key> = '_', ;
		Height = 23, ;
		laudiblealert = .T., ;
		Left = 64, ;
		Name = "txtTableName", ;
		TabIndex = 2, ;
		Top = 12, ;
		Width = 540
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagTable.txtTblValidRule' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 74, ;
		MaxLength = 254, ;
		Name = "txtTblValidRule", ;
		TabIndex = 15, ;
		Top = 137, ;
		Width = 170
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagTable.txtTblValidText' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 74, ;
		MaxLength = 254, ;
		Name = "txtTblValidText", ;
		TabIndex = 18, ;
		Top = 161, ;
		Width = 170
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagTable.txtUpdate' AS sdttextbox WITH ;
		Height = 23, ;
		Left = 389, ;
		MaxLength = 254, ;
		Name = "txtUpdate", ;
		TabIndex = 25, ;
		Top = 162, ;
		Width = 185
		*< END OBJECT: ClassLib="sdtcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfTable.pagTable2.cntExtProps' AS sdtextendedprops WITH ;
		ccurrobjecttype = Table, ;
		Height = 278, ;
		Left = 119, ;
		lgotobject = .T., ;
		Name = "cntExtProps", ;
		Top = 7, ;
		Width = 480, ;
		cntValues.chkValue.Alignment = 0, ;
		cntValues.chkValue.Name = "chkValue", ;
		cntValues.cmdDelete.Left = 207, ;
		cntValues.cmdDelete.Name = "cmdDelete", ;
		cntValues.cmdDelete.Top = 85, ;
		cntValues.cmdEdit.Left = 272, ;
		cntValues.cmdEdit.Name = "cmdEdit", ;
		cntValues.cmdEdit.Top = 85, ;
		cntValues.cmdNew.Left = 142, ;
		cntValues.cmdNew.Name = "cmdNew", ;
		cntValues.cmdNew.Top = 85, ;
		cntValues.edtValue.Height = 53, ;
		cntValues.edtValue.Left = 0, ;
		cntValues.edtValue.Name = "edtValue", ;
		cntValues.edtValue.Top = 20, ;
		cntValues.edtValue.Width = 475, ;
		cntValues.Height = 108, ;
		cntValues.lblValue.Name = "lblValue", ;
		cntValues.Left = 0, ;
		cntValues.ltd = .T., ;
		cntValues.Name = "cntValues", ;
		cntValues.spnValue.Name = "spnValue", ;
		cntValues.Top = 170, ;
		cntValues.txtDValue.Name = "txtDValue", ;
		cntValues.txtTValue.Name = "txtTValue", ;
		cntValues.txtValue.Name = "txtValue", ;
		cntValues.Width = 475, ;
		grdProperty.grcField.grhField.Name = "grhField", ;
		grdProperty.grcField.Name = "grcField", ;
		grdProperty.grcField.txtField.Name = "txtField", ;
		grdProperty.grcName.grhName.Name = "grhName", ;
		grdProperty.grcName.Name = "grcName", ;
		grdProperty.grcName.txtName.Name = "txtName", ;
		grdProperty.grcName.Width = 274, ;
		grdProperty.grcType.grhType.Name = "grhType", ;
		grdProperty.grcType.Name = "grcType", ;
		grdProperty.grcType.txtType.Name = "txtType", ;
		grdProperty.Height = 163, ;
		grdProperty.Left = 0, ;
		grdProperty.Name = "grdProperty", ;
		grdProperty.Panel = 1, ;
		grdProperty.Top = 0, ;
		grdProperty.Width = 475
		*< END OBJECT: ClassLib="sdtccontrol.vcx" BaseClass="container" />
	
	PROCEDURE Activate
		on key label Ctrl+A    _screen.ActiveForm.AddHotKey()
		on key label Ctrl+PgUp _screen.ActiveForm.PgUpHotKey()
		on key label Ctrl+PgDn _screen.ActiveForm.PgDnHotKey()
		
	ENDPROC

	PROCEDURE addfield		&& Adds a new field to FIELDS.
		* Add a new field to _FIELDS.
		
		with This.lstFields
			insert into _FIELDS (XTYPE, NSIZE, NDECIMALS, LNULL, FILTER) values ;
				('Character', 10, 0, set('NULL') = 'ON', .T.)
			This.CalcTableSize()
			.AddItem('')
			.ListIndex = .NewIndex
		endwith
		This.HandleType(XTYPE)
		
	ENDPROC

	PROCEDURE addhotkey		&& Adds a new field or index (fired from a hot key)
		do case
			case This.pgfTable.ActivePage < 4
				This.cmdAdd.Click()
			case This.pgfTable.ActivePage < 6
				This.pgfTable.pagIndex.cmdAdd.Click()
		endcase
		
	ENDPROC

	PROCEDURE addindex		&& Adds a new index to INDEXES.
		* Add a new index to _INDEXES.
		
		local lcCollate
		with This.lstIndexes
			lcCollate = iif(type('This.oSDTForm.oController.Name') = 'C', ;
				This.oSDTForm.oController.cCollate, proper(set('COLLATE')))
			insert into _INDEXES (TYPE, COLLATE, SELECT) ;
				values ('Regular', lcCollate, .T.)
			.AddItem('')
			.ListIndex = .NewIndex
		endwith
		
	ENDPROC

	PROCEDURE calctablesize
		local lnRecno, ;
			lnLength, ;
			lnFields
		
		* Calculate the total record size from the cursor and display it.
		
		if This.cAlias <> ccLIBRARY_TABLE
			select _FIELDS
			lnRecno = recno()
			sum NSIZE, 1 to lnLength, lnFields for empty(XEXPR)
			with This.pgfTable.pagTable
				.txtFields.Value = strtran(ccFRM_TD_FIELDS, ccMSG_INSERT1, ;
					ltrim(str(lnFields)))
				.txtLength.Value = strtran(ccFRM_TD_LENGTH, ccMSG_INSERT1, ;
					ltrim(str(lnLength)))
			endwith
			if lnRecno <= reccount()
				go lnRecno
			endif lnRecno <= reccount()
		endif This.cAlias <> ccLIBRARY_TABLE
		
	ENDPROC

	PROCEDURE checkindexexpression		&& Checks the index expression
		* Find out if the index expression involves more than one field.
		
		lparameters tcExpression
		local lcGotField, ;
			lcExpression, ;
			lnRecno, ;
			lcField, ;
			lnIndexRecno, ;
			llFound, ;
			luValid
		with This
			lcGotField   = ''
			lcExpression = strtran(strtran(strtran(tcExpression, .cAlias + '.'), ;
				upper(.cAlias) + '.'), proper(.cAlias) + '.')
			select _FIELDS
			lnRecno = recno()
			scan
				lcField = trim(CFIELD)
				if .oUtility.InExpr(lcField, lcExpression)
					lcGotField = lcGotField + lcField + ','
					if lcField == lcExpression
						exit
					endif lcField == lcExpression
				endif .oUtility.InExpr(lcField, lcExpression)
			endscan
			select _INDEXES
		
		* If the tag name and/or caption are blank and this index comes from a single
		* field, set the tag name and caption to defaults.
		
			with .pgfTable.pagIndex
				.cboCollate.Enabled = .T.
				if not lcExpression == tcExpression
					replace EXPRESSION with lcExpression
					.txtExpression.Refresh()
				endif not lcExpression == tcExpression
				if (empty(.txtName.Value) or empty(.txtCaption.Value)) ;
					and occurs(',', lcGotField) = 1
					select _FIELDS
					seek padr(left(lcGotField, len(lcGotField) - 1), len(CFIELD))
					select _INDEXES
					if found('_FIELDS')
						if empty(.txtName.Value)
							lnIndexRecno = recno()
							llFound      = seek(padr(_FIELDS.CFIELD, len(NAME)))
							if lnIndexRecno <= reccount()
								go lnIndexRecno
							endif lnIndexRecno <= reccount()
							if not llFound
								replace NAME with iif(empty(NAME), _FIELDS.CFIELD, ;
									NAME)
								.txtName.Refresh()
								Thisform.cCurrentTag = _INDEXES.NAME
								luValid = .txtName.Valid()
								if vartype(luValid) <> 'L' or not luValid
									.txtName.SetFocus()
								endif vartype(luValid) <> 'L' ...
							endif not llFound
						endif empty(.txtName.Value)
						if empty(.txtCaption.Value)
							replace CAPTION with iif(empty(CAPTION), ;
								_FIELDS.XCAPTION, CAPTION)
							.txtCaption.Refresh()
						endif empty(.txtCaption.Value)
					endif found('_FIELDS')
				endif (empty(.txtName.Value) ...
			endwith
			if lnRecno <= reccount('_FIELDS')
				go lnRecno in _FIELDS
			endif lnRecno <= reccount('_FIELDS')
		endwith
		
	ENDPROC

	PROCEDURE createindexes
		local oSDT, ;
			lcAlias, ;
			lcCurrCollate, ;
			lcCurrTalk, ;
			llError, ;
			llPHD, ;
			lcPHD, ;
			lcTag, ;
			lcExpression, ;
			lcForExpr, ;
			lcCollate, ;
			lcType, ;
			lcOptions, ;
			luValue, ;
			luForValue, ;
			lcError
		
		with This
			.oError.ResetError()
			oSDT          = .oMeta.oSDTMgr
			lcAlias       = alias()
			lcCurrCollate = set('COLLATE')
			lcCurrTalk    = set('TALK', 1)
			llError       = .F.
		
		* Prepare to handle PHD if necessary.
		
			llPHD = 'PHDBASE' $ upper(set('LIBRARY'))
			if file('PHDBASE.V50')
				lcPHD = 'PHDBASE.V50'
			else
				lcPHD = 'PHDBASE'
			endif file('PHDBASE.V50')
		
		* Create the indexes.
		
			set talk window
			select _INDEXES
			scan for not empty(NAME)
				lcTag        = trim(NAME)
				lcExpression = trim(EXPRESSION)
				lcForExpr    = trim(FILTER)
				lcCollate    = .GetCollate(COLLATE)
				lcType       = left(TYPE, 1)
				lcOptions    = iif(lcType = 'B', ' binary', ;
					iif(empty(FILTER), '', ' for ' + trim(FILTER)) + ;
					iif(DESCEND, ' descending', '') + iif(lcType = 'U', ' unique', '') + ;
					iif(lcType = 'C' or lcType = 'P', ' candidate', ''))
				select (lcAlias)
				luValue      = iif(upper(left(lcExpression, 4)) = 'PHD(', '.T.', ;
					evaluate(lcExpression))
				luForValue   = iif(empty(lcForExpr), '.T.', evaluate(lcForExpr))
				.oError.SetSuppressErrors(.T.)
				do case
		
		* If this is a PHDBASE index, handle it: load PHDBASE if it isn't already and
		* we can find it. Create the index if we can. If not, give an error message.
		
					case upper(left(lcExpression, 4)) = 'PHD('
						if not llPHD and file(lcPHD) and ;
							not 'PHDBASE' $ upper(set('LIBRARY'))
							set library to ('PHDBASE') additive
						endif not llPHD ...
						if 'PHDBASE' $ upper(set('LIBRARY'))
							set talk on
							= evaluate(lcExpression)
							set talk off
							lcError = .oError.aClassError[cnAERR_MESSAGE]
							llError = .oError.DidErrorOccur()
						else
							lcError = strtran(strtran(ccERR_NO_PHDBASE, ccMSG_INSERT1, ;
								lcTag), ccMSG_INSERT2, .cAlias)
							llError = .T.
						endif 'PHDBASE' $ upper(set('LIBRARY'))
		
		* If all of the expressions are valid, set the collate sequence as necessary.
		* Create the index and reset the collate sequence.
		
					case vartype(luValue) <> 'U' and vartype(luForValue) <> 'U'
						if cpcurrent() <> 0 and cpdbf() <> 0
							set collate to lcCollate
						endif cpcurrent() <> 0 ...
						set talk on
						index on &lcExpression tag (lcTag) &lcOptions
						set talk off
						if cpcurrent() <> 0
							set collate to lcCurrCollate
						endif cpcurrent() <> 0
						lcError = .oError.aClassError[cnAERR_MESSAGE]
						llError = .oError.DidErrorOccur()
		
		* If this is the primary key, flag it in the DBC.
		
						if lcType = 'P' and not llError
							.oMeta.oSDTMgr.DBCOpen(.cDBC)
							oSDT.DBCFindObject(.cAlias, 'Table')
							oSDT.DBCSetProp(cnVF_TABLE_PRIMARYTAG, lcTag)
							use
							select (lcAlias)
						endif lcType = 'P' ...
		
		* The index expression was invalid.
		
					otherwise
						lcError = ccERR_IDX_EXPR_INVALID
						llError = .T.
				endcase
		
		* Exit if an error occurred.
		
				.oError.SetSuppressErrors(.F.)
				if llError
					.IndexError(lcTag, lcError)
					exit
				endif llError
				select _INDEXES
			endscan for not empty(NAME) ...
		endwith
		
		* Cleanup and exit.
		
		if 'PHDBASE' $ upper(set('LIBRARY')) and not llPHD
			release library ('PHDBASE')
		endif 'PHDBASE' $ upper(set('LIBRARY')) ...
		set talk &lcCurrTalk
		select (lcAlias)
		return not llError
		
	ENDPROC

	PROCEDURE createtable
		* Create the table.
		
		lparameters tcFile, ;
			tcAlias
		local laTable[1], ;
			lnBlockSize, ;
			lnCurrBlock
		with This
			.oError.ResetError()
			.GetTableStructure(@laTable, .T.)
		
		* Get the blocksize and set it.
		
			lnBlockSize = .nBlockSize
			lnCurrBlock = set('BLOCKSIZE')
			set blocksize to lnBlockSize
		
		* Create the table and reset the blocksize.
		
			create table (tcFile) name (tcAlias) from array laTable
			set blocksize to lnCurrBlock
		
		* If everything went OK, write the appropriate code page for the table.
		
			if not .oError.DidErrorOccur()
				use
				.oMeta.oSDTMgr.WriteCodePage(.nCodePage,, tcFile)
		
		* If the table name has spaces, VFP created it with underscores, so we need to
		* rename it to get the desired name. Then reopen the table.
		
				if ' ' $ tcAlias and not indbc(tcAlias, 'Table')
					rename table  (strtran(tcAlias, ' ', '_')) to (tcAlias)
				endif ' ' $ tcAlias ...
				use (tcAlias) exclusive
			endif not .oError.DidErrorOccur()
		endwith
		return not This.oError.DidErrorOccur()
		
	ENDPROC

	PROCEDURE Deactivate
		This.ResetHotKeys()
		
	ENDPROC

	PROCEDURE Destroy
		This.ResetHotKeys()
		tablerevert(.T., '_FIELDS')
		tablerevert(.T., '_INDEXES')
		use in _FIELDS
		use in _INDEXES
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lcReturn
		do case
		
		* We couldn't open the table, so just return.
		
			case upper(tcMethod) = 'OPENTABLE'
				return
		
		* Use the normal error handling mechanism for all other types of errors. Note
		* that we add a period to the method name passed. This tells our parent class
		* to return the error resolution string back to us, which is required for RETRY
		* to work.
		
			otherwise
				lcReturn = dodefault(tnError, '.' + tcMethod, tnLine)
				lcReturn = iif(vartype(lcReturn) <> 'C', ccMSG_CONTINUE, lcReturn)
				do case
		
		* It wasn't our error, so pass it back to the calling method.
		
					case '.' $ tcMethod
						return lcReturn
		
		* Handle the error choices.
		
					case lcReturn = ccMSG_RETRY
						retry
					case lcReturn = ccMSG_DEBUG
						debug
						if wexist('Visual FoxPro Debugger')
							keyboard '{SHIFT+F7}' plain
						endif wexist('Visual FoxPro Debugger')
						suspend
					case lcReturn = ccMSG_CANCEL
						cancel
					otherwise
						return
				endcase
		endcase
		return lcReturn
		
	ENDPROC

	PROCEDURE exitwithoutsave		&& Returns .T. if the user wants to exit the form without saving.
		local llReturn
		if getnextmodified(0, '_FIELDS') <> 0 or getnextmodified(0, '_INDEXES') <> 0
			llReturn = This.oMessage.YesNo(ccQST_EXIT_NO_SAVE)
		else
			llReturn = .T.
		endif getnextmodified(0, '_FIELDS') <> 0 ...
		return llReturn
		
	ENDPROC

	PROCEDURE getcollate
		lparameters tcCollate
		local laCollate[1], ;
			lnCollate, ;
			lcCollate
		with This
			acopy(.aCollate, laCollate)
			lnCollate = .oUtility.ArrayScan(@laCollate, alltrim(tcCollate))
			lcCollate = iif(type('.oSDTForm.oController.Name') = 'C', ;
				.oSDTForm.oController.cCollate, proper(set('COLLATE')))
			return iif(lnCollate > 0, .aCollate[lnCollate, 2], lcCollate)
		endwith
		
	ENDPROC

	PROCEDURE getfieldtype		&& Returns the full-text field type for a given field type.
		lparameters tcType, ;
			tlBinary, ;
			tlAutoInc
		local lcType, ;
			laTypes[1], ;
			lnType
		with This
			do case
				case tcType = 'C' and tlBinary
					lcType = 'Character (Binary)'
				case tcType = 'M' and tlBinary
					lcType = 'Memo (Binary)'
				case tcType = 'V' and tlBinary
					lcType = 'Varchar (Binary)'
				case tcType = 'I' and tlAutoInc
					lcType = 'Integer (Auto-Inc)'
				otherwise
					acopy(.aDataTypes, laTypes)
					lnType = .oUtility.ArrayScan(@laTypes, tcType, 2)
					lcType = .aDataTypes[lnType, 1]
			endcase
		endwith
		return lcType
		
	ENDPROC

	PROCEDURE getindexes
		lparameters taIndexes
		local lnIndex
		#define cnCOLUMNS 7
		select _INDEXES
		lnIndex = 0
		dimension taIndexes[1, cnCOLUMNS]
		taIndexes = ''
		taIndexes[1, 6] = .F.
		scan for not empty(NAME)
			lnIndex = lnIndex + 1
			dimension taIndexes[lnIndex, cnCOLUMNS]
			taIndexes[lnIndex, 1] = trim(NAME)
			taIndexes[lnIndex, 2] = trim(EXPRESSION)
			taIndexes[lnIndex, 3] = trim(FILTER)
			taIndexes[lnIndex, 4] = This.GetCollate(COLLATE)
			taIndexes[lnIndex, 5] = left(TYPE, 1)
			taIndexes[lnIndex, 6] = not DESCEND
			taIndexes[lnIndex, 7] = trim(PREVNAME)
		endscan for not empty(NAME)
		return
		
	ENDPROC

	PROCEDURE getlibraryclasses
		lparameters tcLibrary
		local laClasses[1], ;
			lnClasses, ;
			lnI, ;
			lcAlias
		with This.pgfTable.Page2.cboClass
		
		* If there is no VCX file specified, ensure the class combobox has base classes
		* in it. We'll also do this if we can't find the selected VCX (it probably
		* wasn't just selected now, but is there because we're editing a table).
		
			if empty(tcLibrary) or not file(tcLibrary)
				if not empty(tcLibrary)
					This.oMessage.ErrorMessage(strtran(strtran(ccERR_VCX_NOT_EXIST, ;
						ccMSG_INSERT1, trim(_FIELDS.CFIELD)), ccMSG_INSERT2, ;
						trim(tcLibrary)))
				endif not empty(tcLibrary)
				dimension .aItems[cnBASE_CLASSES]
				.aItems[ 1] = ccDEFAULT_CLASS
				.aItems[ 2] = ccCHECKBOX
				.aItems[ 3] = ccCOMBOBOX
				.aItems[ 4] = ccEDITBOX
				.aItems[ 5] = ccGRID
				.aItems[ 6] = ccLISTBOX
				.aItems[ 7] = ccOLEBOUNDCONTROL
				.aItems[ 8] = ccOPTIONGROUP
				.aItems[ 9] = ccSPINNER
				.aItems[10] = ccTEXTBOX
		
		* Open the specified VCX file and put all of the classes defined in it into the
		* class combobox.
		
			else
				lnClasses = avcxclasses(laClasses, trim(tcLibrary))
				dimension .aItems[lnClasses]
				for lnI = 1 to lnClasses
					.aItems[lnI] = laClasses[lnI, 1]
				next lnI
				asort(.aItems)
			endif empty(tcLibrary)
			.Requery()
		
		* If the currently selected class isn't in the selected VCX, default the class
		* to the first class in the VCX.
		
			.Refresh()
			if not empty(_FIELDS.XAUTOCLASS)
				dimension laClasses[1]
				acopy(.aItems, laClasses)
				if This.oUtility.ArrayScan(@laClasses, trim(_FIELDS.XAUTOCLASS)) = 0
					replace XAUTOCLASS with .aItems[1] in _FIELDS
					.Refresh()
					.ListIndex = 1
				endif This.oUtility.ArrayScan( ...
			else
				.ListIndex = 1
			endif not empty(_FIELDS.XAUTOCLASS)
		endwith
		
	ENDPROC

	PROCEDURE gettablestructure
		lparameters taTable, ;
			tlVFPStructure
		local lnField, ;
			laDataTypes[1], ;
			lnColumns, ;
			lnI, ;
			lnType
		with This
			select _FIELDS
			lnField = 0
			acopy(.aDataTypes, laDataTypes)
			do case
				case version(5) < 800 and tlVFPStructure
					lnColumns = 16
				case version(5) < 800 or (version(5) >= 800 and tlVFPStructure)
					lnColumns = 18
				otherwise
					lnColumns = 20
			endcase
			for lnI = 1 to .lstFields.ListCount
				seek padr(.lstFields.List[lnI], len(CFIELD))
				if not empty(CFIELD) and empty(XEXPR)
					lnField = lnField + 1
					dimension taTable[lnField, lnColumns]
					taTable[lnField, 1] = trim(CFIELD)
					lnType = .oUtility.ArrayScan(@laDataTypes, trim(XTYPE))
					taTable[lnField, 2] = .aDataTypes[lnType, 2]
					taTable[lnField, 3] = NSIZE
					taTable[lnField, 4] = NDECIMALS
					taTable[lnField, 5] = LNULL
					taTable[lnField, 6] = LBINARY
					taTable[lnField, 7] = trim(XVALID)
					taTable[lnField, 8] = trim(XERROR)
					taTable[lnField, 9] = trim(XDEFAULT)
					if lnField = 1
						taTable[lnField, 10] = trim(.pgfTable.pagTable.txtTblValidRule.Value)
						taTable[lnField, 11] = trim(.pgfTable.pagTable.txtTblValidText.Value)
					else
						store '' to taTable[lnField, 10], taTable[lnField, 11]
					endif lnField = 1
					store '' to taTable[lnField, 12], taTable[lnField, 13], ;
						taTable[lnField, 14], taTable[lnField, 15], ;
						taTable[lnField, 16]
					do case
						case version(5) < 800 and tlVFPStructure
						case version(5) < 800
							taTable[lnField, 17] = trim(PREVNAME)
							taTable[lnField, 18] = .cAlias + '.' + taTable[lnField, 1]
						case tlVFPStructure
							taTable[lnField, 17] = NNEXTVALUE
							taTable[lnField, 18] = NSTEPVALUE
						otherwise
							taTable[lnField, 17] = NNEXTVALUE
							taTable[lnField, 18] = NSTEPVALUE
							taTable[lnField, 19] = trim(PREVNAME)
							taTable[lnField, 20] = .cAlias + '.' + taTable[lnField, 1]
					endcase
				endif not empty(CFIELD) ...
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE handleblankfield
		local llGotFields, ;
			lnRecno, ;
			llBlankOne
		with This
			llGotFields = not (eof() or deleted())
			lnRecno     = recno()
			seek space(len(CFIELD))
			llBlankOne  = found() and .lstFields.ListCount > 1
			if lnRecno <= reccount()
				go lnRecno
			endif lnRecno <= reccount()
			if empty(_FIELDS.CFIELD)
				.cmdDelete.Enabled = llGotFields
				.cmdCopy.Enabled   = .F.
				.pgfTable.pagFields3.cntExtProps.lGotObject = .F.
			else
				.cmdDelete.Enabled = .T.
				.cmdCopy.Enabled   = not llBlankOne
				.pgfTable.pagFields3.cntExtProps.lGotObject = not This.lNew and ;
					not empty(PREVNAME)
			endif empty(_FIELDS.CFIELD)
			.HandleType(XTYPE)
		endwith
		
	ENDPROC

	PROCEDURE handleblankindex
		local llGotIndexes
		llGotIndexes = not (eof() or deleted())
		with This.pgfTable
			if empty(_INDEXES.NAME)
				.pagIndex.cmdDelete.Enabled = llGotIndexes
				.pagIndex2.cntExtProps.lGotObject = .F.
			else
				.pagIndex.cmdDelete.Enabled = .T.
				.pagIndex2.cntExtProps.lGotObject = not This.lNew and ;
					not empty(PREVNAME)
			endif empty(_INDEXES.NAME)
		endwith
		
	ENDPROC

	PROCEDURE handletype
		lparameters tcType
		with This.pgfTable.Page1
			do case
				case inlist(tcType, 'Character', 'Varchar', 'Varbinary')
					.spnWidth.Enabled    = .T.
					.spnDecimals.Enabled = .F.
				case inlist(tcType, 'Currency', 'Memo', 'Logical', 'General', ;
					'Integer', 'Date', 'DateTime', 'Blob')
					.spnWidth.Enabled    = .F.
					.spnDecimals.Enabled = .F.
				case tcType = 'Numeric' or tcType = 'Float'
					.spnWidth.Enabled    = .T.
					.spnDecimals.Enabled = .T.
				case tcType = 'Double'
					.spnWidth.Enabled    = .F.
					.spnDecimals.Enabled = .T.
			endcase
		endwith
		
	ENDPROC

	PROCEDURE indexerror		&& Display an error regarding an invalid index.
		lparameters tcTag, ;
			tcMessage
		This.oMessage.ErrorMessage(strtran(ccERR_INDEX_INVALID, ccMSG_INSERT1, ;
			tcTag) + ccCR + ccCR + tcMessage)
		return
		
	ENDPROC

	PROCEDURE indexinrelation
		* See if this index is involved in a relation.
		
		lparameters tcTag
		local lcTag, ;
			laRelations[1], ;
			lcAlias, ;
			llGotOne, ;
			lnStart, ;
			lnRow
		lcTag = trim(tcTag)
		if empty(lcTag)
			return 0
		endif empty(lcTag)
		acopy(This.aRelations, laRelations)
		lcAlias  = lower(This.cAlias)
		llGotOne = .F.
		lnStart  = 1
		lnRow    = 1
		do while lnRow > 0 and lnStart < alen(laRelations, 1) and not llGotOne
			lnRow    = This.oUtility.ArrayScan(@laRelations, lcTag, 3, lnStart)
			llGotOne = lnRow > 0 and laRelations[lnRow, 1] = lcAlias
			lnStart  = lnRow + 1
		enddo while lnRow > 0 ...
		lnStart = 1
		lnRow   = max(lnRow, 1)
		do while lnRow > 0 and lnStart < alen(laRelations, 1) and not llGotOne
			lnRow    = This.oUtility.ArrayScan(@laRelations, lcTag, 4, lnStart)
			llGotOne = lnRow > 0 and laRelations[lnRow, 2] = lcAlias
			lnStart  = lnRow + 1
		enddo while lnRow > 0 ...
		return iif(llGotOne, lnRow, 0)
		
	ENDPROC

	PROCEDURE Init
		lparameters tcMetaPath, ;
			toSDT, ;
			tcAlias, ;
			tcFileName, ;
			tlNew, ;
			tcDBC
		local llNew, ;
			laRealFields[1], ;
			laCodePage[1], ;
			laTypes[1], ;
			laIndexes[1], ;
			laCollate[1], ;
			lnCodePage, ;
			lcType, ;
			lcField, ;
			lcAlias, ;
			lcFile, ;
			lcCDX, ;
			laFields[1], ;
			lnFields, ;
			laRelations[1], ;
			lnRelations, ;
			lcDBC, ;
			lnRel, ;
			lnI, ;
			liChild, ;
			lcParent, ;
			lcCTag, ;
			lcPTag, ;
			lnStepValue, ;
			lcComment, ;
			lcCaption, ;
			lcAutoClass, ;
			lcAutoLib, ;
			lcInputMask, ;
			lcFormat, ;
			lcDefault, ;
			lcTag, ;
			lcIndex, ;
			llSelect, ;
			lcKey, ;
			lnCollate, ;
			lcCollate, ;
			lnLineHeight, ;
			lnLines
		
		* Call the baseclass Init().
		
		dodefault()
		with This
		
		* We need to instantiate SFUtility here rather than using SDTController's
		* because we want it to be in our data session.
		
			.oUtility  = MakeObject('SFUtility', 'SFUtility.vcx')
		
		* Save the parameters so we can use them later.
		
			.oSDTForm     = toSDT
			.oError       = toSDT.oError
			.oMessage     = toSDT.oMessage
			.lUseFieldRep = toSDT.lUseFieldRep
			.lShowInternational = toSDT.lShowInternational
			.lViewInheritance   = toSDT.lViewInheritance
			.cAlias       = tcAlias
			.cNewAlias    = tcAlias
			.lNew         = tlNew
			.cDBC         = tcDBC
			.cDatabase    = juststem(tcDBC)
			.cMetaPath    = tcMetaPath
			.cFieldRepDir = toSDT.cFieldRepDir
			llNew         = tlNew
		
		* Select the specified database and instantiate a DBCXMgr object.
		
			if not empty(tcDBC)
				set database to (tcDBC)
			endif not empty(tcDBC)
			.oMeta = MakeObject('SDTDBCXMgr', 'SDTManagers.VCX', '', .F., tcMetaPath)
			if vartype(.oMeta) <> 'O'
				return .F.
			endif vartype(.oMeta) <> 'O'
		
		* Tell MetaMgr which database we're using and turn on "show status" mode.
		
			.oMeta.SetDatabase(dbc())
			.oMeta.lShowStatus = .T.
		
		* Get an array of "real" field names from the table. Try to open the table
		* exclusively. If we can't, the user won't be able to change the table
		* structure.
		
			.oMeta.oSDTMgr.SetSuppressErrors(.T.)
			if not tlNew and tcAlias <> ccLIBRARY_TABLE and ;
				(not .oMeta.oSDTMgr.GetDBFStructure(fullpath(dbgetprop(tcAlias, ;
				'Table', 'Path'), tcDBC), @laRealFields) or ;
				not .OpenTable(tcAlias, .T.))
				.oMessage.ErrorMessage(strtran(ccERR_CANT_OPEN_FILE, ccMSG_INSERT1, ;
					tcAlias))
				return .F.
			endif not tlNew ...
			.oMeta.oSDTMgr.SetSuppressErrors(.F.)
		
		* Set the form's caption to our title plus the name of the database plus an
		* indication if the database is open as read-only. Display the table alias and
		* save the name of the DBC.
		
			.Caption = ccFRM_TD_CAPTION + iif(tcAlias = ccLIBRARY_TABLE, ccLIBRARY, ;
				tcAlias + ' (' + justfname(tcDBC) + ')')
			.pgfTable.pagTable.txtTableName.Value = .cAlias
		
		* Get copies of the aCodePage, aDataTypes, aIndexTypes, and aCollate arrays so
		* we can use them for combo boxes.
		
			.oMeta.oSDTMgr.GetCodePageArray(@laCodePage)
			acopy(laCodePage, .aCodePage)
			.pgfTable.pagTable.cboCodePage.Requery()
			.oMeta.oSDTMgr.GetDataTypeArray(@laTypes)
			acopy(laTypes, .aDataTypes)
			.pgfTable.Page1.cboType.Requery()
			.oMeta.oSDTMgr.GetIndexTypeArray(@laIndexes)
			acopy(laIndexes, .aIndexTypes)
			.pgfTable.pagIndex.cboType.Requery()
			.oMeta.oSDTMgr.GetCollateArray(@laCollate)
		
		* Open the Field Repository tables.
		
			if .lUseFieldRep
				use (toSDT.cFieldRepDir + 'SDTMETA.DBF')  alias LIBSDTMETA  again shared ;
					in 0
				use (toSDT.cFieldRepDir + 'COREMETA.DBF') alias LIBCOREMETA again shared ;
					in 0
				use (toSDT.cFieldRepDir + 'SDTUSER.DBF')  alias LIBSDTUSER  again shared ;
					in 0
			endif .lUseFieldRep
		
		* If we're creating a new table, add a blank field and a blank index to the
		* cursors and initialize the properties of certain objects.
		
			.cCurrParentType = 'Table'
			do case
				case .lNew
					.AddField()
					.AddIndex()
					lnCodePage = .oUtility.ArrayScan(@laCodePage, cpcurrent(), 2)
					.nCodePage = iif(lnCodePage = 0, 0, laCodePage[lnCodePage, 3])
					.nTableCP  = cpcurrent()
					with .pgfTable.pagTable
						.txtPath.Value    = tcFileName
						.txtRecords.Value = strtran(ccFRM_TD_RECORDS, ccMSG_INSERT1, ;
							'0')
						store cnFPT_DEFAULT_BLOCK_SIZE to This.nBlockSize, ;
							.spnBlockSize.Value
						.cboCodePage.Value = iif(lnCodePage = 0, 1, lnCodePage)
					endwith
					.pgfTable.pagTable2.cntExtProps.lGotObject = .F.
		
		* If we're editing the Fields Repository, get the fields in it and remove the
		* pages that we're not going to use.
		
				case tcAlias = ccLIBRARY_TABLE
					.cCurrParentType = ccLIBRARY_TABLE
					.pgfTable.PageCount = 3
					select COREMETA
					scan for COBJECTNAM = ccLIBRARY_TABLE
						lcType = .GetFieldType(cType, lBinary, nStepValue <> 0)
						= seek(upper(space(len(SDTMETA.DBCNAME)) + 'F' + ;
							padr(COREMETA.COBJECTNAM, len(SDTMETA.OBJECTNAME))), ;
							'SDTMETA', 'OBJECTNAME')
						lcField = substr(COREMETA.COBJECTNAM, ;
							at('.', COREMETA.COBJECTNAM) + 1)
						insert into _FIELDS ;
								(CFIELD, ;
								XTYPE, ;
								NSIZE, ;
								NDECIMALS, ;
								LNULL, ;
								LBINARY, ;
								XVALID, ;
								XERROR, ;
								XDEFAULT, ;
								XCOMMENT, ;
								XCAPTION, ;
								XINPUT, ;
								XFORMAT, ;
								PREVNAME, ;
								XAUTOCLASS, ;
								XAUTOLIB, ;
								XEXPR, ;
								FILTER, ;
								NSTEPVALUE) ;
							values ;
								(lcField, ;
								lcType, ;
								COREMETA.nSize, ;
								COREMETA.nDecimals, ;
								COREMETA.lNull, ;
								COREMETA.lBinary, ;
								SDTMETA.Valid, ;
								SDTMETA.Error, ;
								SDTMETA.DefValue, ;
								COREMETA.mComment, ;
								COREMETA.cCaption, ;
								COREMETA.mInputMask, ;
								COREMETA.mFormat, ;
								lcField, ;
								SDTMETA.AutoClass, ;
								SDTMETA.AutoLib, ;
								COREMETA.MExpr, ;
								SDTMETA.Filter, ;
								COREMETA.nStepValue)
					endscan for COBJECTNAM = ccLIBRARY_TABLE
		
		* Put the field names into the list in alphabetical order. If there weren't any
		* fields, use the Add button to add a blank field into the cursor. Point the
		* field list to the first field.
		
					select _FIELDS
					scan
						.lstFields.AddItem(trim(CFIELD))
					endscan
					if reccount() = 0
						.AddField()
						llNew = .T.
					endif reccount() = 0
					.lstFields.ListIndex = 1
		
		* If we're editing an existing table, put its structure into the _FIELDS cursor.
		
				otherwise
					lcAlias  = upper(strtran(.cAlias, ' ', '_'))
					lcFile   = dbf(lcAlias)
					lcCDX    = juststem(lcFile)
					lnFields = afields(laFields, lcAlias)
		
		* Get a list of all relations defined in the DBC, and eliminate those that
		* don't involve the selected table.
		
					dimension .aRelations[1, 6]
					.aRelations  = ''
					lnRelations  = adbobjects(laRelations, 'Relation')
					lcDBC        = .oMeta.oSDTMgr.DBCOpen(.cDBC)
					.iTableID    = .oMeta.oSDTMgr.DBCGetField(.cAlias, 'Table', ;
						'ObjectID')
					.iNewTableID = .iTableID
					lnRel        = 0
					for lnI = 1 to lnRelations
						laRelations[lnI, 1] = lower(iif(left(laRelations[lnI, 1], 1) = '"', ;
							substr(laRelations[lnI, 1], 2, len(laRelations[lnI, 1]) - 2), ;
							laRelations[lnI, 1]))
						laRelations[lnI, 2] = lower(iif(left(laRelations[lnI, 2], 1) = '"', ;
							substr(laRelations[lnI, 2], 2, len(laRelations[lnI, 2]) - 2), ;
							laRelations[lnI, 2]))
						if laRelations[lnI, 1] == .cAlias or ;
							laRelations[lnI, 2] == .cAlias
							lnRel = lnRel + 1
							dimension .aRelations[lnRel, alen(.aRelations, 2)]
							.aRelations[lnRel, 1] = laRelations[lnI, 1]
							.aRelations[lnRel, 2] = laRelations[lnI, 2]
							.aRelations[lnRel, 3] = laRelations[lnI, 3]
							.aRelations[lnRel, 4] = laRelations[lnI, 4]
							.aRelations[lnRel, 5] = laRelations[lnI, 5]
							.aRelations[lnRel, 6] = 0
		
		* Find the relationship record in the database.
		
							liChild = .oMeta.oSDTMgr.DBCGetField(.aRelations[lnRel, 1], ;
								'Table', 'ObjectID')
							locate for ParentID = liChild and ;
								ObjectType = ccVF_OBJ_RELATION
							do while found()
								lcParent = .oMeta.oSDTMgr.DBCGetProp(cnVF_REL_FKTABLE)
								lcCTag   = .oMeta.oSDTMgr.DBCGetProp(cnVF_REL_TAG)
								lcPTag   = .oMeta.oSDTMgr.DBCGetProp(cnVF_REL_FKTAG)
								if lower(lcParent) == .aRelations[lnRel, 2] and ;
									lower(lcCTag) = lower(.aRelations[lnRel, 3]) and ;
									lower(lcPTag) = lower(.aRelations[lnRel, 4])
									.aRelations[lnRel, 6] = recno()
									exit
								else
									continue
								endif lower(lcParent) == .aRelations[lnRel, 2] ...
							enddo while found()
						endif laRelations[lnI, 1] == lcAlias ...
					next lnI
					use
		
		* Put each field in the table into the _FIELDS cursor.
		
					for lnI = 1 to lnFields
						lnStepValue = iif(version(5) >= 800, laFields[lnI, 18], 0)
						lcType  = .GetFieldType(laFields[lnI, 2], laFields[lnI, 6], ;
							lnStepValue <> 0)
						lcField = .cAlias + '.' + trim(laFields[lnI, 1])
						= seek(upper(padr(.cDatabase, len(SDTMETA.DBCName)) + 'F' + ;
								padr(lcField, len(SDTMETA.ObjectName))), 'SDTMETA', ;
								'OBJECTNAME') and ;
							seek(upper(padr(.cDatabase, len(COREMETA.cDBCName)) + 'F' + ;
								padr(lcField, len(COREMETA.cObjectNam))), 'COREMETA', ;
								'OBJECTNAME')
						lcComment   = dbgetprop(lcField, 'Field', 'Comment')
						lcCaption   = dbgetprop(lcField, 'Field', 'Caption')
						lcAutoClass = dbgetprop(lcField, 'Field', 'DisplayClass')
						lcAutoClass = iif(empty(lcAutoClass), ccFRM_TD_DEF_CLASS, ;
							lcAutoClass)
						lcAutoLib   = dbgetprop(lcField, 'Field', 'DisplayClassLibrary')
						lcInputMask = dbgetprop(lcField, 'Field', 'InputMask')
						lcFormat    = dbgetprop(lcField, 'Field', 'Format')
						lcDefault   = iif('Auto' $ lcType, '', laFields[lnI, 9])
						insert into _FIELDS ;
								(CFIELD, ;
								XTYPE, ;
								NSIZE, ;
								NDECIMALS, ;
								LNULL, ;
								LBINARY, ;
								XVALID, ;
								XERROR, ;
								XDEFAULT, ;
								XCOMMENT, ;
								XCAPTION, ;
								XINPUT, ;
								XFORMAT, ;
								PREVNAME, ;
								XAUTOCLASS, ;
								XAUTOLIB, ;
								XREALPREV, ;
								FILTER, ;
								REPLINK, ;
								REPLINKFLD, ;
								NNEXTVALUE, ;
								NSTEPVALUE) ;
							values ;
								(laFields[lnI, 1], ;
								lcType, ;
								laFields[lnI, 3], ;
								laFields[lnI, 4], ;
								laFields[lnI, 5], ;
								laFields[lnI, 6], ;
								laFields[lnI, 7], ;
								laFields[lnI, 8], ;
								lcDefault, ;
								lcComment, ;
								lcCaption, ;
								lcInputMask, ;
								lcFormat, ;
								laFields[lnI, 1], ;
								lcAutoClass, ;
								lcAutoLib, ;
								laRealFields[lnI, 1], ;
								SDTMETA.Filter, ;
								SDTMETA.RepLink, ;
								SDTMETA.RepLinkFld, ;
								COREMETA.nNextValue, ;
								lnStepValue)
					next lnI
		
		* Now put calculated fields into the _FIELDS cursor.
		
					select CoreMeta
					set order to ObjectName
					seek upper(padr(.cDatabase, len(cDBCName)) + 'U' + .cAlias + '.')
					scan while cDBCName = padr(lower(.cDatabase), len(cDBCName)) and ;
						cRecType = 'U' and cObjectNam = lower(.cAlias) + '.'
						= seek(upper(padr(.cDatabase, len(SDTMETA.DBCName)) + 'U' + ;
							CoreMeta.cObjectNam))
						lcType  = .GetFieldType(cType)
						lcField = upper(substr(cObjectNam, rat('.', cObjectNam) + 1))
						insert into _FIELDS ;
								(CFIELD, ;
								XTYPE, ;
								NSIZE, ;
								NDECIMALS, ;
								XCOMMENT, ;
								XCAPTION, ;
								XINPUT, ;
								XFORMAT, ;
								XEXPR, ;
								FILTER, ;
								PREVNAME) ;
							values ;
								(lcField, ;
								lcType, ;
								CoreMeta.nSize, ;
								CoreMeta.nDecimals, ;
								CoreMeta.mComment, ;
								CoreMeta.cCaption, ;
								CoreMeta.mInputMask, ;
								CoreMeta.mFormat, ;
								CoreMeta.mExpr, ;
								SDTMETA.Filter, ;
								lcField)
					endscan while cDBCName = padr(.cDatabase, len(cDBCName)) ...
		
		* Put the field names into the list in the order they appear in the table.
		
					select _FIELDS
					set order to
					scan
						.lstFields.AddItem(trim(CFIELD))
					endscan
					set order to CFIELD
		
		* Put the indexes into the _INDEXES cursor and the list.
		
					for lnI = 1 to tagcount(lcCDX, lcAlias)
						do case
							case primary(lnI, lcAlias)
								lcType = .aIndexTypes[1]
							case candidate(lnI, lcAlias)
								lcType = .aIndexTypes[2]
							case unique(lnI, lcAlias)
								lcType = .aIndexTypes[4]
							case .oMeta.Binary(lnI, lcAlias)
								lcType = .aIndexTypes[5]
							otherwise
								lcType = .aIndexTypes[3]
						endcase
						lcTag   = tag(lnI, lcAlias)
						lcIndex = .cAlias + '.' + lcTag
						= seek(upper(padr(.cDatabase, len(SDTMETA.DBCName)) + 'I' + ;
								padr(lcIndex, len(SDTMETA.ObjectName))), 'SDTMETA', ;
								'OBJECTNAME') and ;
							seek(upper(padr(.cDatabase, len(COREMETA.cDBCName)) + 'I' + ;
								padr(lcIndex, len(COREMETA.cObjectNam))), 'COREMETA', ;
								'OBJECTNAME')
						lcComment = COREMETA.mComment
						lcCaption = COREMETA.cCaption
						llSelect  = SDTMETA.Select
						lcKey     = COREMETA.mTagExpr
						lcKey     = iif(empty(lcKey), key(lnI, lcAlias), lcKey)
						lnCollate = .oUtility.ArrayScan(@laCollate, ;
							idxcollate(lnI, lcAlias), 2)
						lcCollate = iif(lnCollate > 0, laCollate[lnCollate, 1], ;
							iif(type('.oSDTForm.oController.Name') = 'C', ;
							.oSDTForm.oController.cCollate, proper(set('COLLATE'))))
						insert into _INDEXES ;
								(NAME, ;
								TYPE, ;
								EXPRESSION, ;
								FILTER, ;
								DESCEND, ;
								COMMENT, ;
								CAPTION, ;
								COLLATE, ;
								SELECT, ;
								PREVNAME) ;
							values ;
								(lcTag, ;
								lcType, ;
								lcKey, ;
								sys(2021, lnI, lcAlias), ;
								descending(lnI, lcAlias), ;
								lcComment, ;
								lcCaption, ;
								lcCollate, ;
								llSelect, ;
								lcTag)
						.lstIndexes.AddItem(trim(_INDEXES.NAME))
					next lnI
		
		* If we don't have any indexes, add a blank record.
		
					if reccount('_INDEXES') = 0
						.AddIndex()
					endif reccount('_INDEXES') = 0
		
		* Initialize the properties of certain objects to properties of the table.
		
					.nTableCP  = cpdbf(lcAlias)
					lnCodePage = .oUtility.ArrayScan(@laCodePage, .nTableCP, 2)
					.nCodePage = iif(lnCodePage = 0, 0, laCodePage[lnCodePage, 3])
					with .pgfTable.pagTable
						.txtPath.Value          = fullpath(dbgetprop(tcAlias, 'Table', ;
							'Path'), dbc())
						.txtRecords.Value       = strtran(ccFRM_TD_RECORDS, ;
							ccMSG_INSERT1, ltrim(str(reccount(lcAlias))))
						.txtTblValidRule.Value  = dbgetprop(tcAlias, 'Table', ;
							'RuleExpression')
						.txtTblValidText.Value  = dbgetprop(tcAlias, 'Table', ;
							'RuleText')
						.txtInsert.Value        = dbgetprop(tcAlias, 'Table', ;
							'InsertTrigger')
						.txtUpdate.Value        = dbgetprop(tcAlias, 'Table', ;
							'UpdateTrigger')
						.txtDelete.Value        = dbgetprop(tcAlias, 'Table', ;
							'DeleteTrigger')
						.edtTblComment.Value    = dbgetprop(tcAlias, 'Table', ;
							'Comment')
						= seek(upper(padr(This.cDatabase, len(COREMETA.cDBCName)) + 'T' + ;
							padr(tcAlias, len(COREMETA.cObjectNam))), 'COREMETA', ;
							'OBJECTNAME')
						store COREMETA.nBLOCKSIZE to This.nBlockSize, ;
							.spnBlockSize.Value
						.cboCodePage.Value = iif(lnCodePage = 0, 1, lnCodePage)
					endwith
			endcase
		
		* Select the field or index that was selected in the SDT form. We need to set
		* the TopIndex of the appropriate list to a value so the selected field or
		* index is visible.
		
			lnLineHeight = fontmetric(1, .lstIndexes.FontName, ;
				.lstIndexes.FontSize) + ;
				fontmetric(4, .lstIndexes.FontName, .lstIndexes.FontSize) + ;
				fontmetric(5, .lstIndexes.FontName, .lstIndexes.FontSize)
			lnLines      = int(.lstIndexes.Height/lnLineHeight)
			do case
				case inlist(toSDT.cCurrObjectType, 'Field', 'User')
					.lstFields.Value    = upper(justext(toSDT.cCurrObject))
					.lstFields.TopIndex = max(.lstFields.ListIndex - ;
						lnLines + 1, 1)
				case toSDT.cCurrObjectType = 'Index'
					.lstIndexes.Value    = upper(justext(toSDT.cCurrObject))
					.lstIndexes.TopIndex = max(.lstIndexes.ListIndex - ;
						lnLines + 1, 1)
					.pgfTable.ActivePage = 4
					.lSelectedItemOnInit = .T.
			endcase
			if .lstIndexes.ListIndex = 0 and tcAlias <> ccLIBRARY_TABLE
				.lstIndexes.ListIndex = 1
			endif .lstIndexes.ListIndex = 0 ...
			if .lstFields.ListIndex = 0
				.lstFields.ListIndex  = 1
			endif .lstFields.ListIndex = 0
		
		* Update the collate array so only those eligible for the selected code page
		* can be chosen.
		
			if tcAlias <> ccLIBRARY_TABLE
				.RefreshCollate()
			endif tcAlias <> ccLIBRARY_TABLE
		
		* Display the size of the table.
		
			.CalcTableSize()
		
		* Adjust the size of the fields list.
		
			.lstFields.Height = .lstIndexes.Height
			wait clear
		
		* Restore the former position.
		
			.oPersist.cKey = addbs(ccREG_KEY) + 'Extended Table Designer'
			.oPersist.Restore('Top')
			.oPersist.Restore('Left')
		
		* Assign ourselves a unique ID
		
			.cUniqueID = sys(2015)
		
		* Set LockScreen to .T. -- the Activate of the the first page in the pageframe
		* will set it to .F. when it's done.
		
			.LockScreen = .T.
		
		* Table buffer the cursors so we can detect if something changed.
		
			set multilocks on
			cursorsetprop('Buffering', 5, '_FIELDS')
			cursorsetprop('Buffering', 5, '_INDEXES')
		endwith
		
	ENDPROC

	PROCEDURE Load
		dodefault()
		local lcCurrCollate
		lcCurrCollate = set('COLLATE')
		set collate to 'MACHINE'
		
		* Create a cursor to hold extended properties.
		
		create cursor _PROPERTY (PROPERTY C(128), TYPE C(15), FIELD_NAME C(10), ;
			CVALUE M, DVALUE D, DTVALUE T, LVALUE L, NVALUE B(8), FIELD_LEN N(3), ;
			FIELD_DEC N(3), FIELD_TYPE C(1))
		index on PROPERTY   for not deleted() tag PROPERTY
		index on FIELD_NAME for not deleted() tag FIELD_NAME
		
		* Create a cursor to hold the indexes for the table.
		
		create cursor _INDEXES (NAME C(cnVF_INDEX_MAXNAMELEN), TYPE C(9), ;
			EXPRESSION C(cnVF_INDEX_MAXKEYLEN), FILTER C(cnVF_INDEX_MAXKEYLEN), ;
			DESCEND L, COMMENT M, CAPTION C(254), COLLATE C(20), SELECT L, ;
			PREVNAME C(cnVF_INDEX_MAXNAMELEN))
		index on NAME tag NAME
		index on TYPE tag TYPE
		
		* Create a cursor to hold the fields for the table. Those fields in _FIELDS
		* starting with "X" aren't properties stored in DBCX, but in the DBC or use for
		* internal purposes.
		
		create cursor _FIELDS (CFIELD C(cnVF_LONGNAME_LENGTH), XTYPE C(18), ;
			NSIZE N(3), NDECIMALS N(3), LNULL L, LBINARY L, XVALID C(254), ;
			XERROR C(254), XDEFAULT C(254), XCOMMENT M, XCAPTION C(254), ;
			XINPUT C(254), XFORMAT C(254), PREVNAME C(cnVF_LONGNAME_LENGTH), ;
			XAUTOCLASS C(254), XAUTOLIB C(254), XREALPREV C(cnVF_FIELD_MAXNAMELEN), ;
			FILTER L, REPLINK L, REPLINKFLD C(cnVF_LONGNAME_LENGTH), XEXPR M, ;
			NSTEPVALUE I, NNEXTVALUE I)
		index on CFIELD   tag CFIELD
		index on PREVNAME tag PREVNAME
		set order to CFIELD
		set collate to lcCurrCollate
		
	ENDPROC

	PROCEDURE opentable		&& Opens the table being maintained
		lparameters tcAlias, ;
			tlNoWarning
		local lcAlias, ;
			llReturn, ;
			lcFileName
		with This
			lcAlias  = strtran(tcAlias, ' ', '_')
			llReturn = used(lcAlias)
			if not llReturn
				lcFileName = fullpath(dbgetprop(tcAlias, 'Table', 'Path'), .cDBC)
				.oUtility.CloseAllAliases(lcFileName)
				use (lcFileName) alias (lcAlias) again exclusive in 0
				llReturn = used(lcAlias)
				if not llReturn and not tlNoWarning
					.oMessage.ErrorMessage(strtran(ccERR_CANT_OPEN_FILE, ;
						ccMSG_INSERT1, tcAlias))
				endif not llReturn ...
			endif not llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE pgdnhotkey		&& Move to the next field or index (fired from a hotkey)
		do case
			case This.pgfTable.ActivePage < 4
				if type('This.ActiveControl.Name') = 'C'
					This.ActiveControl.SetFocus()
				endif type('This.ActiveControl.Name') = 'C'
				This.lstFields.ListIndex = min(This.lstFields.ListIndex + 1, ;
					This.lstFields.ListCount)
			case This.pgfTable.ActivePage < 6
				if type('This.ActiveControl.Name') = 'C'
					This.ActiveControl.SetFocus()
				endif type('This.ActiveControl.Name') = 'C'
				This.lstIndexes.ListIndex = min(This.lstIndexes.ListIndex + 1, ;
					This.lstIndexes.ListCount)
		endcase
		
	ENDPROC

	PROCEDURE pguphotkey		&& Move to the previous field or index (fired from a hotkey)
		do case
			case This.pgfTable.ActivePage < 4
				if type('This.ActiveControl.Name') = 'C'
					This.ActiveControl.SetFocus()
				endif type('This.ActiveControl.Name') = 'C'
				This.lstFields.ListIndex = max(This.lstFields.ListIndex - 1, 1)
			case This.pgfTable.ActivePage < 6
				if type('This.ActiveControl.Name') = 'C'
					This.ActiveControl.SetFocus()
				endif type('This.ActiveControl.Name') = 'C'
				This.lstIndexes.ListIndex = min(This.lstIndexes.ListIndex - 1, 1)
		endcase
		
	ENDPROC

	PROCEDURE QueryUnload
		do case
			case not This.ExitWithoutSave()
				nodefault
			case vartype(This.oSDTForm) = 'O'
				This.oSDTForm.DoneTD(.F., .F., '', '', lower(This.cDatabase))
		endcase
		
	ENDPROC

	PROCEDURE refreshcollate		&& Ensure the collate combobox only shows collate sequences available for the selected codepage.
		* Update the collate array so only those eligible for the selected code page
		* can be chosen.
		
		local lcCP, ;
			lnI, ;
			laCollate[1]
		with This
			lcCP = ltrim(str(.nTableCP))
			lnI  = 1
			.oMeta.oSDTMgr.GetCollateArray(@laCollate)
			do while lnI <= alen(laCollate, 1)
				if lcCP + ',' $ laCollate[lnI, 3] + ',' or laCollate[lnI, 3] = '*'
					lnI = lnI + 1
				else
					adel(laCollate, lnI, 1)
					dimension laCollate[alen(laCollate, 1) - 1, alen(laCollate, 2)]
				endif lcCP + ',' $ laCollate[lnI, 3] + ',' ...
			enddo while lnI <= alen(laCollate, 1)
			dimension .aCollate[alen(laCollate, 1), alen(laCollate, 2)]
			acopy(laCollate, .aCollate)
			.pgfTable.pagIndex.cboCollate.Requery()
		endwith
		
	ENDPROC

	PROCEDURE removefield
		lparameters tcField
		local lcNotify, ;
			lcField, ;
			lcFieldDBC, ;
			laDBCs[1], ;
			lnDBCs, ;
			lnI, ;
			lcDBC, ;
			lcDBCAlias, ;
			lcPath, ;
			lnPos, ;
			lcObject, ;
			lnRecno, ;
			liParent
		with This
			lcNotify   = 'Removed field ' + tcField + ': '
			lcField    = .cAlias + '.' + tcField
			lcFieldDBC = .cDatabase + '!' + lcField
		
		* Process each database in the meta data.
		
			lnDBCs = .oMeta.DBCXGetAllObjects('Database', @laDBCs)
			for lnI = 1 to lnDBCs
				lcDBC = upper(laDBCs[lnI])
		
		* Open the DBC as a table.
		
				lcPath     = .oMeta.DBCXGetProp(lcDBC, 'Database', 'CBmPath')
				lcPath     = fullpath(lcPath, .oMeta.cRegistryPath)
				lcDBCAlias = .oMeta.oSDTMgr.DBCOpen(lcPath)
				if not empty(lcDBCAlias)
		
		* Let's see if it's used somewhere in the DBC. First, check the stored
		* procedures.
		
					set order to OBJECTNAME
					seek str(cnVF_OBJID_DATABASE) + ccVF_OBJ_DATABASE + ;
						lower(ccVF_OBJ_STOREDPROCSRC)
					if (lcDBC == .cDatabase and .oUtility.InExpr(lcField, CODE)) or ;
						.oUtility.InExpr(lcFieldDBC, CODE)
						replace NOTIFY with lcNotify + 'stored procedures for ' + ;
							lcDBC + ccCR in __NOTIFY
					endif (lcDBC == .cDatabase ...
		
		* Now check all validation rules, defaults, etc.
		
					scan for (lcDBC == .cDatabase and ;
						atc(lcField, PROPERTY) > 0) or ;
						atc(lcFieldDBC, PROPERTY) > 0
						if lcDBC == .cDatabase
							lnPos = .oUtility.InExpr(lcField, PROPERTY, .T.)
						else
							lnPos = 0
						endif lcDBC == .cDatabase
						if lnPos = 0
							lnPos = .oUtility.InExpr(lcFieldDBC, PROPERTY, .T.)
						endif lnPos = 0
						lcObject = alltrim(OBJECTNAME)
						do case
		
		* If it wasn't found exactly, ignore it.
		
							case lnPos = 0
		
		* Flag if we found it in a view.
		
							case OBJECTTYPE = ccVF_OBJ_VIEW
								replace NOTIFY with NOTIFY + lcNotify + ;
									lower(lcDBC) + '!' + lcObject + ccCR in __NOTIFY
		
		* For fields and indexes, flag that we found it (find the parent table or view
		* first).
		
							case inlist(OBJECTTYPE, ccVF_OBJ_FIELD, ccVF_OBJ_INDEX)
								lnRecno  = recno()
								liParent = PARENTID
								locate for OBJECTID = liParent
								lcObject = lower(lcDBC) + '!' + alltrim(OBJECTNAME) + ;
									'.' + lcObject 
								replace NOTIFY with NOTIFY + lcNotify + lcObject + ;
									ccCR in __NOTIFY
								go lnRecno
		
		* In the case of other objects, flag that we found it.
		
							otherwise
								replace NOTIFY with NOTIFY + lcNotify + ;
									lower(lcDBC) + '!' + lcObject + ccCR in __NOTIFY
						endcase
					endscan for (lcDBC == .cDatabase ...
					use
				endif not empty(lcDBCAlias)
			next lnI
			select _FIELDS
		endwith
		
	ENDPROC

	PROCEDURE renamefield
		local lcOldField, ;
			lcOldName, ;
			lcOldNameDBC, ;
			lcNewName, ;
			laDBCs[1], ;
			lnDBCs, ;
			lnI, ;
			lcDBC, ;
			lcDBCAlias, ;
			lcPath, ;
			lnPos, ;
			lcObject, ;
			lnRecno, ;
			liParent, ;
			lcProperty
		with This
		
		* Get the old and new field names.
		
			lcOldField = 'Renamed field ' + trim(_FIELDS.PREVNAME) + ': '
			lcOldName  = upper(.cAlias) + '.' + trim(_FIELDS.PREVNAME)
			lcNewName  = upper(.cAlias) + '.' + trim(_FIELDS.CFIELD)
		
		* Process each database in the meta data.
		
			lnDBCs = .oMeta.DBCXGetAllObjects('Database', @laDBCs)
			for lnI = 1 to lnDBCs
				lcDBC = upper(laDBCs[lnI])
		
		* Open the DBC as a table.
		
				lcPath     = .oMeta.DBCXGetProp(lcDBC, 'Database', 'CBmPath')
				lcPath     = fullpath(lcPath, .oMeta.cRegistryPath)
				lcDBCAlias = .oMeta.oSDTMgr.DBCOpen(lcPath)
				if not empty(lcDBCAlias)
		
		* If the field was renamed, let's see if it's used somewhere else in the DBC.
		* First, check the stored procedures.
		
					set order to OBJECTNAME
					seek str(cnVF_OBJID_DATABASE) + ccVF_OBJ_DATABASE + ;
						lower(ccVF_OBJ_STOREDPROCSRC)
					if .oUtility.InExpr(lcOldName, CODE)
						replace NOTIFY with lcOldField + 'stored procedures for ' + ;
							lcDBC + ccCR in __NOTIFY
					endif (lcDBC == .cDatabase ...
		
		* Now check all validation rules, defaults, etc. in other tables.
		
					scan for atc(lcOldName, PROPERTY) > 0
						lnPos    = .oUtility.InExpr(lcOldName, PROPERTY, .T.)
						lcObject = alltrim(OBJECTNAME)
						do case
		
		* If it wasn't found exactly, ignore it.
		
							case lnPos = 0
		
		* For fields and indexes, flag that we found it if it's in a table or change
		* it if it's part of a view.
		
							case inlist(OBJECTTYPE, ccVF_OBJ_FIELD, ccVF_OBJ_INDEX)
								lnRecno  = recno()
								liParent = PARENTID
								locate for OBJECTID = liParent
								if OBJECTTYPE = ccVF_OBJ_VIEW
									go lnRecno
									lcProperty = .oMeta.oSDTMgr.DBCGetProp(cnVF_VIEWFLD_UPDATENAME)
									lnPos      = .oUtility.InExpr(lcOldName, ;
										lcProperty, .T.)
									do while lnPos > 0
										lcProperty = stuff(lcProperty, lnPos, ;
											len(lcOldName), lcNewName)
										lnPos      = .oUtility.InExpr(lcOldName, ;
											lcProperty, .T.)
									enddo while lnPos > 0
									.oMeta.oSDTMgr.DBCSetProp(cnVF_VIEWFLD_UPDATENAME, ;
										lcProperty)
									replace OBJECTNAME with lower(_FIELDS.CFIELD)
								else
									lcObject = lower(lcDBC) + '!' + ;
										alltrim(OBJECTNAME) + '.' + lcObject
									replace NOTIFY with NOTIFY + lcOldField + ;
										lcObject + ccCR in __NOTIFY
									go lnRecno
								endif OBJECTTYPE = ccVF_OBJ_VIEW
		
		* In the case of a view, rename the field in the SQL property. If it exists in
		* other properties, flag that.
		
							case OBJECTTYPE = ccVF_OBJ_VIEW
								lcProperty = .oMeta.oSDTMgr.DBCGetProp(cnVF_VIEW_SQL)
								lnPos      = .oUtility.InExpr(lcOldName, lcProperty, ;
									.T.)
								do while lnPos > 0
									lcProperty = stuff(lcProperty, lnPos, ;
										len(lcOldName), lcNewName)
									lnPos      = .oUtility.InExpr(lcOldName, ;
										lcProperty, .T.)
								enddo while lnPos > 0
								.oMeta.oSDTMgr.DBCSetProp(cnVF_VIEW_SQL, lcProperty)
								lnPos = .oUtility.InExpr(lcOldName, lcProperty, .T.)
								if lnPos > 0
									replace NOTIFY with NOTIFY + lcOldField + ;
										lower(lcDBC) + '!' + lcObject + ccCR in __NOTIFY
								endif lnPos > 0
		
		* For tables, just flag that we found it (we need to skip any references to
		* the DBF name, so we'll remove those as we find them).
		
							case OBJECTTYPE = ccVF_OBJ_TABLE
								replace NOTIFY with NOTIFY + lcOldField + ;
									lower(lcDBC) + '!' + lcObject + ccCR in __NOTIFY
						endcase
					endscan for (lcDBC == .cDatabase ...
					use
				endif not empty(lcDBCAlias)
			next lnI
			select _FIELDS
		endwith
		
	ENDPROC

	PROCEDURE renamefieldinmetadata
		lparameters tcOldName, ;
			tcNewName
		local lnRecno, ;
			lnPos, ;
			lnI, ;
			lcField, ;
			lcValue
		
		* Rename the field in any index expression or filter it appears in.
		
		with This
			wait window ccMSG_RENAME_FIELD nowait
			.LockScreen = .T.
			select _INDEXES
			lnRecno = recno()
			scan
				lnPos = .oUtility.InExpr(tcOldName, EXPRESSION, .T.)
				do while lnPos > 0
					replace EXPRESSION with stuff(EXPRESSION, lnPos, len(tcOldName), ;
						tcNewName)
					lnPos = .oUtility.InExpr(tcOldName, EXPRESSION, .T.)
				enddo while lnPos > 0
				lnPos = .oUtility.InExpr(tcOldName, FILTER, .T.)
				do while lnPos > 0
					replace FILTER with stuff(FILTER, lnPos, len(tcOldName), tcNewName)
					lnPos = .oUtility.InExpr(tcOldName, FILTER, .T.)
				enddo while lnPos > 0
			endscan
			if lnRecno <= reccount()
				go lnRecno
			endif lnRecno <= reccount()
		
		* Rename the field in some places it occurs in any field's properties.
		
			select _FIELDS
			lnRecno = recno()
			scan
				for lnI = 1 to fcount()
					lcField = field(lnI)
					if type(lcField) $ 'CM' and not inlist(lcField, 'CFIELD', ;
						'XTYPE', 'XCAPTION', 'PREVNAME', 'XAUTOCLASS', 'XAUTOLIB', ;
						'XREALPREV', 'REPLINKFLD')
						lcValue = evaluate(lcField)
						lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
						do while lnPos > 0
							lcValue = stuff(lcValue, lnPos, len(tcOldName), tcNewName)
							lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
						enddo while lnPos > 0
						replace (lcField) with lcValue
					endif type(lcField) $ 'CM' ...
				next lnI
			endscan
			if lnRecno <= reccount()
				go lnRecno
			endif lnRecno <= reccount()
			.pgfTable.Page1.Refresh()
		
		* Rename the field in any table properties it occurs in.
		
			lcValue = .pgfTable.pagTable.txtTblValidRule.Value
			lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
			do while lnPos > 0
				lcValue = stuff(lcValue, lnPos, len(tcOldName), tcNewName)
				lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
			enddo while lnPos > 0
			.pgfTable.pagTable.txtTblValidRule.Value = lcValue
			lcValue = .pgfTable.pagTable.txtTblValidText.Value
			lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
			do while lnPos > 0
				lcValue = stuff(lcValue, lnPos, len(tcOldName), tcNewName)
				lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
			enddo while lnPos > 0
			.pgfTable.pagTable.txtTblValidText.Value = lcValue
			lcValue = .pgfTable.pagTable.txtInsert.Value
			lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
			do while lnPos > 0
				lcValue = stuff(lcValue, lnPos, len(tcOldName), tcNewName)
				lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
			enddo while lnPos > 0
			.pgfTable.pagTable.txtInsert.Value = lcValue
			lcValue = .pgfTable.pagTable.txtUpdate.Value
			lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
			do while lnPos > 0
				lcValue = stuff(lcValue, lnPos, len(tcOldName), tcNewName)
				lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
			enddo while lnPos > 0
			.pgfTable.pagTable.txtUpdate.Value = lcValue
			lcValue = .pgfTable.pagTable.txtDelete.Value
			lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
			do while lnPos > 0
				lcValue = stuff(lcValue, lnPos, len(tcOldName), tcNewName)
				lnPos   = .oUtility.InExpr(tcOldName, lcValue, .T.)
			enddo while lnPos > 0
			.pgfTable.pagTable.txtDelete.Value = lcValue
			.LockScreen = .F.
			wait clear
		endwith
		
	ENDPROC

	PROCEDURE resethotkeys		&& Clears hot keys
		on key label Ctrl+A
		on key label Ctrl+PgUp
		on key label Ctrl+PgDn
		
	ENDPROC

	PROCEDURE selectfield
		select _FIELDS
		with This
			seek padr(.lstFields.Value, len(CFIELD))
			.cCurrObjectType = iif(empty(XEXPR), 'Field', 'User')
			.cCurrObject = .cAlias + '.' + iif(empty(PREVNAME), trim(CFIELD), ;
				trim(PREVNAME))
			.LockScreen = .T.
			.HandleBlankField()
			.GetLibraryClasses(trim(XAUTOLIB))
			.pgfTable.Pages[This.pgfTable.ActivePage].Refresh()
			.pgfTable.pagFields3.cntExtProps.cCurrObjectType = .cCurrObjectType
			.pgfTable.pagFields3.cntExtProps.GetExtProps(.cCurrObject, .cCurrObjectType)
			.pgfTable.pagFields3.cntExtProps.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE selectindex
		local oPage, ;
			lcName, ;
			llPrimary, ;
			lcChar
		
		* Enable/disable the "primary" choice in the popup depending on whether
		* there's a primary key for this table and this one isn't it.
		
		select _INDEXES
		with This
			oPage  = .pgfTable.pagIndex
			lcName = padr(.lstIndexes.Value, len(NAME))
			set order to TYPE
			seek 'Primary'
		* Checking again that TYPE is Primary is a workaround for a bug in VFP.
			llPrimary = found() and TYPE = 'Primary' and not trim(lcName) == trim(NAME)
			lcChar    = left(oPage.cboType.List[1], 1)
			if llPrimary
				oPage.cboType.List[1] = '\' + .aIndexTypes[1]
			else
				oPage.cboType.List[1] = .aIndexTypes[1]
			endif llPrimary
		
		* Move to the selected index record and refresh the page.
		
			set order to NAME
			seek lcName
			.cCurrObjectType = 'Index'
			.cCurrObject = .cAlias + '.' + iif(empty(PREVNAME), trim(NAME), ;
				trim(PREVNAME))
			.LockScreen = .T.
			.HandleBlankIndex()
			oPage.Refresh()
			.pgfTable.pagIndex2.cntExtProps.GetExtProps(.cCurrObject, 'Index')
			.pgfTable.pagIndex2.cntExtProps.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu
		lparameters toMenu, ;
			tcObject
		local lcObject
		with toMenu
			if .nBarCount > 0
				.AddMenuSeparator()
			endif .nBarCount > 0
			do case
				case inlist(This.pgfTable.ActivePage, 1, 2)
					.AddMenuBar('\<Add Field', tcObject + '.cmdAdd.Click()', , , , ;
						'not ' + tcObject + '.cmdAdd.Enabled', , This.cmdAdd.Picture)
					.AddMenuBar('Remo\<ve Field...', tcObject + '.cmdDelete.Click()', , , , ;
						'not ' + tcObject + '.cmdDelete.Enabled', ;
						, This.cmdDelete.Picture)
					.AddMenuBar('\<Get From Repository...', tcObject + '.cmdGet.Click()', , , , ;
						'not ' + tcObject + '.cmdGet.Enabled', , This.cmdGet.Picture)
					.AddMenuBar('Cop\<y Field', tcObject + '.cmdCopy.Click()', , , , ;
						'not ' + tcObject + '.cmdCopy.Enabled', , This.cmdCopy.Picture)
					.AddMenuSeparator()
					.AddMenuBar('\<Save',   tcObject + '.cmdOK.Click()', , , , , , ;
						This.cmdOK.Picture)
					.AddMenuBar('\<Cancel', tcObject + '.cmdCancel.Click()', , , , , , ;
						This.cmdCancel.Picture)
				case inlist(This.pgfTable.ActivePage, 3, 5, 7)
					lcObject = tcObject + '.pgfTable.' + ;
						This.pgfTable.Pages[This.pgfTable.ActivePage].Name + ;
						'.cntExtProps.cntValues'
					.AddMenuBar('\<New Property...', lcObject + '.cmdNew.Click()', , , , ;
						'not ' + lcObject + '.cmdNew.Enabled')
					.AddMenuBar('\<Delete Property...', lcObject + '.cmdDelete.Click()', , , , ;
						'not ' + lcObject + '.cmdDelete.Enabled')
					.AddMenuBar('\<Edit Property...', lcObject + '.cmdEdit.Click()', , , , ;
						'not ' + lcObject + '.cmdEdit.Enabled')
					.AddMenuSeparator()
					.AddMenuBar('\<Save',   tcObject + '.cmdOK.Click()', , , , , , ;
						This.cmdOK.Picture)
					.AddMenuBar('\<Cancel', tcObject + '.cmdCancel.Click()', , , , , , ;
						This.cmdCancel.Picture)
				case This.pgfTable.ActivePage = 4
					lcObject = tcObject + '.pgfTable.pagIndex'
					.AddMenuBar('\<Add Index', lcObject + '.cmdAdd.Click()', , , , ;
						'not ' + lcObject + '.cmdAdd.Enabled', , ;
						evaluate(lcObject + '.cmdAdd.Picture'))
					.AddMenuBar('Remo\<ve Index...', lcObject + '.cmdDelete.Click()', , , , ;
						'not ' + lcObject + '.cmdDelete.Enabled', , ;
						evaluate(lcObject + '.cmdDelete.Picture'))
					.AddMenuBar('\<Index Wizard...', lcObject + '.cmdWizard.Click()', , , , ;
						'not ' + lcObject + '.cmdWizard.Enabled', , ;
						evaluate(lcObject + '.cmdWizard.Picture'))
					.AddMenuSeparator()
					.AddMenuBar('\<Save',   tcObject + '.cmdOK.Click()', , , , , , ;
						This.cmdOK.Picture)
					.AddMenuBar('\<Cancel', tcObject + '.cmdCancel.Click()', , , , , , ;
						This.cmdCancel.Picture)
				case This.pgfTable.ActivePage = 6
					.AddMenuBar('\<Save',   tcObject + '.cmdOK.Click()', , , , , , ;
						This.cmdOK.Picture)
					.AddMenuBar('\<Cancel', tcObject + '.cmdCancel.Click()', , , , , , ;
						This.cmdCancel.Picture)
			endcase
		endwith
		
	ENDPROC

	PROCEDURE Show
		* If an item was selected on startup, don't do the default behavior, which
		* selects the first page.
		
		lparameters tnStyle
		if not This.lSelectedItemOnInit
			dodefault(tnStyle)
		endif not This.lSelectedItemOnInit
		
	ENDPROC

	PROCEDURE showbuttons
		lparameters tlShow
		with This
			.cmdDelete.Visible = tlShow
			.cmdCopy.Visible   = tlShow
			.cmdAdd.Visible    = tlShow
			.cmdGet.Visible    = tlShow
		endwith
		
	ENDPROC

	PROCEDURE showmenu
		if vartype(This.oMenu) = 'O'
			This.oMenu.ClearMenu()
		endif vartype(This.oMenu) = 'O'
		dodefault()
		
	ENDPROC

	PROCEDURE updateindexes
		lparameters tcAlias
		local lcAlias, ;
			llPHD, ;
			lcPHD, ;
			lcPrimary, ;
			llError, ;
			oSDT, ;
			laTableIndexes[1], ;
			laIndexes[1], ;
			lcCurrCollate, ;
			lcCurrTalk, ;
			lnIndexes, ;
			lnColumns, ;
			lnI, ;
			lcTag, ;
			lcExpression, ;
			lcForExpr, ;
			lcCollate, ;
			lcType, ;
			lcOptions, ;
			lnRelation, ;
			luValue, ;
			luForValue, ;
			lcError, ;
			llCollate, ;
			lcDBC, ;
			lcChild, ;
			liChild, ;
			lcParent, ;
			lcCTag, ;
			lcPTag, ;
			lcFile, ;
			lcTemp
		
		* Prepare to handle PHD if necessary.
		
		lcAlias = upper(strtran(tcAlias, ' ', '_'))
		llPHD   = 'PHDBASE' $ upper(set('LIBRARY'))
		if file('PHDBASE.V50')
			lcPHD = 'PHDBASE.V50'
		else
			lcPHD = 'PHDBASE'
		endif file('PHDBASE.V50')
		
		* Put the table's current indexes into laTableIndexes and the new definitions
		* into laTable.
		
		lcPrimary = ''
		with This
			llError = .F.
			oSDT    = .oMeta.oSDTMgr
			.oError.ResetError()
			oSDT.GetIndexStructure(lcAlias, @laTableIndexes)
			.GetIndexes(@laIndexes)
		
		* Use the IsIndexOutOfSync method to determine if the indexes are out of sync
		* with the DBC. If so, first delete all tags, then recreate all indexes.
		
			if oSDT.IsIndexOutOfSync(@laTableIndexes, @laIndexes)
				select (lcAlias)
				delete tag all
				lcCurrCollate = set('COLLATE')
				lcCurrTalk    = set('TALK', 1)
				lnIndexes     = alen(laIndexes, 1)
				lnColumns     = alen(laIndexes, 2)
				set talk window
				for lnI = 1 to lnIndexes
					lcTag = laIndexes[lnI, 1]
					if not empty(lcTag)
						lcExpression = laIndexes[lnI, 2]
						lcForExpr    = laIndexes[lnI, 3]
						lcCollate    = laIndexes[lnI, 4]
						lcType       = laIndexes[lnI, 5]
						lcOptions    = iif(lcType = 'B', ' binary', ;
							iif(empty(lcForExpr), '', ' for ' + lcForExpr) + ;
							iif(laIndexes[lnI, 6], '', ' descending') + ;
							iif(lcType = 'U', ' unique', '') + ;
							iif(lcType = 'C' or lcType = 'P', ' candidate', ''))
						lnRelation   = .IndexInRelation(lcTag)
						luValue      = iif(upper(left(lcExpression, 4)) = 'PHD(', ;
							'.T.', evaluate(lcExpression))
						luForValue   = iif(empty(lcForExpr), '.T.', ;
							evaluate(lcForExpr))
						.oError.SetSuppressErrors(.T.)
						do case
		
		* If this is a PHDBASE index, handle it: load PHDBASE if it isn't already and
		* we can find it. Create the index if we can. If not, give an error message.
		
							case upper(left(lcExpression, 4)) = 'PHD('
								if not llPHD and file(lcPHD) and ;
									not 'PHDBASE' $ upper(set('LIBRARY'))
									set library to ('PHDBASE') additive
								endif not llPHD ...
								if 'PHDBASE' $ upper(set('LIBRARY'))
									set talk on
									= evaluate(lcExpression)
									set talk off
									lcError = .oError.aClassError[cnAERR_MESSAGE]
									llError = .oError.DidErrorOccur()
								else
									lcError = strtran(strtran(ccERR_NO_PHDBASE, ;
										ccMSG_INSERT1, lcTag), ccMSG_INSERT2, tcAlias)
									llError = .T.
								endif 'PHDBASE' $ upper(set('LIBRARY'))
		
		* If all of the expressions are valid, set the collate sequence as necessary.
		* Create the index and reset the collate sequence.
		
							case vartype(luValue) <> 'U' and vartype(luForValue) <> 'U'
								llCollate = cpcurrent() <> 0 and cpdbf() <> 0 and ;
									upper(lcCollate) <> lcCurrCollate
								if llCollate
									set collate to lcCollate
								endif llCollate
		
		* Create the tag.
		
								set talk on
								index on &lcExpression tag (lcTag) &lcOptions
								set talk off
								if cpcurrent() <> 0
									set collate to lcCurrCollate
								endif cpcurrent() <> 0
								lcError = .oError.aClassError[cnAERR_MESSAGE]
								llError = .oError.DidErrorOccur()
		
		* If this is the primary key, save its name.
		
								if lcType = 'P'
									lcPrimary = lcTag
								endif lcType = 'P'
		
		* The index expression was invalid.
		
							otherwise
								lcError = ccERR_IDX_EXPR_INVALID
								llError = .T.
						endcase
		
		* Exit if an error occurred.
		
						.oError.SetSuppressErrors(.F.)
						if llError
							.IndexError(lcTag, lcError)
							exit
						endif llError
					endif not empty(lcTag)
				next lnI
		
		* If this table has a primary key or any persistent relationships, open the DBC
		* because we'll need to process them.
		
				if not llError and (not empty(lcPrimary) or ;
					not empty(.aRelations[1, 1]))
					lcDBC = .oMeta.oSDTMgr.DBCOpen(.cDBC)
		
		* If there's a primary key for the table, flag it in the DBC.
		
					if not empty(lcPrimary)
						oSDT.DBCFindObject(tcAlias, 'Table')
						oSDT.DBCSetProp(cnVF_TABLE_PRIMARYTAG, lcPrimary)
					endif not empty(lcPrimary)
		
		* Recall all deleted relations records that are still valid (that is, for which
		* the tag still exists). In the case of relations from this table, we need to
		* copy them to a temporary file and reimport them, since relation records must
		* exist after the table record. We also need to change the PARENTID in this
		* case.
		
					if not empty(.aRelations[1, 1])
						lcFile = juststem(dbf(lcAlias))
						lcTemp = 'T' + left(sys(3), 7) + '.DBF'
						for lnI = 1 to alen(.aRelations, 1)
							if .aRelations[lnI, 6] <> 0 and ;
								((tcAlias == .aRelations[lnI, 2] and ;
									tagno(.aRelations[lnI, 4], lcFile, lcAlias) <> 0) or ;
								(tcAlias == .aRelations[lnI, 1] and ;
									tagno(.aRelations[lnI, 3], lcFile, lcAlias) <> 0))
								go .aRelations[lnI, 6]
								recall
								if PARENTID = .iTableID and .iTableID <> .iNewTableID
									copy next 1 to (lcTemp)
									delete
									append from (lcTemp)
									replace OBJECTID with recno(), ;
										PARENTID with .iNewTableID
								endif PARENTID = .iTableID ...
							endif .aRelations[lnI, 6] <> 0 ...
						next lnI
						if file(lcTemp)
							erase (lcTemp)
							erase (forceext(lcTemp, 'FPT'))
						endif file(lcTemp)
					endif not empty(.aRelations[1, 1])
					use
				endif not llError ...
		
		* Cleanup and exit.
		
				if 'PHDBASE' $ upper(set('LIBRARY')) and not llPHD
					release library ('PHDBASE')
				endif 'PHDBASE' $ upper(set('LIBRARY')) ...
				set talk &lcCurrTalk
			endif oSDT.IsIndexOutOfSync(@laFieldList, @laTable)
		endwith
		return not llError
		
	ENDPROC

	PROCEDURE updatetable
		lparameters tcAlias
		local oSDT, ;
			llOK, ;
			lcAlias, ;
			laFieldList[1], ;
			lcFile, ;
			laTable[1], ;
			lnSync, ;
			lcToDo, ;
			lnBlockSize, ;
			lnRecCount, ;
			lcCurrTalk, ;
			lnI, ;
			lcTask, ;
			lnPos1, ;
			lnPos2, ;
			lnPos3, ;
			lcField, ;
			lnStep, ;
			lnNextValue, ;
			lcTempFile, ;
			lnCurrBlock, ;
			lcTempAlias, ;
			lnPos
		
		* Put the definition of the table into laFieldList and the new definition in
		* laTable.
		
		with This
			oSDT = .oMeta.oSDTMgr
			llOK = .T.
			.oError.ResetError()
			lcAlias = strtran(tcAlias, ' ', '_')
			afields(laFieldList, lcAlias)
			lcFile = dbf(lcAlias)
			.GetTableStructure(@laTable)
			lnCodePage  = .aCodePage[.pgfTable.pagTable.cboCodePage.Value, 2]
			lnBlockSize = .pgfTable.pagTable.spnBlockSize.Value
		
		* Use the IsTableOutOfSync method to determine if the table is out of sync
		* with the DBC. If the file isn't in sync with the DBC, use the HowToSyncTable
		* method to determine how to synchronize them.
		
			lnSync = oSDT.IsTableOutOfSync(@laFieldList, @laTable, cpdbf(lcAlias), ;
				lnCodePage, val(sys(2012, lcAlias)), lnBlockSize)
			if lnSync > 0
				lcToDo = oSDT.HowToSyncTable(@laFieldList, @laTable, .F.)
		
		* Delete all tags for the table because we might be making a change that'll
		* invalidate an index or we might be using REMOVE TABLE later, which'll bomb if
		* this table has any relations.
		
				select (lcAlias)
				lnRecCount = reccount()
				delete tag all
				.oSDTForm.RemoveRelations(tcAlias)
		
		* Alter the structure as necessary.
		
				lcCurrTalk = set('TALK', 1)
				set talk window
				if not empty(lcToDo)
					set talk on
					alter table (lcAlias) &lcToDo novalidate
					set talk off
		
		* If an existing field was converted to an auto-inc field, assign the NEXTVALUE
		* property.
		
					if ' nextvalue -909090' $ lcToDo
						for lnI = 1 to alen(oSDT.aHowToSync)
							lcTask = oSDT.aHowToSync[lnI]
							if ' nextvalue -909090' $ lcTask
								lnPos1  = at(' column ', lcTask)
								lnPos2  = at(' ', lcTask, 2)
								lnPos3  = at(' ', lcTask, 3)
								lcField = substr(lcTask, ;
									lnPos2 + 1, ;
									lnPos3 - lnPos2 - 1)
								if seek(padr(lcField, len(_FIELDS.CFIELD)), ;
									'_FIELDS', 'CFIELD')
									lnStep = _FIELDS.NSTEPVALUE
								endif seek(padr(lcField ...
								calculate max(&lcField) to lnNextValue
								alter table (lcAlias) ;
									alter column &lcField I autoinc ;
									nextvalue lnNextValue + lnStep step lnStep ;
									novalidate
							endif ' nextvalue -909090' $ lcTask
						next lnI
					endif ' nextvalue -909090' $ lcToDo
		
		* Now update the laFieldList array with the new structure and see if there
		* are more changes to make yet (changes we couldn't do with ALTER TABLE, such
		* as rearranging fields or adding fields in the middle of the structure).
		
					afields(laFieldList, lcAlias)
					lnSync = oSDT.IsTableOutOfSync(@laFieldList, @laTable, ;
						cpdbf(lcAlias), lnCodePage)
				endif not empty(lcToDo)
		
		* If there's more to do, use the "create and append" method. Start by creating
		* a new file with the new structure.
		
				if lnSync > 0
					if lnSync <> 2
						lcTempFile = addbs(justpath(lcFile)) + 'T' + ;
							left(sys(3), 7) + '.DBF'
		
		* Get the blocksize and set it.
		
						lnBlockSize = .nBlockSize
						lnCurrBlock = set('BLOCKSIZE')
						set blocksize to lnBlockSize
		
		* Now create a copy of the table with the new structure, ensuring that the
		* block size is set as appropriate for the table. First, we need to change the
		* structure of the array so it's in the format VFP expects. Then we need to
		* read the next value for any auto-inc fields from the DBF header so we can use
		* it later. Then zero the step value for all auto-inc fields so they're not
		* auto-inc in the copy, otherwise the APPEND FROM can't import values for them.
		* Finally, create the table and reset the blocksize.
		
						local laCreate[1]
						.oUtility.CloseAllAliases(lcFile)
						.oMeta.oSDTMgr.GetStructureArray(@laTable, @laCreate)
						select _FIELDS
						locate for NSTEPVALUE <> 0
						llAutoInc = found()
						if llAutoInc
							.oMeta.oSDTMgr.ReadNextValue(lcFile, @laTable)
							for lnI = 1 to alen(laCreate, 1)
								laCreate[lnI, 18] = 0
							next lnI
						endif llAutoInc
						create table (lcTempFile) from array laCreate
						set blocksize to lnCurrBlock
						lcTempAlias = alias()
						set deleted off
						set talk on
						append from (lcFile)
						set talk off
						set deleted on
		
		* For any auto-inc fields we added, assign values.
		
						select _FIELDS
						scan for NSTEPVALUE <> 0 and empty(PREVNAME)
							lcField     = trim(CFIELD)
							lnStep      = NSTEPVALUE
							lnNextValue = NNEXTVALUE
							select (lcTempAlias)
							replace all &lcField with ;
								(recno() - 1) * lnStep + lnNextValue
							lnPos = .oUtility.ArrayScan(@laTable, lcField, 1)
							laTable[lnPos, 17] = reccount() * lnStep + lnNextValue
						endscan for NSTEPVALUE <> 0 ...
						select (lcTempAlias)
		
		* Now make any auto-inc fields auto-inc again.
		
						if llAutoInc
							for lnI = 1 to alen(laTable, 1)
								lnStep = laTable[lnI, 18]
								if lnStep <> 0
									lcField     = laTable[lnI, 1]
									lnNextValue = laTable[lnI, 17]
									alter table (lcTempAlias) ;
										alter column &lcField I autoinc ;
										nextvalue lnNextValue step lnStep novalidate
								endif laTable[lnI, 18] <> 0
							next lnI
							erase (forceext(lcTempAlias, 'BAK'))
						endif llAutoInc
		
		* Delete the original file and rename the new file to it (we don't need to
		* rename the CDX since it doesn't exist, but we might need to rename an FPT).
		
						llOK = lnRecCount = reccount()
						if llOK
							use
							remove table (tcAlias) delete
							rename table (lcTempAlias) to (tcAlias)
							rename (lcTempFile) to (lcFile)
							if file(strtran(lcTempFile, '.DBF', '.FPT'))
								rename (strtran(lcTempFile, '.DBF', '.FPT')) to ;
									(strtran(lcFile, '.DBF', '.FPT'))
							endif file(strtran(lcTempFile, '.DBF', '.FPT'))
		
		* Change the name property for the table in the DBC.
		
						.oMeta.oSDTMgr.DBCOpen(.cDBC)
						oSDT.DBCFindObject(tcAlias, ccVF_OBJ_TABLE)
						oSDT.DBCSetProp(cnVF_TABLE_FILEPATH, sys(2014, lcFile, .cDBC))
						use
		
		* If the record counts didn't match, we had a problem, so clean up and display
		* a warning.
		
						else
							use
							remove table (lcTempAlias) delete
							oSDT.OpenTable(tcAlias, '', .T., tcAlias, .F., ;
								.DataSessionID)
							.oMessage.ErrorMessage(ccERR_NOT_UPDATED)
						endif llOK
					else
						use in (lcAlias)
					endif lnSync <> 2
		
		* Write the code page into the file header and reopen the table.
		
					if llOK
						oSDT.WriteCodePage(.nCodePage,, lcFile)
						oSDT.OpenTable(tcAlias, '', .T., tcAlias, .F., .DataSessionID)
					endif llOK
				endif lnSync > 0 ...
		
		* If everything went OK, get the new OBJECTID for the table.
		
				if llOK
					.oMeta.oSDTMgr.DBCOpen(.cDBC)
					.iNewTableID = .oMeta.oSDTMgr.DBCGetField(tcAlias, 'Table', ;
						'ObjectID')
					use
				endif llOK
				set talk &lcCurrTalk
			endif lnSync > 0
		endwith
		return llOK and not This.oError.DidErrorOccur()
		
	ENDPROC

	PROCEDURE cmdAdd.Click
		local oList, ;
			oPage, ;
			oFields, ;
			lnBlank, ;
			lnI
		oList   = Thisform.lstFields
		oPage   = Thisform.pgfTable
		oFields = oPage.Page1
		select _FIELDS
		lnBlank = 0
		for lnI = 1 to oList.ListCount
			if empty(oList.List[lnI])
				lnBlank = lnI
				exit
			endif empty(oList.List[lnI])
		next lnI
		if lnBlank > 0
			oList.ListIndex = lnBlank
		else
			Thisform.AddField()
		endif lnBlank > 0
		oPage.ActivePage = 1
		oFields.txtName.SetFocus()
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		with Thisform
			if .ExitWithoutSave()
				.oSDTForm.DoneTD(.F., .F., '', '', lower(.cDatabase))
				.Release()
			endif .ExitWithoutSave()
		endwith
		
	ENDPROC

	PROCEDURE cmdCopy.Click
		local lcName, ;
			laCopyField[1], ;
			lnRecno, ;
			lcDigits, ;
			lnI, ;
			lcNewName
		lcName = trim(CFIELD)
		scatter memo to laCopyField
		insert into _FIELDS from array laCopyField
		replace PREVNAME with '', XREALPREV with ''
		lnRecno  = recno()
		lcDigits = ''
		for lnI = len(lcName) to 1 step -1
			if not isdigit(substr(lcName, lnI, 1))
				exit
			endif not isdigit(substr(lcName, lnI, 1))
			lcDigits = substr(lcName, lnI, 1) + lcDigits
		next lnI
		lcNewName = left(lcName, len(lcName) - len(lcDigits))
		lnI = val(lcDigits) + 1
		do while seek(padr(lcName, len(CFIELD)))
			lcName = lcNewName + transform(lnI)
			lnI    = lnI + 1
		enddo while seek(padr(lcName, len(CFIELD)))
		go lnRecno
		replace CFIELD with lcName, XCAPTION with proper(strtran(lcName, '_', ' '))
		with Thisform.lstFields
			.AddItem(trim(CFIELD))
			.ListIndex = .NewIndex
		endwith
		Thisform.CalcTableSize()
		Thisform.pgfTable.ActivePage = 1
		Thisform.pgfTable.Page1.txtName.SetFocus()
		
	ENDPROC

	PROCEDURE cmdDelete.Click
		local lcField, ;
			lnRecno, ;
			llFound, ;
			lnI, ;
			oList, ;
			lnList
		
		* See if this field's involved in any indexes.
		
		with Thisform
			lcField = trim(_FIELDS.CFIELD)
			select _INDEXES
			lnRecno = recno()
			locate for .oUtility.InExpr(lcField, upper(EXPRESSION)) or ;
				.oUtility.InExpr(lcField, upper(FILTER))
			llFound = found()
			if lnRecno <= reccount()
				go lnRecno
			endif lnRecno <= reccount()
		
		* If this field's involved in any indexes, warn the user. If the user says Yes
		* or the field wasn't involved in any indexes, remove it.
		
			select _FIELDS
			if (llFound and .oMessage.YesNo(strtran(ccQST_REMOVE_IDX_FIELD, ;
				ccMSG_INSERT1, lcField))) or ;
				(not llFound and .oMessage.YesNo(strtran(ccQST_REMOVE_FIELD, ;
				ccMSG_INSERT1, lcField)))
				delete
		
		* Now remove any indexes the field is involved in.
		
				if llFound
					select _INDEXES
					oList = .lstIndexes
					scan for .oUtility.InExpr(lcField, upper(EXPRESSION)) or ;
						.oUtility.InExpr(lcField, upper(FILTER))
						delete
						for lnI = 1 to oList.ListCount
							if trim(oList.List[lnI]) == trim(NAME)
								oList.RemoveItem(lnI)
								exit
							endif trim(oList.List[lnI]) == trim(NAME)
						next lnI
					endscan for .oUtility.InExpr(lcField, upper(EXPRESSION)) ...
					lnList = oList.ListIndex
					oList.ListIndex = min(lnList, oList.ListCount)
					select _FIELDS
				endif llFound
		
		* Update the list.
		
				.CalcTableSize()
				oList  = .lstFields
				lnList = oList.ListIndex
				oList.RemoveItem(oList.ListIndex)
				oList.ListIndex = min(lnList, oList.ListCount)
			endif (llFound ...
		endwith
		
	ENDPROC

	PROCEDURE cmdGet.Click
		* Get fields from the Field Repository.
		
		local loParameters, ;
			lnI, ;
			lnRecno, ;
			loFields, ;
			llAdd, ;
			CFIELD, ;
			NSIZE, ;
			NDECIMALS, ;
			LNULL, ;
			LBINARY, ;
			VALID, ;
			ERROR, ;
			DEFVALUE, ;
			MCOMMENT, ;
			CCAPTION, ;
			MINPUTMASK, ;
			MFORMAT, ;
			NNEXTVALUE, ;
			NSTEPVALUE, ;
			AUTOCLASS, ;
			AUTOLIB, ;
			FILTER, ;
			lcField, ;
			lcType, ;
			lcTable
		
		* Create a PassParameters object and pass it and a reference to the SDT form to
		* the GETFIELD form so we can get an array of fields the user wants to add to
		* this table.
		
		with Thisform
			if vartype(.oSDTForm) <> 'O'
				return .F.
			endif vartype(.oSDTForm) <> 'O'
			loParameters = MakeObject('SDTPassParameters', 'SDT.VCX')
			loParameters.aArray = ''
			lnI = 1
			select _FIELDS
			lnRecno = recno()
			scan
				dimension loParameters.aArray[lnI]
				loParameters.aArray[lnI] = CFIELD
				lnI = lnI + 1
			endscan
			if lnRecno <= reccount()
				go lnRecno
			endif lnRecno <= reccount()
			do form GETFIELD with .oSDTForm, loParameters name loFields linked
		
		* Add the selected fields to the current table.
		
			llAdd = .F.
			for lnI = 1 to alen(loParameters.aArray)
				if not empty(loParameters.aArray[lnI])
		
		* Get the information from the LIBSDTMETA and LIBCOREMETA tables.
		
					select LIBSDTMETA
					= seek(upper(space(len(LIBSDTMETA.DBCNAME)) + 'F' + ;
						padr(ccLIBRARY_TABLE + '.' + loParameters.aArray[lnI], ;
						len(LIBSDTMETA.OBJECTNAME))), 'LIBSDTMETA', 'OBJECTNAME')
					scatter memvar memo
					select LIBCOREMETA
					= seek(upper(space(len(LIBCOREMETA.CDBCNAME)) + 'F' + ;
						padr(ccLIBRARY_TABLE + '.' + loParameters.aArray[lnI], ;
						len(LIBCOREMETA.COBJECTNAM))), 'LIBCOREMETA', 'OBJECTNAME')
					scatter memvar memo
					lcField  = trim(upper(justext(M.OBJECTNAME)))
					lcType   = .GetFieldType(M.CTYPE, M.LBINARY, M.NSTEPVALUE <> 0)
					lcTable  = .cAlias		&& may be used in textmerge text
					VALID    = textmerge(M.VALID)
					ERROR    = textmerge(M.ERROR)
					MCOMMENT = textmerge(M.MCOMMENT)
					CCAPTION = textmerge(M.CCAPTION)
					MFORMAT  = textmerge(M.MFORMAT)
					MEXPR    = textmerge(M.MEXPR)
					DEFVALUE = textmerge(M.DEFVALUE)
					select _FIELDS
					locate
					if not eof() and empty(CFIELD)
						gather memvar memo
						replace CFIELD with lcField, ;
							XTYPE      with lcType, ;
							XVALID     with M.VALID, ;
							XERROR     with M.ERROR, ;
							XDEFAULT   with M.DEFVALUE, ;
							XCOMMENT   with M.MCOMMENT, ;
							XCAPTION   with M.CCAPTION, ;
							XINPUT     with M.MINPUTMASK, ;
							XFORMAT    with M.MFORMAT, ;
							NSTEPVALUE with M.NSTEPVALUE, ;
							NNEXTVALUE with M.NNEXTVALUE, ;
							XAUTOLIB   with M.AUTOLIB, ;
							XAUTOCLASS with M.AUTOCLASS, ;
							XEXPR      with M.MEXPR, ;
							REPLINK    with .T., ;
							REPLINKFLD with lcField
						.lstFields.List(.lstFields.ListIndex) = lcField
					else
						insert into _FIELDS ;
								(CFIELD, ;
								XTYPE, ;
								NSIZE, ;
								NDECIMALS, ;
								LNULL, ;
								LBINARY, ;
								XVALID, ;
								XERROR, ;
								XDEFAULT, ;
								XCOMMENT, ;
								XCAPTION, ;
								XINPUT, ;
								XFORMAT, ;
								NNEXTVALUE, ;
								NSTEPVALUE, ;
								XAUTOCLASS, ;
								XAUTOLIB, ;
								XEXPR, ;
								FILTER, ;
								REPLINK, ;
								REPLINKFLD) ;
							values ;
								(lcField, ;
								lcType, ;
								M.NSIZE, ;
								M.NDECIMALS, ;
								M.LNULL, ;
								M.LBINARY, ;
								M.VALID, ;
								M.ERROR, ;
								M.DEFVALUE, ;
								M.MCOMMENT, ;
								M.CCAPTION, ;
								M.MINPUTMASK, ;
								M.MFORMAT, ;
								M.NNEXTVALUE, ;
								M.NSTEPVALUE, ;
								M.AUTOCLASS, ;
								M.AUTOLIB, ;
								M.MEXPR, ;
								M.FILTER, ;
								.T., ;
								lcField)
						.lstFields.AddItem(lcField)
					endif not eof() ...
					llAdd = .T.
				endif not empty(loParameters.aArray[lnI])
			next lnI
			if llAdd
				.lstFields.ListIndex = .lstFields.ListCount
			endif llAdd
			.CalcTableSize()
		endwith
		
	ENDPROC

	PROCEDURE cmdGet.Refresh
		* This button is disabled for the Field Repository.
		
		This.Enabled = upper(Thisform.cAlias) <> upper(ccLIBRARY_TABLE) and ;
			Thisform.lUseFieldRep
		
	ENDPROC

	PROCEDURE cmdOK.Click
		* Save the changes and update the table structure (if necessary).
		
		local lnCurrSelect, ;
			lnFieldRecno, ;
			lnIndexRecno, ;
			lnFields, ;
			lcAlias, ;
			lcNewAlias, ;
			laDataTypes[1], ;
			lcField, ;
			lnType, ;
			lcType, ;
			lcClass, ;
			liID, ;
			llOK, ;
			loTable, ;
			lcFile, ;
			llTable, ;
			lnOldFields, ;
			laOldFields[1], ;
			lcTrigger, ;
			lcDBC, ;
			laDBCFields[1], ;
			laRealFields[1], ;
			lnField, ;
			lcRecType, ;
			laProps[1], ;
			lcOldField, ;
			lcOldName, ;
			lcNewName, ;
			lnPos, ;
			lcObject, ;
			lnRecno, ;
			liParent, ;
			lcProperty, ;
			lcIndex, ;
			lcTable, ;
			lnI, ;
			loNotify, ;
			lnRecno, ;
			llFound
		
		* If no fields were defined, let's just exit.
		
		with Thisform
			lnCurrSelect = select()
			select _FIELDS
			lnFieldRecno = recno()
			lnIndexRecno = recno('_INDEXES')
			count to lnFields
			go top
			if empty(CFIELD) and lnFields = 1
				.Release()
				return
			endif empty(CFIELD) ...
		
		* If this is the Fields Repository, save the meta data.
		
			lcAlias    = strtran(.cAlias, ' ', '_')
			lcNewAlias = .cNewAlias
			acopy(.aDataTypes, laDataTypes)
			if .cAlias = ccLIBRARY_TABLE
				select _FIELDS
				scan for not empty(CFIELD)
					lcField = trim(CFIELD)
					lnType  = .oUtility.ArrayScan(@laDataTypes, trim(XTYPE))
					lcType  = .aDataTypes[lnType, 2]
					lcClass = iif(XAUTOCLASS = ccDEFAULT_CLASS, '', trim(XAUTOCLASS))
					if seek(upper(space(len(SDTMETA.DBCNAME)) + 'F' + ;
						padr(ccLIBRARY_TABLE + '.' + lcField, len(SDTMETA.OBJECTNAME))), ;
						'SDTMETA', 'OBJECTNAME')
						= seek(upper(space(len(COREMETA.CDBCNAME)) + 'F' + ;
							padr(ccLIBRARY_TABLE + '.' + lcField, ;
							len(COREMETA.COBJECTNAM))), 'COREMETA', 'OBJECTNAME')
					else
						if not empty(PREVNAME) and seek(upper(space(len(SDTMETA.DBCNAME)) + ;
							'F' + padr(ccLIBRARY_TABLE + '.' + trim(PREVNAME), ;
							len(SDTMETA.OBJECTNAME))), 'SDTMETA', 'OBJECTNAME')
							= seek(upper(space(len(COREMETA.CDBCNAME)) + 'F' + ;
								padr(ccLIBRARY_TABLE + '.' + trim(PREVNAME), ;
								len(COREMETA.COBJECTNAM))), 'COREMETA', 'OBJECTNAME')
							delete in SDTMETA
							delete in COREMETA
						endif not empty(PREVNAME) ...
						liID = .oMeta.NewID()
						insert into COREMETA (IID) values (liID)
						append blank in SDTMETA
					endif seek(upper(space(len(SDTMETA.DBCNAME)) ...
					replace OBJECTNAME with ccLIBRARY_TABLE + '.' + lcField, ;
						RECTYPE with 'F', ;
						AUTOCLASS with lcClass, ;
						AUTOLIB with trim(_FIELDS.XAUTOLIB), ;
						VALID with trim(_FIELDS.XVALID), ;
						ERROR with trim(_FIELDS.XERROR), ;
						FILTER with _FIELDS.FILTER, ;
						DEFVALUE with trim(_FIELDS.XDEFAULT), ;
						UPDATED with datetime(), ;
						PREVNAME with iif(lcField == alltrim(_FIELDS.PREVNAME), '', ;
							_FIELDS.PREVNAME) ;
						in SDTMETA
					replace COBJECTNAM with ccLIBRARY_TABLE + '.' + lcField, ;
						CTYPE with lcType, ;
						NSIZE with _FIELDS.NSIZE, ;
						NDECIMALS with _FIELDS.NDECIMALS, ;
						CRECTYPE with 'F', ;
						LNULL with _FIELDS.LNULL, ;
						LBINARY with _FIELDS.LBINARY, ;
						MCOMMENT with trim(_FIELDS.XCOMMENT), ;
						CCAPTION with trim(_FIELDS.XCAPTION), ;
						MFORMAT with trim(_FIELDS.XFORMAT), ;
						MINPUTMASK with trim(_FIELDS.XINPUT), ;
						NSTEPVALUE with _FIELDS.NSTEPVALUE, ;
						NNEXTVALUE with _FIELDS.NNEXTVALUE, ;
						MEXPR with _FIELDS.XEXPR, ;
						TLASTMOD with datetime() ;
						in COREMETA
				endscan for not empty(CFIELD)
				llOK = .T.
		
		* Handle a real table: prepare for the update.
		
			else
				wait window strtran(iif(.lNew, ccMSG_CREATING, ccMSG_UPDATING), ;
					ccMSG_INSERT1, .cNewAlias) nowait
				loTable = .pgfTable.pagTable
				lcFile  = trim(loTable.txtPath.Value)
		
		* Initialize the codepage values.
		
				.nCodePage = .aCodePage[loTable.cboCodePage.Value, 3]
		
		* See if this table exists in the DBC (in case this one was added already but
		* we didn't exit due to an error).
		
				llTable = indbc(.cAlias, 'Table')
		
		* Ensure we have valid indexes defined.
		
				select _INDEXES
				locate for not empty(NAME) and empty(EXPRESSION)
				do case
		
		* We have an index without an expression.
		
					case found()
						llOK = .F.
						.IndexError(trim(NAME), ccERR_IDX_EXPR_INVALID)
		
		* If this is a new table, create it and its indexes.
		
					case .lNew and not llTable
						lnOldFields = 0
						.cAlias     = lcNewAlias
						lcAlias     = strtran(.cAlias, ' ', '_')
						llOK        = .CreateTable(lcFile, .cAlias)
						llOK        = llOK and .CreateIndexes()
		
		* The table exists, so we may need to change its structure.
		
					otherwise
						llOK = .OpenTable(.cAlias)
						if llOK
							lnOldFields = afields(laOldFields, lcAlias)
							llOK        = .UpdateTable(.cAlias)
							llOK        = llOK and .UpdateIndexes(.cAlias)
						endif llOK
				endcase
		
		* If everything was OK, carry on. Use VFP commands for those things stored
		* in the DBC: first, table comments and triggers.
		
				if llOK
					dbsetprop(.cAlias, 'Table', 'Comment', ;
						alltrim(loTable.edtTblComment.Value))
					do case
						case loTable.txtInsert.Value == dbgetprop(.cAlias, 'Table', ;
							'InsertTrigger')
						case empty(loTable.txtInsert.Value)
							delete trigger on (.cAlias) for insert
						otherwise
							lcTrigger = alltrim(loTable.txtInsert.Value)
							create trigger on (.cAlias) for insert as &lcTrigger
					endcase
					do case
						case loTable.txtUpdate.Value == dbgetprop(.cAlias, 'Table', ;
							'UpdateTrigger')
						case empty(loTable.txtUpdate.Value)
							delete trigger on (.cAlias) for update
						otherwise
							lcTrigger = alltrim(loTable.txtUpdate.Value)
							create trigger on (.cAlias) for update as &lcTrigger
					endcase
					do case
						case loTable.txtDelete.Value == dbgetprop(.cAlias, 'Table', ;
							'DeleteTrigger')
						case empty(loTable.txtDelete.Value)
							delete trigger on (.cAlias) for delete
						otherwise
							lcTrigger = alltrim(loTable.txtDelete.Value)
							create trigger on (.cAlias) for delete as &lcTrigger
					endcase
		
		* Tell DBCX about any fields or indexes we've renamed (the table itself will
		* be handled in frmSDT.DoneTD).
		
					if not .lNew
						select _FIELDS
						scan for not empty(CFIELD) and not CFIELD == PREVNAME and ;
							not empty(PREVNAME)
							.oMeta.DBCXRenameObject(.cAlias + '.' + trim(PREVNAME), ;
								iif(empty(XEXPR), 'Field', 'User'), ;
								.cAlias + '.' + trim(CFIELD))
						endscan for not empty(CFIELD) ...
						select _INDEXES
						scan for not empty(NAME) and not NAME == PREVNAME and ;
							not empty(PREVNAME)
							.oMeta.DBCXRenameObject(.cAlias + '.' + trim(PREVNAME), ;
								'Index', .cAlias + '.' + trim(NAME))
						endscan for not empty(NAME) ...
					endif not .lNew
		
		* Create a cursor to contain notes for the developer.
		
					create cursor __NOTIFY (MESSAGE C(128), NOTIFY M)
					insert into __NOTIFY (MESSAGE) values ;
						(strtran(ccMSG_REMOVE_EDITS, ccMSG_INSERT1, ccRENAMED_FIELDS))
		
		* Update DBC properties for fields. We have to do this before Validate so DBCX
		* managers can see the properties for the table for things like defaults.
		
					select _FIELDS
					scan for not empty(CFIELD) and empty(XEXPR)
						lcField = .cAlias + '.' + trim(CFIELD)
						dbsetprop(lcField, 'Field', 'Comment', ;
							trim(XCOMMENT))
						dbsetprop(lcField, 'Field', 'Caption', ;
							trim(XCAPTION))
						dbsetprop(lcField, 'Field', 'Format', ;
							trim(XFORMAT))
						dbsetprop(lcField, 'Field', 'InputMask', ;
							trim(XINPUT))
						lcClass = iif(XAUTOCLASS = ccDEFAULT_CLASS, '', ;
							trim(XAUTOCLASS))
						dbsetprop(lcField, 'Field', 'DisplayClass', ;
							lcClass)
						dbsetprop(lcField, 'Field', 'DisplayClassLibrary', ;
							trim(XAUTOLIB))
					endscan for not empty(CFIELD) ...
		
		* Validate the table.
		
					.oMeta.Validate(.cAlias, 'Table')
		
		* Get "real" field names for all the fields.
		
					afields(laDBCFields, lcAlias)
					use in (lcAlias)
					.oMeta.oSDTMgr.GetDBFStructure(lcFile, @laRealFields)
		
		* Update properties for fields. We're only concerned with non-structual
		* properties because structural properties were handled by Validate().
		
					select _FIELDS
					scan for not empty(CFIELD)
						lcField   = .cAlias + '.' + trim(CFIELD)
						lnType    = .oUtility.ArrayScan(@laDataTypes, trim(XTYPE))
						lcType    = .aDataTypes[lnType, 2]
						lnField   = .oUtility.ArrayScan(@laDBCFields, trim(CFIELD))
						lcRecType = iif(empty(XEXPR), 'Field', 'User')
		
		* If this is a real field, populate an array of DBCX properties. Only update
		* the PREVNAME property if the user renamed the field.
		
						if empty(XEXPR)
							dimension laProps[5, 3]
							laProps[1, 1] = 'oSDTMgr'
							laProps[1, 2] = 'Filter'
							laProps[1, 3] = _FIELDS.FILTER
							laProps[2, 1] = 'oSDTMgr'
							laProps[2, 2] = 'RepLink'
							laProps[2, 3] = _FIELDS.REPLINK
							laProps[3, 1] = 'oSDTMgr'
							laProps[3, 2] = 'RepLinkFld'
							laProps[3, 3] = _FIELDS.REPLINKFLD
							laProps[4, 1] = 'oSDTMgr'
							laProps[4, 2] = 'RealName'
							laProps[4, 3] = laRealFields[lnField, 1]
							laProps[5, 1] = 'oCoreMgr'
							laProps[5, 2] = 'nNextValue'
							laProps[5, 3] = _FIELDS.NNEXTVALUE
							if not CFIELD == PREVNAME or ;
								not laRealFields[lnField, 1] == trim(_FIELDS.XREALPREV)
								dimension laProps[6, 3]
								laProps[6, 1] = 'oSDTMgr'
								laProps[6, 2] = 'PrevName'
								laProps[6, 3] = _FIELDS.XREALPREV
							endif not CFIELD == PREVNAME ...
						else
		
		* If the calculated field doesn't already exist, add it, then put its
		* properties into the array.
		
							if not seek(upper(padr(.cDatabase, len(SDTMETA.DBCNAME)) + ;
								'U' + padr(lcField, len(SDTMETA.OBJECTNAME))), 'SDTMETA', ;
								'OBJECTNAME') or ;
								not seek(upper(padr(.cDatabase, len(COREMETA.CDBCNAME)) + ;
								'U' + padr(lcField, len(COREMETA.COBJECTNAM))), ;
								'COREMETA', 'OBJECTNAME')
								.oMeta.AddRow(.cDatabase + '!' + lcField, 'User')
							endif not seek(upper(padr(.cDatabase, ...
							dimension laProps[12, 3]
							laProps[ 1, 1] = 'oSDTMgr'
							laProps[ 1, 2] = 'Filter'
							laProps[ 1, 3] = _FIELDS.FILTER
							laProps[ 2, 1] = 'oSDTMgr'
							laProps[ 2, 2] = 'RepLink'
							laProps[ 2, 3] = _FIELDS.REPLINK
							laProps[ 3, 1] = 'oSDTMgr'
							laProps[ 3, 2] = 'RepLinkFld'
							laProps[ 3, 3] = _FIELDS.REPLINKFLD
							laProps[ 4, 1] = 'oCoreMgr'
							laProps[ 4, 2] = 'CTYPE'
							laProps[ 4, 3] = lcType
							laProps[ 5, 1] = 'oCoreMgr'
							laProps[ 5, 2] = 'NSIZE'
							laProps[ 5, 3] = _FIELDS.NSIZE
							laProps[ 6, 1] = 'oCoreMgr'
							laProps[ 6, 2] = 'NDECIMALS'
							laProps[ 6, 3] = _FIELDS.NDECIMALS
							laProps[ 7, 1] = 'oCoreMgr'
							laProps[ 7, 2] = 'MEXPR'
							laProps[ 7, 3] = _FIELDS.XEXPR
							laProps[ 8, 1] = 'oCoreMgr'
							laProps[ 8, 2] = 'TLASTMOD'
							laProps[ 8, 3] = datetime()
							laProps[ 9, 1] = 'oCoreMgr'
							laProps[ 9, 2] = 'MCOMMENT'
							laProps[ 9, 3] = _FIELDS.XCOMMENT
							laProps[10, 1] = 'oCoreMgr'
							laProps[10, 2] = 'CCAPTION'
							laProps[10, 3] = _FIELDS.XCAPTION
							laProps[11, 1] = 'oCoreMgr'
							laProps[11, 2] = 'MINPUTMASK'
							laProps[11, 3] = _FIELDS.XINPUT
							laProps[12, 1] = 'oCoreMgr'
							laProps[12, 2] = 'MFORMAT'
							laProps[12, 3] = _FIELDS.XFORMAT
						endif empty(XEXPR)
		
		* Use DBCXSetRowProp to save the DBCX properties.
		
						.oMeta.DBCXSetRowProp(@laProps, lcField, lcRecType)
		
		* If the field was renamed, let's see if it's used somewhere else in the DBC.
		* First, check the stored procedures.
		
						if not .lNew and empty(XEXPR) and not CFIELD == PREVNAME and ;
							not empty(PREVNAME)
							.RenameField()
						endif not .lNew ...
					endscan for not empty(CFIELD)
		
		* Now do index properties. We're only concerned with non-structual properties
		* because structural properties were handled by Validate().
		
					select _INDEXES
					dimension laProps[4, 3]
					scan for not empty(NAME)
						lcIndex       = .cAlias + '.' + trim(NAME)
						laProps[1, 1] = 'oSDTMgr'
						laProps[1, 2] = 'Select'
						laProps[1, 3] = _INDEXES.SELECT
						laProps[2, 1] = 'oCoreMgr'
						laProps[2, 2] = 'cCaption'
						laProps[2, 3] = trim(_INDEXES.CAPTION)
						laProps[3, 1] = 'oCoreMgr'
						laProps[3, 2] = 'mComment'
						laProps[3, 3] = trim(_INDEXES.COMMENT)
						laProps[4, 1] = 'oCoreMgr'
						laProps[4, 2] = 'tLastMod'
						laProps[4, 3] = datetime()
						.oMeta.DBCXSetRowProp(@laProps, lcIndex, 'Index')
		
		* If the index was renamed, let's fix any relation records in the DBC.
		
						if not .lNew and not NAME == PREVNAME and ;
							not empty(PREVNAME)
							lcOldName = alltrim(lower(PREVNAME))
							lcNewName = alltrim(lower(NAME))
							lcTable   = lower(.cAlias)
							lcDBC     = .oMeta.oSDTMgr.DBCOpen(.cDBC)
							select (lcDBC)
							scan for OBJECTTYPE = ccVF_OBJ_RELATION
								do case
									case PARENTID = .iNewTableID and ;
										.oMeta.oSDTMgr.DBCGetProp(cnVF_REL_TAG) == lcOldName
										replace OBJECTNAME with lcNewName
										.oMeta.oSDTMgr.DBCSetProp(cnVF_REL_TAG, ;
											lcNewName)
									case .oMeta.oSDTMgr.DBCGetProp(cnVF_REL_FKTABLE) == lcTable and ;
										.oMeta.oSDTMgr.DBCGetProp(cnVF_REL_FKTAG) == lcOldName
										.oMeta.oSDTMgr.DBCSetProp(cnVF_REL_FKTAG, ;
											lcNewName)
								endcase
							endscan for OBJECTTYPE = ccVF_OBJ_RELATION
							use in (lcDBC)
							select _INDEXES
						endif not .lNew ...
					endscan for not empty(NAME)
		
		* If any fields have been removed, use RemoveField to update the notify
		* message.
		
					for lnI = 1 to lnOldFields
						lcField = padr(laOldFields[lnI, 1], len(_FIELDS.CFIELD))
						if not ((seek(lcField, '_FIELDS', 'CFIELD') or ;
							seek(lcField, '_FIELDS', 'PREVNAME')) and ;
							empty(_FIELDS.XEXPR))
							.RemoveField(laOldFields[lnI, 1])
						endif not ((seek(lcField, '_FIELDS', 'CFIELD') ...
					next lnI
		
		* Now display a message so the user knows what objects were affected.
		
					if not empty(__NOTIFY.NOTIFY)
						do form NOTIFY with '__NOTIFY' name loNotify linked
					endif not empty(__NOTIFY.NOTIFY)
					use in __NOTIFY
				endif llOK
			endif .cAlias = ccLIBRARY_TABLE
		
		* Time to clean up and leave.
		
			if llOK
		
		* Handle any deleted records.
		
				select _FIELDS
				set deleted off
				scan for deleted()
					lcField = CFIELD
					lnRecno = recno()
					set deleted on
					llFound = seek(lcField, '_FIELDS', 'CFIELD')
					go lnRecno
					if not llFound
						lcField = iif(.cAlias = ccLIBRARY_TABLE, '!', '') + .cAlias + ;
							'.' + trim(CFIELD)
						lcType  = iif(empty(XEXPR), 'Field', 'User')
						.oMeta.DBCXDeleteRow(lcField, lcType)
					endif not llFound
					set deleted off
				endscan for deleted()
				set deleted on
				select (lnCurrSelect)
		
		* Before we release the form, call the SDT form's DoneTD method to update the
		* tree or save any table name changes.
		
				if vartype(.oSDTForm) = 'O'
					.oSDTForm.DoneTD(.T., .lNew, .cAlias, lcNewAlias, ;
						lower(.cDatabase))
				endif vartype(.oSDTForm) = 'O'
				wait clear
				.Release()
			else
				if lnFieldRecno <= reccount('_FIELDS')
					go lnFieldRecno in _FIELDS
				endif lnFieldRecno <= reccount('_FIELDS')
				if lnIndexRecno <= reccount('_INDEXES')
					go lnIndexRecno in _INDEXES
				endif lnIndexRecno <= reccount('_INDEXES')
				select (lnCurrSelect)
				wait clear
			endif llOK
		endwith
		
	ENDPROC

	PROCEDURE cmdOK.Refresh
		This.Enabled = not empty(_FIELDS.CFIELD) or reccount('_FIELDS') > 1
		
	ENDPROC

	PROCEDURE lstFields.anychange
		Thisform.SelectField()
		
	ENDPROC

	PROCEDURE lstFields.DragDrop
		lparameters toSource, ;
			tnXCoord, ;
			tnYCoord
		local loParent, ;
			lcField, ;
			lcAlias, ;
			lcDBC, ;
			lnRecno, ;
			lcObject, ;
			lcCBPrefix, ;
			lcSDTPrefix, ;
			laProps[1], ;
			lnI, ;
			lcProperty, ;
			lcTable, ;
			luValue, ;
			lcFieldProp, ;
			CFIELD, ;
			XTYPE, ;
			NSIZE, ;
			NDECIMALS, ;
			LNULL, ;
			LBINARY, ;
			XVALID, ;
			XERROR, ;
			XDEFAULT, ;
			XCOMMENT, ;
			XCAPTION, ;
			XINPUT, ;
			XFORMAT, ;
			XAUTOCLASS, ;
			XAUTOLIB, ;
			XEXPR, ;
			lcDatabase
		
		* We'll only proceed if the source is from another TD form or a field from an
		* SDT session.
		
		with Thisform
			loParent = toSource.Parent
			if ((loParent.Name = .Name and loParent.cUniqueID <> .cUniqueID) or ;
				(upper(toSource.Name) = 'OTREE' and ;
				loParent.cCurrObjectType $ 'Field,User'))
		
		* Get the field, alias, and DBC from the appropriate places.
		
				if loParent.Name = .Name
					lcField = toSource.Value
					lcAlias = loParent.cAlias
				else
					lcField = loParent.cCurrObject
					lcField = upper(substr(lcField, at('.', lcField) + 1))
					lcAlias = upper(loParent.cCurrParent)
				endif loParent.Name = .Name
				lcDBC = iif(lcAlias = ccLIBRARY_TABLE or ;
					loParent.cCurrParentType = ccFREE_TABLES, '', loParent.cDBC)
		
		* If the field already exists in this table, do nothing. Otherwise, add it.
		
				select _FIELDS
				lnRecno = recno()
				if seek(padr(lcField, len(_FIELDS.CFIELD)), '_FIELDS', 'CFIELD')
					if lnRecno <= reccount()
						go lnRecno
					endif lnRecno <= reccount()
		
		* We're going to add the field, so start by getting the DBCX ID for it and an
		* array of DBCX properties by asking the other form's MetaMgr (in case the
		* field comes from a table managed by a different set of meta data).
		
				else
					scatter memvar memo blank
					lcObject = lcAlias + '.' + lcField
		
		* Get the prefixes used by SDTMgr and CoreMgr.
		
					lcCBPrefix  = .oMeta.oCoreMgr.cPrefix
					lcSDTPrefix = .oMeta.oSDTMgr.cPrefix
		
		* Create an array of properties from the Field Repository.
		
					if lcAlias = ccLIBRARY_TABLE
						dimension laProps[fcount('LIBSDTMETA') + ;
							fcount('COREMETA'), 3]
						= seek(upper(padr(lcDBC, len(LIBSDTMETA.DBCNAME)) + 'F' + ;
							padr(lcObject, len(LIBSDTMETA.OBJECTNAME))), 'LIBSDTMETA', ;
							'OBJECTNAME')
						= seek(upper(padr(lcDBC, len(LIBCOREMETA.CDBCNAME)) + 'F' + ;
							padr(lcObject, len(LIBCOREMETA.COBJECTNAM))), 'LIBCOREMETA', ;
							'OBJECTNAME')
						for lnI = 1 to fcount('LIBSDTMETA')
							lcProperty      = field(lnI, 'LIBSDTMETA')
							laProps[lnI, 1] = 'SDTMETA'
							laProps[lnI, 2] = lcSDTPrefix + lcProperty
							laProps[lnI, 3] = evaluate('LIBSDTMETA.' + lcProperty)
						next lnI
						for lnI = 1 to fcount('LIBCOREMETA')
							lcProperty = field(lnI, 'LIBCOREMETA')
							laProps[fcount('LIBSDTMETA') + lnI, 1] = 'COREMETA'
							laProps[fcount('LIBSDTMETA') + lnI, 2] = lcCBPrefix + ;
								lcProperty
							laProps[fcount('LIBSDTMETA') + lnI, 3] = evaluate('LIBCOREMETA.' + ;
								lcProperty)
						next lnI
		
		* Get an properties for the selected object.
		
					else
						loParent.oMeta.DBCXGetRowProp(@laProps, ;
							lcDBC + '!' + lcObject, loParent.cCurrObjectType)
					endif lcAlias = ccLIBRARY_TABLE
		
		* Process every property in the array.
		
					CFIELD  = lcField
					lcTable = .cAlias	&& may be used in textmerge text
					for lnI = 1 to alen(laProps, 1)
						lcProperty = laProps[lnI, 2]
						luValue    = laProps[lnI, 3]
						do case
		
		* Get the CoreMgr property.
		
							case left(lcProperty, len(lcCBPrefix)) = lcCBPrefix
								lcFieldProp = substr(lcProperty, len(lcCBPrefix) + 1)
		
		* Get the SDT property.
		
							case left(lcProperty, len(lcSDTPrefix)) = lcSDTPrefix
								lcFieldProp = substr(lcProperty, len(lcSDTPrefix) + 1)
						endcase
						do case
							case inlist(lcProperty, 'CBNSIZE', 'CBNDECIMALS', ;
								'CBLNULL', 'CBLBINARY', 'CBNSTEPVALUE', 'CBNNEXTVALUE')
								store luValue to (lcFieldProp)
							case inlist(lcProperty, 'SDTAUTOCLASS', 'SDTAUTOLIB')
								store luValue to ('X' + lcFieldProp)
							case inlist(lcProperty, 'SDTVALID', 'SDTERROR')
								store textmerge(luValue) to ('X' + lcFieldProp)
							case inlist(lcProperty, 'CBMCOMMENT', 'CBCCAPTION', ;
								'CBMFORMAT', 'CBMEXPR')
								store textmerge(luValue) to ;
									('X' + substr(lcFieldProp, 2))
							case lcProperty = 'CBCTYPE'
								XTYPE = luValue
							case lcProperty = 'CBMINPUTMASK'
								XINPUT = luValue
							case lcProperty = 'SDTDEFVALUE'
								XDEFAULT = textmerge(luValue)
							case lcProperty = 'SDTFILTER'
								FILTER = luValue
						endcase
					next lnI
					do case
		
		* If the field is from the Field Repository, set the link fields.
		
						case lcAlias = ccLIBRARY_TABLE
							REPLINK    = .T.
							REPLINKFLD = lcField
		
		* Get the database properties for the field.
		
						case not empty(lcDBC) and empty(M.XEXPR)
							lcDatabase = iif(empty(.cDBC), '', '"' + .cDBC + '"')
							set database to (lcDBC)
							XCOMMENT   = dbgetprop(lcObject, 'Field', 'Comment')
							XCAPTION   = dbgetprop(lcObject, 'Field', 'Caption')
							XAUTOCLASS = dbgetprop(lcObject, 'Field', 'DisplayClass')
							XAUTOLIB   = dbgetprop(lcObject, 'Field', ;
								'DisplayClassLibrary')
							XINPUT     = dbgetprop(lcObject, 'Field', 'InputMask')
							XFORMAT    = dbgetprop(lcObject, 'Field', 'Format')
							XVALID     = dbgetprop(lcObject, 'Field', 'RuleExpression')
							XERROR     = dbgetprop(lcObject, 'Field', 'RuleText')
							XDEFAULT   = dbgetprop(lcObject, 'Field', 'DefaultValue')
							set database to &lcDatabase
					endcase
		
		* Get the full description of the type, set AutoClass to "default" if it's
		* empty, then add the field the _FIELDS cursor and the list. Recalculate the
		* table size.
		
					XTYPE      = .GetFieldType(M.XTYPE, M.LBINARY, M.NSTEPVALUE <> 0)
					XAUTOCLASS = iif(empty(M.XAUTOCLASS), ccFRM_TD_DEF_CLASS, ;
						M.XAUTOCLASS)
					locate
					if not eof() and empty(CFIELD)
						for lnI = 1 to This.ListCount
							if empty(This.ListItem[lnI])
								This.ListIndex = lnI
								exit
							endif empty(This.ListItem[lnI])
						next lnI
						gather memvar memo
						This.ListItem[This.ListIndex] = alltrim(CFIELD)
					else
						insert into _FIELDS from memvar
						This.AddItem(alltrim(CFIELD))
						This.ListIndex = This.NewIndex
					endif not eof() ...
					.CalcTableSize()
					.HandleType(XTYPE)
				endif seek(padr(lcField, ...
			endif ((loParent.Name = .Name ...
		endwith
		
	ENDPROC

	PROCEDURE lstFields.DragOver
		lparameters toSource, ;
			tnXCoord, ;
			tnYCoord, ;
			tnState
		local lcField, ;
			lnRecno
		with Thisform
			do case
		
		* If the mouse is entering the object and the source is from another TD form or
		* a field from an SDT session, ensure that a field is being dragged and it
		* doesn't already exist in this table. If so, change the icon so it appears we
		* can drop the source here.
		
				case tnState = DRAG_ENTER and ((toSource.Parent.Name = .Name and ;
					toSource.Parent.cUniqueID <> .cUniqueID) or ;
					(upper(toSource.Name) = 'OTREE' and ;
					toSource.Parent.cCurrObjectType $ 'Field,User'))
					if toSource.Parent.Name = .Name
						lcField = toSource.Value
					else
						lcField = upper(toSource.SelectedItem.Text)
					endif toSource.Parent.Name = .Name
					lnRecno = recno('_FIELDS')
					if not seek(padr(lcField, len(_FIELDS.CFIELD)), '_FIELDS', ;
						'CFIELD')
						toSource.DragIcon = .cDragIcon
					endif not seek(padr(lcField, ...
					if lnRecno <= reccount('_FIELDS')
						go lnRecno in _FIELDS
					endif lnRecno <= reccount('_FIELDS')
		
		* If the mouse is leaving the object, change to a "no drop" icon.
		
				case tnState = DRAG_LEAVE
					toSource.DragIcon = .cNoDropIcon
			endcase
		endwith
		
	ENDPROC

	PROCEDURE lstFields.KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		do case
			case tnKeyCode = 7		&& Delete
				Thisform.cmdDelete.Click()
			case tnKeyCode = 22		&& Insert
				Thisform.cmdAdd.Click()
		endcase
		
	ENDPROC

	PROCEDURE lstFields.MouseDown
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		
		* Record the current mouse position so we can later determine if the mouse
		* moved enough to start a drag operation.
		
		if tnButton = BUTTON_LEFT
			with Thisform
				.nMouseX = tnXCoord
				.nMouseY = tnYCoord
			endwith
		endif tnButton = BUTTON_LEFT
		
	ENDPROC

	PROCEDURE lstFields.MouseMove
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		
		* If the left mouse button is pressed and the user has moved the mouse (since
		* the button was first pressed) by more than our defined threshold, start the
		* drag operation.
		
		with Thisform
			if tnButton = BUTTON_LEFT and ;
				(abs(tnXCoord - .nMouseX) > .nDragThreshold or ;
				abs(tnYCoord - .nMouseY) > .nDragThreshold)
				This.DragIcon = .cDragIcon
				This.Drag()
			endif tnButton = BUTTON_LEFT ...
		endwith
		
	ENDPROC

	PROCEDURE lstIndexes.anychange
		Thisform.SelectIndex()
		
	ENDPROC

	PROCEDURE lstIndexes.KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		do case
			case tnKeyCode = 7		&& Delete
				Thisform.pgfTable.pagIndex.cmdDelete.Click()
			case tnKeyCode = 22		&& Insert
				Thisform.pgfTable.pagIndex.cmdAdd.Click()
		endcase
		
	ENDPROC

	PROCEDURE pgfTable.Page1.Activate
		select _FIELDS
		with Thisform
			.LockScreen         = .T.
			.cCurrObjectType    = iif(empty(XEXPR), 'Field', 'User')
			.cCurrObject        = .cAlias + '.' + iif(empty(PREVNAME), trim(CFIELD), ;
				trim(PREVNAME))
			.lstFields.Visible  = .T.
			.lstIndexes.Visible = .F.
			.ShowButtons(.T.)
			This.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.Page1.cboType.anychange
		local lcValue, ;
			lcType
		lcValue = This.Value
		do case
			case lcValue = 'Character'
				replace NDECIMALS with 0
				lcType = 'C'
			case lcValue = 'Currency'
				replace NSIZE with 8, NDECIMALS with 4
				lcType = 'Y'
			case lcValue = 'Numeric' or lcValue = 'Float'
				lcType = iif(lcValue = 'Numeric', 'N', 'F')
			case lcValue = 'Date' or lcValue = 'DateTime'
				replace NSIZE with 8, NDECIMALS with 0
				lcType = iif(lcValue = 'Date', 'D', 'T')
			case lcValue = 'Double'
				replace NSIZE with 8
				lcType = 'B'
			case lcValue = 'Integer'
				replace NSIZE with 4, NDECIMALS with 0
				lcType = 'I'
			case lcValue = 'Logical'
				replace NSIZE with 1, NDECIMALS with 0
				lcType = 'L'
			case lcValue = 'Memo'
				replace NSIZE with 4, NDECIMALS with 0
				lcType = 'M'
			case lcValue = 'General'
				replace NSIZE with 4, NDECIMALS with 0
				lcType = 'G'
			case lcValue = 'Blob'
				replace NSIZE with 4, NDECIMALS with 0
				lcType = 'W'
			case lcValue = 'Varchar'
				replace NDECIMALS with 0
				lcType = 'V'
			case lcValue = 'Varbinary'
				replace NDECIMALS with 0
				lcType = 'Q'
		endcase
		replace LBINARY with '(Binary)' $ lcValue or ;
			trim(lcValue) $ 'Currency,Integer,Double,DateTime,Varbinary,Blob'
		if 'Auto' $ lcValue and not empty(XDEFAULT)
			replace XDEFAULT with ''
		endif 'Auto' $ lcValue ...
		do case
			case 'Auto' $ lcValue and NSTEPVALUE = 0
				replace NSTEPVALUE with 1
			case not 'Auto' $ lcValue and NSTEPVALUE <> 0
				replace NSTEPVALUE with 0
		endcase
		with This.Parent
			.spnWidth.Refresh()
			.spnDecimals.Refresh()
			.txtDefault.Refresh()
			.spnStepValue.Refresh()
			.spnNextValue.Refresh()
		endwith
		Thisform.HandleType(lcValue)
		
	ENDPROC

	PROCEDURE pgfTable.Page1.cboType.When
		return not eof()
	ENDPROC

	PROCEDURE pgfTable.Page1.chkLinked.Refresh
		This.Enabled = not empty(_FIELDS.REPLINKFLD)
		This.Visible = Thisform.cAlias <> ccLIBRARY_TABLE
		
	ENDPROC

	PROCEDURE pgfTable.Page1.chkNull.Refresh
		This.Enabled = empty(_FIELDS.XEXPR)
		
	ENDPROC

	PROCEDURE pgfTable.Page1.chkNull.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.cmdExprCaption.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.cmdExprDefault.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.cmdExprFormat.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.cmdExprInput.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.cmdExprText.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.cmdExprValid.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.spnDecimals.When
		store max(NSIZE - 2, 0) to This.KeyboardHighValue, This.SpinnerHighValue
		return not eof() and inlist(XTYPE, 'Numeric', 'Float', 'Double')
		
	ENDPROC

	PROCEDURE pgfTable.Page1.spnNextValue.Refresh
		store empty(_FIELDS.XEXPR) and _FIELDS.NSTEPVALUE <> 0 and ;
			empty(_FIELDS.PREVNAME) to This.Enabled, This.Parent.lblNextValue.Enabled
		dodefault()
		nodefault
		if This.Enabled and This.Value = 0
			This.Value = 1
		endif This.Enabled ...
		
	ENDPROC

	PROCEDURE pgfTable.Page1.spnNextValue.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.spnStepValue.Refresh
		store empty(_FIELDS.XEXPR) and _FIELDS.NSTEPVALUE <> 0 to ;
			This.Enabled, This.Parent.lblStepValue.Enabled
		dodefault()
		nodefault
		if This.Enabled and This.Value = 0
			This.Value = 1
		endif This.Enabled ...
		
	ENDPROC

	PROCEDURE pgfTable.Page1.spnStepValue.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.spnWidth.InteractiveChange
		if This.Parent.spnDecimals.Value > 0
			This.Parent.spnDecimals.Value = min(This.Value - 2, ;
				This.Parent.spnDecimals.Value)
		endif This.Parent.spnDecimals.Value > 0
		dodefault()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.spnWidth.validation
		Thisform.CalcTableSize()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.spnWidth.When
		with This
			do case
				case inlist(XTYPE, 'Character', 'Varchar', 'Varbinary')
					store 254 to .KeyboardHighValue, .SpinnerHighValue
				case XTYPE = 'Numeric' or XTYPE = 'Float'
					store 20 to .KeyboardHighValue, .SpinnerHighValue
			endcase
		endwith
		return not eof() and inlist(XTYPE, 'Character', 'Numeric', 'Float', ;
			'Character (Binary)', 'Varchar', 'Varchar (Binary)', 'Varbinary')
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtCaption.When
		return not eof()
	ENDPROC

	PROCEDURE pgfTable.Page1.txtDefault.Refresh
		store empty(_FIELDS.XEXPR) and _FIELDS.NSTEPVALUE = 0 to This.Enabled, ;
			This.Parent.lblDefault.Enabled, ;
			This.Parent.cmdExprDefault.Enabled
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtDefault.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtFormat.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtInputMask.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtName.Refresh
		This.Value = _FIELDS.CFIELD
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtName.validation
		local lcValue, ;
			lnRecno, ;
			llError, ;
			lcOldName, ;
			lcName, ;
			lcCaption
		
		* If the name wasn't entered, don't bother checking.
		
		with Thisform
			lcValue = This.Value
			if empty(lcValue)
				return
			endif empty(lcValue)
		
		* Ensure the field name hasn't already been used. If so, give an error. If not,
		* update the list with the name.
		
			lnRecno = recno()
			seek lcValue
			llError = found() and recno() <> lnRecno
			if lnRecno <= reccount()
				go lnRecno
			endif lnRecno <= reccount()
			if llError
				wait window ccERR_FIELD_EXISTS nowait
			else
		
		* See if the user renamed the field or entered a name for the first time.
		
				lcValue   = trim(lcValue)
				lcOldName = trim(.lstFields.List(.lstFields.ListIndex))
				do case
					case lcOldName == lcValue
		
		* A new name was assigned, so use it as the default for certain fields.
		
					case empty(lcOldName)
						replace CFIELD with lcValue
						lcName    = iif(iif(vartype(.oSDTForm) = 'O', ;
							.oSDTForm.lNamingConv, .F.), substr(lcValue, 2), lcValue)
						lcCaption = proper(strtran(lcName, '_', ' '))
						replace XCAPTION with lcCaption
						This.Parent.txtCaption.Refresh()
						.cmdOK.Refresh()
		
		* Rename the field if necessary.
		
					case .cAlias <> ccLIBRARY_TABLE
						replace CFIELD with lcValue
						.RenameFieldInMetaData(lcOldName, lcValue)
					otherwise
						replace CFIELD with lcValue
				endcase
		
		* Store the field name in the list and use the HandleBlankField() method to
		* ensure things are enabled as necessary.
		
				.lstFields.List(.lstFields.ListIndex) = trim(lcValue)
				.HandleBlankField()
			endif llError
		endwith
		return iif(llError, 0, .T.)
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtName.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtValidRule.Refresh
		store empty(_FIELDS.XEXPR) to This.Enabled, ;
			This.Parent.lblRule.Enabled, ;
			This.Parent.cmdExprValid.Enabled
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtValidRule.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtValidText.Refresh
		store empty(_FIELDS.XEXPR) to This.Enabled, ;
			This.Parent.lblMessage.Enabled, ;
			This.Parent.cmdExprText.Enabled
		
	ENDPROC

	PROCEDURE pgfTable.Page1.txtValidText.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page2.Activate
		select _FIELDS
		with Thisform
			.LockScreen         = .T.
			.cCurrObjectType    = iif(empty(XEXPR), 'Field', 'User')
			.cCurrObject        = .cAlias + '.' + iif(empty(PREVNAME), trim(CFIELD), ;
				trim(PREVNAME))
			.lstFields.Visible  = .T.
			.lstIndexes.Visible = .F.
			.ShowButtons(.T.)
			This.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.Page2.cboClass.Refresh
		store empty(_FIELDS.XEXPR) to This.Enabled, ;
			This.Parent.lblClass.Enabled
		
	ENDPROC

	PROCEDURE pgfTable.Page2.chkCalculated.anychange
		store This.Value to This.Parent.lblExpr.Enabled, This.Parent.edtExpr.Enabled, ;
			This.Parent.cmdExprExpr.Enabled
		if not This.Value and not empty(XEXPR)
			replace XEXPR with ''
		endif not This.Value ...
		This.Parent.txtAutoLib.Refresh()
		This.Parent.cboClass.Refresh()
		
	ENDPROC

	PROCEDURE pgfTable.Page2.chkCalculated.Refresh
		with This
			.Enabled = Thisform.cAlias <> ccLIBRARY_TABLE
			if .Enabled
				.Value = not empty(_FIELDS.XEXPR)
			else
				.Value = .F.
			endif .Enabled
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.Page2.chkCalculated.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page2.chkFilter.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page2.cmdExprExpr.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page2.cmdGetLib.Click
		dodefault()
		Thisform.cClassLib = This.Parent.txtAutoLib.Value
		
	ENDPROC

	PROCEDURE pgfTable.Page2.edtComment.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page2.edtExpr.validation
		* If we can evaluate the expression, store its type and size.
		
		local lcType, ;
			lcFullType, ;
			luValue
		lcType = type(This.Value)
		if lcType <> 'U'
			lcFullType  = Thisform.GetFieldType(lcType)
			luValue = evaluate(This.Value)
			replace XTYPE with lcFullType, ;
				NSIZE with iif(lcType = 'C', len(luValue), _FIELDS.NSIZE) ;
				in _FIELDS
		endif lcType <> 'U'
		
	ENDPROC

	PROCEDURE pgfTable.Page2.edtExpr.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.Page2.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE pgfTable.Page2.txtAutoLib.Refresh
		store empty(_FIELDS.XEXPR) to This.Enabled, ;
			This.Parent.lblLibrary.Enabled, ;
			This.Parent.cmdGetLib.Enabled
		
	ENDPROC

	PROCEDURE pgfTable.Page2.txtAutoLib.validation
		return trim(Thisform.cClassLib) == trim(This.Value) or ;
			Thisform.GetLibraryClasses(This.Value)
		
	ENDPROC

	PROCEDURE pgfTable.Page2.txtAutoLib.When
		Thisform.cClassLib = This.Value
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagFields3.Activate
		select _FIELDS
		with Thisform
			.LockScreen         = .T.
			.cCurrObjectType    = iif(empty(XEXPR), 'Field', 'User')
			.cCurrObject        = .cAlias + '.' + iif(empty(PREVNAME), trim(CFIELD), ;
				trim(PREVNAME))
			.lstFields.Visible  = .T.
			.lstIndexes.Visible = .F.
			.ShowButtons(.F.)
			This.cntExtProps.GetExtProps(.cCurrObject, .cCurrObjectType)
			This.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.pagFields3.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.Activate
		select _INDEXES
		with Thisform
			.LockScreen         = .T.
			.cCurrObjectType    = 'Index'
			.cCurrObject        = .cAlias + '.' + iif(empty(PREVNAME), trim(NAME), ;
				trim(PREVNAME))
			.lstFields.Visible  = .F.
			.lstIndexes.Visible = .T.
			.ShowButtons(.F.)
			This.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cboCollate.Refresh
		store Thisform.lShowInternational to This.Visible, ;
			This.Parent.lblCollate.Visible
		dodefault()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cboCollate.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cboType.anychange
		with This
			replace TYPE with .Value in _INDEXES
			if .Value = ccBINARY
				replace FILTER with '', DESCEND with .F. in _INDEXES
			endif .Value = ccBINARY
			.Parent.Refresh()
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cboType.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.chkDescend.Refresh
		This.Enabled = _INDEXES.TYPE <> ccBINARY
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.chkDescend.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.chkSelect.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cmdAdd.Click
		local lnBlank, ;
			lnI
		with Thisform.lstIndexes
			select _INDEXES
			lnBlank = 0
			for lnI = 1 to .ListCount
				if empty(.List[lnI])
					lnBlank = lnI
					exit
				endif empty(.List[lnI])
			next lnI
			if lnBlank > 0
				.ListIndex = lnBlank
			else
				Thisform.AddIndex()
			endif lnBlank > 0
		endwith
		This.Parent.txtName.SetFocus()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cmdDelete.Click
		local lcIndex, ;
			llGotOne, ;
			lnList
		
		* If the index is involved in a relation, let's see if the user still wants to
		* delete it. If so (or if it wasn't involved in a relation), remove it. If
		* we've deleted the last one, add an empty index.
		
		with Thisform
			lcIndex  = trim(_INDEXES.NAME)
			llGotOne = .IndexInRelation(_INDEXES.NAME) > 0
			if (llGotOne and .oMessage.YesNo(strtran(ccQST_REMOVE_REL_INDEX, ;
				ccMSG_INSERT1, lcIndex))) or ;
				(not llGotOne and .oMessage.YesNo(strtran(ccQST_REMOVE_INDEX, ;
				ccMSG_INSERT1, lcIndex)))
				delete
				with .lstIndexes
					lnList = .ListIndex
					.RemoveItem(.ListIndex)
					if .ListCount = 0
						Thisform.AddIndex()
					else
						.ListIndex = min(lnList, .ListCount)
					endif .ListCount = 0
				endwith
			endif (llGotOne ...
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cmdExprCaption.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cmdExprExpr.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cmdExprFilter.Refresh
		This.Enabled = _INDEXES.TYPE <> ccBINARY
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cmdExprFilter.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.cmdWizard.Click
		local lnIndexes, ;
			oWizard, ;
			llGotIt, ;
			lnI
		with Thisform
		
		* Store the current number of indexes, then run the wizard.
		
			lnIndexes = reccount()
			do form INDEXWIZ with .oUtility, .oError name oWizard linked
		
		* If any indexes were added, add them to the list.
		
			if reccount() > lnIndexes
				scan
					llGotIt = .F.
					for lnI = 1 to .lstIndexes.ListCount
						if alltrim(.lstIndexes.ListItem[lnI]) == alltrim(NAME)
							llGotIt = .T.
							exit
						endif alltrim(.lstIndexes.ListItem[lnI]) == alltrim(NAME)
					next lnI
					if not llGotIt
						.lstIndexes.AddItem(trim(NAME))
					endif not llGotIt
				endscan
		
		* If there's a blank record, delete it.
		
				seek space(len(NAME))
				if found()
					delete
					.lstIndexes.RemoveItem(.lstIndexes.ListIndex)
				endif found()
				go top
				.lstIndexes.Value = trim(NAME)
			endif reccount() > lnIndexes
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.edtComment.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.txtCaption.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.txtExpression.LostFocus
		Thisform.CheckIndexExpression(trim(This.Value))
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.txtExpression.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.txtFilter.Refresh
		This.Enabled = _INDEXES.TYPE <> ccBINARY
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.txtFilter.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.txtName.Refresh
		This.Value = _INDEXES.NAME
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.txtName.validation
		local lnRecno, ;
			lcValue, ;
			llError, ;
			lnRow
		
		* If the tag name was changed, ensure it hasn't already been used. If so, give
		* an error. If not, update the list with the name.
		
		with Thisform
			lnRecno = recno()
			lcValue = padr(This.Value, len(NAME))
			seek lcValue
			llError = found() and recno() <> lnRecno
			if lnRecno <= reccount()
				go lnRecno
			endif lnRecno <= reccount()
			if llError
				wait window ccERR_INDEX_EXISTS nowait
		
		* Store the tag name in the list and use the HandleBlankIndex() method to
		* ensure things are enabled as necessary.
		
			else
				.lstIndexes.List(.lstIndexes.ListIndex) = trim(lcValue)
				.HandleBlankIndex()
		
		* See if this index is involved in a relation. If so, rename it in the
		* relation array.
		
				lnRow = .IndexInRelation(.cCurrentTag)
				do case
					case lnRow = 0
					case .aRelations[lnRow, 1] == .cAlias
						.aRelations[lnRow, 3] = trim(lcValue)
					otherwise
						.aRelations[lnRow, 4] = trim(lcValue)
				endcase
				if not NAME == lcValue
					replace NAME with lcValue
				endif not NAME == lcValue
		
		* If the expression is empty and the tag name matches a field name, use the
		* field name as the default expression.
		
				lnRecno = recno('_FIELDS')
				if empty(EXPRESSION) and ;
					seek(padr(lcValue, len(_FIELDS.CFIELD)), '_FIELDS', ;
					'CFIELD')
					replace EXPRESSION with lcValue
					This.Parent.txtExpression.Refresh()
				endif empty(EXPRESSION) ...
				if lnRecno <= reccount('_FIELDS')
					go lnRecno in _FIELDS
				endif lnRecno <= reccount('_FIELDS')
			endif llError
		endwith
		return iif(llError, 0, .T.)
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex.txtName.When
		Thisform.cCurrentTag = _INDEXES.NAME
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex2.Activate
		select _INDEXES
		with Thisform
			.LockScreen         = .T.
			.cCurrObjectType    = 'Index'
			.cCurrObject        = .cAlias + '.' + iif(empty(PREVNAME), trim(NAME), ;
				trim(PREVNAME))
			.lstFields.Visible  = .F.
			.lstIndexes.Visible = .T.
			.ShowButtons(.F.)
			This.cntExtProps.GetExtProps(.cCurrObject, 'Index')
			This.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.pagIndex2.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE pgfTable.pagTable.Activate
		with Thisform
			.LockScreen         = .T.
			.cCurrObjectType    = 'Table'
			.cCurrObject        = .cAlias
			.lstFields.Visible  = .F.
			.lstIndexes.Visible = .F.
			.ShowButtons(.F.)
			This.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.pagTable.cboCodePage.Refresh
		store Thisform.lShowInternational to This.Visible, ;
			This.Parent.lblCodePage.Visible
		dodefault()
		
	ENDPROC

	PROCEDURE pgfTable.pagTable.cboCodePage.validation
		* Ensure that all index collate sequences are valid for this code page.
		
		local luReturn, ;
			laCollate[1], ;
			lcCodePage, ;
			lnCollate, ;
			laCodePage[1]
		luReturn = .T.
		with Thisform
			acopy(.aCollate, laCollate)
			lcCodePage = ltrim(str(.aCodePage[This.Value, 2]))
			select _INDEXES
			lnRecno = recno()
			scan
				lnCollate = .oUtility.ArrayScan(@laCollate, alltrim(COLLATE), 1)
		
		* If any tag has a collate sequence incompatible with the selected code page,
		* give an error and rollback the code page value.
		
				if not lcCodePage + ',' $ laCollate[lnCollate, 3] + ',' and not ;
					laCollate[lnCollate, 3] = '*'
					.oMessage.ErrorMessage(strtran(strtran(ccERR_INVALID_COLLATE, ;
						ccMSG_INSERT1, alltrim(COLLATE)), ccMSG_INSERT2, ;
						alltrim(NAME)))
					acopy(.aCodePage, laCodePage)
					This.Value = .oUtility.ArrayScan(@laCodePage, .nTableCP, 2)
					luReturn = 0
					exit
				endif not lcCodePage + ',' $ laCollate[lnCollate, 3] + ',' ...
			endscan
			if lnRecno <= reccount()
				go lnRecno
			endif lnRecno <= reccount()
				
		* Update the collate array so only those eligible for the selected code page
		* can be chosen.
		
			if vartype(luReturn) = 'L'
				.nTableCP = .aCodePage[This.Value, 2]
				.RefreshCollate()
			endif vartype(luReturn) = 'L'
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE pgfTable.pagTable.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

	PROCEDURE pgfTable.pagTable.spnBlockSize.validation
		* Set the blocksize property of the form to the value we'll use.
		
		with Thisform
			.nBlockSize = .oMeta.oSDTMgr.GetBlockSize(This.Value)
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.pagTable.txtFields.When
		return .F.
		
	ENDPROC

	PROCEDURE pgfTable.pagTable.txtPath.When
		return .F.
		
	ENDPROC

	PROCEDURE pgfTable.pagTable.txtRecords.When
		return .F.
		
	ENDPROC

	PROCEDURE pgfTable.pagTable.txtTableName.validation
		local llError, ;
			lcName
		
		* If the user changed the table name, ensure that name hasn't already been
		* used.
		
		llError = .F.
		lcName  = alltrim(This.Value)
		do case
			case Thisform.cAlias == lcName
			case indbc(lcName, 'Table') or indbc(lcName, 'View')
				wait window strtran(ccERR_TABLE_IN_DBC, ccMSG_INSERT1, lcName) nowait
				llError = .T.
		
		* Save the new name.
		
			otherwise
				Thisform.cNewAlias = lcName
		endcase
		return iif(llError, 0, .T.)
		
	ENDPROC

	PROCEDURE pgfTable.pagTable.txtTableName.When
		return not eof()
		
	ENDPROC

	PROCEDURE pgfTable.pagTable2.Activate
		with Thisform
			.LockScreen         = .T.
			.cCurrObjectType    = 'Table'
			.cCurrObject        = .cAlias
			.lstFields.Visible  = .F.
			.lstIndexes.Visible = .F.
			.ShowButtons(.F.)
			This.cntExtProps.GetExtProps(.cAlias, 'Table')
			This.Refresh()
			.LockScreen = .F.
		endwith
		
	ENDPROC

	PROCEDURE pgfTable.pagTable2.RightClick
		Thisform.ShowMenu()
		
	ENDPROC

ENDDEFINE
