*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfmover.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfmoverbutton AS sfcommandbutton OF "sfctrls.vcx" 		&& Base class for buttons in SFMoverList
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = ""
	Height = 30
	Name = "sfmoverbutton"
	Width = 30
	
	PROCEDURE about
		*==============================================================================
		* Class:				SFMoverButton
		* Based On:				SFCommandButton
		* Purpose:				Base class for all CommandButton objects in the
		*						MoverList class
		* Author:				Doug Hennig
		* Copyright:			(c) 1996 Stonefield Systems Group Inc.
		* Last revision:		12/08/96
		* Include file:			none
		*
		* Changes in base class properties:
		*	Caption:			None so only a picture will be used
		*	Height:				30
		*	Width:				30
		*
		* Changes in base class methods:
		*	None
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmoverlist AS sfcontainer OF "sfctrls.vcx" 		&& Generic two-column mover class
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lstAvailable" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAddAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemove" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemoveAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstSelected" UniqueID="" Timestamp="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: addall		&& Adds all items from the available list to the selected list.
		*m: addavailablefromselected		&& Adds an item to the available list that's being removed from the selected list
		*m: addselected		&& Adds selected items in the available list to the selected list.
		*m: afteradditem		&& Abstract method that fires after an item was added to the selected list
		*m: afterremoveitem		&& Abstract method that fires after an item is removed from the selected list
		*m: beforeremoveitem		&& Abstract method that fires before an item is removed from the selected list
		*m: handlechange		&& Handles the fact that the user changed something
		*m: removeall		&& Removes all items in the selected list.
		*m: removeselected		&& Removes selected items in the selected list.
		*p: cdragicon		&& The icon used when the dragged item can be dropped.
		*p: cnodropicon		&& The icon used when the dragged item cannot be dropped.
		*p: lanyavailable		&& .T. if there are any non-disabled items in the available list.
		*p: lchanged		&& .T. if the user did something
		*p: lremovefromavailable		&& If .T., items are removed from the available list as they are added to the selected list. Otherwise, they are disabled in the available list.
		*p: lselected		&& .T. if any items are selected
		*p: ndragthreshold		&& The number of pixels the user has to move the mouse to signify a drag operation.
		*p: nmousex		&& The last mouse X position.
		*p: nmousey		&& The last mouse Y position.
	*</DefinedPropArrayMethod>

	cdragicon = dragmove.cur		&& The icon used when the dragged item can be dropped.
	cnodropicon = nodrop01.cur		&& The icon used when the dragged item cannot be dropped.
	Height = 141
	lanyavailable = .F.		&& .T. if there are any non-disabled items in the available list.
	lchanged = .F.		&& .T. if the user did something
	lremovefromavailable = .F.		&& If .T., items are removed from the available list as they are added to the selected list. Otherwise, they are disabled in the available list.
	lselected = .F.		&& .T. if any items are selected
	Name = "sfmoverlist"
	ndragthreshold = 4		&& The number of pixels the user has to move the mouse to signify a drag operation.
	nmousex = 0		&& The last mouse X position.
	nmousey = 0		&& The last mouse Y position.
	TabIndex = 1
	Width = 440

	ADD OBJECT 'cmdAdd' AS sfmoverbutton WITH ;
		Left = 205, ;
		Name = "cmdAdd", ;
		Picture = add_one.bmp, ;
		StatusBarText = "Add selected items", ;
		TabIndex = 3, ;
		ToolTipText = "Add selected items", ;
		Top = 5
		*< END OBJECT: ClassLib="sfmover.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdAddAll' AS sfmoverbutton WITH ;
		Caption = "", ;
		Left = 205, ;
		Name = "cmdAddAll", ;
		Picture = add_all.bmp, ;
		StatusBarText = "Add all items", ;
		TabIndex = 4, ;
		ToolTipText = "Add all items", ;
		Top = 35
		*< END OBJECT: ClassLib="sfmover.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemove' AS sfmoverbutton WITH ;
		Caption = "", ;
		Left = 205, ;
		Name = "cmdRemove", ;
		Picture = rem_one.bmp, ;
		StatusBarText = "Remove selected items", ;
		TabIndex = 5, ;
		ToolTipText = "Remove selected items", ;
		Top = 75
		*< END OBJECT: ClassLib="sfmover.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemoveAll' AS sfmoverbutton WITH ;
		Caption = "", ;
		Left = 205, ;
		Name = "cmdRemoveAll", ;
		Picture = rem_all.bmp, ;
		StatusBarText = "Remove all items", ;
		TabIndex = 6, ;
		ToolTipText = "Remove all items", ;
		Top = 105
		*< END OBJECT: ClassLib="sfmover.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lstAvailable' AS sflistbox WITH ;
		Height = 141, ;
		Left = 0, ;
		MultiSelect = .T., ;
		Name = "lstAvailable", ;
		RowSource = "", ;
		RowSourceType = 0, ;
		TabIndex = 3, ;
		Top = 0, ;
		Width = 186
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="listbox" />

	ADD OBJECT 'lstSelected' AS sflistbox WITH ;
		Height = 141, ;
		Left = 254, ;
		MoverBars = .T., ;
		MultiSelect = .T., ;
		Name = "lstSelected", ;
		RowSource = "", ;
		RowSourceType = 0, ;
		TabIndex = 2, ;
		Top = 0, ;
		Width = 186
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="listbox" />
	
	PROCEDURE addall		&& Adds all items from the available list to the selected list.
		* Add all items in the available list to the selected list.
		
		local loAvailable, ;
			loSelected, ;
			lnIndex, ;
			lnI
		Thisform.LockScreen = .T.
		with This
			loAvailable = .lstAvailable
			loSelected  = .lstSelected
			lnIndex     = loSelected.ListCount
			if loSelected.ListIndex > 0
				loSelected.Selected[loSelected.ListIndex] = .F.
			endif loSelected.ListIndex > 0
		
		* If items are to be removed from the available list, do so in a loop using
		* DO WHILE. Otherwise, disable the items as they're added to the selected list.
		
			if .lRemoveFromAvailable
				do while loAvailable.ListCount > 0
					loSelected.AddItem(loAvailable.List[1])
					.AfterAddItem(1, loSelected.NewIndex)
					loSelected.Selected[loSelected.ListCount] = .T.
					loAvailable.RemoveItem[1]
				enddo while loAvailable.ListCount > 0
			else
				for lnI = 1 to loAvailable.ListCount
					loSelected.AddItem(loAvailable.List[lnI])
					.AfterAddItem(lnI, loSelected.NewIndex)
					loSelected.Selected[loSelected.ListCount] = .T.
					loAvailable.List[lnI] = '\' + loAvailable.List[lnI]
					loAvailable.Selected[lnI] = .F.
					loAvailable.aItems[lnI]   = .T.
				next lnI
			endif .lRemoveFromAvailable
		
		* Set the list index of the selected list to the last one added and refresh
		* the controls.
		
			loSelected.ListIndex = lnIndex + 1	&&loSelected.ListCount
			.lAnyAvailable = .F.
			.HandleChange(.T., .T.)
			.Refresh()
		endwith
		Thisform.LockScreen = .F.
		
	ENDPROC

	PROCEDURE addavailablefromselected		&& Adds an item to the available list that's being removed from the selected list
		* Add the specified item in the selected list to the available list, select
		* the new item in the available list, and return its index number.
		
		lparameters tnSelectedItem
		local loAvailable, ;
			lnAvailable
		loAvailable = This.lstAvailable
		loAvailable.AddItem(This.lstSelected.List[tnSelectedItem])
		lnAvailable = loAvailable.NewIndex
		loAvailable.Selected[lnAvailable] = .T.
		return lnAvailable
		
	ENDPROC

	PROCEDURE addselected		&& Adds selected items in the available list to the selected list.
		* Add all selected items in the available list to the selected list.
		
		local loAvailable, ;
			loSelected, ;
			llFirst, ;
			lnIndex, ;
			lnI, ;
			lnJ
		Thisform.LockScreen = .T.
		with This
			loAvailable = .lstAvailable
			loSelected  = .lstSelected
			llFirst     = .T.
			lnIndex     = 0
			.lAnyAvailable = .F.
		
		* Loop throught the selected items in the available list (DO WHILE is used
		* instead of FOR because items may be removed from the available list as we
		* go). Add the selected items to the selected list.
		
			lnI = 1
			do while lnI <= loAvailable.ListCount
				if loAvailable.Selected[lnI]
		
		* If this was the first selected one, deselect all the items in the selected
		* list.
		
					if llFirst
						for lnJ = 1 to loSelected.ListCount
							loSelected.Selected[lnJ] = .F.
						next lnJ
						llFirst = .F.
					endif llFirst
		
		* Add the item to the selected list and select it.
		
					loSelected.AddItem(loAvailable.List[lnI])
					.AfterAddItem(lnI, loSelected.NewIndex)
					loSelected.Selected[loSelected.NewIndex] = .T.
		
		* If items are to be removed from the available list, do so. Otherwise, disable
		* the items.
		
					if .lRemoveFromAvailable
						lnIndex = loAvailable.ListIndex
						loAvailable.RemoveItem(lnI)
						lnIndex = min(lnIndex, loAvailable.ListCount)
					else
						loAvailable.List[lnI] = '\' + loAvailable.List[lnI]
						loAvailable.Selected[lnI] = .F.
						loAvailable.aItems[lnI]   = .T.
						lnI = lnI + 1
					endif .lRemoveFromAvailable
				else
					if not .lRemoveFromAvailable and not loAvailable.aItems[lnI]
						.lAnyAvailable = .T.
					endif not .lRemoveFromAvailable ...
					lnI = lnI + 1
				endif loAvailable.Selected[lnI]
			enddo while lnI <= loAvailable.ListCount
		
		* Set the list index of the selected list to the last one added and refresh
		* the controls.
		
			loSelected.ListIndex = loSelected.NewIndex
			if lnIndex <> 0
				loAvailable.ListIndex = lnIndex
			endif lnIndex <> 0
			.HandleChange(.T.)
			.Refresh()
		endwith
		Thisform.LockScreen = .F.
		
	ENDPROC

	PROCEDURE afteradditem		&& Abstract method that fires after an item was added to the selected list
		lparameters tnAvailableItem, ;
			tnNewSelectedIndex
		
	ENDPROC

	PROCEDURE afterremoveitem		&& Abstract method that fires after an item is removed from the selected list
	ENDPROC

	PROCEDURE beforeremoveitem		&& Abstract method that fires before an item is removed from the selected list
		lparameters tnSelectedItem, ;
			tnNewAvailableIndex
		
	ENDPROC

	PROCEDURE handlechange		&& Handles the fact that the user changed something
		* Flag that the user changed something.
		
		lparameters tlAdd, ;
			tlAll
		with This
			.lChanged  = .T.
			.lSelected = .lstSelected.ListCount > 0
		endwith
		
	ENDPROC

	PROCEDURE Refresh
		* Determine if there are any available items in the available list. This isn't
		* 100% straight-forward if we're not removing items from the available list but
		* just disabling them, because while a item can be disabled by adding a "\" to
		* the start of its text, asking for the text of the item *doesn't* give you
		* back the "\". So the approach we'll take is to use a parallel array (the
		* aItems array that's part of the SFListBox class) to flag disabled items.
		
		local lnI, ;
			lnJ
		with This.lstAvailable
			do case
		
		* If we're removing items from the available list, lAnyAvailable is set based
		* on whether there are any items in the list.
		
				case This.lRemoveFromAvailable
					This.lAnyAvailable = .ListCount <> 0
		
		* If this is the first time the mover list has been refreshed and we're not
		* removing items from the available list, let's copy the items in the available
		* list to an array so we can track disabled items.
		
				case alen(.aItems, 1) <> .ListCount and .ListCount > 0
					This.lAnyAvailable = .F.
					dimension .aItems[.ListCount]
					for lnI = 1 to .ListCount
						for lnJ = 1 to This.lstSelected.ListCount
							if .List[lnI] == This.lstSelected.List[lnJ]
								.aItems[lnI] = .T.
								exit
							endif .List[lnI] == This.lstSelected.List[lnJ]
							if not .aItems[lnI]
								This.lAnyAvailable = .T.
							endif not .aItems[lnI]
						next lnJ
					next lnI
		
		* If this isn't the first time we've been refreshed, check to see if any items
		* are available.
		
				otherwise
					This.lAnyAvailable = .F.
					for lnI = 1 to .ListCount
						if not .aItems[lnI]
							This.lAnyAvailable = .T.
						endif not .aItems[lnI]
					next lnI
			endcase
		endwith
		
		* Sometimes, the selected item in a list isn't actually selected (a dashed line
		* appears around it and ListIndex <> 0 but Selected[ListIndex] is .F.), so
		* let's fix that.
		
		with This
			if .lstAvailable.ListIndex > 0 and ;
				not .lstAvailable.Selected[.lstAvailable.ListIndex]
				.lstAvailable.Selected[.lstAvailable.ListIndex] = .T.
			endif .lstAvailable.ListIndex > 0 ...
			if .lstSelected.ListIndex > 0 and ;
				not .lstSelected.Selected[.lstSelected.ListIndex]
				.lstSelected.Selected[.lstSelected.ListIndex] = .T.
			endif .lstSelected.ListIndex > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE removeall		&& Removes all items in the selected list.
		* Remove all items in the selected list.
		
		local loAvailable, ;
			loSelected, ;
			lnIndex, ;
			lnI, ;
			lnAvailable
		Thisform.LockScreen = .T.
		with This
			loAvailable = .lstAvailable
			loSelected  = .lstSelected
			lnIndex     = loAvailable.ListCount
		
		* First deselect all selected items in the available list.
		
			for lnI = 1 to lnIndex
				loAvailable.Selected[lnI] = .F.
			next lnI
		
		* If items were removed from the available list as they were added to the
		* selected list, add each to the available list and remove it from the
		* selected list until they're all gone.
		
			if .lRemoveFromAvailable
				do while loSelected.ListCount > 0
					lnAvailable = .AddAvailableFromSelected(1)
					.BeforeRemoveItem(1)
					loSelected.RemoveItem(1)
					.AfterRemoveItem()
				enddo while loSelected.ListCount > 0
		
		* If items were disabled in the available list as they were added to the
		* selected list, clear the selected list and enable all the items in the
		* available list.
		
			else
				loSelected.Clear()
				for lnI = 1 to loAvailable.ListCount
					loAvailable.List[lnI]     = loAvailable.List[lnI]
					loAvailable.Selected[lnI] = .T.
					loAvailable.aItems[lnI]   = .F.
				next lnI
				lnAvailable = 1
			endif .lRemoveFromAvailable
		
		* Set the list index to the first item in the available list and refresh all
		* the controls.
		
			if lnAvailable <> 0
				loAvailable.ListIndex = lnAvailable
			endif lnAvailable <> 0
			.lAnyAvailable = .T.
			.HandleChange(.F., .T.)
			.Refresh()
		endwith
		Thisform.LockScreen = .F.
		
	ENDPROC

	PROCEDURE removeselected		&& Removes selected items in the selected list.
		* Remove all selected items in the selected list.
		
		local loAvailable, ;
			loSelected, ;
			lnCurrent, ;
			lnI, ;
			lnAvailable, ;
			lnJ
		Thisform.LockScreen = .T.
		with This
			loAvailable = .lstAvailable
			loSelected  = .lstSelected
			lnCurrent   = loSelected.ListIndex
		
		* First deselect all selected items in the available list.
		
			for lnI = 1 to loAvailable.ListCount
				loAvailable.Selected[lnI] = .F.
			next lnI
		
		* Loop throught the selected items in the selected list (DO WHILE is used
		* instead of FOR because items are removed from the selected list as we go) and
		* process the selected items.
		
			lnI = 1
			lnAvailable = 0
			do while lnI <= loSelected.ListCount
				if loSelected.Selected[lnI]
		
		* If items were removed from the available list as they were added to the
		* selected list, add the selected item to the available list.
		
					if .lRemoveFromAvailable
						lnAvailable = .AddAvailableFromSelected(lnI)
						.BeforeRemoveItem(lnI, lnAvailable)
		
		* If items were disabled in the available list as they were added to the
		* selected list, find the selected item in the available list and enable it.
		
					else
						for lnJ = 1 to loAvailable.ListCount
							if loAvailable.List[lnJ]      = loSelected.List[lnI]
								loAvailable.List[lnJ]     = loSelected.List[lnI]
								loAvailable.Selected[lnJ] = .T.
								loAvailable.aItems[lnJ]   = .F.
								lnAvailable = lnJ
								exit
							endif loAvailable.List[lnJ] = loSelected.List[lnI]
						next lnJ
					endif .lRemoveFromAvailable
		
		* Remove the item in the selected list.
		
					loSelected.RemoveItem(lnI)
					.AfterRemoveItem()
		
		* The item wasn't selected, so move on to the next one.
		
				else
					lnI = lnI + 1
				endif loSelected.Selected(lnI)
			enddo while lnI <= loSelected.ListCount
		
		* Select the last one processed in the available list, and either the formerly
		* selected item or the last item in the selected list. Refresh all the controls.
		
			if lnAvailable <> 0
				loAvailable.ListIndex = lnAvailable
			endif lnAvailable <> 0
			loSelected.ListIndex  = min(lnCurrent, loSelected.ListCount)
			.lAnyAvailable = .T.
			.HandleChange()
			.Refresh()
		endwith
		Thisform.LockScreen = .F.
		
	ENDPROC

	PROCEDURE cmdAdd.Click
		* Add the selected items in the available list to the selected list.
		
		This.Parent.AddSelected()
		
	ENDPROC

	PROCEDURE cmdAdd.Refresh
		* This button is only enabled if an item in the available list is selected.
		
		with This
			.Enabled = .Parent.Enabled and .Parent.lstAvailable.ListIndex > 0
		endwith
		
	ENDPROC

	PROCEDURE cmdAddAll.Click
		* Add all items in the available list to the selected list.
		
		This.Parent.AddAll()
		
	ENDPROC

	PROCEDURE cmdAddAll.Refresh
		* This button is only enabled if there are any items in the available list.
		
		with This
			.Enabled = .Parent.Enabled and .Parent.lAnyAvailable
		endwith
		
	ENDPROC

	PROCEDURE cmdRemove.Click
		* Remove the selected items in the selected list.
		
		This.Parent.RemoveSelected()
		
	ENDPROC

	PROCEDURE cmdRemove.Refresh
		* This button is only enabled if an item in the selected list is selected.
		
		with This
			.Enabled = .Parent.Enabled and .Parent.lstSelected.ListIndex > 0
		endwith
		
	ENDPROC

	PROCEDURE cmdRemoveAll.Click
		* Remove all items in the selected list.
		
		This.Parent.RemoveAll()
		
	ENDPROC

	PROCEDURE cmdRemoveAll.Refresh
		* This button is only enabled if there are any items in the selected list.
		
		with This
			.Enabled = .Parent.Enabled and .Parent.lstSelected.ListCount > 0
		endwith
		
	ENDPROC

	PROCEDURE lstAvailable.Click
		with This
		
		* Select the chosen item
		
			.Selected[.ListIndex] = .T.
		
		* Now refresh our form so our parent (and anything else) knows about what's
		* selected.
		
			Thisform.RefreshForm()
		endwith
		
	ENDPROC

	PROCEDURE lstAvailable.DblClick
		* Treat a double-click like an add.
		
		This.Parent.AddSelected()
		
	ENDPROC

	PROCEDURE lstAvailable.DragDrop
		* The user just dropped something on the list, so check to see if it came from
		* the "selected" list. If so, remove the selected items.
		
		lparameters toSource, ;
			tnXCoord, ;
			tnYCoord
		if toSource.Name = 'lstSelected' and toSource.Parent.Name = This.Parent.Name
			This.Parent.RemoveSelected()
		endif toSource.Name = 'lstSelected' ...
		
	ENDPROC

	PROCEDURE lstAvailable.DragOver
		* If the user held the mouse button down and moved it more than the threshold
		* amount, start a drag.
		
		lparameters toSource, ;
			tnXCoord, ;
			tnYCoord, ;
			tnState
		do case
			case tnState = DRAG_ENTER
				toSource.DragIcon = This.Parent.cDragIcon
			case tnState = DRAG_LEAVE
				toSource.DragIcon = This.Parent.cNoDropIcon
		endcase
		
	ENDPROC

	PROCEDURE lstAvailable.InteractiveChange
		dodefault()
		This.Parent.cmdAdd.Refresh()
		
	ENDPROC

	PROCEDURE lstAvailable.MouseDown
		* Record the current X and Y coordinates so we can later determine if we should
		* start a drag operation.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		with This.Parent
			.nMouseX = tnXCoord
			.nMouseY = tnYCoord
		endwith
		
	ENDPROC

	PROCEDURE lstAvailable.MouseMove
		* If the user held the mouse button down and moved it more than the threshold
		* amount, start a drag.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		with This.Parent
			if tnButton = BUTTON_LEFT and This.ListIndex > 0 and ;
				(abs(tnXCoord - .nMouseX) > .nDragThreshold or ;
				abs(tnYCoord - .nMouseY) > .nDragThreshold) and file(.cDragIcon)
				This.DragIcon = .cDragIcon
				This.Drag()
			endif tnButton = BUTTON_LEFT ...
		endwith
		
	ENDPROC

	PROCEDURE lstSelected.Click
		with This
		
		* Select the chosen item
		
			.Selected[.ListIndex] = .T.
		
		* Now refresh our form so our parent (and anything else) knows about what's
		* selected.
		
			Thisform.RefreshForm()
		endwith
		
	ENDPROC

	PROCEDURE lstSelected.DblClick
		This.Parent.RemoveSelected()
		
	ENDPROC

	PROCEDURE lstSelected.DragDrop
		* The user just dropped something on the list, so check to see if it came from
		* the "available" list. If so, add the selected items.
		
		lparameters toSource, ;
			tnXCoord, ;
			tnYCoord
		if toSource.Name = 'lstAvailable' and toSource.Parent.Name = This.Parent.Name
			This.Parent.AddSelected()
		endif toSource.Name = 'lstSelected' ...
		
	ENDPROC

	PROCEDURE lstSelected.DragOver
		* If the user held the mouse button down and moved it more than the threshold
		* amount, start a drag.
		
		lparameters toSource, ;
			tnXCoord, ;
			tnYCoord, ;
			tnState
		do case
			case tnState = DRAG_ENTER
				toSource.DragIcon = This.Parent.cDragIcon
			case tnState = DRAG_LEAVE
				toSource.DragIcon = This.Parent.cNoDropIcon
		endcase
		
	ENDPROC

	PROCEDURE lstSelected.Init
		* Initialize the first element of aItems to .F.
		
		This.aItems[1] = .F.
		
	ENDPROC

	PROCEDURE lstSelected.InteractiveChange
		This.Parent.cmdRemove.Refresh()
		
	ENDPROC

	PROCEDURE lstSelected.MouseDown
		* Record the current X and Y coordinates so we can later determine if we should
		* start a drag operation.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		with This.Parent
			.nMouseX = tnXCoord
			.nMouseY = tnYCoord
		endwith
		
	ENDPROC

	PROCEDURE lstSelected.MouseMove
		* If the user held the mouse button down and moved it more than the threshold
		* amount, start a drag.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		with This.Parent
			if tnButton = BUTTON_LEFT and This.ListIndex > 0 and ;
				(abs(tnXCoord - .nMouseX) > .nDragThreshold or ;
				abs(tnYCoord - .nMouseY) > .nDragThreshold) and file(.cDragIcon)
				This.DragIcon = .cDragIcon
				This.Drag()
			endif tnButton = BUTTON_LEFT ...
		endwith
		
	ENDPROC

ENDDEFINE
