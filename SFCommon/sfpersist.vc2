*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfpersist.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfconfigmgr AS sfcustom OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: cfilename_assign
		*m: checkpersistmgr		&& Check to make sure the persistence manager exists; if not, create it
		*m: checkscriptmgr		&& Check to make sure the script manager exists; if not, create it
		*m: loadproperties		&& Loads the list of properties from the configuration file
		*m: reset		&& Resets the class
		*m: restore		&& Restores properties from the configuration table
		*p: cfilename		&& The name of the configuration file
		*p: cpersistentclass		&& The class to instantiate for the persistent manager
		*p: cpersistentlibrary		&& The library for the persistent manager class
		*p: cscriptmgrclass		&& The class to instantiate for the script manager class
		*p: cscriptmgrlibrary		&& The library for the script manager class
		*p: levaluating		&& .T. if we're evaluating an expression
		*p: opersist		&& A reference to an SFPersistent object
		*p: oscriptmgr		&& A reference to a script manager object
	*</DefinedPropArrayMethod>

	PROTECTED levaluating,opersist
	cfilename = SFConfig.dbf		&& The name of the configuration file
	cpersistentclass = SFPersistentTable		&& The class to instantiate for the persistent manager
	cpersistentlibrary = SFPersist.vcx		&& The library for the persistent manager class
	cscriptmgrclass = SFScriptMgr		&& The class to instantiate for the script manager class
	cscriptmgrlibrary = SFScript.vcx		&& The library for the script manager class
	levaluating = .F.		&& .T. if we're evaluating an expression
	Name = "sfconfigmgr"
	opersist = .NULL.		&& A reference to an SFPersistent object
	oscriptmgr = .NULL.		&& A reference to a script manager object
	
	PROCEDURE cfilename_assign
		* If the file path is changed, close the existing table.
		
		lparameters tcPath
		with This
			if not tcPath == .cFileName and vartype(.oPersist) = 'O' and ;
				not empty(.oPersist.cAlias) and used(.oPersist.cAlias)
				use in (.oPersist.cAlias)
				.Reset()
			endif not tcPath == .cFileName ...
			.cFileName = tcPath
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE checkpersistmgr		&& Check to make sure the persistence manager exists; if not, create it
		* Instantiate the persistent manager class and set its properties if we don't
		* have one already.
		
		local llReturn
		with This
			if vartype(.oPersist) <> 'O'
				.oPersist = MakeObject(.cPersistentClass, .cPersistentLibrary, '', .T.)
				.oPersist.lUpdateTarget  = .F.
				.oPersist.cFilePath      = .cFileName
				.oPersist.lSaveOnDestroy = .F.
		
		* Open the configuration table and load the list of properties in it.
		
				llReturn = .oPersist.OpenTable()
				if llReturn
					.LoadProperties()
				endif llReturn
			endif vartype(.oPersist) <> 'O'
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE checkscriptmgr		&& Check to make sure the script manager exists; if not, create it
		* Instantiate the script manager if we don't have one already.
		
		with This
			if vartype(.oScriptMgr) <> 'O'
				.oScriptMgr = MakeObject(.cScriptMgrClass, .cScriptMgrLibrary)
			endif vartype(.oScriptMgr) <> 'O'
		endwith
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lcReturn
		do case
		
		* If an error occurs while evaluating an expression, set a flag and return.
		
			case This.lEvaluating
				This.lErrorOccurred = .T.
				return
		
		* Use the normal error handling mechanism for all other types of errors. Note
		* that we add a period to the method name passed. This tells our parent class
		* to return the error resolution string back to us, which is required for RETRY
		* to work.
		
			otherwise
				lcReturn = dodefault(tnError, '.' + tcMethod, tnLine)
				lcReturn = iif(vartype(lcReturn) <> 'C', ccMSG_CONTINUE, lcReturn)
				do case
		
		* It wasn't our error, so pass it back to the calling method.
		
					case '.' $ tcMethod
						return lcReturn
		
		* Handle the error choices.
		
					case lcReturn = ccMSG_RETRY
						retry
					case lcReturn = ccMSG_DEBUG
						debug
						if wexist('Visual FoxPro Debugger')
							keyboard '{SHIFT+F7}' plain
						endif wexist('Visual FoxPro Debugger')
						suspend
					case lcReturn = ccMSG_CANCEL
						cancel
					otherwise
						return
				endcase
		endcase
		
	ENDPROC

	PROTECTED PROCEDURE loadproperties		&& Loads the list of properties from the configuration file
		* Load the list of properties from the configuration file.
		
		local lnSelect, ;
			lcValue
		with This
			lnSelect = select()
			select (.oPersist.cAlias)
			scan
				lcValue = VALUE
		
		* If we have an expression, we won't do any data conversion from the storage
		* data type to the desired data type. Otherwise, we will.
		
				if substr(lcValue, 1, 1) = '='
					.oPersist.AddItem(KEY, TARGET, TYPE, .T.)
				else
					.oPersist.AddItem(KEY, TARGET, TYPE)
				endif substr(lcValue, 1, 1) = '='
			endscan
			select (lnSelect)
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Nuke member object references.
		
		This.oPersist   = .NULL.
		This.oScriptMgr = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE reset		&& Resets the class
		* Nuke the persistence object so we'll recreate it the next time it's needed.
		
		This.oPersist = .NULL.
		
	ENDPROC

	PROCEDURE restore		&& Restores properties from the configuration table
		* Restore properties from the configuration table for the specified filter.
		
		lparameters tcFilter, ;
			toObject
		local lnSelect, ;
			llOK, ;
			llObject, ;
			luValue, ;
			lcScript, ;
			lcTarget
		with This
		
		* Ensure the persistence and script managers have been set up.
		
			if .CheckPersistMgr() 
				.CheckScriptMgr() 
		
		* Spin through the configuration table and restore all settings for the
		* specified filter. Use the script manager to execute any script specified, or
		* evaluate any expression.
		
				lnSelect = select()
				llObject = vartype(toObject) = 'O'
				select (.oPersist.cAlias)
				scan for upper(GROUP) = upper(tcFilter)
					llOK     = .T.
					luValue  = .oPersist.Restore(KEY)
					lcTarget = TARGET
					if vartype(luValue) = 'C' and substr(luValue, 1, 1) = '=' and ;
						vartype(.oScriptMgr) = 'O'
						lcScript = substr(luValue, 2)
						if .oScriptMgr.DoesScriptExist(lcScript)
							luValue = .oScriptMgr.Execute(lcScript)
						else
							.lErrorOccurred = .F.
							.lEvaluating    = .T.
							luValue         = evaluate(lcScript)
							.lEvaluating    = .F.
							llOK            = .lErrorOccurred
						endif .oScriptMgr.DoesScriptExist(lcScript)
					endif vartype(luValue) = 'C' ...
					do case
						case not llOK
						case llObject and pemstatus(toObject, lcTarget, 5)
							store luValue to ('toObject.' + lcTarget)
						case not llObject and type(lcTarget) <> 'U'
							store luValue to (lcTarget)
					endcase
				endscan for upper(GROUP) = upper(tcFilter)
				select (lnSelect)
			endif .CheckPersistMgr() 
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpersistent AS sfcustom OF "sfctrls.vcx" 		&& Base class for persistent properties objects
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfpersist.h"
	*<DefinedPropArrayMethod>
		*m: additem		&& Adds an item that should be persisted
		*m: convertchartotype		&& Converts the specified character string to the specified data type
		*m: converttypetochar		&& Converts the specified value to a character string
		*m: defineitems		&& An abstract method to define the items this class will manage
		*m: restore		&& Restores the values for one or all items
		*m: restoreone		&& Restores the value for a single item
		*m: restoreoneitem		&& Abstract method to restore a single item
		*m: save		&& Saves the values for one or all items
		*m: saveone		&& Saves the value for a single item
		*m: saveoneitem		&& Abstract method to save a single item
		*m: wasitemrestored		&& Returns .T. if the specified item was restored
		*p: lrestoreoninit		&& .T. to restore the values of the items when the object is instantiated
		*p: lsaveondestroy		&& .T. if the current values of the items should be automatically saved when the object is destroyed
		*p: lupdatetarget		&& .T. to have Restore store the value into the managed property
		*a: aitems[1,0]		&& An array of items managed by this class
	*</DefinedPropArrayMethod>

	PROTECTED aitems
	lrestoreoninit = .T.		&& .T. to restore the values of the items when the object is instantiated
	lsaveondestroy = .T.		&& .T. if the current values of the items should be automatically saved when the object is destroyed
	lupdatetarget = .T.		&& .T. to have Restore store the value into the managed property
	Name = "sfpersistent"
	
	PROCEDURE about
		*==============================================================================
		* Class:					SFPersistent
		* Based On:					SFCustom
		* Purpose:					Persistent item base class
		* Author:					Doug Hennig
		* Copyright:				(c) 1999-2002 Stonefield Systems Group Inc.
		* Last revision:			02/25/2002
		* Include file:				SFPERSIST.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Destroy:				calls Save() if This.lSaveOnDestroy is .T.
		*	Init:					calls DefineItems(), and optionally calls
		*							Restore()
		*
		* Custom public properties added:
		*	lRestoreOnInit:			.T. to restore the values of the items when the
		*							object is instantiated
		*	lSaveOnDestroy:			.T. if the current values of the items should be
		*							automatically saved when the object is destroyed
		*	lUpdateTarget:			.T. to have Restore store the value into the
		*							managed property
		*
		* Custom protected properties added:
		*	aItems:					an array of items managed by this class
		*
		* Custom public methods added:
		*	DefineItems:			an abstract method to define the items this class
		*							will manage
		*	Restore:				restores values for one or all items
		*	Save:					saves values for one or all items
		*	WasItemRestored:		returns .T. if the specified item was restored
		*
		* Custom protected methods added:
		*	ConvertCharToType:		converts the specified character string to the
		*							specified data type
		*	ConvertTypeToChar:		converts the specified value to a character string
		*	RestoreOne:				restores the value for a single item
		*	RestoreOneItem:			abstract method to restore a single item
		*	SaveOne:				saves the value for a single item
		*	SaveOneItem:			abstract method to save a single item
		*==============================================================================
		
	ENDPROC

	PROCEDURE additem		&& Adds an item that should be persisted
		*==============================================================================
		* Method:			AddItem
		* Status:			Public
		* Purpose:			Adds an item that should be persisted
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2001 Stonefield Systems Group Inc.
		* Last revision:	07/10/2001
		* Parameters:		tcKey           - the key where the item is stored in the
		*						persistent storage
		*					tcItem          - the item being persisted
		*					tcDataType      - the data type of the item (optional: if it
		*						isn't specified, the type will be determined)
		*					tlNoConvertType - .T. for no conversion or .F. to convert
		*						the persisted string to the desired data type and vice
		*						versa
		* Returns:			.T. if everything went OK
		* Environment in:	none
		* Environment out:	the last row in This.aItems has information about the
		*						item
		*==============================================================================
		
		lparameters tcKey, ;
			tcItem, ;
			tcDataType, ;
			tlNoConvertType
		local lnItem
		
		* Ensure we have valid parameters.
		
		if vartype(tcKey) <> 'C' or empty(tcKey) or vartype(tcItem) <> 'C' or ;
			empty(tcItem) or (pcount() > 2 and (vartype(tcDataType) <> 'C' or ;
			empty(tcDataType))) or (pcount() > 3 and vartype(tlNoConvertType) <> 'L')
			error cnERR_ARGUMENT_INVALID
			return .F.
		endif vartype(tcKey) <> 'C' ...
		
		* Add the item to the array.
		
		with This
			lnItem = alen(.aItems, 1)
			lnItem = iif(lnItem = 1 and empty(.aItems[1, 1]), 1, lnItem + 1)
			dimension .aItems[lnItem, 5]
			.aItems[lnItem, 1] = tcKey
			.aItems[lnItem, 2] = tcItem
			if pcount() > 2
				.aItems[lnItem, 3] = tcDataType
			else
				.aItems[lnItem, 3] = type(tcItem)
			endif pcount() > 3
			.aItems[lnItem, 4] = tlNoConvertType
		endwith
		return .T.
		
	ENDPROC

	PROTECTED PROCEDURE convertchartotype		&& Converts the specified character string to the specified data type
		*==============================================================================
		* Method:			ConvertCharToType
		* Status:			Protected
		* Purpose:			Converts the specified character string to the specified
		*						data type
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2001 Stonefield Systems Group Inc.
		* Last revision:	10/25/2001
		* Parameters:		tuValue - the value to convert
		*					tcType  - the data type to convert it to
		* Returns:			the value converted to the desired type
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tuValue, ;
			tcType
		local lcType, ;
			luReturn, ;
			lnStrict
		lcType = vartype(tuValue)
		do case
			case lcType = tcType
				luReturn = tuValue
			case tcType $ 'NFIBY'
				luReturn = val(alltrim(tuValue))
			case tcType = 'L'
				luReturn = upper(left(tuValue, 1)) = 'Y' or upper(tuValue) = '.T.'
			case tcType = 'D'
				lnStrict = set('STRICTDATE')
				set strictdate to 0
				luReturn = ctod(tuValue)
				set strictdate to lnStrict
			case tcType = 'T'
				lnStrict = set('STRICTDATE')
				set strictdate to 0
				luReturn = ctot(tuValue)
				set strictdate to lnStrict
			otherwise
				error cnERR_ARGUMENT_INVALID
		endcase
		return luReturn
		
	ENDPROC

	PROTECTED PROCEDURE converttypetochar		&& Converts the specified value to a character string
		*==============================================================================
		* Method:			ConvertTypeToChar
		* Status:			Protected
		* Purpose:			Converts the specified value to a string
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2001 Stonefield Systems Group Inc.
		* Last revision:	06/12/2001
		* Parameters:		tuValue - the value to convert
		* Returns:			the value converted to a string
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tuValue
		local lcType, ;
			lcReturn
		lcType = vartype(tuValue)
		do case
			case lcType = 'C'
				lcReturn = tuValue
			case lcType = 'L'
				lcReturn = iif(tuValue, 'Y', 'N')
			case lcType $ 'NFIBY'
				lcReturn = transform(tuValue)
			case lcType = 'D'
				lcReturn = dtoc(tuValue)
			case lcType = 'T'
				lcReturn = ttoc(tuValue)
		endcase
		return lcReturn
		
	ENDPROC

	PROCEDURE defineitems		&& An abstract method to define the items this class will manage
		*==============================================================================
		* Method:			DefineItems
		* Status:			Public
		* Purpose:			Define the items this object will manage
		* Author:			Doug Hennig
		* Copyright:		(c) 1999 Stonefield Systems Group Inc.
		* Last revision:	11/04/99
		* Parameters:		none
		* Returns:			.T. if everything went OK
		* Environment in:	none
		* Environment out:	see This.AddItem
		* Notes:			This method must be coded in a subclass or specific
		*						instance of the object. Here's an example that defines
		*						two items, WindowTopPosition and WindowLeftPosition,
		*						and binds them to the form's Top and Left properties:
		*
		*					llOK = This.AddItem('WindowTopPosition', 'Thisform.Top')
		*					llOK = llOK and This.AddItem('WindowLeftPosition', ;
		*						'Thisform.Left')
		*					return llOK
		*==============================================================================
		
	ENDPROC

	PROCEDURE Destroy
		*==============================================================================
		* Method:			Destroy
		* Status:			Public
		* Purpose:			Save the values of the items managed by this object if
		*						necessary
		* Author:			Doug Hennig
		* Copyright:		(c) 1999 Stonefield Systems Group Inc.
		* Last revision:	11/04/99
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.aItems contains information about the items being
		*						managed
		* Environment out:	the persisted values for the items may have been saved
		*==============================================================================
		
		with This
			if .lSaveOnDestroy
				.Save()
			endif .lSaveOnDestroy
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Initialize the class
		* Author:			Doug Hennig
		* Copyright:		(c) 1999 Stonefield Systems Group Inc.
		* Last revision:	11/04/99
		* Parameters:		tlNoRestore - .T. to not restore the persisted values for the
		*						items
		* Returns:			.T. if everything went OK
		* Environment in:	none
		* Environment out:	This.aItems contains information about the items being
		*						managed
		*					the persisted values for the items may have been restored
		*==============================================================================
		
		lparameters tlNoRestore
		with This
		
		* Call the method where the items to be managed is filled in.
		
			llReturn = .DefineItems()
		
		* If we're supposed to, restore the items managed by the object.
		
			if llReturn and not tlNoRestore and .lRestoreOnInit
				.Restore()
			endif llReturn ...
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE restore		&& Restores the values for one or all items
		*==============================================================================
		* Method:			Restore
		* Status:			Public
		* Purpose:			Restores the values for one or all items
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2001 Stonefield Systems Group Inc.
		* Last revision:	06/28/2001
		* Parameters:		tcItem - the item to restore (optional: if it isn't
		*						specified, the values of all items are restored)
		* Returns:			the value if a single item was specified
		* Environment in:	none
		* Environment out:	the values of the specified item (or all items) has been
		*						restored
		*==============================================================================
		
		lparameters tcItem
		local lcItem, ;
			luReturn, ;
			lnI
		with This
		
		* Ensure that if the property was specified, it's a valid name, and that we
		* have some properties defined.
		
			lcItem   = iif(vartype(tcItem) = 'C' and not empty(tcItem), tcItem, '')
			luReturn = .NULL.
			if alen(.aItems, 2) = 0 or empty(.aItems[1, 1]) or ;
				empty(.aItems[1, 2])
				error ccERR_NO_ITEMS
				return .F.
			endif alen(.aItems, 2) = 0 ...
		
		* If no item was specified, restore them all.
		
			if empty(lcItem)
				for lnI = 1 to alen(.aItems, 1)
					.RestoreOne(lnI)
				next lnI
		
		* If an item was specified, try to find it. If we can, restore it. If not, give
		* an error.
		
			else
				lnI = ascan(.aItems, lcItem)
				if lnI > 0
					lnI = asubscript(.aItems, lnI, 1)
					luReturn = .RestoreOne(lnI)
				else
					error cnERR_PROPERTY_NOT_FOUND, tcItem
				endif lnI > 0
			endif empty(lcItem)
		endwith
		return luReturn
		
	ENDPROC

	PROTECTED PROCEDURE restoreone		&& Restores the value for a single item
		*==============================================================================
		* Method:			RestoreOne
		* Status:			Protected
		* Purpose:			Restores the value for a single item
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2002 Stonefield Systems Group Inc.
		* Last revision:	02/25/2002
		* Parameters:		tnItem - the row number in This.aItems for the item
		* Returns:			the value or .NULL. if it failed
		* Environment in:	This.aItems has been properly set up
		* Environment out:	the value for the specified item has been restored
		*					the fifth column of the row for this key in This.aItems is
		*						.T. if the value was restored
		*==============================================================================
		
		lparameters tnItem
		local lcItem, ;
			luDefault, ;
			luValue
		with This
		
		* If we're going to be updating the target item, get it's name and current
		* value. 
		
			if .lUpdateTarget
				lcItem    = .aItems[tnItem, 2]
				luDefault = evaluate(lcItem)
			endif .lUpdateTarget
		
		* Call RestoreOneItem to get the value, convert it to the proper data type if
		* necessary, and store it in the bound item if the value is different.
		
			luValue = .RestoreOneItem(.aItems[tnItem, 1], luDefault)
			if not isnull(luValue)
				if not .aItems[tnItem, 4]
					luValue = .ConvertCharToType(luValue, .aItems[tnItem, 3])
				endif not .aItems[tnItem, 4] ...
				if .lUpdateTarget and not luDefault == luValue
					store luValue to (lcItem)
					.aItems[tnItem, 5] = .T.
				endif .lUpdateTarget ...
			endif isnull(luValue)
		endwith
		return luValue
		
	ENDPROC

	PROTECTED PROCEDURE restoreoneitem		&& Abstract method to restore a single item
		*==============================================================================
		* Method:			RestoreOneItem
		* Status:			Protected
		* Purpose:			Abstract method to restore a single item
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	06/26/2001
		* Parameters:		tcKey     - the key where the item is stored in the
		*						persistent storage
		*					tuDefault - the current value for the item
		* Returns:			.T. if everything went OK
		* Environment in:	see the implementation in a subclass
		* Environment out:	see the implementation in a subclass
		* Notes:			This method must be coded in a subclass or specific
		*						instance of the object
		*==============================================================================
		
		lparameters tcKey, ;
			tuDefault
		
	ENDPROC

	PROCEDURE save		&& Saves the values for one or all items
		*==============================================================================
		* Method:			Save
		* Status:			Public
		* Purpose:			Save the values for one or all items
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2002 Stonefield Systems Group Inc.
		* Last revision:	03/15/2002
		* Parameters:		tcItem  - the item to save (optional: if it isn't
		*						specified, the values of all items are saved)
		*					tuValue - the value to save if a single item was specified
		*						(optional: if it isn't specified, the current value of
		*						the bound item is used)
		* Returns:			.T. if everything went OK
		* Environment in:	none
		* Environment out:	the values of the specified item (or all items) has been
		*						persisted
		*==============================================================================
		
		lparameters tcItem, ;
			tuValue
		local llReturn, ;
			lnI
		with This
		
		* Ensure that if the item was specified, it's a valid name, and that we have
		* some items defined.
		
			if pcount() = 1 and (vartype(tcItem) <> 'C' or empty(tcItem))
				error cnERR_ARGUMENT_INVALID
				return .F.
			endif pcount() = 1 ...
			if alen(.aItems, 2) = 0 or empty(.aItems[1, 1]) or ;
				empty(.aItems[1, 2])
				error ccERR_NO_ITEMS
				return .F.
			endif alen(.aItems, 2) = 0 ...
		
		* If no item was specified, save them all.
		
			llReturn = .T.
			if pcount() = 0
				for lnI = 1 to alen(.aItems, 1)
					llReturn = llReturn and .SaveOne(lnI)
				next lnI
		
		* If an item was specified, try to find it. If we can, save it. If not, give an
		* error.
		
			else
				lnI = ascan(.aItems, tcItem)
				if lnI > 0
					lnI = asubscript(.aItems, lnI, 1)
					if pcount() = 1
						llReturn = .SaveOne(lnI)
					else
						llReturn = .SaveOne(lnI, tuValue)
					endif pcount() = 1
				else
					error cnERR_PROPERTY_NOT_FOUND, tcItem
					llReturn = .F.
				endif lnI > 0
			endif pcount() = 0
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE saveone		&& Saves the value for a single item
		*==============================================================================
		* Method:			SaveOne
		* Status:			Protected
		* Purpose:			Saves the value for a single item
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2002 Stonefield Systems Group Inc.
		* Last revision:	03/15/2002
		* Parameters:		tnItem  - the row number in This.aItems for the item
		*					tuValue - the value to save if a single item was specified
		*						(optional: if it isn't specified, the current value of
		*						the bound item is used)
		* Returns:			.T. if everything went OK
		* Environment in:	This.aItems has been properly set up
		* Environment out:	the value for the specified item has been saved
		*==============================================================================
		
		lparameters tnItem, ;
			tuValue
		local luValue, ;
			llReturn
		with This
		
		* If it wasn't passed, get the value from the bound item. Convert the value to
		* character if we're supposed to, then call SaveOneItem to save it.
		
			if pcount() = 1
				luValue = evaluate(.aItems[tnItem, 2])
			else
				luValue = tuValue
			endif pcount() = 1
			if not .aItems[tnItem, 4]
				luValue = .ConvertTypeToChar(luValue)
			endif not .aItems[tnItem, 4]
			llReturn = .SaveOneItem(.aItems[tnItem, 1], luValue)
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE saveoneitem		&& Abstract method to save a single item
		*==============================================================================
		* Method:			SaveOneItem
		* Status:			Protected
		* Purpose:			Abstract method to save a single item
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	06/26/2001
		* Parameters:		tcKey   - the key where the item is stored in the
		*						persistent storage
		*					tuValue - the value to store
		* Returns:			.T. if everything went OK
		* Environment in:	see the implementation in a subclass
		* Environment out:	see the implementation in a subclass
		* Notes:			This method must be coded in a subclass or specific
		*						instance of the object
		*==============================================================================
		
		lparameters tcKey, ;
			tuValue
		
	ENDPROC

	PROCEDURE wasitemrestored		&& Returns .T. if the specified item was restored
		*==============================================================================
		* Method:			WasItemRestored
		* Status:			Public
		* Purpose:			Returns .T. if the specified item was restored
		* Author:			Doug Hennig
		* Copyright:		(c) 2000-2001 Stonefield Systems Group Inc.
		* Last revision:	06/26/2001
		* Parameters:		tcItem - the item to restore
		* Returns:			.T. if the item was restored
		* Environment in:	none
		* Environment out:	the values of the specified item (or all items) has been
		*						restored
		*==============================================================================
		
		lparameters tcItem
		local llReturn, ;
			lnI
		with This
		
		* Ensure that if the property was specified, it's a valid name, and that we
		* have some properties defined.
		
			if pcount() = 1 and (vartype(tcItem) <> 'C' or empty(tcItem))
				error cnERR_ARGUMENT_INVALID
				return .F.
			endif pcount() = 1 ...
			if alen(.aItems, 2) = 0 or empty(.aItems[1, 1]) or ;
				empty(.aItems[1, 2])
				error ccERR_NO_ITEMS
				return .F.
			endif alen(.aItems, 2) = 0 ...
		
		* Try to find the item. If we can, return .T. if it was restored.
		
			lnI = ascan(.aItems, tcItem)
			if lnI > 0
				lnI      = asubscript(.aItems, lnI, 1)
				llReturn = .aItems[lnI, 5]
			else
				error cnERR_PROPERTY_NOT_FOUND, tcItem
				llReturn = .F.
			endif lnI > 0
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpersistentfile AS sfpersistent OF "sfpersist.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: cfilepath_assign
		*p: cfilepath		&& The file used for persistent storage
	*</DefinedPropArrayMethod>

	cfilepath = 		&& The file used for persistent storage
	Name = "sfpersistentfile"
	
	PROCEDURE cfilepath_assign
		lparameters tcValue
		This.cFilePath = fullpath(tcValue)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpersistentform AS sfpersistentregistry OF "sfpersist.vcx" 		&& Saves and restores form size and position
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "sfpersistentform"
	
	PROCEDURE defineitems
		* We'll manage the left, top, height, and width properties of the form.
		
		with This
			.AddItem('Left',   'Thisform.Left')
			.AddItem('Top',    'Thisform.Top')
			.AddItem('Height', 'Thisform.Height')
			.AddItem('Width',  'Thisform.Width')
		endwith
		
	ENDPROC

	PROCEDURE restore
		lparameters tcItem
		dodefault(tcItem)
		with This
			do case
				case .WasItemRestored('Top') or .WasItemRestored('Left')
				case not type('Thisform.Name') = 'C'
				otherwise
					Thisform.AutoCenter = Thisform.AutoCenter
			endcase
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpersistentinifile AS sfpersistentfile OF "sfpersist.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	Name = "sfpersistentinifile"
	
	PROCEDURE Init
		lparameters tlNoRestore
		declare integer GetPrivateProfileString in Win32API ;
			string cSection, string cEntry, string cDefault, string @ cBuffer, ;
			integer nBufferSize, string cINIFile
		declare integer WritePrivateProfileString in Win32API ;
			string cSection, string cEntry, string cValue, string cINIFile
		dodefault(tlNoRestore)
		
	ENDPROC

	PROCEDURE restoreoneitem
		*==============================================================================
		* Method:			RestoreOneItem
		* Status:			Protected
		* Purpose:			Restores the value of a single item from the INI file
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2001 Stonefield Systems Group Inc.
		* Last revision:	06/28/2001
		* Parameters:		tcKey     - the key where the item is stored in the
		*						persistent storage (the section name and key name
		*						separated with commas)
		*					tuDefault - the current value for the item
		* Returns:			the value from the INI file
		* Environment in:	This.cFilePath contains the name of the INI file
		* Environment out:	none
		*==============================================================================
		
		lparameters tcKey, ;
			tuDefault
		local luValue, ;
			lnPos, ;
			lcSection, ;
			lcKey, ;
			lcBuffer, ;
			lcDefault, ;
			luValue
		#define ccNULL             chr(0)
		#define cnBUFFER_SIZE      2048
		with This
		
		* Ensure we have a valid INI file. If not, we can't do anything.
		
			if empty(.cFilePath) or vartype(.cFilePath) <> 'C' or not file(.cFilePath)
				luValue = .NULL.
		
		* Read the value from the INI file.
		
			else
				lnPos     = at(',', tcKey)
				lcSection = left(tcKey, lnPos - 1)
				lcKey     = substr(tcKey, lnPos + 1)
				lcBuffer  = replicate(ccNULL, cnBUFFER_SIZE)
				lcDefault = .ConvertTypeToChar(tuDefault)
				GetPrivateProfileString(lcSection, lcKey, lcDefault, @lcBuffer, ;
					cnBUFFER_SIZE, .cFilePath)
				luValue   = strtran(lcBuffer, ccNULL)
			endif empty(.cFilePath) ...
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE saveoneitem
		*==============================================================================
		* Method:			SaveOneItem
		* Status:			Protected
		* Purpose:			Saves the value of a single item to the INI file
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	06/28/2001
		* Parameters:		tcKey   - the key where the item is stored in the
		*						persistent storage (the section name and key name
		*						separated with commas)
		*					tuValue - the value to store
		* Returns:			.T. if everything went OK
		* Environment in:	This.cFilePath contains the name of the INI file
		* Environment out:	the value for the specified item has been saved
		*==============================================================================
		
		lparameters tcKey, ;
			tuValue
		local lnPos, ;
			lcSection, ;
			lcKey, ;
			llReturn
		with This
		
		* If we have a valid INI file and section, save it.
		
			if not empty(.cFilePath) and vartype(.cFilePath) = 'C' and file(.cFilePath)
				lnPos     = at(',', tcKey)
				lcSection = left(tcKey, lnPos - 1)
				lcKey     = substr(tcKey, lnPos + 1)
				llReturn  = WritePrivateProfileString(lcSection, lcKey, tuValue, ;
					.cFilePath) > 0
			endif not empty(.cFilePath) ...
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpersistentregistry AS sfpersistent OF "sfpersist.vcx" 		&& Saves and restores persistent properties from the Registry
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfpersist.h"
	*<DefinedPropArrayMethod>
		*p: ckey		&& The Registry key where the properties should be stored
		*p: cregistryclass		&& The class to use for Registry handling
		*p: cregistrylibrary		&& The library the cRegistryClass is located in
		*p: oregistry		&& An object reference to the Registry handling object
	*</DefinedPropArrayMethod>

	PROTECTED oregistry
	ckey = 		&& The Registry key where the properties should be stored
	cregistryclass = SFRegistry		&& The class to use for Registry handling
	cregistrylibrary = SFRegistry.vcx		&& The library the cRegistryClass is located in
	Name = "sfpersistentregistry"
	oregistry = .NULL.		&& An object reference to the Registry handling object
	
	PROCEDURE about
		*==============================================================================
		* Class:					SFPersistentRegistry
		* Based On:					SFPersistent
		* Purpose:					Read/save persistent properties from the Registry
		* Author:					Doug Hennig
		* Copyright:				(c) 1999-2001 Stonefield Systems Group Inc.
		* Last revision:			06/26/2001
		* Include file:				none
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Init:					instantiate an SFRegistry class into This.oRegistry
		*							and set the cKey property from a passed value
		*	RestoreOneItem:			reads the value of a single item from the Registry
		*	ReleaseMembers:			nuke member objects
		*	SaveOneItem:			saves the value of a single item to the Registry
		*
		* Custom public properties added:
		*	cKey:					the Registry key where the values should be stored
		*	cRegistryClass:			the class to use for Registry handling (default =
		*							SFRegistry)
		*	cRegistryLibrary:		the library the cRegistryClass is located in
		*							(default = SFFFC.vcx)
		*
		* Custom protected properties added:
		*	oRegistry:				an object reference to the Registry handling object
		*
		* Custom public methods added:
		*	none
		*
		* Custom protected methods added:
		*	none
		*==============================================================================
		
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Status:			Public
		* Purpose:			Instantiate an SFRegistry class into This.oRegistry and set
		*						the cKey property from a passed value
		* Author:			Doug Hennig
		* Copyright:		(c) 1999 Stonefield Systems Group Inc.
		* Last revision:	11/04/99
		* Parameters:		tcKey       - the Registry key to use
		*					tlNoRestore - .T. to not restore the persisted values for
		*						the items
		* Returns:			.T. if everything went OK
		* Environment in:	the class specified in This.cRegistryClass and
		*						This.cRegistryLibrary can be found
		*					MAKEOBJECT.PRG is available
		* Environment out:	This.oRegistry contains a reference to a Registry handling
		*						object
		*					if tcKey was passed, it's put into This.cKey
		*==============================================================================
		
		lparameters tcKey, ;
			tlNoRestore
		with This
		
		* Save the key if it was specified.
		
			if vartype(tcKey) = 'C' and not empty(tcKey)
				.cKey = tcKey
			endif vartype(tcKey) = 'C' ...
		
		* Create an SFRegistry object to do the actual dirty work.
		
			.oRegistry = MakeObject(.cRegistryClass, .cRegistryLibrary, '', .cKey)
		endwith
		return dodefault(tlNoRestore)
		
	ENDPROC

	PROCEDURE releasemembers
		*==============================================================================
		* Method:			ReleaseMembers
		* Status:			Public
		* Purpose:			Nuke the member objects
		* Author:			Doug Hennig
		* Copyright:		(c) 1999 Stonefield Systems Group Inc.
		* Last revision:	11/04/99
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.oRegistry is set to .NULL.
		*==============================================================================
		
		dodefault()
		This.oRegistry = .NULL.
		
	ENDPROC

	PROCEDURE restoreoneitem
		*==============================================================================
		* Method:			RestoreOneItem
		* Status:			Protected
		* Purpose:			Restores the value of a single item from the Registry
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2001 Stonefield Systems Group Inc.
		* Last revision:	06/26/2001
		* Parameters:		tcKey     - the key where the item is stored in the
		*						persistent storage
		*					tuDefault - the current value for the item
		* Returns:			the value from the Registry
		* Environment in:	This.cKey contains the key for the Registry
		* Environment out:	none
		*==============================================================================
		
		lparameters tcKey, ;
			tuDefault
		local luValue, ;
			llKey
		with This
		
		* Ensure we have a valid key. If not, we can't do anything.
		
			if empty(.cKey)
				luValue = .NULL.
		
		* Use the oRegistry object to get the value.
		
			else
				llKey   = .oRegistry.IsKeyValue(.cKey, tcKey)
				luValue = iif(llKey, .oRegistry.GetKey(.cKey, tcKey), tuDefault)
			endif empty(.cKey)
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE saveoneitem
		*==============================================================================
		* Method:			SaveOneItem
		* Status:			Protected
		* Purpose:			Abstract method to save a single item
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	06/26/2001
		* Parameters:		tcKey   - the key where the item is stored in the
		*						persistent storage
		*					tuValue - the value to store
		* Returns:			.T. if everything went OK
		* Environment in:	This.cKey contains the key for the Registry
		* Environment out:	the value for the specified item has been saved
		*==============================================================================
		
		lparameters tcKey, ;
			tuValue
		local llReturn
		with This
		
		* If we have a valid key, use the oRegistry object to save it.
		
			if not empty(.cKey)
				llReturn = .oRegistry.SetKey(.cKey, tcKey, tuValue)
			endif empty(.cKey)
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpersistenttable AS sfpersistentfile OF "sfpersist.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: opentable		&& Opens the persistence table
		*p: calias		&& The alias of the persistence table
		*p: ckeyfield		&& The name of the field containing the key
		*p: ctag		&& The tag on which to seek for the value
		*p: cvaluefield		&& The name of the field containing the value
	*</DefinedPropArrayMethod>

	calias = 		&& The alias of the persistence table
	ckeyfield = KEY		&& The name of the field containing the key
	ctag = KEY		&& The tag on which to seek for the value
	cvaluefield = VALUE		&& The name of the field containing the value
	Name = "sfpersistenttable"
	
	PROCEDURE Init
		lparameters tlNoRestore
		dodefault(tlNoRestore)
		if empty(This.cAlias)
			This.cAlias = sys(2015)
		endif empty(This.cAlias)
		
	ENDPROC

	PROCEDURE opentable		&& Opens the persistence table
		local llReturn
		with This
			do case
				case used(.cAlias)
					llReturn = .T.
				case used(juststem(.cFilePath))
					.cAlias  = juststem(.cFilePath)
					llReturn = .T.
				case empty(.cFilePath) or vartype(.cFilePath) <> 'C' or ;
					not file(.cFilePath)
					llReturn = .F.
				otherwise
					use (.cFilePath) again alias(.cAlias) shared in 0
					llReturn = used(.cAlias)
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE restoreoneitem
		*==============================================================================
		* Method:			RestoreOneItem
		* Status:			Protected
		* Purpose:			Restores the value of a single item from the table
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2002 Stonefield Systems Group Inc.
		* Last revision:	12/19/2002
		* Parameters:		tcKey     - the key where the item is stored in the
		*						persistent storage
		*					tuDefault - the current value for the item
		* Returns:			the value from the table
		* Environment in:	This.cAlias contains the alias of the table, This.cTag
		*						contains the tag to seek on for the key, and
		*						This.cValueField contains the name of the value field
		* Environment out:	none
		*==============================================================================
		
		lparameters tcKey, ;
			tuDefault
		local luValue
		with This
			do case
				case not .OpenTable()
					luValue = .NULL.
				case not seek(upper(tcKey), .cAlias, .cTag)
					luValue = tuDefault
				otherwise
					luValue = evaluate(.cAlias + '.' + .cValueField)
					if vartype(luValue) = 'C' and '<<' $ luValue
						luValue = textmerge(luValue)
					endif vartype(luValue) = 'C' ...
			endcase
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE saveoneitem
		*==============================================================================
		* Method:			SaveOneItem
		* Status:			Protected
		* Purpose:			Saves the value of a single item to the table
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	06/28/2001
		* Parameters:		tcKey   - the key where the item is stored in the
		*						persistent storage
		*					tuValue - the value to store
		* Returns:			.T. if everything went OK
		* Environment in:	This.cAlias contains the alias of the table, This.cTag
		*						contains the tag to seek on for the key,
		*						This.cValueField contains the name of the value field,
		*						and This.cKeyField contains the name of the key field
		* Environment out:	the value for the specified item has been saved
		*==============================================================================
		
		lparameters tcKey, ;
			tuValue
		with This
			do case
				case not .OpenTable()
					llReturn = .F.
				case not seek(upper(tcKey), .cAlias, .cTag)
					lcKey   = .cKeyField
					lcValue = .cValueField
					insert into (.cAlias) (&lcKey, &lcValue) values (tcKey, tuValue)
				otherwise
					replace (.cValueField) with luValue in (.cAlias)
					llReturn = .T.
			endcase
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE
