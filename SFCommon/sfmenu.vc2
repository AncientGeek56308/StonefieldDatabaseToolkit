*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfmenu.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfbar AS sfcollection OF "sfcollection.vcx" 		&& A bar in a popup
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the submenu popup for this bar
		*m: addbars		&& Add bars to the submenu popup for this bar
		*m: addseparatorbar		&& Adds a separator bar to the submenu popup for this bar
		*m: allow		&& Determine if the bar is enabled
		*m: click		&& Called when the bar is chosen
		*m: define		&& Defines the bar
		*m: findbarposition		&& Finds where the bar should be placed
		*m: hide		&& Hides the bar
		*m: lmarked_assign
		*m: lvisible_assign
		*m: show		&& Displays the bar
		*p: cactiveformmethod		&& The method of the active form to execute
		*p: cappobjectmethod		&& The method of the application object to execute
		*p: cappobjectname		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
		*p: cbarposition		&& A "before" or "after" bar number clause
		*p: ccaption		&& The caption for the bar
		*p: cinstancename		&& The complete object path to this object starting from the menu object
		*p: ckey		&& The hotkey for the bar
		*p: ckeytext		&& The text for the hotkey
		*p: cmenuclauses		&& Other clauses for bar
		*p: conclickcommand		&& The command to execute when the bar is clicked
		*p: cpicturefile		&& The file name for the picture to use
		*p: cpictureresource		&& The system menu bar name for the picture to use
		*p: cpopupname		&& The name of the popup this bar belongs to
		*p: cpopupnamethis		&& The name of the popup this bar uses for submenus
		*p: cskipfor		&& The SKIP FOR clause for the bar
		*p: cstatusbartext		&& The text displayed in the status bar when this bar is highlighted
		*p: csystembar		&& The name of the VFP system menu bar if this is one of those
		*p: ldefined		&& .T. if the menu bar for this object has been defined
		*p: lenabled		&& .T. if the bar is enabled
		*p: linvert		&& .T. to make this an inverted bar
		*p: lmarked		&& .T. if the bar is marked
		*p: lmru		&& .T. to add an MRU bar at the bottom of the submenu
		*p: lspecified		&& .T. if the bar number is specified at a certain position
		*p: lvisible		&& .T. if the bar should be visible
		*p: nbarnumber		&& The number of the bar
		*p: nseparatorbarcount		&& The number of separator bars in the menu
	*</DefinedPropArrayMethod>

	PROTECTED cpopupname,cpopupnamethis,ldefined,lspecified,nseparatorbarcount
	cactiveformmethod = 		&& The method of the active form to execute
	cappobjectmethod = 		&& The method of the application object to execute
	cappobjectname = oApp		&& The name of the variable containing the application object (only used if cAppObjectMethod is filled in)
	cbarposition = 		&& A "before" or "after" bar number clause
	ccaption = 		&& The caption for the bar
	cinstancename = 		&& The complete object path to this object starting from the menu object
	ckey = 		&& The hotkey for the bar
	ckeytext = 		&& The text for the hotkey
	cmenuclauses = 		&& Other clauses for bar
	conclickcommand = 		&& The command to execute when the bar is clicked
	cpicturefile = 		&& The file name for the picture to use
	cpictureresource = 		&& The system menu bar name for the picture to use
	cpopupname = 		&& The name of the popup this bar belongs to
	cpopupnamethis = 		&& The name of the popup this bar uses for submenus
	cskipfor = not This.Allow()		&& The SKIP FOR clause for the bar
	cstatusbartext = 		&& The text displayed in the status bar when this bar is highlighted
	csystembar = 		&& The name of the VFP system menu bar if this is one of those
	ldefined = .F.		&& .T. if the menu bar for this object has been defined
	lenabled = .T.		&& .T. if the bar is enabled
	linvert = .F.		&& .T. to make this an inverted bar
	lmarked = .F.		&& .T. if the bar is marked
	lmru = .F.		&& .T. to add an MRU bar at the bottom of the submenu
	lspecified = .F.		&& .T. if the bar number is specified at a certain position
	lvisible = .T.		&& .T. if the bar should be visible
	Name = "sfbar"
	nbarnumber = 0		&& The number of the bar
	nseparatorbarcount = 0		&& The number of separator bars in the menu
	
	PROCEDURE about
		* Thanks to Jim Slater for suggesting (and mostly implementing) the following
		* ideas:
		*
		* - Submenu support
		* - Support for specifying a bar by name rather than number in cBarPosition
		* - Support for the cAppObjectName property
		* - Support for multi-line code in cOnClickCommand
		* - Bug fixes
		
	ENDPROC

	PROCEDURE addbar		&& Adds a bar to the submenu popup for this bar
		lparameters tcClass, ;
			tcLibrary, ;
			tcName, ;
			tnBarNumber
		local lcName, ;
			lnBarNumber, ;
			llSpecified, ;
			loBar
		with This
		
		* Create a bar number if one wasn't passed.
		
			if vartype(tnBarNumber) = 'N' and tnBarNumber <> 0
				lnBarNumber = tnBarNumber
				llSpecified = .T.
			else
				lnBarNumber = .Count + 1
			endif vartype(tnBarNumber) = 'N' ...
		
		* Create the object as a member and increment the bar count.
		
			if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
				.AddObject(tcName, tcClass, lnBarNumber, .cPopupNameThis, llSpecified)
			else
				.NewObject(tcName, tcClass, tcLibrary, '', lnBarNumber, ;
					.cPopupNameThis, llSpecified)
			endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
		
		* Add the bar to the collection.
		
			loBar = evaluate('.' + tcName)
			.AddItem(loBar, tcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE addbars		&& Add bars to the submenu popup for this bar
		* Abstract method
		
	ENDPROC

	PROCEDURE addseparatorbar		&& Adds a separator bar to the submenu popup for this bar
		local lcName, ;
			loBar
		with This
			.nSeparatorBarCount = .nSeparatorBarCount + 1
			lcName = 'Separator' + transform(.nSeparatorBarCount)
			loBar  = .AddBar('SFSeparatorBar', 'SFMenu.vcx', lcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE allow		&& Determine if the bar is enabled
		* Abstract method
		
	ENDPROC

	PROCEDURE click		&& Called when the bar is chosen
		local lcMethod, ;
			lnPos, ;
			lcPadPath, ;
			lcBarPath, ;
			lcCommand
		with This
			do case
		
		* If a method of the application object was specified, call it.
		
				case not empty(.cAppObjectMethod)
					lcMethod = .cAppObjectMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type(.cAppObjectName + '.Name') = 'C' and ;
						pemstatus(evaluate(.cAppObjectName), lcMethod, 5)
						evaluate(.cAppObjectName + '.' + .cAppObjectMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type(.cAppObjectName + '.Name') = 'C' ...
		
		* If a method of the active form was specified, call it.
		
				case not empty(.cActiveFormMethod)
					lcMethod = .cActiveFormMethod
					lnPos    = at('(', lcMethod)
					if lnPos > 0
						lcMethod = left(lcMethod, lnPos - 1)
					endif lnPos > 0
					if type('_screen.ActiveForm.Name') = 'C' and ;
						pemstatus(_screen.ActiveForm, lcMethod, 5)
						evaluate('_screen.ActiveForm.' + .cActiveFormMethod + ;
							iif(lnPos = 0, '()', ''))
					endif type('_screen.ActiveForm.Name') = 'C' ...
		
		* If an command to execute was specified, call it.
		
				case not empty(.cOnClickCommand)
					lcPadPath = .Parent.cInstanceName + '.'
					lcBarPath = lcPadPath + .Name + '.'
					lcCommand = strtran(strtran(.cOnClickCommand, 'This.Parent.', ;
						lcPadPath), 'This.', lcBarPath)
					if ccCR $ lcCommand or ccCRLF $ lcCommand
						execscript(lcCommand)
					else
						&lcCommand
					endif ccCR $ lcCommand ...
			endcase
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE define		&& Defines the bar
		local lcPopupName, ;
			lcPadPath, ;
			lcBarPath, ;
			llSystemBar, ;
			lcBarNumber, ;
			lcSkipFor, ;
			lcBarPosition, ;
			lcBarName, ;
			lnI, ;
			loBar, ;
			lcClauses, ;
			lcPopupNameThis
		with This
			lcPopupName    = .cPopupName
			lcPadPath      = .Parent.cInstanceName + '.'
			.cInstanceName = lcPadPath + .Name
			lcBarPath      = .cInstanceName + '.'
		
		* Get the bar number based on whether we're a system bar or not.
		
			if empty(.cSystemBar)
				lcBarNumber = transform(.nBarNumber)
			else
				lcBarNumber = transform(evaluate(.cSystemBar))
				llSystemBar = .T.
			endif empty(.cSystemBar)
		
		* Create a default status bar text if we don't have one.
		
			if empty(.cStatusBarText)
				.cStatusBarText = strtran(strtran(.cCaption, '\<'), '\')
			endif empty(.cStatusBarText)
		
		* Set the SKIP FOR for the bar.
		
			lcSkipFor = 'not ' + lcBarPath + 'lEnabled'
			if not empty(.cSkipFor)
				lcSkipFor = lcSkipFor + ' or ' + ;
					strtran(strtran(.cSkipFor, 'This.Parent.', lcPadPath), 'This.', ;
					lcBarPath)
			endif not empty(.cSkipFor)
		
		* If a bar position has been defined, it may have been defined by bar name
		* rather than number, so get the appropriate bar number.
		
			lcBarPosition = ''
			if not empty(.cBarPosition)
				lcBarName = alltrim(upper(substr(.cBarPosition, 7)))
				if val(lcBarName) = 0
					for lnI = 1 to .nBarNumber - 1
						loBar = .Parent.Item(lnI)
						do case
							case not upper(loBar.Name) == lcBarName
							case empty(loBar.cSystemBar)
								lcBarPosition = trim(left(.cBarPosition, 6)) + ' ' + ;
									transform(loBar.nBarNumber)
								exit
							otherwise
								lcBarPosition = trim(left(.cBarPosition, 6)) + ' ' + ;
									transform(evaluate(loBar.cSystemBar))
								exit
						endcase
					next lnI
				else
					lcBarPosition = .cBarPosition
				endif val(lcBarName) = 0
			endif not empty(.cBarPosition)
		
		* Set the other clauses of the DEFINE BAR command.
		
			lcClauses = .cMenuClauses + iif(empty(.cMenuClauses), '', ' ') + ;
				lcBarPosition
			if not empty(.cKey)
				lcClauses = lcClauses + ' key ' + .cKey + ", '" + .cKeyText + "'"
			endif not empty(.cKey)
			if .lInvert and clVFP7ORLATER
				lcClauses = lcClauses + ' invert'
			endif .lInvert ...
			do case
				case not clVFP7ORLATER
				case not empty(.cPictureResource)
					lcClauses = lcClauses + ' pictres ' + .cPictureResource
				case not empty(.cPicturefile)
					lcClauses = lcClauses + " picture '" + .cPicturefile + "'"
				case not empty(.cSystemBar)
					lcClauses = lcClauses + ' pictres ' + .cSystemBar
			endcase
		
		* Define the bar.
		
			define bar &lcBarNumber of &lcPopupName prompt .cCaption ;
				message .cStatusBarText skip for &lcSkipFor &lcClauses
		
		* Mark the bar if it's supposed to be.
		
			if .lMarked
				set mark of bar &lcBarNumber of &lcPopupName to .T.
			endif .lMarked
		
		* If this isn't a system bar, call the Click method when the bar's selected.
		
			if not llSystemBar
				on selection bar &lcBarNumber of &lcPopupName &lcBarPath.Click()
			endif not llSystemBar
		
		* If we have any bars in our submenu, create the popup for it.
		
			if .Count > 0
				lcPopupNameThis = .cPopupNameThis
				define popup (.cPopupNameThis) margin relative shadow color scheme 4
				on bar &lcBarNumber of &lcPopupName activate popup &lcPopupNameThis
		
		* Now add bars to the submenu.
		
				.AddBars()
		
		* If this is an MRU submenu (only in VFP 7 or later), add an MRU bar at the
		* end.
		
				if .lMRU and clVFP7ORLATER
					.AddBar(.cMRUBarClass, .cMRUBarLibrary, 'MRUBar')
				endif .lMRU ...
			endif .Count > 0
		
		* Flag that the menu bar has been defined.
		
			.lDefined = .T.
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE findbarposition		&& Finds where the bar should be placed
		local lnBar, ;
			loBar, ;
			lcBarNumber, ;
			llFoundBar
		with This
		
		* We'll only do this if we don't already have a bar position.
		
			if empty(.cBarPosition)
		
		* See if there are any bars before this one that are currently visible.
		
				for lnBar = .nBarNumber - 1 to 1 step -1
					loBar = .Parent.Item(lnBar)
					if vartype(loBar) = 'O' and loBar.lVisible
						if empty(loBar.cSystemBar)
							lcBarNumber = transform(loBar.nBarNumber)
						else
							lcBarNumber = transform(evaluate(loBar.cSystemBar))
						endif empty(loBar.cSystemBar)
						.cBarPosition = 'after ' + lcBarNumber
						llFoundBar    = .T.
						exit
					endif vartype(loBar) = 'O' ...
				next lnBar
		
		* If we haven't found a bar to place this one after, see if there's one we can
		* place this before.
		
				if not llFoundBar
					for lnBar = .nBarNumber + 1 to .Parent.Count
						loBar = .Parent.Item(lnBar)
						if vartype(loBar) = 'O' and loBar.lVisible
							if empty(loBar.cSystemBar)
								lcBarNumber = transform(loBar.nBarNumber)
							else
								lcBarNumber = transform(evaluate(loBar.cSystemBar))
							endif empty(loBar.cSystemBar)
							.cBarPosition = 'before ' + lcBarNumber
							exit
						endif vartype(loBar) = 'O' ...
					next lnBar
				endif not llFoundBar
			endif empty(.cBarPosition)
		endwith
		
	ENDPROC

	PROCEDURE hide		&& Hides the bar
		local lnI, ;
			lcBarNumber, ;
			lcPopupName, ;
			lcPopupNameThis
		with This
			if .lDefined
		
		* Hide any bars in the submenu if there is one.
		
				for lnI = 1 to .Count
					loBar = .Item(lnI)
					if vartype(loBar) = 'O'
						loBar.Hide()
					endif vartype(loBar) = 'O'
				next lnI
		
		* Hide the bar by releasing it.
		
				if empty(.cSystemBar)
					lcBarNumber = transform(.nBarNumber)
				else
					lcBarNumber = transform(evaluate(.cSystemBar))
				endif empty(.cSystemBar)
				lcPopupName = .cPopupName
				release bar &lcBarNumber of &lcPopupName
			endif .lDefined
		
		* Release our submenu popup if it exists.
		
			lcPopupNameThis = .cPopupNameThis
			if popup(lcPopupNameThis)
				release popup &lcPopupNameThis
			endif popup(lcPopupNameThis)
			.lDefined = .F.
		endwith
		
	ENDPROC

	PROCEDURE Init
		lparameters tnBarNumber, ;
			tcPopupName, ;
			tlSpecified
		with This
			dodefault()
			.nBarNumber = tnBarNumber
			.cPopupName = tcPopupName
			.lSpecified = tlSpecified
		
		* Define the popup for this bar.
		
			if empty(.cPopupNameThis)
				.cPopupNameThis = .Name
			endif empty(.cPopupNameThis)
		endwith
		
	ENDPROC

	PROCEDURE lmarked_assign
		lparameters tlValue
		local lcSetting, ;
			lcBarNumber, ;
			lcPopupName
		with This
			assert vartype(tlValue) = 'L'
			lcSetting = iif(tlValue, '.T.', '.F.')
			.lMarked  = tuSetting
			if empty(.cSystemBar)
				lcBarNumber = transform(.nBarNumber)
			else
				lcBarNumber = transform(evaluate(.cSystemBar))
			endif empty(.cSystemBar)
			lcPopupname = .cPopupName
			set mark of bar &lcBarNumber of &lcPopupName to &lcSetting
		endwith
		
	ENDPROC

	PROCEDURE lvisible_assign
		lparameters tlValue
		assert vartype(tlValue) = 'L'
		with This
			if tlValue <> .lVisible
				.lVisible   = tlValue
				.lSpecified = .T.	&& so when we show it, it appears in correct place
				do case
					case .CalledFromThisClass()
					case tlValue
						.Show()
					otherwise
						.Hide()
				endcase
			endif tlValue <> .lVisible
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Hide the bar by releasing it.
		
		This.Hide()
		dodefault()
		
	ENDPROC

	PROCEDURE show		&& Displays the bar
		* If we're supposed to, call FindBarPosition to see where the bar should go,
		* then define it.
		
		local lnI, ;
			loBar
		with This
			if .lVisible and not .lDefined
				if .lSpecified or .lInvert
					.FindBarPosition()
				endif .lSpecified ...
				.Define()
			endif .lVisible ...
		
		* Display any bars in our submenu if there is one.
		
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				else
					loBar.Show()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfeditpad AS sfpad OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = \<Edit
	ckey = ALT+E
	cstatusbartext = Edit text
	Name = "sfeditpad"
	
	PROCEDURE addbars		&& Add bars to the submenu popup for this bar
		with This
			.AddBar('SFBar', 'SFMenu.vcx', 'EditUndo')
			with .EditUndo
				.cCaption       = '\<Undo'
				.cKey           = 'CTRL+Z'
				.cKeyText       = 'Ctrl+Z'
				.cStatusBarText = 'Reverse the most recent edit action'
				.cSystemBar     = '_med_undo'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditRedo')
			with .EditRedo
				.cCaption       = '\<Redo'
				.cKey           = 'CTRL+R'
				.cKeyText       = 'Ctrl+R'
				.cStatusBarText = 'Repeat the action previously reversed with Undo'
				.cSystemBar     = '_med_redo'
			endwith
		
			.AddSeparatorBar()
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditCut')
			with .EditCut
				.cCaption       = 'Cu\<t'
				.cKey           = 'CTRL+X'
				.cKeyText       = 'Ctrl+X'
				.cStatusBarText = 'Remove the selection and put it on the clipboard'
				.cSystemBar     = '_med_cut'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditCopy')
			with .EditCopy
				.cCaption       = '\<Copy'
				.cKey           = 'CTRL+C'
				.cKeyText       = 'Ctrl+C'
				.cStatusBarText = 'Copy the selection and put it on the clipboard'
				.cSystemBar     = '_med_copy'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditPaste')
			with .EditPaste
				.cCaption       = '\<Paste'
				.cKey           = 'CTRL+V'
				.cKeyText       = 'Ctrl+V'
				.cStatusBarText = 'Paste the contents of the clipboard at the ' + ;
					'insertion point'
				.cSystemBar     = '_med_paste'
			endwith
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditClear')
			with .EditClear
				.cCaption       = 'Clear'
				.cStatusBarText = 'Erase the selection'
				.cSystemBar     = '_med_clear'
				.cSkipFor       = 'empty(wontop())'
			endwith
		
			.AddSeparatorBar()
		
			.AddBar('SFBar', 'SFMenu.vcx', 'EditSelectAll')
			with .EditSelectAll
				.cCaption       = 'Select \<All'
				.cKey           = 'CTRL+A'
				.cKeyText       = 'Ctrl+A'
				.cStatusBarText = 'Select all lines of text in the current field'
				.cSystemBar     = '_med_slcta'
			endwith
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfhelptopicsbar AS sfbar OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = \<Help Topics
	ckey = F1
	ckeytext = F1
	cstatusbartext = Display Help table of contents
	csystembar = _mst_hpsch
	Name = "sfhelptopicsbar"

ENDDEFINE

DEFINE CLASS sfmenu AS sfcollection OF "sfcollection.vcx" 		&& A menu
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addpad		&& Adds a pad to the menu
		*m: cinstancename_assign
		*m: definemenu		&& Defines the desired pads in the menu
		*m: refresh		&& Refreshes the display of the menu.
		*m: show		&& Displays the menu.
		*p: cinstancename		&& The name of the variable containing the reference for this object
	*</DefinedPropArrayMethod>

	cinstancename = 		&& The name of the variable containing the reference for this object
	Name = "sfmenu"
	
	PROCEDURE addpad		&& Adds a pad to the menu
		lparameters tcClass, ;
			tcLibrary, ;
			tcName
		local loPad, ;
			lnCount, ;
			loOtherPad
		with This
		
		* Add a pad of the desired class and name to the menu.
		
			if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
				.AddObject(tcName, tcClass)
			else
				.NewObject(tcName, tcClass, tcLibrary)
			endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
		
		* Add the pad to the collection.
		
			loPad = evaluate('.' + tcName)
			.AddItem(loPad, tcName)
			lnCount = .Count
			do case
		
		* If this is the second item in the menu, tell the first item to display BEFORE
		* this item and this item to display AFTER that item.
		
				case lnCount = 2
					loOtherPad = .Item(1)
					loOtherPad.cPadPosition = 'before ' + tcName
					loPad.cPadPosition = 'after ' + loOtherPad.Name
		
		* If there are more than 2 items in the menu, this item will be displayed AFTER
		* the previous one.
		
				case lnCount > 2
					loOtherPad = .Item(lnCount - 1)
					loPad.cPadPosition = 'after ' + loOtherPad.Name
			endcase
		endwith
		return loPad
		
	ENDPROC

	PROCEDURE cinstancename_assign
		lparameters tuValue
		if This.CalledFromThisClass()
			This.cInstanceName = tuValue
		else
			error 1743, 'cInstanceName'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE definemenu		&& Defines the desired pads in the menu
		* Abstract method
		
	ENDPROC

	PROCEDURE Init
		* Save the name of the variable or property we're being instantiated into in
		* cInstanceName. We need this so we can reference the object path from a bar
		* all the way up to the menu properly.
		
		lparameter tcInstanceName
		This.cInstancename = tcInstanceName
		dodefault()
		
	ENDPROC

	PROCEDURE refresh		&& Refreshes the display of the menu.
		* Refresh the menu by activating it.
		
		activate menu _msysmenu nowait
		
	ENDPROC

	PROCEDURE releasemembers
		* Clean up upon exit. We're specifically not using DODEFAULT() here because the
		* default behavior is to release every member, but since all pads are contained
		* objects, we don't need to specifically release them (in fact, doing so can
		* cause a GPF).
		
		set sysmenu automatic
		set sysmenu off
		set sysmenu to
		set sysmenu to default
		set sysmenu on
		
	ENDPROC

	PROCEDURE show		&& Displays the menu.
		* Clear the old menu, define the new one if it hasn't already been, show all
		* the pads, and display the menu.
		
		local lnI, ;
			loPad
		with This
			set sysmenu to
			if .Count = 0
				.DefineMenu()
			endif .Count = 0
			for lnI = 1 to .Count
				loPad = .Item(lnI)
				loPad.Show()
			next lnI
			set sysmenu automatic
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfmrubar AS sfbar OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	cmenuclauses = mru
	conclickcommand = This.Parent.MRUSelected()
	Name = "sfmrubar"

ENDDEFINE

DEFINE CLASS sfpad AS sfcollection OF "sfcollection.vcx" 		&& A pad in a menu
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the popup for this pad
		*m: addbars		&& Add bars to the popup attached to this pad
		*m: addseparatorbar		&& Adds a separator bar to the menu
		*m: define		&& Defines the pad
		*m: definepad		&& Define the pad
		*m: hide		&& Hide the pad
		*m: lvisible_assign
		*m: mruselected		&& Called when the MRU bar is clicked
		*m: show		&& Shows the pad
		*p: ccaption		&& The caption for the menu pad
		*p: cinstancename		&& The complete object path to this object starting from the menu object
		*p: ckey		&& The hotkey for the pad
		*p: cmrubarclass		&& The class to use for the MRU bar
		*p: cmrubarlibrary		&& The library containing the class specified in cMRUBarClass
		*p: cpadposition		&& Optional 'before' or 'after' pad clause to use in defining the pad's location on the menu
		*p: cpopupname		&& The name of the popup attached to this pad
		*p: cskipfor		&& The logical expression used for the SKIP FOR clause
		*p: cstatusbartext		&& Text displayed in the status bar when this pad is highlighted
		*p: ldefined		&& .T. if the pad and popup for this object have been defined
		*p: lmru		&& .T. to add an MRU bar at the bottom of the menu
		*p: lpaddefined		&& .T. if the pad has been defined
		*p: lvisible		&& .T. if the pad is visible
		*p: nseparatorbarcount		&& The number of separator bars in the menu
	*</DefinedPropArrayMethod>

	PROTECTED cpopupname,ldefined,lpaddefined,nseparatorbarcount
	ccaption = 		&& The caption for the menu pad
	cinstancename = 		&& The complete object path to this object starting from the menu object
	ckey = 		&& The hotkey for the pad
	cmrubarclass = SFMRUBar		&& The class to use for the MRU bar
	cmrubarlibrary = SFMenu.vcx		&& The library containing the class specified in cMRUBarClass
	cpadposition = 		&& Optional 'before' or 'after' pad clause to use in defining the pad's location on the menu
	cpopupname = 		&& The name of the popup attached to this pad
	cskipfor = 		&& The logical expression used for the SKIP FOR clause
	cstatusbartext = 		&& Text displayed in the status bar when this pad is highlighted
	ldefined = .F.		&& .T. if the pad and popup for this object have been defined
	lmru = .F.		&& .T. to add an MRU bar at the bottom of the menu
	lpaddefined = .F.		&& .T. if the pad has been defined
	lvisible = .T.		&& .T. if the pad is visible
	Name = "sfpad"
	nseparatorbarcount = 0		&& The number of separator bars in the menu
	
	PROCEDURE addbar		&& Adds a bar to the popup for this pad
		lparameters tcClass, ;
			tcLibrary, ;
			tcName, ;
			tnBarNumber
		local lcName, ;
			lnBarNumber, ;
			llSpecified, ;
			loBar
		with This
		
		* Create a bar number if one wasn't passed.
		
			if vartype(tnBarNumber) = 'N' and tnBarNumber <> 0
				lnBarNumber = tnBarNumber
				llSpecified = .T.
			else
				lnBarNumber = .Count + 1
			endif vartype(tnBarNumber) = 'N' ...
		
		* Create the object as a member and increment the bar count.
		
			if '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
				.AddObject(tcName, tcClass, lnBarNumber, .cPopupName, llSpecified)
			else
				.NewObject(tcName, tcClass, tcLibrary, '', lnBarNumber, .cPopupName, ;
					llSpecified)
			endif '\' + upper(tcLibrary) $ upper(set('CLASSLIB'))
		
		* Add the bar to the collection.
		
			loBar = evaluate('.' + tcName)
			.AddItem(loBar, tcName)
		endwith
		return loBar
		
	ENDPROC

	PROCEDURE addbars		&& Add bars to the popup attached to this pad
		* Abstract method
		
	ENDPROC

	PROCEDURE addseparatorbar		&& Adds a separator bar to the menu
		local lcName, ;
			loBar
		with This
			.nSeparatorBarCount = .nSeparatorBarCount + 1
			lcName = 'Separator' + transform(.nSeparatorBarCount)
			loBar  = .AddBar('SFSeparatorBar', 'SFMenu.vcx', lcName)
		endwith
		return loBar
		
	ENDPROC

	PROTECTED PROCEDURE define		&& Defines the pad
		with This
		
		* Get the object path and the names of the pad, menu, and popup.
		
			.cInstanceName = .Parent.cInstanceName + '.' + .Name
		
		* Create a default status bar text if we don't have one.
		
			if empty(.cStatusBarText)
				.cStatusBarText = strtran(strtran(.cCaption, '\<'), '\')
			endif empty(.cStatusBarText)
		
		* Define the pad if necessary, then add bars to the popup.
		
			if not .lPadDefined
				.DefinePad()
			endif not .lPadDefined
			.AddBars()
		
		* If this is an MRU menu (only in VFP 7 or later), add an MRU bar at the end.
		
			if .lMRU and clVFP7ORLATER
				.AddBar(.cMRUBarClass, .cMRUBarLibrary, 'MRUBar')
			endif .lMRU ...
		
		* Flag that the pad and popup have been defined.
		
			.lDefined = .T.
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE definepad		&& Define the pad
		* Define the pad.
		
		local lcObjectPath, ;
			lcPadName, ;
			lcPopupName, ;
			lcPosition, ;
			lcSkipFor, ;
			lcClauses
		with This
			lcObjectPath = .cInstanceName + '.'
			lcPadName    = .Name
			lcPopupName  = .cPopupName
			lcPosition   = alltrim(.cPadPosition)
		
		* Set the SKIP FOR for the pad.
		
			if empty(.cSkipFor)
				lcSkipFor = ''
			else
				lcSkipFor = 'skip for ' + strtran(.cSkipFor, 'This.', lcObjectPath)
			endif not empty(.cSkipFor)
		
		* Set the key clauses of the DEFINE PAD command.
		
			lcClauses = ''
			if not empty(.cKey)
				lcClauses = lcClauses + ' key ' + strtran(.cKey, '"', "'")
			endif not empty(.cKey)
		
		* Define the pad.
		
			define pad &lcPadName of _msysmenu prompt .cCaption color scheme 3 ;
				&lcPosition &lcSkipFor message .cStatusBarText negotiate left, right ;
				&lcClauses
			on pad &lcPadName of _msysmenu activate popup &lcPopupName
		
		* Flag that the pad has been defined.
		
			.lPadDefined = .T.
		endwith
		
	ENDPROC

	PROCEDURE hide		&& Hide the pad
		* Hide the pad by releasing it and its popup.
		
		local lcPadName, ;
			lcPopupName
		with This
			.lVisible    = .F.
		***	.lDefined    = .F.
			.lPadDefined = .F.
			lcPadName    = .Name
		***	lcPopupName = .cPopupName
			release pad &lcPadName of _msysmenu
		***	release popup &lcPopupName
		endwith
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		with This
		
		* Define the popup for this pad.
		
			if empty(.cPopupName)
				.cPopupName = .Name
			endif empty(.cPopupName)
			define popup (.cPopupName) margin relative shadow color scheme 4
		endwith
		
	ENDPROC

	PROCEDURE lvisible_assign
		lparameters tlValue
		assert vartype(tlValue) = 'L'
		with This
			if tlValue <> .lVisible
				.lVisible = tlValue
				do case
					case .CalledFromThisClass()
					case tlValue
						.Show()
					otherwise
						.Hide()
				endcase
			endif tlValue <> .lVisible
		endwith
		
	ENDPROC

	PROCEDURE mruselected		&& Called when the MRU bar is clicked
		local lnI, ;
			loBar, ;
			lcPopupName
		with This
		
		* Hide the MRU bar, then show all inverted bars.
		
			.MRUBar.Hide()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Show()
				endif loBar.lInvert
			next lnI
		
		* Display the popup again.
		
			lcPopupName = .cPopupName
			activate popup &lcPopupName
		
		* Now that the popup is closed, show the MRU bar and hide all inverted bars.
		
			.MRUBar.Show()
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Hide the pad. We're specifically not using DODEFAULT() here because the
		* default behavior is to release every member, but since all bars are contained
		* objects, we don't need to specifically release them (in fact, doing so can
		* cause a GPF).
		
		This.Hide()
		lcPopupName = This.cPopupName
		if popup(lcPopupName)
			release popup &lcPopupName
		endif popup(lcPopupName)
		
	ENDPROC

	PROCEDURE show		&& Shows the pad
		* Define the popup and show all bars (except inverted bars, which must be
		* hidden).
		
		local lnI, ;
			loBar
		with This
			do case
		
		* If the pad has never been defined, call Define.
		
				case not .lDefined
					.Define()
		
		* If the pad has been defined but then released, call DefinePad.
		
				case not .lPadDefined
					.DefinePad()
			endcase
			for lnI = 1 to .Count
				loBar = .Item(lnI)
				if loBar.lInvert
					loBar.Hide()
				else
					loBar.Show()
				endif loBar.lInvert
			next lnI
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfseparatorbar AS sfbar OF "sfmenu.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	ccaption = \-
	Name = "sfseparatorbar"

ENDDEFINE

DEFINE CLASS sfshortcutmenu AS sfcustom OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: addmenubar		&& Adds new menu bar to shortcut menu.
		*m: addmenuseparator		&& Adds separator to shortcut menu.
		*m: clearmenu		&& Releases existing shortcut menu.
		*m: editmenubar		&& Changes any setting for the specified bar
		*m: findbar		&& Returns the bar number for the specified prompt
		*m: nbarcount_access
		*m: nbarcount_assign
		*m: newmenu		&& Creates new menu popup for shortcut menu.
		*p: cmenu		&& Name of shortcut menu.
		*p: conselection		&& Menu bar selection routine.
		*p: nbarcount		&& The number of bars defined
		*p: ncol		&& The column for the menu (leave 0 to use the default)
		*p: nrow		&& The row for the menu (leave 0 to use the default)
		*a: amenu[1,0]
	*</DefinedPropArrayMethod>

	cmenu = 		&& Name of shortcut menu.
	conselection = 		&& Menu bar selection routine.
	Name = "sfshortcutmenu"
	nbarcount = 0		&& The number of bars defined
	ncol = 0		&& The column for the menu (leave 0 to use the default)
	nrow = 0		&& The row for the menu (leave 0 to use the default)
	
	PROCEDURE addmenubar		&& Adds new menu bar to shortcut menu.
		lparameters tcPrompt, ;
			tcOnSelection, ;
			tcClauses, ;
			tnElementNumber, ;
			tlMark, ;
			tlDisabled, ;
			tlBold, ;
			tcImage
		local lnIndex, ;
			lnMenuCount, ;
			lnElementNumber
		with This
		
		* If we were passed a reference to another menu, we'll create a submenu from
		* it.
		
			if vartype(tcPrompt) = 'O'
				for lnIndex = 1 to alen(tcPrompt.aMenu, 1)
					.AddMenuBar(tcPrompt.aMenu[lnIndex, 1], ;
						tcPrompt.aMenu[lnIndex, 2], tcPrompt.aMenu[lnIndex, 3])
				next lnIndex
				return
			endif vartype(tcPrompt) = 'O'
		
		* If we weren't passed a prompt, return .F.
		
			if empty(tcPrompt)
				return .F.
			endif empty(tcPrompt)
		
		* Find the next open spot in the menu array.
		
			lnMenuCount = alen(.aMenu, 1)
			lnMenuCount = iif(lnMenuCount = 1 and empty(.aMenu[1]), 0, lnMenuCount) + 1
			lnIndex     = lnMenuCount
			dimension .aMenu[lnIndex, 7]
		
		* If the menu item number was passed, we'll add the menu item at that spot in
		* the menu.
		
			if vartype(tnElementNumber) = 'N'
				lnElementNumber = max(int(tnElementNumber), 1)
				if lnElementNumber < lnMenuCount
					if ains(.aMenu, lnElementNumber) <> 1
						return .F.
					endif ains(.aMenu, lnElementNumber) <> 1
					lnIndex = lnElementNumber
				endif lnElementNumber < lnMenuCount
			endif vartype(tnElementNumber) = 'N'
		
		* Put the menu item information into the array.
		
			.aMenu[lnIndex, 1] = tcPrompt
			.aMenu[lnIndex, 2] = tcOnSelection
			.aMenu[lnIndex, 3] = tcClauses
			.aMenu[lnIndex, 4] = transform(tlMark)
			.aMenu[lnIndex, 5] = transform(tlDisabled)
			.aMenu[lnIndex, 6] = transform(tlBold)
			.aMenu[lnIndex, 7] = tcImage
		endwith
		
	ENDPROC

	PROCEDURE addmenuseparator		&& Adds separator to shortcut menu.
		lparameters tnElementNumber
		This.AddMenuBar('\-', , , tnElementNumber)
		
	ENDPROC

	PROCEDURE clearmenu		&& Releases existing shortcut menu.
		with This
			dimension .aMenu[1]
			.aMenu        = ''
			.cOnSelection = ''
		endwith
		
	ENDPROC

	PROCEDURE editmenubar		&& Changes any setting for the specified bar
		lparameters tnBar, ;
			tcPrompt, ;
			tcOnSelection, ;
			tcClauses, ;
			tcMark, ;
			tcDisabled, ;
			tcBold, ;
			tcImage
		local lnI, ;
			lcPrompt, ;
			lcOnSelection, ;
			lcClauses, ;
			lcMark, ;
			lcDisabled, ;
			lcBold, ;
			lcImage
		with This
			assert vartype(tnBar) $ 'NFIBY' and between(tnBar, 1, .nBarCount)
		
		* Get either the existing or the new value, depending on what was passed.
		
			lcPrompt      = iif(vartype(tcPrompt)      = 'C' and ;
				not empty(tcPrompt),      tcPrompt,      .aMenu[tnBar, 1])
			lcOnSelection = iif(vartype(tcOnSelection) = 'C' and ;
				not empty(tcOnSelection), tcOnSelection, .aMenu[tnBar, 2])
			lcClauses     = iif(vartype(tcClauses)     = 'C' and ;
				not empty(tcClauses),     tcClauses,     .aMenu[tnBar, 3])
			lcMark        = iif(vartype(tcMark)        = 'C' and ;
				not empty(tcMark),        tcMark,        .aMenu[tnBar, 4])
			lcDisabled    = iif(vartype(tcDisabled)    = 'C' and ;
				not empty(tcDisabled),    tcDisabled,    .aMenu[tnBar, 5])
			lcBold        = iif(vartype(tcBold)        = 'C' and ;
				not empty(tcBold),        tcBold,        .aMenu[tnBar, 6])
			lcImage       = iif(vartype(tcImage)       = 'C' and ;
				not empty(tcImage),       tcImage,       .aMenu[tnBar, 7])
		
		* Put the values into the array
		
			.aMenu[tnBar, 1] = lcPrompt
			.aMenu[tnBar, 2] = lcOnSelection
			.aMenu[tnBar, 3] = lcClauses
			.aMenu[tnBar, 4] = lcMark
			.aMenu[tnBar, 5] = lcDisabled
			.aMenu[tnBar, 6] = lcBold
			.aMenu[tnBar, 7] = lcImage
		endwith
		
	ENDPROC

	PROCEDURE findbar		&& Returns the bar number for the specified prompt
		lparameters tcPrompt
		local lcPrompt, ;
			lnBar, ;
			lnI
		with This
			lcPrompt = upper(alltrim(tcPrompt))
			lnBar    = 0
			for lnI = 1 to .nBarCount
				if upper(strtran(strtran(.aMenu[lnI, 1], '\<'), '^')) == lcPrompt
					lnBar = lnI
					exit
				endif upper(strtran(strtran(.aMenu[lnI, 1], '\<'), '^')) == lcPrompt
			next lnI
		endwith
		return lnBar
		
	ENDPROC

	PROCEDURE Init
		* Start with an empty menu array.
		
		This.ClearMenu()
		
	ENDPROC

	PROCEDURE nbarcount_access
		return iif(empty(This.aMenu[1]) or isnull(This.aMenu[1]), 0, ;
			alen(This.aMenu, 1))
		
	ENDPROC

	PROCEDURE nbarcount_assign
		error 1743, 'nBarCount'
		
	ENDPROC

	PROCEDURE newmenu		&& Creates new menu popup for shortcut menu.
		lparameters toObject
		local loObject, ;
			lcClass, ;
			lcClassLibrary, ;
			lcBaseClass, ;
			loNewObject
		loObject       = iif(vartype(toObject) = 'O', toObject, This)
		lcClass        = lower(loObject.Class)
		lcClassLibrary = lower(loObject.ClassLibrary)
		lcBaseClass    = lower(loObject.BaseClass)
		if empty(lcClassLibrary)
			loNewObject = createobject(lcBaseClass)
		else
			loNewObject = MakeObject(lcClass, lcClassLibrary)
		endif empty(lcClassLibrary)
		return loNewObject
		
	ENDPROC

	PROCEDURE showmenu
		lparameters tcParentMenu
		local lnMenuCount, ;
			lcMenu, ;
			lnMRow, ;
			lnMCol, ;
			lnSkipCount, ;
			lnCount, ;
			lcMenuItem, ;
			lnBar, ;
			lcClauses, ;
			lcImage, ;
			llSetMark, ;
			lcMenu2, ;
			luMenuSelection
		with This
		
		* Get the number of bars in the menu. Return .F. if the menu is empty.
		
			lnMenuCount = alen(.aMenu, 1)
			if vartype(.aMenu[1]) <> 'C' or (lnMenuCount = 1 and empty(.aMenu[1]))
				return .F.
			endif vartype(.aMenu[1]) <> 'C' ...
		
		* If we were passed the name of the parent menu, use it. Otherwise, create a
		* new menu name. Deactivate the menu and create a new popup if necessary.
		
			lcMenu = iif(empty(tcParentMenu), sys(2015), alltrim(tcParentMenu))
			.cMenu = lcMenu
			deactivate popup (lcMenu)
			clear typeahead
			if empty(tcParentMenu)
				lnMRow = iif(.nRow = 0, max(mrow(), 0), .nRow)
				lnMCol = iif(.nCol = 0, max(mcol(), 0), .nCol)
				define popup (lcMenu) from lnMRow, lnMCol margin shortcut
				on selection popup (lcMenu) deactivate menu (lcMenu)
			endif empty(tcParentMenu)
		
		* Add a bar for each menu item to the popup.
		
			lnSkipCount = 0
			for lnCount = 1 to lnMenuCount
				lcMenuItem = .aMenu[lnCount, 1]
		
		* If the item is empty or the first bar or last item is a separator, skip this
		* item.
		
				if vartype(lcMenuItem) <> 'C' or empty(lcMenuItem) or ;
					((lnCount = 1 or lnCount = lnMenuCount) and ;
					alltrim(lcMenuItem) = '\-')
					lnSkipCount = lnSkipCount + 1
					loop
				endif vartype(lcMenuItem) <> 'C' ...
				lnBar = lnCount - lnSkipCount
		
		* Set the clauses appropriately.
		
				if not empty(.aMenu[lnCount, 3])
					lcClauses = alltrim(.aMenu[lnCount, 3])
				else
					lcClauses = ''
				endif not empty(.aMenu[lnCount, 3])
		
		* Evaluate the mark expression (if there is one) and set the mark appropriately.
		
				if not empty(.aMenu[lnCount, 4]) and evaluate(.aMenu[lnCount, 4])
					lcMenuItem = '^' + lcMenuItem
				endif not empty(this.aMenu[lnCount, 4]) ...
		
		* Evaluate the SKIP FOR expression (if there is one) and set the clauses
		* appropriately.
		
				if not empty(.aMenu[lnCount, 5]) and evaluate(.aMenu[lnCount, 5])
					lcClauses = lcClauses + [ SKIP FOR .T.]
				endif not empty(.aMenu[lnCount, 6]) ...
		
		* Evaluate the "bold" expression (if there is one) and set the clauses
		* appropriately.
		
				if not empty(.aMenu[lnCount, 6]) and evaluate(.aMenu[lnCount, 6])
					lcClauses = lcClauses + [ STYLE "B"]
				endif not empty(.aMenu[lnCount, 6]) ...
		
		* Evaluate the image expression (if there is one) and set the clauses
		* appropriately.
		
				if clVFP7ORLATER and not empty(.aMenu[lnCount, 7])
					lcImage = .aMenu[lnCount, 7]
					if lcImage = '_'
						lcClauses = lcClauses + ' pictres ' + lcImage
					else
						lcClauses = lcClauses + ' picture "' + lcImage + '"'
					endif lcImage = '_'
				endif clVFP7ORLATER ...
		
		* Handle the mark being turned on for the item.
		
				llSetMark = left(lcMenuItem,1) = '^'
				if llSetMark
					lcMenuItem = substr(lcMenuItem,2)
				endif llSetMark
		
		* Define the bar and set the mark if necessary.
		
				if empty(lcClauses)
					define bar lnBar of (lcMenu) prompt (lcMenuItem)
				else
					define bar lnBar of (lcMenu) prompt (lcMenuItem) &lcClauses
				endif empty(lcClauses)
				if llSetMark
					set mark of bar (lnBar) of (lcMenu) to .t.
				endif llSetMark
		
		* If this is a submenu, handle it.
		
				luMenuSelection = .aMenu[lnCount, 2]
				if vartype(luMenuSelection) = 'O'
					lcMenu2 = sys(2015)
					define popup (lcMenu2) margin shortcut
					on selection popup (lcMenu2) deactivate menu (lcMenu2)
					on bar lnBar of (lcMenu) activate popup (lcMenu2)
					if empty(luMenuSelection.cOnSelection)
						luMenuSelection.cOnSelection = .cOnSelection
					endif empty(luMenuSelection.cOnSelection)
					luMenuSelection.ShowMenu(lcMenu2)
					loop
				endif vartype(luMenuSelection) = 'O'
		
		* If no action was specified, use the overall one for the menu.
		
				
				luMenuSelection = iif(empty(luMenuSelection), alltrim(.cOnSelection), ;
					luMenuSelection)
				if not empty(luMenuSelection)
					on selection bar lnBar of (lcMenu) &luMenuSelection
				endif not empty(luMenuSelection)
			next lnCount
		
		* If there are no menu items, we're done. Otherwise, activate the menu.
		
			if lnSkipCount >= lnMenuCount or not empty(tcParentMenu)
				return
			endif lnSkipCount >= lnMenuCount ...
			activate popup (lcMenu)
			if not empty(.cMenu)
				deactivate popup (.cMenu)
			endif not empty(.cMenu)
			.cMenu = ''
		endwith
		
	ENDPROC

ENDDEFINE
