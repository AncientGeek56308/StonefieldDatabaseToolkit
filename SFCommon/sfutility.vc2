*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfutility.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfcommondialog AS sfcustom OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfutility.h"
	*<DefinedPropArrayMethod>
		*m: addfilter		&& Sets file extension filters for use when displaying dialog.
		*m: cleardlls
		*m: clearfilters		&& Clears all file extension filters.
		*m: dialoghandler
		*m: integertostring
		*m: loaddlls
		*m: showdialog		&& Displays dialog with various options such as filters.
		*m: stringtointeger
		*p: ccustomfilter		&& Custom filter the user created while using dialog.
		*p: cdefaultextension		&& Default file extension to display.
		*p: cfilename		&& Name of file selected or initially set as default.
		*p: cfilepath		&& Path that files were selected from.
		*p: cfiletitle		&& File title property of the selected file(s).
		*p: cinitialdirectory		&& Initial directory to show files from.
		*p: ctitlebartext		&& Caption for dialog title bar.
		*p: lallowmultiselect		&& Whether to allow selection of multiple files.
		*p: lfilemustexist		&& Allows only valid existing files to be entered.
		*p: lhidereadonly		&& Hides read-only files from list.
		*p: lnewexplorer		&& Use new explorer user interface and features such as Places bar.
		*p: lnochangedir		&& Don't allow initially displayed directory to be changed.
		*p: lnonetworkbutton		&& Do not include a network button in dialog.
		*p: lnoplacesbar		&& Do not include Places bar in dialog.
		*p: lnovalidate
		*p: lpathmustexist		&& .T. if the path must exist
		*p: lsavedialog		&& Use Save dialog instead of Open one.
		*p: nfilecount		&& Number of files selected from dialog.
		*p: nfilterindex		&& Specifies which of the filters the user selected from the dialog.
		*p: nhwndowner		&& For internal use only.
		*p: ninstance		&& For internal use only.
		*a: afilenames[1,0]		&& Array of filenames returned from dialog.
		*a: afilterlist[1,2]		&& Array of file extension filters passed to dialog.
	*</DefinedPropArrayMethod>

	PROTECTED afilterlist,nhwndowner,ninstance
	ccustomfilter = 		&& Custom filter the user created while using dialog.
	cdefaultextension = 		&& Default file extension to display.
	cfilename = 		&& Name of file selected or initially set as default.
	cfilepath = 		&& Path that files were selected from.
	cfiletitle = 		&& File title property of the selected file(s).
	cinitialdirectory = 		&& Initial directory to show files from.
	ctitlebartext = 		&& Caption for dialog title bar.
	lallowmultiselect = .F.		&& Whether to allow selection of multiple files.
	lfilemustexist = .F.		&& Allows only valid existing files to be entered.
	lhidereadonly = .T.		&& Hides read-only files from list.
	lnewexplorer = .T.		&& Use new explorer user interface and features such as Places bar.
	lnochangedir = .F.		&& Don't allow initially displayed directory to be changed.
	lnonetworkbutton = .F.		&& Do not include a network button in dialog.
	lnoplacesbar = .F.		&& Do not include Places bar in dialog.
	lnovalidate = .F.
	lpathmustexist = .F.		&& .T. if the path must exist
	lsavedialog = .F.		&& Use Save dialog instead of Open one.
	Name = "sfcommondialog"
	nfilecount = 0		&& Number of files selected from dialog.
	nfilterindex = 0		&& Specifies which of the filters the user selected from the dialog.
	nhwndowner = 0		&& For internal use only.
	ninstance = 0		&& For internal use only.
	
	PROCEDURE addfilter		&& Sets file extension filters for use when displaying dialog.
		lparameters tcDescription, ;
			tcSkeleton
		local lnNewRow
		with This
			lnNewRow = iif(empty(.aFilterList[1]), 1, alen(.aFilterList, 1) + 1)
			dimension .aFilterList[lnNewRow, 2]
			.aFilterList[lnNewRow, 1] = tcDescription
			if vartype(tcSkeleton) <> 'C' or empty(tcSkeleton)
				.aFilterList[lnNewRow, 2] = '*.*'
			else
				.aFilterList[lnNewRow, 2] = tcSkeleton
			endif vartype(tcSkeleton) <> 'C' ...
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE cleardlls
		if clVFP7ORLATER
			clear dlls _FFC_SAVEFILENAME, _FFC_GETFILENAME, _FFC_MEMCPY, ;
				_FFC_MEMCPY2, _FFC_MALLOC, _FFC_FREEMEM
		endif clVFP7ORLATER
		
	ENDPROC

	PROCEDURE clearfilters		&& Clears all file extension filters.
		LPARAMETERS lComplete
		DIMENSION THIS.aFilterList[1,2]
		IF lComplete
			THIS.aFilterList= ""
		ELSE
			THIS.aFilterList[1,1] = "All files (*.*)"
			THIS.aFilterList[1,2] = "*.*"
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE dialoghandler
		
		#define OFN_READONLY                 0x00000001
		#define OFN_OVERWRITEPROMPT          0x00000002
		#define OFN_HIDEREADONLY             0x00000004
		#define OFN_NOCHANGEDIR              0x00000008
		#define OFN_SHOWHELP                 0x00000010
		#define OFN_ENABLEHOOK               0x00000020
		#define OFN_ENABLETEMPLATE           0x00000040
		#define OFN_ENABLETEMPLATEHANDLE     0x00000080
		#define OFN_NOVALIDATE               0x00000100
		#define OFN_ALLOWMULTISELECT         0x00000200
		#define OFN_EXTENSIONDIFFERENT       0x00000400
		#define OFN_PATHMUSTEXIST            0x00000800
		#define OFN_FILEMUSTEXIST            0x00001000
		#define OFN_CREATEPROMPT             0x00002000
		#define OFN_SHAREAWARE               0x00004000
		#define OFN_NOREADONLYRETURN         0x00008000
		#define OFN_NOTESTFILECREATE         0x00010000
		#define OFN_NONETWORKBUTTON          0x00020000		&& for old style dialog
		#define OFN_NOLONGNAMES              0x00040000     && force no long names for 4.x modules
		#define OFN_EXPLORER                 0x00080000     && new look commdlg
		#define OFN_NODEREFERENCELINKS       0x00100000
		#define OFN_LONGNAMES                0x00200000     && force long names for 3.x modules
		#define OFN_ENABLEINCLUDENOTIFY      0x00400000     && send include message to callback
		#define OFN_ENABLESIZING             0x00800000
		#define OFN_EX_NOPLACESBAR         	 0x00000001		&& used for newer OS only (uses FlagsEx)
		
		
		local lStructSize, hwndOwner, hInstance,;
			cMyFilter, i, lpMyFilter,;
			nMaxCustomFilter, cUserCustomFilter, lpUserCustomFilter,;
			nMaxFileName, cFileName, lpFileName,;
			nMaxFileTitle, cFileTitle, lpFileTitle
		local lpInitialDirectory, lpTitlebarText, nFlags, nFlagsEx, ;
			nFileOffset, nFileExtension, cDefExt,;
			lpDefExt, lCustomData, lpHook, lpTemplateName,;
			cMyStruct, nReturnVal, nFileNameOffset
		local lcFileName, lcUserCustomFilter, lcFileTitle,;
			nCurrentFilePos, nArraySize, nNextFilePos, ;
			lcCurDir, lnFilter
		
		hwndOwner = this.nHwndOwner
		hInstance = this.nInstance
		nFlags = 0
		nFlags = OFN_ENABLEHOOK
		nFlagsEx = 0
		
		* Blank certain properties before we start.
		
		dimension This.aFileNames[1]
		This.aFileNames[1] = ''
		This.nFileCount = 0
		
		*  Build the filter string.
		cMyFilter = ""
		for i = 1 to alen(this.aFilterList, 1)
			cMyFilter = cMyFilter + this.aFilterList[m.i,1] + chr(0) + this.aFilterList[m.i,2] + chr(0)
		endfor
		cMyFilter = cMyFilter + + repl(chr(0),2)
		lpMyFilter = _FFC_MALLOC(len(cMyFilter))
		if lpMyFilter = 0
		* Couldn't allocate memory
			return ""
		endif
		
		*  Setup Flags
		if this.lNewExplorer
			nFlags = nFlags + OFN_EXPLORER
		endif
		if this.lHideReadOnly
			nFlags = nFlags + OFN_HIDEREADONLY
		endif
		if this.lFileMustExist
			nFlags = nFlags + OFN_FILEMUSTEXIST
		endif
		if this.lPathMustExist
			nFlags = nFlags + OFN_PATHMUSTEXIST
		endif
		if this.lNoNetworkButton
		* Old style dialogs only
			nFlags = nFlags + OFN_NONETWORKBUTTON
		endif
		if this.lNoChangeDir
			nFlags = nFlags + OFN_NOCHANGEDIR
		endif
		if this.lNoValidate
			nFlags = nFlags + OFN_NOVALIDATE
		endif
		if this.lAllowMultiSelect and !this.lSaveDialog
			nFlags = nFlags + OFN_ALLOWMULTISELECT
		endif
		
		*  Setup FlagsEx
		if this.lnoplacesbar
			nFlagsEx = nFlagsEx + OFN_EX_NOPLACESBAR
		endif
		
		declare integer memcpy in msvcrt.dll as _FFC_MEMCPY  integer , string @, integer
		
		_FFC_MEMCPY(lpMyFilter, @cMyFilter, len(cMyFilter))
		
		*  Prepare the custom filter string
		nMaxCustomFilter = 1024
		cUserCustomFilter = repl(chr(0), nMaxCustomFilter)
		lpUserCustomFilter = _FFC_MALLOC(nMaxCustomFilter)
		if lpUserCustomFilter = 0
		* Couldn't allocate memory
			_FFC_FREEMEM(lpMyFilter)
			return ""
		endif
		_FFC_MEMCPY(lpUserCustomFilter, @cUserCustomFilter, nMaxCustomFilter)
		
		* Prepare the string for the selected filename(s)
		nMaxFileName = 1024
		cFileName = left(this.cFileName, 1023) + repl(chr(0), nMaxFileName - min(len(this.cFileName),1023))
		lpFileName = _FFC_MALLOC(nMaxFileName)
		if lpFileName = 0
			_FFC_FREEMEM(lpMyFilter)
			_FFC_FREEMEM(lpUserCustomFilter)
		endif
		_FFC_MEMCPY(lpFileName, @cFileName, nMaxFileName)
		
		*  File Title
		nMaxFileTitle = 300
		cFileTitle  = repl(chr(0), nMaxFileTitle)
		lpFileTitle = _FFC_MALLOC(nMaxFileTitle)
		if lpFileTitle = 0
			_FFC_FREEMEM(lpMyFilter)
			_FFC_FREEMEM(lpUserCustomFilter)
			_FFC_FREEMEM(lpFileName)
		endif
		_FFC_MEMCPY(lpFileTitle, @cFileTitle, nMaxFileTitle)
		
		*  Initial Directory
		lpInitialDirectory = _FFC_MALLOC(266)
		if lpInitialDirectory = 0
			_FFC_FREEMEM(lpMyFilter)
			_FFC_FREEMEM(lpUserCustomFilter)
			_FFC_FREEMEM(lpFileName)
			_FFC_FREEMEM(lpFileTitle)
		endif
		_FFC_MEMCPY(lpInitialDirectory, this.cInitialDirectory + chr(0), min(len(this.cInitialDirectory) + 1, 260))
		
		* Title bar text
		lpTitlebarText = _FFC_MALLOC(len(this.cTitlebartext) + 2)
		_FFC_MEMCPY(lpTitlebarText, this.cTitlebartext + chr(0) + chr(0), len(this.cTitlebartext) + 2)
		
		nFileOffset = 0
		nFileExtension = 0
		
		* Default Extension
		cDefExt = "TXT" + chr(0) + chr(0)
		lpDefExt = _FFC_MALLOC(len(this.cDefaultExtension) + 1)
		_FFC_MEMCPY(lpDefExt, this.cDefaultExtension + chr(0), len(this.cDefaultExtension) + 1)
		
		lCustomData = 0	&& not used without a hook
		lpHook = 0
		lpTemplateName = 0
		
		lStructSize = iif(val(os(3)) > 4, 22, 19) * 4
		
		lnFilter = iif(This.nFilterIndex = 0, 1, This.nFilterIndex)
		
		cMyStruct = this.IntegerToString(lStructSize,4) + ;
			this.IntegerToString(hwndOwner,4) + ;
			this.IntegerToString(hInstance,4) + ;
			this.IntegerToString(lpMyFilter,4) + ;
			this.IntegerToString(lpUserCustomFilter,4) + ;
			this.IntegerToString(nMaxCustomFilter,4) + ;
			this.IntegerToString(lnFilter, 4) + ;
			this.IntegerToString(lpFileName,4) + ;
			this.IntegerToString(nMaxFileName,4) + ;
			this.IntegerToString(lpFileTitle,4) + ;
			this.IntegerToString(nMaxFileTitle,4) + ;
			this.IntegerToString(lpInitialDirectory,4) + ;
			this.IntegerToString(lpTitlebarText,4) + ;
			this.IntegerToString(nFlags,4) + ;
			this.IntegerToString(nFileOffset,2) + ;
			this.IntegerToString(nFileExtension,2) + ;
			this.IntegerToString(lpDefExt,4) + ;
			this.IntegerToString(lCustomData,4) + ;
			this.IntegerToString(lpHook,4) + ;
			this.IntegerToString(lpTemplateName,4)
		
		if val(os(3)) > 4
			cMyStruct = cMyStruct + ;
				this.IntegerToString(0,4) + ;
				this.IntegerToString(0,4) + ;
				this.IntegerToString(nFlagsEx,4)
		endif
		
		* Save the current directory because the dialog changes it.
		
		lcCurDir = sys(5) + curdir()
		
		* Call the dialog now
		if this.lSaveDialog
			nReturnVal = _FFC_SAVEFILENAME(@cMyStruct)
		else
			nReturnVal = _FFC_GETFILENAME(@cMyStruct)
		endif
		
		* Restore the directory.
		
		cd (lcCurDir)
		
		if nReturnVal = 1
		*  Now retrieve info from allocated strings
		*  Retrieve Filename string
			declare integer memcpy in msvcrt.dll as	_FFC_MEMCPY2 string @, integer , integer
			lcFileName = repl(chr(0),nMaxFileName)
			_FFC_MEMCPY2(@lcFileName, lpFileName, nMaxFileName)
			nFileNameOffset = this.StringToInteger(substr(cMyStruct, 14*4+1, 2), 2)
		
		*  Check if user selected multiple files.
			if this.lAllowMultiSelect and nFileNameOffset > 1 and substr(lcFileName, nFileNameOffset, 1) = chr(0)
		*Now parse out to get multiple file names
				nCurrentFilePos = at(chr(0), lcFileName) + 1
				this.cFilePath = left(lcFileName, nCurrentFilePos - 2)
				nArraySize = 1
				do while .t.
					if substr(lcFileName, nCurrentFilePos, 1) = chr(0)
		* end of list.
						exit
					endif
					dimension this.aFileNames[nArraySize]
					nNextFilePos = at(chr(0), lcFileName, nArraySize + 1) + 1
					this.aFileNames[nArraySize] = substr(lcFileName, nCurrentFilePos, nNextFilePos - nCurrentFilePos - 1)
					nArraySize = nArraySize + 1
					nCurrentFilePos = nNextFilePos
				enddo
				this.nFileCount = nArraySize - 1
			else
		*  Didn't multiselect, so there's just one filename.
				lcFileName = left(lcFileName, at(chr(0), lcFileName) - 1)
				this.cFilePath = justpath(lcFileName)
				dimension this.aFileNames[1]
				this.aFileNames[1] = justfname(lcFileName)
				this.nFileCount = 1
			endif
		
			this.cFileName = left(lcFileName, at(chr(0), lcFileName) - 1)
		
			lcUserCustomFilter= repl(chr(0), nMaxCustomFilter)
			_FFC_MEMCPY2(@lcUserCustomFilter, lpUserCustomFilter, nMaxCustomFilter)
			this.cCustomFilter= left(lcUserCustomFilter, at(chr(0), lcUserCustomFilter) - 1)
		
			lcFileTitle = repl(chr(0), nMaxFileTitle)
			_FFC_MEMCPY2(@lcFileTitle, lpFileTitle, nMaxFileTitle)
			this.cFileTitle = left(lcFileTitle , at(chr(0), lcFileTitle ) - 1)
		
			this.nFilterIndex = this.StringToInteger(substr(cMyStruct, 6*4+1, 4), 4)
		endif
		
		_FFC_FREEMEM(lpMyFilter)
		_FFC_FREEMEM(lpUserCustomFilter)
		_FFC_FREEMEM(lpFileName)
		_FFC_FREEMEM(lpFileTitle)
		_FFC_FREEMEM(lpInitialDirectory)
		_FFC_FREEMEM(lpTitlebarText)
		_FFC_FREEMEM(lpDefExt)
		
		return nReturnVal
		
	ENDPROC

	PROCEDURE Init
		THIS.aFilterList[1,1] = "All Files (*.*)"
		THIS.aFilterList[1,2] = "*.*"
		
	ENDPROC

	PROTECTED PROCEDURE integertostring
		LPARAMETERS nInteger, nBytes
		LOCAL cRetVal
		IF pCount() < 2
			nBytes = 4
		ENDIF
		cRetVal = ""
		FOR nCurByte = 1 to nBytes
			cRetVal = cRetVal + CHR(BITAND(BITRSHIFT(nInteger, 8 * (nCurByte -1) ), 255))
		ENDFOR
		RETURN cRetVal
		
	ENDPROC

	PROTECTED PROCEDURE loaddlls
		DECLARE INTEGER GetSaveFileNameA IN comdlg32.dll AS _FFC_SAVEFILENAME STRING @
		DECLARE INTEGER GetOpenFileNameA IN comdlg32.dll AS _FFC_GETFILENAME STRING @
		DECLARE INTEGER malloc IN msvcrt.dll AS _FFC_MALLOC INTEGER
		DECLARE free in msvcrt.dll AS _FFC_FREEMEM INTEGER 
		
	ENDPROC

	PROCEDURE showdialog		&& Displays dialog with various options such as filters.
		local llReturn
		with This
			store '' to .cFilePath, .cFileTitle
			.LoadDLLs()
			llReturn = .DialogHandler() = 1
			.ClearDLLs()
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE stringtointeger
		LPARAMETERS cPDWORD, nBytes
		LOCAL nCurByte, nRetVal
		IF PCOUNT() < 2
			nBytes = LEN(cPDWord)
		ENDIF
		nRetVal = 0
		FOR nCurByte = 1 to nBytes
			nRetVal = nRetVal + ASC(SUBSTR(cPDWord, nCurByte, 1))*(256^(nCurByte-1))
		ENDFOR
		RETURN nRetVal
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfutility AS sfcustom OF "sfctrls.vcx" 		&& A class containing various utility library routines
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfutility.h"
	*<DefinedPropArrayMethod>
		*m: arrayscan		&& Find a particular value in a certain column in an array.
		*m: calcexprwidth		&& Calculates the width of an expression in pixels based on its type.
		*m: calcfontmetric		&& Determine the width to use for font calculations based on a size.
		*m: calcobjectstyle		&& Determines the font style of an object.
		*m: clearpleasewait		&& Clears a "please wait" message and restores the mouse pointer
		*m: closeallaliases		&& Close all open copies of a given table.
		*m: closeallaliasesindatasession		&& Close all open copies of a given table in the current datasession
		*m: closeopenedtables		&& Close any tables that were opened since a snapshot was taken.
		*m: copyproperties		&& Copies all possible properties from one object to another
		*m: createdesktopshortcut		&& Creates a shortcut on the Desktop
		*m: createshortcut		&& Creates a shortcut to a file
		*m: createuniquealias		&& Create a unique alias for a table.
		*m: createuniquefilename		&& Ensure a filename is unique by appending a number.
		*m: datatypetostring		&& Converts from a data type to a string
		*m: decimal2hex		&& Convert a decimal number to a hex string.
		*m: decrypt		&& Decrypt a string
		*m: encrypt		&& Encrypt a string
		*m: errorsound		&& Sounds a Windows error sound
		*m: exprfields		&& Return a comma-delimited list of fields for a given expression
		*m: fieldsinexpr		&& Fills an array with the fields in the specified expression
		*m: fixalias		&& Converts invalid characters in a cursor alias into underscores
		*m: getappdirectory		&& Returns the directory the application was started in
		*m: getblankvalue		&& Returns a blank value of the desired data type
		*m: getdatetime		&& Combines a date and time string into a DateTime value
		*m: getdesktopdirectory		&& Returns the directory for the Windows desktop
		*m: getdirectorytree		&& Fills an array with the subdirectories of the specified directory
		*m: getdrivespace		&& Returns the amount of total or free space on a volume
		*m: getfieldtag		&& Finds a tag on a field if it exists
		*m: getlongfilename		&& Returns the long name for a short (DOS 8.3) file name
		*m: getmethod		&& Returns the name of the current method without the object.
		*m: getproperdirectory		&& Converts the specified directory into the case as it actually exists on disk
		*m: getsystemdirectory		&& Returns the System directory
		*m: gettempdirectory		&& Returns the Windows temp directory
		*m: getvfpversion		&& Gets the VFP product date version number
		*m: getvolumeinformation		&& Returns information about the specified volume
		*m: getwindowsdirectory		&& Returns the Windows directory
		*m: hex2decimal		&& Converts a word in Intel format to a decimal value.
		*m: inexpr		&& Determine if a name is contained within an expression.
		*m: inheritsfrom		&& Return .T. if the specified object is or is a subclass of the specified class
		*m: isdiskin		&& Returns .T. if a disk is in the specified drive
		*m: keyfields		&& Return a comma-delimited list of fields for a given tag.
		*m: loadimage		&& Loads an image and returns a reference to it
		*m: lockwindow		&& Locks Windows from updating the screen
		*m: numericpicture		&& Create an inputmask for a numeric field
		*m: optimizedskip		&& Performs a Rushmore-optimizable SKIP.
		*m: pleasewait		&& Displays a "please wait" message and shows an hourglass cursor
		*m: reposition		&& Reposition a table file to a former record number.
		*m: reversedecimal2hex		&& Convert a decimal number to a hex string in reverse Intel format (most significant byte first).
		*m: reversehex2decimal		&& Converts a word in reverse Intel format (most significant byte first) to a decimal value.
		*m: runcode		&& Executes the specified code
		*m: shellexecute
		*m: shortpath		&& Returns a DOS 8.3 filename from a long filename
		*m: stripalias		&& Strips all aliases from the specified expression
		*m: tempfile		&& Create a temporary filename.
		*m: urldecode		&& Decodes URL encoded text
		*m: wordstrtran		&& Performs a STRTRAN on whole words, not substrings
		*p: nmousepointer		&& The saved mouse pointer
	*</DefinedPropArrayMethod>

	PROTECTED nmousepointer
	Name = "sfutility"
	nmousepointer = -1		&& The saved mouse pointer
	
	PROCEDURE arrayscan		&& Find a particular value in a certain column in an array.
		*==============================================================================
		* Method:			ArrayScan
		* Status:			Public
		* Purpose:			Find a particular value in a certain column in an array
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
		* Last Revision:	04/01/2002
		* Parameters:		taArray    - the array (passed by reference using @) to
		*						search
		*					tuValue    - the value to search for
		*					tnColumn   - the column to search (optional: if it isn't
		*						specified, column 1 is searched)
		*					tnOccur    - the occurrance to search for (optional: if it
		*						isn't specified, the first occurrance is located)
		*					tlNotExact - if .T., an non-exact match will be found
		* Returns:			the row the value was found in if it was found, or 0 if
		*						not
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters taArray, ;
			tuValue, ;
			tnColumn, ;
			tnOccur, ;
			tlNotExact
		external array taArray
		
		* In VFP 7, use the new capabilities of ASCAN.
		
		if clVFP7ORLATER
			local lnColumn, ;
				lnOccur, ;
				lnFlags, ;
				lnRows, ;
				lnColumns, ;
				lnStartElement, ;
				lnFound, ;
				lnRow
			#define cnEXACT_OFF   4
			#define cnEXACT_ON    6
			#define cnRETURN_ROW  8
			lnColumn       = iif(vartype(tnColumn) = 'N', tnColumn, 1)
			lnOccur        = iif(vartype(tnOccur)  = 'N', tnOccur,  1)
			lnFlags        = iif(tlNotExact, cnEXACT_OFF, cnEXACT_ON) + cnRETURN_ROW
			lnRows         = alen(taArray, 1)
			lnColumns      = alen(taArray, 2)
			lnStartElement = 1
			lnFound        = 0
			do while lnStartElement <= lnRows
		#if type('version(5)') <> 'U' and version(5) >= 700
				lnRow = ascan(taArray, tuValue, lnStartElement, -1, lnColumn, lnFlags)
		#endif
				if lnRow > 0
					lnFound = lnFound + 1
					if lnFound = lnOccur
						exit
					else
						lnStartElement = lnRow + 1
						lnRow = 0
					endif lnFound = lnOccur
				else
					exit
				endif lnRow > 0
			enddo while lnStartElement <= lnRows
		else
		
		* In VFP 6, use ASCAN in a loop to find the desired element.
		
			local lnColumn, ;
				lnOccur, ;
				lnRow, ;
				lnStartElement, ;
				lnFound, ;
				lnRows, ;
				lnColumns, ;
				lcType, ;
				lnElement, ;
				lnCol, ;
				lnI
			lnColumn       = iif(vartype(tnColumn) = 'N', tnColumn, 1)
			lnOccur        = iif(vartype(tnOccur)  = 'N', tnOccur,  1)
			lnRow          = 0
			lnStartElement = 1
			lnFound        = 0
			lnRows         = alen(taArray, 1)
			lnColumns      = alen(taArray, 2)
			lcType         = vartype(tuValue)
		
		* If we're dealing with a character expression, use ASCAN to find the value in
		* the array, then determine if it's in the correct column. If not, change the
		* starting element number and try again.
		
			if lcType = 'C'
				do while lnStartElement <= alen(taArray)
					lnElement = ascan(taArray, tuValue, lnStartElement)
					if lnElement <> 0
						lnCol = iif(lnColumns > 1, asubscript(taArray, lnElement, 2), 1)
						if lnCol = lnColumn and (tlNotExact or lcType <> 'C' or ;
							taArray[lnElement] == tuValue)
							lnFound = lnFound + 1
							if lnFound = lnOccur
								lnRow = iif(lnColumns > 1, ;
									asubscript(taArray, lnElement, 1), lnElement)
								exit
							endif lnCol = lnColumn ...
						endif lnCol = lnColumn ...
						lnStartElement = lnElement + 1
					else
						exit
					endif lnElement <> 0
				enddo while lnStartElement <= alen(taArray)
		
		* For non-character expressions, we'll use a brute force method because of a
		* bug in ASCAN() which prevents it from working with non-character expressions.
		
			else
				for lnI = 1 to lnRows
					if (lnColumns > 1 and vartype(taArray[lnI, lnColumn]) = lcType and ;
						taArray[lnI, lnColumn] = tuValue) or (lnColumns < 2 and ;
						vartype(taArray[lnI]) = lcType and taArray[lnI] = tuValue)
						lnRow = lnI
						exit
					endif (lnColumns > 1 ...
				next lnI
			endif lcType = 'C'
		endif clVFP7ORLATER
		return lnRow
		
	ENDPROC

	PROCEDURE calcexprwidth		&& Calculates the width of an expression in pixels based on its type.
		*==============================================================================
		* Method:			CalcExprWidth
		* Status:			Public
		* Purpose:			Calculates the width of an expression in pixels based on
		*						its type
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	08/12/96
		* Parameters:		tcExpression - the expression
		*					tcFontName   - the font
		*					tnFontSize   - the font size
		*					tcFontStyle  - the font style
		* Returns:			the width of the expression in pixels
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcExpression, ;
			tcFontName, ;
			tnFontSize, ;
			tcFontStyle
		local lcType, ;
			lnWidth, ;
			lnPos, ;
			lcAlias, ;
			lcField
		lcType = type(tcExpression)
		do case
		
		* Dates are sized to the width of 00/00/00 or 00/00/0000, depending on whether
		* CENTURY is on or not.
		
			case lcType = 'D'
				lnWidth = txtwidth('00/00/00' + iif(set('CENTURY') = 'ON', '00', ''), ;
					tcFontName, tnFontSize, tcFontStyle)
		
		* DateTime expressions are sized to an appropriate width based on the settings
		* of CENTURY, SECONDS, and HOURS.
		
			case lcType = 'T'
				lnWidth = txtwidth('00/00/00' + iif(set('CENTURY') = 'ON', '00', '') + ;
					' 00:00' + iif(set('SECONDS') = 'ON', ':00', '') + ;
					iif(set('HOURS') = 12, ' PM', ''), tcFontName, tnFontSize, tcFontStyle)
		
		* Numeric expressions are sized according to the field width if the expression
		* is a field or 20 if not.
		
			case lcType $ 'NF'
				lnPos = at('.', tcExpression)
				if lnPos > 0
					lcAlias = left(tcExpression, lnPos - 1)
					lcField = substr(tcExpression, lnPos + 1)
					if used(lcAlias) and type(lcAlias + '.' + lcField) <> 'U'
						lnWidth = fsize(lcField, lcAlias)
					else
						lnWidth = 20
					endif used(lcAlias) ...
				else
					lnWidth = 20
				endif lnPos > 0
		
		* Integer expressions are sized to 11.
		
			case lcType = 'I'
				lnWidth = 10
		
		* Double and currency expressions are sized to 20.
		
			case lcType $ 'BY'
				lnWidth = 20
		
		* Logical expressions are sized to the width of an "N".
		
			case lcType = 'L'
				lnWidth = txtwidth('N', tcFontName, tnFontSize, tcFontStyle)
		
		* All other expressions are sized to the width of the expression.
		
			otherwise
				lnWidth = len(evaluate(tcExpression))
		endcase
		return lnWidth * fontmetric(6, tcFontName, tnFontSize, tcFontStyle)
		
	ENDPROC

	PROCEDURE calcfontmetric		&& Determine the width to use for font calculations based on a size.
		*==============================================================================
		* Method:			CalcFontMetric
		* Status:			Public
		* Purpose:			Determine the width to use for font calculations based on
		*						a size
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	12/23/96
		* Parameters:		tcFontName  - the font
		*					tnFontSize  - the font size
		*					tcFontStyle - the font style
		*					tnSize      - the size to base the font metric choice on
		* Returns:			the appropriate font metric based on the size
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcFontName, ;
			tcFontSize, ;
			tcFontStyle, ;
			tnSize
		local lnMetric
		do case
			case tnSize <= 10
				lnMetric = fontmetric(7, tcFontName, tcFontSize, tcFontStyle)
			case between(tnSize, 11, 36)
				lnMetric = (fontmetric(6, tcFontName, tcFontSize, tcFontStyle) + ;
					fontmetric(7, tcFontName, tcFontSize, tcFontStyle))/2
			otherwise
				lnMetric = fontmetric(6, tcFontName, tcFontSize, tcFontStyle)
		endcase
		return lnMetric
		
	ENDPROC

	PROCEDURE calcobjectstyle		&& Determines the font style of an object.
		*==============================================================================
		* Method:			CalcObjectStyle
		* Status:			Public
		* Purpose:			Determines the font style of an object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last revision:	08/12/96
		* Parameters:		oObject - a reference to the object
		* Returns:			a character representing the object's font style,
		*						suitable for FONTMETRIC(), for example
		* Environment in:	the specified object exists and has various font properties
		* Environment out:	none
		*==============================================================================
		
		lparameters oObject
		local lcStyle
		lcStyle = iif(oObject.FontBold, 'B', '') + iif(oObject.FontItalic, 'I', '') + ;
			iif(oObject.FontCondense, 'C', '') + iif(oObject.FontExtend, 'E', '') + ;
			iif(oObject.FontOutline, 'O', '') + iif(oObject.FontShadow, 'S', '') + ;
			iif(oObject.FontStrikethru, '-', '') + iif(oObject.FontUnderline, 'U', '')
		lcStyle = iif(empty(lcStyle), 'N', lcStyle)
		return lcStyle
		
	ENDPROC

	PROCEDURE clearpleasewait		&& Clears a "please wait" message and restores the mouse pointer
		*==============================================================================
		* Method:			ClearPleaseWait
		* Status:			Public
		* Purpose:			Clears the "Please wait" message and restores
		*						_screen.MousePointer
		* Author:			Doug Hennig
		* Copyright:		(c) 2000-2002 Stonefield Systems Group Inc.
		* Last Revision:	12/19/2002
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	This.nMousePointer contains the former _screen.MousePointer
		* Environment out:	_screen.MousePointer is restore to This.nMousePointer
		*					any WAIT WINDOW is removed
		*					This.nMousePointer contains -1 indicating we're done
		*==============================================================================
		
		if This.nMousePointer <> -1
			_screen.MousePointer = This.nMousePointer
			This.nMousePointer = -1
			wait clear
			doevents
		endif This.nMousePointer <> -1
		
	ENDPROC

	PROCEDURE closeallaliases		&& Close all open copies of a given table.
		*==============================================================================
		* Method:			CloseAllAliases
		* Status:			Public
		* Purpose:			Close all open copies of a given table in all datasessions
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	02/04/2004
		* Parameters:		tcFile - the DBF name and path of the table or the name of
		*						a view
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	any open copies of the specified table or view are closed
		*==============================================================================
		
		lparameters tcFile
		local lcFile, ;
			laSessions[1], ;
			lnSessions, ;
			lnI, ;
			lnSession
		with This
			lcFile = upper(tcFile)
		#if type('version(5)') <> 'U' and version(5) >= 700
			lnSessions = asessions(laSessions)
			for lnI = lnSessions to 1 step -1
				.CloseAllAliasesInDataSession(lcFile, laSessions[lnI])
			next lnSession
		#else
			lnSessions = _screen.FormCount
			for lnI = 1 to lnSessions
				lnSession = _screen.Forms[lnI].DataSessionID
				if lnSession <> 1
					.CloseAllAliasesInDataSession(lcFile, lnSession)
				endif lnSession <> 1
			next lnI
			.CloseAllAliasesInDataSession(lcFile, 1)
		#endif
		endwith
		return
		
	ENDPROC

	PROCEDURE closeallaliasesindatasession		&& Close all open copies of a given table in the current datasession
		*==============================================================================
		* Method:			CloseAllAliasesInDataSession
		* Status:			Public
		* Purpose:			Close all open copies of a given table in the specified
								*datasessions
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/08/2001
		* Parameters:		tcFile        - the DBF name and path of the table or the
		*						name of a view
		*					tnDataSession - the datasession to check
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	any open copies of the specified table or view in the
		*						specified datasession are closed
		*==============================================================================
		
		lparameters tcFile, ;
			tnDataSession
		local lnDataSession, ;
			lcFullPath, ;
			lcFile, ;
			laTables[1], ;
			lnTables, ;
			lcAlias, ;
			lnI, ;
			lcTable
		lnDataSession = set('DATASESSION')
		set datasession to tnDataSession
		lcFullPath = set('FULLPATH')
		set fullpath on
		lcFile   = upper(tcFile)
		lnTables = aused(laTables)
		lcAlias  = strtran(juststem(tcFile), ' ', '_')
		for lnI = 1 to lnTables
			lcTable = laTables[lnI, 1]
			if dbf(lcTable) == tcFile or lcTable == tcFile or lcTable == lcAlias
				use in (lcTable)
			endif dbf(lcTable) == tcFile ...
		next lnI
		if lcFullPath = 'OFF'
			set fullpath off
		endif lcFullPath = 'OFF'
		set datasession to lnDataSession
		return
		
	ENDPROC

	PROCEDURE closeopenedtables		&& Close any tables that were opened since a snapshot was taken.
		*==============================================================================
		* Method:			CloseOpenedTables
		* Status:			Public
		* Purpose:			Closes any tables opened since a snapshot was taken
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		taTables      - a array of tables opened when the snapshot
		*						was taken
		*					tnDataSession - the datasession to use (optional: if not
		*						specified, the current datasession is used)
		* Returns:			.T. if everything worked OK
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters taTables, ;
			tnDataSession
		local lnDataSession, ;
			laTablesOpen[1], ;
			lnTables, ;
			lnI, ;
			lcTable
		
		* Ensure we were passed an array.
		
		if type('taTables[1]') = 'U'
			error cnERR_ARRAYDIM
			return .F.
		endif type('taTables[1]') = 'U'
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
		lnDataSession = set('DATASESSION')
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to tnDataSession
		endif vartype(tnDataSession) = 'N' ...
		
		* Get an array of currently open tables and go through them one at a time. If
		* the table wasn't open before, close it.
		
		lnTables = aused(laTablesOpen)
		for lnI = 1 to lnTables
			lcTable = laTablesOpen[lnI, 1]
			if not empty(lcTable) and This.ArrayScan(@taTables, lcTable) = 0
				use in (lcTable)
			endif not empty(lcTable) ...
		next lnI
		
		* Restore the former datasession if necessary.
		
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to lnDataSession
		endif vartype(tnDataSession) = 'N' ...
		return
		
	ENDPROC

	PROCEDURE copyproperties		&& Copies all possible properties from one object to another
		*==============================================================================
		* Method:			CopyProperties
		* Status:			Public
		* Purpose:			Copies all possible properties from one object to another
		* Author:			Doug Hennig
		* Copyright:		(c) 1999 Stonefield Systems Group Inc.
		* Last revision:	01/07/00
		* Parameters:		toSource - the object to copy properties from
		*					toTarget - the object to copy properties to
		* Returns:			.T.
		* Environment in:	toSource and toTarget must be objects
		* Environment out:	all possible properties (those that exist in the target and
		*						aren't read-only or protected) are copied from toSource
		*						to toTarget
		*==============================================================================
		
		lparameters toSource, ;
			toTarget
		local laProperties[1], ;
			lnProperties, ;
			lnI, ;
			lcProperty, ;
			luValue
		lnProperties = amembers(laProperties, toSource)
		for lnI = 1 to lnProperties
			lcProperty = upper(laProperties[lnI])
			if not inlist(lcProperty, 'BASECLASS', 'CLASS', 'CLASSLIBRARY', ;
				'CONTROLCOUNT', 'CONTROLS', 'NAME', 'OBJECTS', 'PARENT', 'PARENTCLASS')
				luValue = evaluate('toSource.' + lcProperty)
		
		* Ensure the property exists in the target object, is not read-only, and not
		* protected. Note: having separate statements for PEMSTATUS is a workaround
		* because VFP has a problem with two such commands within one line of code.
		
				if pemstatus(toTarget, lcProperty, 5) 
					if not pemstatus(toTarget, lcProperty, 1)
						if not pemstatus(toTarget, lcProperty, 2)
		
		* If this is an array property, use ACOPY (the check for element 0 is a
		* workaround for a VFP bug that makes native properties look like arrays; that
		* is, TYPE('OBJECT.NAME[1]') is not "U"). Otherwise, save the value in the
		* property.
		
							if type('toTarget.' + lcProperty + '[0]') = 'U' and ;
								type('toTarget.' + lcProperty + '[1]') <> 'U'
								acopy(toSource.&lcProperty, toTarget.&lcProperty)
							else
								store luValue to ('toTarget.' + lcProperty)
							endif type('toTarget.' + lcProperty + '[0]') = 'U' ...
						endif not pemstatus(toTarget, lcProperty, 2)
					endif not pemstatus(toTarget, lcProperty, 1)
				endif pemstatus(toTarget, lcProperty, 5) 
			endif not inlist(lcProperty, ...
		next lnI
		return
		
	ENDPROC

	PROCEDURE createdesktopshortcut		&& Creates a shortcut on the Desktop
		*==============================================================================
		* Method:			CreateDesktopShortcut
		* Status:			Public
		* Purpose:			Creates a shortcut on the desktop
		* Author:			Doug Hennig
		* Copyright:		(c) 2000 Stonefield Systems Group Inc.
		* Last revision:	10/23/2000
		* Parameters:		tcLinkFile   - the name of the shortcut file
		*					tcFileToLink - the EXE (including path) the shortcut is for
		* Returns:			.T. if the shortcut was created
		* Environment in:	the specified EXE must exist
		* Environment out:	the shortcut was created
		*==============================================================================
		
		lparameters tcLinkFile, ;
			tcFileToLink
		local lcDesktop, ;
			lcLinkFile
		
		* Find the Desktop folder, then create the shortcut in it.
		
		lcDesktop  = This.GetDesktopDirectory()
		lcLinkFile = lcDesktop + justfname(tcLinkFile)
		return This.CreateShortcut(lcLinkFile, tcFileToLink)
		
	ENDPROC

	PROCEDURE createshortcut		&& Creates a shortcut to a file
		*==============================================================================
		* Method:			CreateShortcut
		* Status:			Public
		* Purpose:			Creates a shortcut to a file
		* Author:			Doug Hennig
		* Copyright:		(c) 2000 Stonefield Systems Group Inc.
		* Last revision:	10/19/2000
		* Parameters:		tcLinkFile   - the name of the shortcut file (including
		*						path)
		*					tcFileToLink - the EXE (including path) the shortcut is for
		* Returns:			.T. if the shortcut was created
		* Environment in:	the specified EXE must exist
		* Environment out:	the shortcut was created
		*==============================================================================
		
		lparameters tcLinkFile, ;
			tcFileToLink
		local lcLinkFile, ;
			lcFileToLink, ;
			lcDirectory, ;
			lnResult
		
		* Ensure we have proper parameters.
		
		assert vartype(tcLinkFile) = 'C' and not empty(tcLinkFile) ;
			message 'SFUtility.CreateShortcut: invalid shortcut filename specified'
		assert vartype(tcFileToLink) = 'C' and not empty(tcFileToLink) ;
			message 'SFUtility.CreateShortcut: invalid link filename specified'
		
		* Declare the WinAPI functions we need to create a shortcut.
		
		declare integer CreateShellLink in lnkfiles.dll ;
			string @lpzLinkFileName, string @lpzExeFileName
		declare integer SetLinkWorkDir in lnkfiles.dll ;
			integer hWnd, string @lpszLinkName, string @lpszPath
		
		* Create the shortcut.
		
		lcLinkFile   = forceext(tcLinkFile, 'lnk')
		lcFileToLink = fullpath(tcFileToLink)
		lcDirectory  = justpath(lcFileToLink)
		lnResult     = CreateShellLink(@lcLinkFile, @lcFileToLink)
		lnResult     = SetLinkWorkDir(0, @lcLinkFile, @lcDirectory)
		return lnResult = 0
		
	ENDPROC

	PROCEDURE createuniquealias		&& Create a unique alias for a table.
		*==============================================================================
		* Method:			CreateUniqueAlias
		* Status:			Public
		* Purpose:			Create a unique alias for a table
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tnDataSession - the datasession to use (optional: if not
		*						specified, the current datasession is used)
		* Returns:			a unique alias
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tnDataSession
		local lnDataSession, ;
			lcAlias
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
		lnDataSession = set('DATASESSION')
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to tnDataSession
		endif vartype(tnDataSession) = 'N' ...
		
		* Assign a unique alias.
		
		lcAlias = sys(2015)
		do while used(lcAlias)
			lcAlias = sys(2015)
		enddo while used(lcAlias)
		
		* Restore the former datasession if necessary and return the alias.
		
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to lnDataSession
		endif vartype(tnDataSession) = 'N' ...
		return lcAlias
		
	ENDPROC

	PROCEDURE createuniquefilename		&& Ensure a filename is unique by appending a number.
		*==============================================================================
		* Method:			CreateUniqueFilename
		* Status:			Public
		* Purpose:			Ensures the specified filename is unique by appending a
		*						number
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
		* Last revision:	02/27/2002
		* Parameters:		tcFile    - the base file (including path if necessary) to
		*						create a unique name from
		*					tnCurrent - the next number to append. Note: this parameter
		*						is only used when this routine calls itself recursively
		* Returns:			a unique filename with a number appended to the filename,
		*						or blank if the number goes pas 99
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcFile, ;
			tnCurrent
		local lcFile, ;
			lnCurrent, ;
			lnPos, ;
			laFiles[1]
		
		* If the current digit to try wasn't specified, start at 1. Otherwise, append
		* the digit to the filename.
		
		if empty(tnCurrent)
			lcFile    = tcFile
			lnCurrent = 0
		else
			lnPos     = rat('.', tcFile)
			lcFile    = left(tcFile, lnPos - 1) + transform(tnCurrent) + ;
				substr(tcFile, lnPos)
			lnCurrent = tnCurrent
		endif empty(tnCurrent)
		do case
		
		* To ensure we don't cycle forever, don't let the file counter go past 99.
		
			case lnCurrent >= 99
				lcFile = ''
		
		* If the file we want to create exists, call ourselves recursively with a new
		* name.
		
			case adir(laFiles, lcFile) <> 0
				lnCurrent = lnCurrent + 1
				lcFile    = This.CreateUniqueFileName(tcFile, lnCurrent)
		endcase
		return lcFile
		
	ENDPROC

	PROCEDURE datatypetostring		&& Converts from a data type to a string
		*==============================================================================
		* Method:			DataTypeToString
		* Status:			Public
		* Purpose:			Converts a value from any data type to a string in a format
		*						suitable for using EVALUATE() to convert it back (that
		*						is, with the necessary delimiters)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
		* Last revision:	08/14/2002
		* Parameters:		tuValue - the value to convert
		* Returns:			a string representation of the value
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tuValue
		local lcType, ;
			lcReturn, ;
			lcDate, ;
			lnHour, ;
			lcTime
		lcType = vartype(tuValue)
		do case
			case lcType = 'C' and '"' $ tuValue
				lcReturn = "'" + trim(tuValue) + "'"
			case lcType = 'C' and "'" $ tuValue and '"' $ tuValue
				lcReturn = '[' + trim(tuValue) + ']'
			case lcType = 'C'
				lcReturn = '"' + trim(tuValue) + '"'
			case lcType $ 'DT' and empty(tuValue)
				lcReturn = '{//' + iif(lcType = 'T', ':', '') + '}'
			case lcType $ 'DT'
				lcDate = '^' + str(year(tuValue), 4) + '-' + ;
					padl(month(tuValue), 2, '0') + '-' + padl(day(tuValue), 2, '0')
				if lcType = 'T'
					lnHour = hour(tuValue)
					do case
						case lnHour = 0
							lnHour = 12
							lcTime = ' AM'
						case lnHour > 12
							lnHour = lnHour - 12
							lcTime = ' PM'
						otherwise
							lcTime = ' AM'
					endcase
					lcDate = lcDate + ' ' + padl(lnHour, 2, '0') + ':' + ;
						padl(minute(tuValue), 2, '0') + ':' + ;
						padl(sec(tuValue), 2, '0') + lcTime
				endif lcType = 'T'
				lcReturn = '{' + lcDate + '}'
			case lcType $ 'NL'
				lcReturn = transform(tuValue)
			otherwise
				lcReturn = ''
		endcase
		return lcReturn
		
	ENDPROC

	PROCEDURE decimal2hex		&& Convert a decimal number to a hex string.
		*==============================================================================
		* Method:			Decimal2Hex
		* Status:			Public
		* Purpose:			Convert a decimal number to a hex string
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	09/07/99
		* Parameters:		tnValue  - the decimal value
		*					tnPlaces - the number of places needed (optional: if it
		*						isn't specified, 4 is used)
		* Returns:			the hex string
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tnValue, ;
			tnPlaces
		local lnPlaces, ;
			lcHex, ;
			lcOut, ;
			lnI
		lnPlaces = iif(pcount() = 1, 4, tnPlaces)
		lcHex    = This.ReverseDecimal2Hex(tnValue, lnPlaces)
		lcOut    = ''
		for lnI = 1 to lnPlaces
			lcOut = lcOut + substr(lcHex, lnPlaces - lnI + 1, 1)
		next lnI
		return lcOut
		
	ENDPROC

	PROCEDURE decrypt		&& Decrypt a string
		*===========================================================================
		* Method:			Decrypt
		* Status:			Public
		* Purpose:			Decrypt a string
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	01/29/97
		* Parameters:		tcString - the string to decrypt
		*					tcKey    - a key to decrypt against
		* Returns:			the decrypted string
		* Environment in:	none
		* Environment out:	none
		*===========================================================================
		
		lparameters tcString, ;
			tcKey
		local lnLen, ;
			lcKeyExpr, ;
			lcDecrypt, ;
			lnI, ;
			lnChar
		lnLen     = len(tcString)
		lcKeyExpr = tcKey
		do while len(lcKeyExpr) < lnLen
			lcKeyExpr = lcKeyExpr + tcKey
		enddo while len(lcKeyExpr) < lnLen
		lcDecrypt = ''
		for lnI = 1 to lnLen
			lnChar    = max(asc(substr(tcString, lnI, 1)) - ;
				asc(substr(lcKeyExpr, lnI, 1)) - lnI, 0)
			lcDecrypt = lcDecrypt + iif(lnChar = 0, ' ', chr(lnChar))
		next lnI
		return lcDecrypt
		
	ENDPROC

	PROCEDURE encrypt		&& Encrypt a string
		*===========================================================================
		* Method:			Encrypt
		* Status:			Public
		* Purpose:			Encrypt a string
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	01/29/97
		* Parameters:		tcString - the string to encrypt
		*					tcKey    - a key to encrypt against
		* Returns:			the encrypted string
		* Environment in:	none
		* Environment out:	none
		*===========================================================================
		
		lparameters tcString, ;
			tcKey
		local lnLen, ;
			lcKeyExpr, ;
			lcEncrypt, ;
			lnI, ;
			lnChar
		lnLen     = len(tcString)
		lcKeyExpr = tcKey
		do while len(lcKeyExpr) < lnLen
			lcKeyExpr = lcKeyExpr + tcKey
		enddo while len(lcKeyExpr) < lnLen
		lcEncrypt = ''
		for lnI = 1 to lnLen
			lnChar    = min(asc(substr(tcString, lnI, 1)) + ;
				asc(substr(lcKeyExpr, lnI, 1)) + lnI, 255)
			lcEncrypt = lcEncrypt + chr(lnChar)
		next lnI
		return lcEncrypt
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcReturn
		aerror(laError)
		This.lErrorOccurred = .T.
		do case
		
		* Ignore errors in the code called from RunCode.
		
			case upper(tcMethod) = 'RUNCODE'
				This.cErrorMessage = laError[2]
				return
		
		* Use the normal error handling mechanism for all other types of errors. Note
		* that we add a period to the method name passed. This tells our parent class
		* to return the error resolution string back to us, which is required for RETRY
		* to work.
		
			otherwise
				lcReturn = dodefault(tnError, '.' + tcMethod, tnLine)
				lcReturn = iif(vartype(lcReturn) <> 'C', ccMSG_CONTINUE, lcReturn)
				do case
					case lcReturn = ccMSG_RETRY
						retry
					case lcReturn = ccMSG_DEBUG
						debug
						if wexist('Visual FoxPro Debugger')
							keyboard '{SHIFT+F7}' plain
						endif wexist('Visual FoxPro Debugger')
						suspend
					case lcReturn = ccMSG_CANCEL
						cancel
					otherwise
						return
				endcase
		endcase
		
	ENDPROC

	PROCEDURE errorsound		&& Sounds a Windows error sound
		*==============================================================================
		* Method:			ErrorSound
		* Status:			Public
		* Purpose:			Plays the Windows error sound
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	02/08/2001
		* Parameters:		tnSound - the sound value to play (optional: if is isn't
		*						specified, 16, which plays the "critical stop" sound,
		*						is used)
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the sound was played
		*==============================================================================
		
		lparameters tnSound
		local lnSound
		lnSound = iif(vartype(tnSound) = 'N', tnSound, 16)
		declare integer MessageBeep in Win32API ;
			integer wType
		MessageBeep(lnSound)
		
	ENDPROC

	PROCEDURE exprfields		&& Return a comma-delimited list of fields for a given expression
		*==============================================================================
		* Method:			ExprFields
		* Status:			Public
		* Purpose:			Return a comma-delimited list of fields for a given
		*						expression
		* Author:			Doug Hennig and Michael Colbert
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcAlias       - the alias of the table the tag is from
		*					tcExpression  - the expression to be parsed
		*					tnDataSession - the datasession to use (optional: if not
		*						specified, the current datasession is used)
		* Environment in:	the specified table is open
		* Environment out:	none
		*==============================================================================
		
		lparameters tcAlias, ;
			tcExpression, ;
			tnDataSession
		local lnDataSession, ;
			lcExprFields, ;
			lnI, ;
			lcField
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
		lnDataSession = set('DATASESSION')
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to tnDataSession
		endif vartype(tnDataSession) = 'N' ...
		
		* Ensure a table is specified and open.
		
		assert vartype(tcAlias) = 'C' and not empty(tcAlias) ;
			message 'SFUtility.ExprFields: no table was specified'
		assert used(tcAlias) ;
			message 'SFUtility.ExprFields: ' + tcAlias + ' is not open'
		
		* Check each field to see if it's in the expression.
		
		lcExprFields = ''
		if not empty(tcExpression) 
			for lnI = 1 to fcount(tcAlias)
				lcField = field(lnI, tcAlias)
				do case
					case lcField == tcExpression
						lcExprFields = lcField
						exit
					case This.InExpr(lcField, tcExpression)
						lcExprFields = lcExprFields + ;
							iif(empty(lcExprFields), '', ',') + lcField
				endcase
			next lnI
		endif not empty(tcTag) ...
		
		* Restore the former datasession if necessary.
		
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to lnDataSession
		endif vartype(tnDataSession) = 'N' ...
		return lcExprFields
		
	ENDPROC

	PROCEDURE fieldsinexpr		&& Fills an array with the fields in the specified expression
		*==============================================================================
		* Method:			FieldsInExpr
		* Purpose:			Fills an array with fields in an expression
		* Status:			Public
		* Author:			Doug Hennig
		* Copyright:		(c) 2002 Stonefield Systems Group Inc.
		* Last revision:	08/26/2002
		* Parameters:		taFields     - an array (passed by reference using @) to
		*						contain the fields
		*					tcExpression - the expression
		*					tcAlias      - an alias to add to unaliased fields
		*						(optional: if it isn't specified, no alias is added)
		* Returns:			the number of fields in the array
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters taFields, ;
			tcExpression, ;
			tcAlias
		local lcExpression, ;
			lnFields, ;
			llAddAlias, ;
			lcWords, ;
			lnWords, ;
			lnI, ;
			lcWord, ;
			lnWord, ;
			lcChar, ;
			lcStart
		
		* Define function and field delimiters in expressions.
		
		#define ccDELIMITERS ' !#%^*()-+/,<>[]{}='
		
		* Ensure the necessary parameters were passed.
		
		assert type('taFields[1]') <> 'U' ;
			message 'SFUtility.FieldsInExpr: array not passed'
		assert vartype(tcExpression) = 'C' and not empty(tcExpression) ;
			message 'SFUtility.FieldsInExpr: invalid expression passed'
		
		* Set up the variables we need. Because a space before an open paren can fool
		* us, let's remove any we find (note that we can't use NORMALIZE() here because
		* a field list like COMPANY, CITY is reduced to just COMPANY).
		
		lcExpression = strtran(tcExpression, ' (', '(')
		lnFields     = 0
		llAddAlias   = vartype(tcAlias) = 'C' and not empty(tcAlias)
		lcWords      = ''
		
		* Initialize the array.
		
		dimension taFields[1]
		taFields[1] = ''
		
		* Determine how many "words" there are in the expression, and then check each
		* one. Count how many times each word occurs.
		
		for lnI = 1 to len(ccDELIMITERS)
			lcDelimiter  = substr(ccDELIMITERS, lnI, 1)
			lcExpression = strtran(lcExpression, lcDelimiter, ccCR)
		next lnI
		lnWords = alines(laWords, lcExpression)
		for lnI = 1 to lnWords
			lcWord  = laWords[lnI]
			lnWord  = occurs(lcWord + ',', lcWords) + 1
			lcWords = lcWords + lcWord + ','
		
		* If this isn't a digit, see if it's a function (it's followed by an open
		* paren; we need to check this specific occurrence of the word since it may
		* appear more than once) or a keyword.
		
			if not empty(lcWord) and val(lcWord) = 0 and lcWord <> '0' and ;
				not upper(lcWord) == 'AND' and not upper(lcWord) == 'OR' and ;
				not upper(lcWord) == 'NOT'
				lcChar  = substr(tcExpression, at(lcWord, tcExpression, lnWord) + ;
					len(lcWord), 1)
				lcStart = left(lcWord, 1)
				if lcChar <> '(' and not lcStart $ ['"] and lcStart <> '['
					do case
		
		* If the field starts and ends with ".", we likely have a logical value or
		* .NULL., so ignore it.
		
						case left(lcWord, 1) = '.' and right(lcWord, 1) = '.'
							loop
		
		* If we have a ". in the word, that's likely because we have an alias with a
		* space surrounded by quotes (which got split into two words), so combine them
		* back together.
		
						case '".' $ lcWord and lnI > 1
							lcWord = laWords[lnI - 1] + ' ' + lcWord
		
		* If we have a ." in the word, that's likely because we have a field name with
		* a space surrounded by quotes (which got split into two words), so combine
		* them back together.
		
						case '."' $ lcWord and lnI < lnWords
							lcWord = lcWord + ' ' + laWords[lnI + 1]
							laWords[lnI + 1] = ''
		
		* If we have "." in the word, that's likely because we have both an alias and
		* a field name with a space surrounded by quotes (which got split into three
		* words), so combine them back together.
		
						case '"."' $ lcWord and lnI > 1 and lnI < lnWords
							lcWord = laWords[lnI - 1] + ' ' + lcWord + ' ' + ;
								laWords[lnI + 1]
							laWords[lnI + 1] = ''
					endcase
		
		* Add an alias to the name if necessary. If the word isn't already in the
		* array, add it.
		
					if llAddAlias and not '.' $ lcWord
						lcWord = tcAlias + '.' + lcWord
					endif llAddAlias ...
					if ascan(taFields, lcWord) = 0
						lnFields = lnFields + 1
						dimension taFields[lnFields]
						taFields[lnFields] = lcWord
					endif ascan(taFields, lcWord) = 0
				endif lcChar <> '(' ...
			endif not empty(lcWord) ...
		next lnI
		return lnFields
		
	ENDPROC

	PROCEDURE fixalias		&& Converts invalid characters in a cursor alias into underscores
		*==============================================================================
		* Method:			FixAlias
		* Purpose:			Converts invalid characters in a cursor alias into
		*						underscores
		* Status:			Public
		* Author:			Doug Hennig
		* Copyright:		(c) 2002 Stonefield Systems Group Inc.
		* Last revision:	03/18/2002
		* Parameters:		tcAlias - the alias to fix
		* Returns:			the alias with invalid characters converted to underscores
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcAlias
		local lcAlias, ;
			lnI, ;
			lcChar
		lcAlias = strtran(tcAlias, '"')
		for lnI = 1 to len(lcAlias)
			lcChar = substr(lcAlias, lnI, 1)
			if not isalpha(lcChar) and not isdigit(lcChar) and lcChar <> '_'
				lcAlias = strtran(lcAlias, lcChar, '_')
			endif not isalpha(lcChar) ...
		next lnI
		return lcAlias
		
	ENDPROC

	PROCEDURE getappdirectory		&& Returns the directory the application was started in
		*==============================================================================
		* Method:			GetAppDirectory
		* Status:			Public
		* Purpose:			Returns the directory the application was started in
		* Author:			Doug Hennig, modified from a routine published by Rick
		*						Strahl
		* Copyright:		(c) 2002 Stonefield Systems Group Inc.
		* Last revision:	07/26/2002
		* Parameters:		tcProgram - the program to get the directory from
		*						(optional: if it isn't specified, the top program is
		*						used)
		* Returns:			the directory with trailing backslash
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcProgram
		local lcProgram, ;
			lcPath, ;
			lcFileName, ;
			lnBytes
		lcProgram = iif(vartype(tcProgram) = 'C' and not empty(tcProgram), tcProgram, ;
			sys(16, 0))
		do case
		
		* In-process DLL server or Active Document.
		
			case atc('.VFD', lcProgram) > 0 or Application.StartMode = 3
				lcPath = home()
		
		* Out-of-process EXE server.
		
			case Application.StartMode = 2
				declare integer GetModuleFileName in Win32API ;
					integer hModule, string @cFileName, integer @nSize
				lnBytes    = cnMAX_PATH
				lcFileName = space(cnMAX_PATH)
				GetModuleFileName(0, @lcFilename, @lnBytes)
				lnBytes    = at(ccNULL, lcFilename)
				lcFileName = iif(lnBytes > 1, substr(lcFileName, 1, lnBytes - 1), '')
				lcPath     = justpath(lcFileName)
		
		* Standalone EXE or VFP development.
		
			otherwise
				lcPath = justpath(lcProgram)
				if atc('PROCEDURE', lcPath) > 0
					lcPath = substr(lcPath, rat(':', lcPath) - 1)
				endif atc('PROCEDURE', lcPath) > 0
		endcase
		lcPath = This.GetProperDirectory(addbs(lcPath))
		return lcPath
		
	ENDPROC

	PROCEDURE getblankvalue		&& Returns a blank value of the desired data type
		*==============================================================================
		* Method:			GetBlankValue
		* Status:			Public
		* Purpose:			Returns a blank value of the desired data type
		* Author:			Doug Hennig
		* Copyright:		(c) 2001-2004 Stonefield Systems Group Inc.
		* Last revision:	03/22/2004
		* Parameters:		tcType     - the data type
		*					tlString   - .T. to return it as a string
		*					tnLength   - the length of the value (used by SQL SELECT to
		*						ensure value is correct length)
		*					tnDecimals - the number of decimals for numeric values
		* Returns:			a blank value of the desired data type
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcType, ;
			tlString, ;
			tnLength, ;
			tnDecimals
		local lnLength, ;
			luReturn
		lnLength = iif(pcount() >= 3, tnLength, 0)
		do case
			case tcType $ 'CMV' and tlString
				luReturn = "'" + space(lnLength) + "'"
			case tcType $ 'CMV'
				luReturn = ''
			case tcType $ 'NFIBY' and tlString
				if tcType $ 'IBY'
					lnLength = 20
				endif tcType $ 'IBY'
				if pcount() = 4 and tnDecimals > 0
					lnDecimals = tnDecimals
					lnLength   = lnLength - lnDecimals - 1
				else
					lnDecimals = 0
				endif pcount() = 4 ...
				lnLength = max(lnLength, 1)
				luReturn = replicate('0', lnLength) + ;
					iif(lnDecimals > 0, '.' + replicate('0', lnDecimals), '')
			case tcType $ 'NFIBY'
				luReturn = 0
			case tcType $ 'DT' and tlString
				luReturn = '{}'
			case tcType $ 'DT'
				luReturn = {}
			case tlString
				luReturn = '.F.'
		endcase
		return luReturn
		
	ENDPROC

	PROCEDURE getdatetime		&& Combines a date and time string into a DateTime value
		*==============================================================================
		* Method:			GetDateTime
		* Status:			Public
		* Purpose:			Combines a date and time string into a DateTime value
		* Author:			Doug Hennig
		* Copyright:		(c) 2002 Stonefield Systems Group Inc.
		* Last revision:	01/15/2002
		* Parameters:		tdDate - the date
		*					tcTime - the time
		* Returns:			a DateTime value
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tdDate, ;
			tcTime
		return datetime(year(tdDate), month(tdDate), day(tdDate), ;
			val(left(tcTime, 2)), val(substr(tcTime, 4, 2)), val(substr(tcTime, 7, 2)))
		
	ENDPROC

	PROCEDURE getdesktopdirectory		&& Returns the directory for the Windows desktop
		*==============================================================================
		* Method:			GetDesktopDirectory
		* Status:			Public
		* Purpose:			Returns the directory for the Windows desktop
		* Author:			Doug Hennig, using George Tasker's LNKFILES.DLL
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	02/08/2001
		* Parameters:		none
		* Returns:			the directory with trailing backslash
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		local lcBuffer, ;
			lnResult, ;
			lcDesktop
		
		* Declare the WinAPI functions we need to find the Desktop folder.
		
		declare integer FindDesktopFolder in lnkfiles.dll ;
			integer hOwner, string @lpbuffer
		
		* Find the Desktop folder.
		
		lcBuffer  = space(cnMAX_PATH)
		lnResult  = FindDesktopFolder(0, @lcBuffer)
		lcDesktop = addbs(left(lcBuffer, lnResult))
		return lcDesktop
		
	ENDPROC

	PROCEDURE getdirectorytree		&& Fills an array with the subdirectories of the specified directory
		*==============================================================================
		* Method:			GetDirectoryTree
		* Status:			Public
		* Purpose:			Fills an array with the subdirectories of the specified
		*						directory
		* Author:			Doug Hennig, taken from an idea published in Microsoft
		*						Office Automation, by Tamar Granor and Della Martin
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	02/01/2001
		* Parameters:		taArray    - the array to fill (passed by reference with @)
		*					tcPath     - the directory to get subdirectories for
		*					tlRootOnly - .T. to get only top-level directories
		* Returns:			the number of subdirectories in the array
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters taArray, ;
			tcPath, ;
			tlRootOnly
		local lcCurrPath, ;
			lcPath, ;
			laDir[1], ;
			lnDir, ;
			lnDirs, ;
			lnI, ;
			lcDir
		
		* Save the current directory, then switch to the specified one (because ADIR
		* has a bug in that "D" doesn't work unless the current directory is the one
		* we're looking for), and get an array of subdirectories.
		
		lcCurrPath = sys(5) + curdir()
		lcPath     = addbs(tcPath)
		cd (lcPath)
		lnDir  = adir(laDir, '', 'D')
		lnDirs = alen(taArray)
		lnDirs = iif(lnDirs = 1 and empty(taArray[1]), 0, lnDirs)
		
		* Spin through the array, fill the passed array with valid subdirectories, and
		* then call ourselves recursively with each one if we're supposed to.
		
		for lnI = 1 to lnDir
			if laDir[lnI, 1] <> '.'
				lcDir  = lcPath + laDir[lnI, 1]
				lnDirs = lnDirs + 1
				dimension taArray[lnDirs]
				taArray[lnDirs] = lcDir
				if not tlRootOnly
					lnDirs = This.GetDirectoryTree(@taArray, lcDir, tlRootOnly)
				endif not tlRootOnly
			endif laDir[lnI, 1] <> '.'
		next lnI
		
		* Clean up and return.
		
		cd (lcCurrPath)
		return lnDirs
		
	ENDPROC

	PROCEDURE getdrivespace		&& Returns the amount of total or free space on a volume
		*==============================================================================
		* Method:			GetDriveSpace
		* Status:			Public
		* Purpose:			Returns the total or free space on a drive; workaround for
		*						a bug in VFP's DISKSPACE() routine which doesn't handle
		*						free space more than 2 GB
		* Author:			Doug Hennig, from code written by George Tasker
		* Copyright:		(c) 1996, 2001 Stonefield Systems Group Inc.
		* Last revision:	04/16/2001
		* Parameters:		tcDirectory - any directory on the drive to check space for
		*						(optional: if it isn't specified, the current drive is
		*						used)
		*					tlTotal     - .T. to return the total space on the drive or
		*						.F. to return the free space
		* Returns:			the amount of free or total space, depending on tlTotal, or
		*						-1 if an error occurred (such as drive not ready)
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcDirectory, ;
			tlTotal
		lparameters tcDirectory, ;
			tlTotal
		local lcDir, ;
			lnResult, ;
			lcDLL, ;
			lnFunction, ;
			lnHandle, ;
			lcCaller, ;
			lcTotal, ;
			lcFree
		
		* Declare Win32API functions to determine if the GetDiskFreeSpaceEx function is
		* available.
		
		declare integer GetModuleHandle in Win32API ;
			string @lpModuleName
		declare integer GetProcAddress in Win32API ;
			integer hModule, string @lpProcName
		
		* If the path wasn't specified, use the current drive. Otherwise, get the drive
		* for the specified path, handling UNC paths specially.
		
		do case
			case vartype(tcDirectory) <> 'C' or empty(tcDirectory)
				lcDir = addbs(sys(5))
			case left(tcDirectory, 2) = '\\'
				lcDir = addbs(tcDirectory)
				lcDir = left(lcDir, at('\', lcDir, 4))
			case len(tcDirectory) = 1
				lcDir = tcDirectory + ':'
			otherwise
				lcDir = addbs(justdrive(tcDirectory))
		endcase
		lnResult = -1
		
		* See if the GetDiskFreeSpaceEx Win32API function is available; if so, call it
		* to get the drive space.
		
		lcDLL      = 'kernel32.dll'
		lcFunction = 'GetDiskFreeSpaceExA'
		lnHandle   = GetModuleHandle(@lcDLL)
		if GetProcAddress(lnHandle, @lcFunction) > 0
			declare short GetDiskFreeSpaceEx in Win32API ;
				string @lpDirectoryName, string @lpFreeBytesAvailableToCaller, ;
				string @lpTotalNumberOfBytes, string @lpTotalNumberOfFreeBytes
			store replicate(ccNULL, 8) to lcCaller, lcTotal, lcFree
			if GetDiskFreeSpaceEx(@lcDir, @lcCaller, @lcTotal, @lcFree) <> 0
				lnResult = This.Hex2Decimal(iif(tlTotal, lcTotal, lcFree))
			endif GetDiskFreeSpaceEx(@lcDir, ...
		
		* Since we can't use GetDiskFreeSpaceEx, just use DISKSPACE.
		
		else
			lnResult = diskspace(lcDir)
		endif GetProcAddress(lnHandle, @lcFunction) > 0
		return lnResult
		
	ENDPROC

	PROCEDURE getfieldtag		&& Finds a tag on a field if it exists
		*==============================================================================
		* Method:			GetFieldTag
		* Status:			Public
		* Purpose:			Finds a tag on a field if it exists
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tcField       - the aliased field to look for the tag for
		*					tnDataSession - the datasession to use (optional: if not
		*						specified, the current datasession is used)
		* Returns:			the name of a tag if one exists for the field or blank if
		*						not
		* Environment in:	the specified alias must be in use somewhere
		* Environment out:	none
		*==============================================================================
		
		lparameters tcField, ;
			tnDataSession
		local lnDataSession, ;
			lnPos, ;
			lcAlias, ;
			lcField, ;
			lcTag, ;
			lnTags, ;
			lcAliasedField, ;
			lcKey, ;
			llKeyword
		
		* Ensure we were passed a proper field.
		
		assert vartype(tcField) = 'C' and not empty(tcField) and '.' $ tcField ;
			message 'SFUtility.GetFieldTag: specify a properly aliased field name.'
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
		lnDataSession = set('DATASESSION')
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to tnDataSession
		endif vartype(tnDataSession) = 'N' ...
		
		* Figure out the alias and unaliased field name, plus some other things we'll
		* need.
		
		lnPos   = at('.', tcField)
		lcAlias = upper(left(tcField, lnPos - 1))
		lcField = upper(substr(tcField, lnPos + 1))
		lcTag   = ''
		if used(lcAlias)
			lnTags         = tagcount('', lcAlias)
			lcAliasedField = upper(tcField)
		
		* Check every tag to see if we can find the field.
		
			for lnI = 1 to lnTags
				lcKey     = normalize(key('', lnI, lcAlias))
				llKeyword = .T.
				do while llKeyword and (lcField $ lcKey or lcAliasedField $ lcKey)
					llKeyword = .F.
					if lcKey = 'UPPER('
						lcKey     = substr(lcKey, 7)
						llKeyword = .T.
					endif lcKey = 'UPPER('
					if lcKey = 'LOWER('
						lcKey     = substr(lcKey, 7)
						llKeyword = .T.
					endif lcKey = 'LOWER('
					if lcKey = 'PROPER('
						lcKey     = substr(lcKey, 8)
						llKeyword = .T.
					endif lcKey = 'PROPER('
					if lcKey = 'PADR('
						lcKey     = substr(lcKey, 6)
						llKeyword = .T.
					endif lcKey = 'PADR('
				enddo while llKeyword ...
				if lcKey = lcField or lcKey = lcAliasedField
					lcTag = upper(tag('', lnI, lcAlias))
					exit
				endif lcKey = lcField ...
			next lnI
		endif used(lcAlias)
		
		* Restore the former datasession if necessary.
		
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to lnDataSession
		endif vartype(tnDataSession) = 'N' ...
		return lcTag
		
	ENDPROC

	PROCEDURE getlongfilename		&& Returns the long name for a short (DOS 8.3) file name
		*==============================================================================
		* Method:			GetLongFileName
		* Status:			Public
		* Purpose:			Returns the long name for a short (DOS 8.3) file name
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	04/10/2001
		* Parameters:		tcFile - the short filename
		* Returns:			the long name (or empty if the file doesn't exist)
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcFile
		local lcDLL, ;
			lcFunction, ;
			lnHandle, ;
			lcFile, ;
			lnLength, ;
			lcBuffer
		if '~' $ tcFile
		
		* Declare Win32API functions to determine if the GetLongPathName function is
		* available.
		
			declare integer GetModuleHandle in Win32API ;
				string @lpModuleName
			declare integer GetProcAddress in Win32API ;
				integer hModule, string @lpProcName
		
		* See if the GetLongPathName Win32API function is available; if so, call it.
		
			lcDLL      = 'kernel32.dll'
			lcFunction = 'GetLongPathNameA'
			lnHandle   = GetModuleHandle(@lcDLL)
			if GetProcAddress(lnHandle, @lcFunction) > 0
				declare integer GetLongPathName in Win32API ;
					string @lpszShortPath, string @lpszLongPath, integer cchBuffer
				lcFile   = tcFile + ccNULL
				lnLength = 260
				lcBuffer = space(lnLength)
				GetLongPathName(@lcFile, @lcBuffer, lnLength)
				lcFile = left(lcBuffer, at(ccNULL, lcBuffer) - 1)
			endif GetProcAddress(lnHandle, @lcFunction) > 0
		else
			lcFile = tcFile
		endif '~' $ tcFile
		return lcFile
		
	ENDPROC

	PROCEDURE getmethod		&& Returns the name of the current method without the object.
		*==============================================================================
		* Method:			GetMethod
		* Status:			Public
		* Purpose:			Returns the name of the current method without the object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	08/12/96
		* Parameters:		tcMethod - the name of the current method
		* Returns:			the method without the object name
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcMethod
		return substr(tcMethod, rat('.', tcMethod) + 1)
		
	ENDPROC

	PROCEDURE getproperdirectory		&& Converts the specified directory into the case as it actually exists on disk
		*==============================================================================
		* Method:			GetProperDirectory
		* Status:			Public
		* Purpose:			Converts the specified directory into the case as it
		*						actually exists on disk (VFP 7 and later only; in
		*						earlier versions, it returns the passed value)
		* Author:			Doug Hennig
		* Copyright:		(c) 2002-2003 Stonefield Systems Group Inc.
		* Last revision:	03/10/2003
		* Parameters:		tcDirectory - the directory to convert
		* Returns:			the directory in the proper case
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcDirectory
		local lcDirectory, ;
			lnStart, ;
			lnI, ;
			lcCurDir, ;
			laDir[1]
		if clVFP7ORLATER
			do case
				case left(tcDirectory, 2) = '\\'
					lcDirectory = left(tcDirectory, at('\', tcDirectory, 4))
					lnStart     = 5
				case substr(tcDirectory, 2, 1) = ':'
					lcDirectory = left(tcDirectory, 3)
					lnStart     = 2
				otherwise
					lcDirectory = sys(5) + '\'
					lnStart     = 2
			endcase
			for lnI = lnStart to occurs('\', tcDirectory)
				lcCurDir = left(tcDirectory, at('\', tcDirectory, lnI) - 1)
				adir(laDir, lcCurDir, 'D', 1)
				if alen(laDir, 2) = 0
					lcDirectory = tcDirectory
				else
					lcDirectory = lcDirectory + laDir[1, 1] + '\'
				endif alen(laDir, 2) = 0
			next lnI
		else
			lcDirectory = tcDirectory
		endif clVFP7ORLATER
		return lcDirectory
		
	ENDPROC

	PROCEDURE getsystemdirectory		&& Returns the System directory
		*==============================================================================
		* Method:			GetSystemDirectory
		* Status:			Public
		* Purpose:			Returns the Windows System directory
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	02/08/2001
		* Parameters:		none
		* Returns:			the Windows System directory
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		local lcBuffer
		lcBuffer = space(cnMAX_PATH)
		declare integer GetSystemDirectory in Win32API ;
			string @szBuffer, integer nLength
		GetSystemDirectory(@lcBuffer, cnMAX_PATH)
		return addbs(alltrim(left(lcBuffer, at(ccNULL, lcBuffer) - 1)))
		
	ENDPROC

	PROCEDURE gettempdirectory		&& Returns the Windows temp directory
		*==============================================================================
		* Method:			GetTempDirectory
		* Status:			Public
		* Purpose:			Returns the Windows temp directory
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	02/08/2001
		* Parameters:		none
		* Returns:			the Windows temp directory
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		local lcBuffer
		lcBuffer = space(cnMAX_PATH)
		declare integer GetTempPath in Win32API ;
			integer nLength, string @szBuffer
		GetTempPath(cnMAX_PATH, @lcBuffer)
		return addbs(alltrim(left(lcBuffer, at(ccNULL, lcBuffer) - 1)))
		
	ENDPROC

	PROCEDURE getvfpversion		&& Gets the VFP product date version number
		*==============================================================================
		* Method:			GetVFPVersion
		* Status:			Public
		* Purpose:			Gets the VFP product date version number
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	06/12/2001
		* Parameters:		none
		* Returns:			returns the 4-character product date
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		local lcVersion
		lcVersion = version(4)
		if clVFP7ORLATER
			lcVersion = substr(lcVersion, at('.', lcVersion, 3) + 1)
		else
			lcVersion = substr(lcVersion, at('.', lcVersion, 2) + 1)
			lcVersion = left(lcVersion, at('.', lcVersion) - 1)
		endif clVFP7ORLATER
		return lcVersion
		
	ENDPROC

	PROCEDURE getvolumeinformation		&& Returns information about the specified volume
		*==============================================================================
		* Method:			GetVolumeInformation
		* Status:			Public
		* Purpose:			Returns information about the specified volume
		* Author:			Doug Hennig, from code taken off MSDN
		* Copyright:		(c) 2001-2002 Stonefield Systems Group Inc.
		* Last revision:	04/02/2002
		* Parameters:		tcVolume - the volume to get information for
		*					taArray  - an array to hold information about the volume:
		*
		*					Column	Information
		*					------	-----------
		*					 1		Volume name
		*					 2		Volume serial number
		*					 3		File system name (FAT, NTFS, etc.)
		*					 4		.T. if the file system supports case-sensitive
		*							filenames
		*					 5		.T. if the file system preserves case of filenames
		*					 6		.T. if the file system supports Unicode filenames
		*					 7		.T. if the file system preserves and enforces ACLs
		*							(NTFS only)
		*					 8		.T. if the file system supports file-based
		*							compression
		*					 9		.T. if the volume is compressed
		*					10		maximum filename length
		*
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcVolume, ;
			taArray
		local lcVolume, ;
			lcVolumeName, ;
			lnVolumeNameLen, ;
			lnVolumeSerialNumber, ;
			lnMaxFileNameLen, ;
			lnFileSystemFlags, ;
			lcFileSystemName, ;
			lnFileSystemNameLen, ;
			lcFileInfo, ;
			lcFileName, ;
			laFiles[1], ;
			lnFiles, ;
			lnI, ;
			lcFile, ;
			lnHandle
		
		* Declare the API function and constants.
		
		declare GetVolumeInformation in Win32API ;
			string lpRootPathName, string @lpVolumeNameBuffer, ;
			integer nVolumeNameSize, integer @lpVolumeSerialNumber, ;
			integer @lpMaximumComponentLength, integer @lpFileSystemFlags, ;
			string @lpFileSystemNameBuffer, integer nFileSystemNameSize
		
		* If the path wasn't specified, use the current drive. Otherwise, get the drive
		* for the specified path, handling UNC paths specially.
		
		do case
			case vartype(tcVolume) <> 'C' or empty(tcVolume)
				lcVolume = addbs(sys(5))
			case left(tcVolume, 2) = '\\'
				lcVolume = addbs(tcVolume)
				lcVolume = left(lcVolume, at('\', lcVolume, 4))
			case len(tcVolume) = 1
				lcVolume = tcVolume + ':\'
			otherwise
				lcVolume = addbs(justdrive(tcVolume))
		endcase
		if empty(lcVolume)
			lcVolume = addbs(sys(5))
		endif empty(lcVolume)
		
		* Create the parameters for the API function, then call it.
		
		lcVolumeName         = space(255)
		lnVolumeNameLen      = len(lcVolumeName)
		lnVolumeSerialNumber = 0
		lnMaxFileNameLen     = 0
		lnFileSystemFlags    = 0
		lcFileSystemName     = space(255)
		lnFileSystemNameLen  = len(lcFileSystemName)
		GetVolumeInformation(lcVolume, @lcVolumeName, lnVolumeNameLen, ;
			@lnVolumeSerialNumber, @lnMaxFileNameLen, @lnFileSystemFlags, ;
			@lcFileSystemName, lnFileSystemNameLen)
		
		* Put the information into the array.
		
		dimension taArray[10]
		taArray[ 1] = left(lcVolumeName, at(ccNULL, lcVolumeName) - 1)
		taArray[ 2] = lnVolumeSerialNumber
		taArray[ 3] = left(lcFileSystemName, at(ccNULL, lcFileSystemName) - 1)
		taArray[ 4] = bittest(lnFileSystemFlags, cnFS_CASE_SENSITIVE)
		taArray[ 5] = bittest(lnFileSystemFlags, cnFS_CASE_IS_PRESERVED)
		taArray[ 6] = bittest(lnFileSystemFlags, cnFS_UNICODE_STORED_ON_DISK)
		taArray[ 7] = bittest(lnFileSystemFlags, cnFS_PERSISTENT_ACLS)
		taArray[ 8] = bittest(lnFileSystemFlags, cnFS_FILE_COMPRESSION)
		taArray[ 9] = bittest(lnFileSystemFlags, cnFS_VOL_IS_COMPRESSED)
		taArray[10] = lnMaxFileNameLen
		
		* If the serial number is 0 (which happens with Win95/98 systems on remote
		* drives), open a file on the drive and get the file information for it.
		
		if lnVolumeSerialNumber = 0
			declare GetFileInformationByHandle in Win32API ;
				integer lnHandle, string @lcFileInfo
			declare integer CreateFile in Win32API ;
				string @lcFileName, integer dwDesiredAccess, ;
				integer dwShareMode, integer lpSecurityAttributes, ;
				integer dwCreationDisposition, integer dwFlagsAndAttributes, ;
				integer hTemplateFile
			declare CloseHandle in Win32API ;
				integer lnHandle
			lcFileInfo = space(255)
		
		* If a file was specified for the volume name, use it. Otherwise, find some
		* file we can open.
		
			if file(tcVolume)
				lcFileName = tcVolume
			else
				lnFiles    = adir(laFiles, lcVolume + '*.*')
				lcFileName = ''
				for lnI = 1 to lnFiles
					lcFile   = lcVolume + laFiles[lnI, 1]
					lnHandle = fopen(lcFile)
					fclose(lnHandle)
					if lnHandle >= 0
						lcFileName = lcFile
						exit
					endif lnHandle >= 0
				next lnI
			endif file(tcVolume)
			if not empty(lcFileName)
				lnHandle = CreateFile(@lcFileName, 0, 0, 0, 3, 0, 0)
				if lnHandle >= 0
					GetFileInformationByHandle(lnHandle, @lcFileInfo)
					CloseHandle(lnHandle)
					lnVolumeSerialNumber = This.Hex2Decimal(substr(lcFileInfo, 29, 4))
					taArray[2] = lnVolumeSerialNumber
				endif lnHandle >= 0
			endif not empty(lcFileName)
		endif lnVolumeSerialNumber = 0
		return .T.
		
	ENDPROC

	PROCEDURE getwindowsdirectory		&& Returns the Windows directory
		*==============================================================================
		* Method:			GetWindowsDirectory
		* Status:			Public
		* Purpose:			Returns the Windows directory
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	02/08/2001
		* Parameters:		none
		* Returns:			the Windows directory
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		local lcBuffer
		lcBuffer = space(cnMAX_PATH)
		declare integer GetWindowsDirectory in Win32API ;
			string @szBuffer, integer nLength
		GetWindowsDirectory(@lcBuffer, cnMAX_PATH)
		return addbs(alltrim(left(lcBuffer, at(ccNULL, lcBuffer) - 1)))
		
	ENDPROC

	PROCEDURE hex2decimal		&& Converts a word in Intel format to a decimal value.
		*==============================================================================
		* Method:			Hex2Decimal
		* Status:			Public
		* Purpose:			Converts a value in Intel format to a decimal value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	09/07/99
		* Parameters:		tcValue  - the value to convert
		*					tlSigned - .T. if the value is signed
		* Returns:			the numeric value
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcValue, ;
			tlSigned
		local lnDecimal, ;
			lnLen, ;
			lnI, ;
			lnMSB, ;
			lnMax
		lnDecimal = 0
		lnLen     = len(tcValue)
		for lnI = 1 to lnLen
			lnDecimal = lnDecimal + asc(substr(tcValue, lnI, 1)) * 256 ^ (lnI - 1)
		next lnI
		if tlSigned
			lnMSB = (lnLen * 8) - 1
			if bittest(lnDecimal, lnMSB)
				lnMax     = 2 ^ (lnMSB + 1)
				lnDecimal = lnResult - lnMax
			endif bittest(lnDecimal, lnMSB)
		endif tlSigned
		return lnDecimal
		
	ENDPROC

	PROCEDURE inexpr		&& Determine if a name is contained within an expression.
		*==============================================================================
		* Method:			InExpr
		* Status:			Public
		* Purpose:			Determine if a name is contained within an expression
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last Revision:	01/21/2004
		* Parameters:		tcField - the name in question
		*					tcExpr  - the expression to check
		*					tlPosn  - .T. to return the position within the expression
		*						(otherwise, it returns .T. if the name was found)
		*					tlTable - .T. if the name can be terminated with a period
		* Returns:			if tlPosn is .T., the position within the expression or 0
		*						if the name wasn't found
		*					if tlPosn is .F., .T. if the name was found
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcField, ;
			tcExpr, ;
			tlPosn, ;
			tlTable
		local llReturn, ;
			lnPos, ;
			lcChar, ;
			llFirstChar, ;
			llLastChar, ;
			lcAftChar, ;
			lcBefChar
		llReturn    = .F.
		for lnI = 1 to occurs(upper(tcField), upper(tcExpr))
			lnPos       = atc(tcField, tcExpr, lnI)
			lcChar      = left(tcField, 1)
			llFirstChar = not isalpha(lcChar) and not isdigit(lcChar) and lcChar <> '_'
			lcChar      = right(tcField, 1)
			llLastChar  = not isalpha(lcChar) and not isdigit(lcChar) and lcChar <> '_'
			do case
				case lnPos = 0
				case lnPos = 1 and len(tcExpr) = len(tcField)
					llReturn = .T.
				case lnPos = 1
					lcAftChar = iif(llLastChar, ' ', substr(tcExpr, len(tcField) + 1, ;
						1))
					llReturn  = not isalpha(lcAftChar) and not isdigit(lcAftChar) and ;
						lcAftChar <> '_' and (lcAftChar <> '.' or tlTable) and ;
						lcAftChar <> '(' and lcAftChar <> '['
				otherwise
					lcBefChar = iif(llFirstChar, ' ', substr(tcExpr, lnPos - 1, 1))
					lcAftChar = iif(llLastChar, ' ', substr(tcExpr, lnPos + ;
						len(tcField), 1))
					llReturn  = not isalpha(lcBefChar) and not isdigit(lcBefChar) and ;
						lcBefChar <> '_' and not isalpha(lcAftChar) and not ;
						isdigit(lcAftChar) and lcAftChar <> '_' and ;
						(lcAftChar <> '.' or tlTable) and lcAftChar <> '(' and ;
						lcAftChar <> '['
			endcase
			if llReturn
				exit
			endif llReturn
		next lnI
		return iif(tlPosn, iif(llReturn, lnPos, 0), llReturn)
		
	ENDPROC

	PROCEDURE inheritsfrom		&& Return .T. if the specified object is or is a subclass of the specified class
		*==============================================================================
		* Method:			InheritsFrom
		* Status:			Public
		* Purpose:			Return .T. if the specified object is or is a subclass of
		*						the specified class
		* Author:			Doug Hennig
		* Copyright:		(c) 1999 Stonefield Systems Group Inc.
		* Last Revision:	12/10/99
		* Parameters:		toObject - the object of interest
		*					tcClass  - the class of interest
		* Returns:			.T. if the specified object is or is a subclass of the
		*						specified class
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters toObject, ;
			tcClass
		local laTest[1], ;
			lcClass, ;
			llReturn
		if vartype(toObject) = 'O' and vartype(tcClass) = 'C' and not empty(tcClass)
			aclass(laTest, toObject)
			lcClass  = upper(tcClass)
			llReturn = This.ArrayScan(@laTest, lcClass) > 0
		else
			llReturn = .F.
		endif vartype(toObject) = 'O' ...
		return llReturn
		
		
	ENDPROC

	PROCEDURE isdiskin		&& Returns .T. if a disk is in the specified drive
		*==============================================================================
		* Method:			IsDiskIn
		* Status:			Public
		* Purpose:			Returns .T. if a disk is in the specified drive
		* Author:			Doug Hennig, from code written by Ted Roche
		* Copyright:		unknown
		* Last revision:	09/07/99
		* Parameters:		tcDrive - the drive to check
		* Returns:			.T. if a disk is in the specified drive
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcDrive
		local lcDrive, ;
			lnWinErrMode, ;
			llCanRead
		declare integer SetErrorMode in Win32API ;
			integer nErrorMode
		lcDrive      = iif(substr(tcDrive, 2, 1) = ':', left(tcDrive, 2), tcDrive)
		lnWinErrMode = SetErrorMode(1)
		llCanRead    = diskspace(lcDrive) <> -1
		SetErrorMode(lnWinErrMode)
		return llCanRead
		
	ENDPROC

	PROCEDURE keyfields		&& Return a comma-delimited list of fields for a given tag.
		*==============================================================================
		* Method:			KeyFields
		* Status:			Public
		* Purpose:			Return a comma-delimited list of fields for a given
		*						tag
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tcAlias       - the alias of the table the tag is from
		*					tcTag         - the tag to check
		*					tnDataSession - the datasession to use (optional: if not
		*						specified, the current datasession is used)
		* Environment in:	the specified table is open
		* Environment out:	none
		*==============================================================================
		
		lparameters tcAlias, ;
		    tcTag, ;
			tnDataSession
		local lnDataSession, ;
			lcKeyFields, ;
			lcKeyExpr, ;
			lnI, ;
			lcField
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
		lnDataSession = set('DATASESSION')
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to tnDataSession
		endif vartype(tnDataSession) = 'N' ...
		
		* Ensure a table is specified and open.
		
		assert vartype(tcAlias) = 'C' and not empty(tcAlias) ;
			message 'SFUtility.KeyFields: no table was specified'
		assert used(tcAlias) ;
			message 'SFUtility.KeyFields: ' + tcAlias + ' is not open'
		
		* Check each field to see if it's involved in the index expression.
		
		lcKeyFields = ''
		if not empty(tcTag) and tagno(tcTag, '', tcAlias) > 0
			lcKeyExpr   = key('', tagno(tcTag, '', tcAlias), tcAlias)
			lcKeyFields = This.ExprFields(tcAlias, lcKeyExpr)
		endif not empty(tcTag) ...
		
		* Restore the former datasession if necessary.
		
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to lnDataSession
		endif vartype(tnDataSession) = 'N' ...
		return lcKeyFields
		
	ENDPROC

	PROCEDURE loadimage		&& Loads an image and returns a reference to it
		*==============================================================================
		* Method:			LoadImage
		* Status:			Public
		* Purpose:			Loads the specified image file
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2002 Stonefield Systems Group Inc.
		* Last revision:	04/23/2002
		* Parameters:		tcFile  - the name of the image file to load
		*					tcTable - the alias of a table (or path and name if the
		*						table isn't open) that contains the image; see below
		*						(optional: if it isn't specified and a table called
		*						_GRAPHICS exists, it's used)
		* Returns:			the loaded image object or .NULL. if it couldn't be loaded
		* Environment in:	the specified file must exist in: the path specified in
		*						tcFile (if specified), the application directory, a
		*						GRAPHICS subdirectory of the application directory, or
		*						the GRAPHIC memo field of the table specified in
		*						tcTable
		* Environment out:	the image may have been loaded
		* Note:				1. This routine should be used rather than LOADPICTURE()
		*						because that function can't load an image included in
		*						an APP/EXE
		*					2. If tcTable is specified, the table must have at least
		*						two fields, one named NAME that contains the name of
		*						the image and a memo file named GRAPHIC that contains
		*						the image. It must have a tag called NAME on
		*						UPPER(NAME).
		*==============================================================================
		
		lparameters tcFile, ;
			tcTable
		local lcTable, ;
			lcAlias, ;
			llUsed, ;
			lnSelect, ;
			lcDirectory, ;
			llDelete, ;
			laFiles[1], ;
			lcFile, ;
			loPicture
		
		* Ensure if tcTable is specified that it's open or exists.
		
		assert pcount() = 1 or empty(tcTable) or (vartype(tcTable) = 'C' and ;
			(used(tcTable) or file(tcTable))) ;
			message 'LoadImage: improper table specified'
		do case
		
		* If a table name was specified, use it.
		
			case vartype(tcTable) = 'C'
				lcTable = tcTable
		
		* If a file called _GRAPHICS.DBF can be found, use it.
		
			case file('_GRAPHICS.DBF')
				lcTable = '_GRAPHICS.DBF'
		
		* If a table is open in the current workarea, we'll use it.
		
			case not empty(alias())
				lcTable = alias()
		
		* We don't have a table, so we'll look for a file on disk.
		
			otherwise
				lcTable = ''
		endcase
		
		* Figure out what directory we're in.
		
		lcDirectory = This.GetAppDirectory()
		llDelete    = .F.
		do case
		
		* If we have a table to look in, open it if necessary and try to find the image
		* file there.
		
			case not empty(lcTable)
				lcAlias  = juststem(lcTable)
				llUsed   = used(lcAlias)
				lnSelect = select()
				if llUsed
					select (lcAlias)
				else
					select 0
					use (lcTable) again shared alias (lcAlias)
				endif llUsed
				lcFile = upper(justfname(trim(tcFile)))
				do case
		
		* We can't open the table or the index is missing.
		
					case not used(lcAlias) or tagno('NAME', '', lcAlias) = 0
						lcFile = ''
		
		* We can't find the specified image.
		
					case not seek(lcFile, lcAlias, 'NAME')
						error 1, tcFile
						lcFile = ''
		
		* We did find it, so copy it to a temporary file.
		
					otherwise
						lcFile = forceext(This.TempFile(justext(lcFile)), 'bmp')
						copy memo GRAPHIC to (lcFile)
						llDelete = .T.
				endcase
				select (lnSelect)
				if not llUsed and used(lcAlias)
					use in (lcAlias)
				endif not llUsed ...
		
		* If the file exists in the specified path, we'll use it.
		
			case adir(laFiles, tcFile) = 1
				lcFile = tcFile
		
		* If the file exists in the application directory, we'll use it.
		
			case adir(laFiles, lcDirectory + tcFile) = 1
				lcFile = lcDirectory + tcFile
		
		* If the file exists in a GRAPHICS subdirectory of the application directory,
		* we'll use it.
		
			case adir(laFiles, lcDirectory + 'Graphics\' + tcFile) = 1
				lcFile = lcDirectory + 'Graphics\' + tcFile
		
		* We can't find the file.
		
			otherwise
				lcFile = ''
		endcase
		
		* If we can't find the file, raise an error. Otherwise, load it.
		
		if empty(lcFile)
			error 1, tcFile
			loPicture = .NULL.
		else
			loPicture = loadpicture(lcFile)
		endif empty(lcFile)
		
		* If we copied the file to disk, erase it now.
		
		if llDelete
			erase (lcFile)
		endif llDelete
		return loPicture
		
	ENDPROC

	PROCEDURE lockwindow		&& Locks Windows from updating the screen
		*==============================================================================
		* Method:			LockWindow
		* Status:			Public
		* Purpose:			Locks Windows from updating a window
		* Author:			Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last Revision:	02/08/2001
		* Parameters:		tlLock - .T. to lock the window, .F. to unlock
		*					tnHWnd - the handle of the window (optional: if it isn't
		*						passed, the active window is used)
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the window is either locked or unlocked, depending on
		*						tlLock
		*==============================================================================
		
		lparameters tlLock, ;
			tnHWnd
		local lnHWnd
		declare integer LockWindowUpdate in Win32API ;
			integer nHandle
		do case
			case not tlLock
				lnHWnd = 0
			case pcount() = 1
				declare integer GetDesktopWindow in Win32API
				lnHWnd = GetDesktopWindow()
			otherwise
				lnHWnd = tnHWnd
		endcase
		LockWindowUpdate(lnHWnd)
		return
		
	ENDPROC

	PROCEDURE numericpicture		&& Create an inputmask for a numeric field
		*===========================================================================
		* Method:			NumericPicture
		* Status:			Public
		* Purpose:			Create an inputmask for a numeric field
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tnWidth    - the width of the field
		*					tnDecimals - the number of decimals (optional)
		*					tlCommas   - .T. to include commas in the inputmask
		* Returns:			a numeric picture string
		* Environment in:	none
		* Environment out:	none
		*===========================================================================
		
		lparameters tnWidth, ;
			tnDecimals, ;
			tlCommas
		local lcComma, ;
			lnDecimals, ;
			lcPicture
		lcComma    = set('SEPARATOR')
		lnDecimals = iif(vartype(tnDecimals) = 'N', tnDecimals, 0)
		lcPicture  = '9' + iif(lnDecimals = 0, '', '.' + replicate('9', lnDecimals))
		lnWidth    = tnWidth
		do while len(lcPicture) < lnWidth
			if tlCommas and ;
				mod(len(lcPicture) - iif(lnDecimals > 0, lnDecimals, -1), 4) = 0
				lcPicture = '9' + lcComma + lcPicture
				lnWidth   = lnWidth + 1
			else
				lcPicture = '9' + lcPicture
			endif tlCommas ...
		enddo while len(lcPicture) < lnWidth
		return lcPicture
		
	ENDPROC

	PROCEDURE optimizedskip		&& Performs a Rushmore-optimizable SKIP.
		*==============================================================================
		* Method:			OptimizedSkip
		* Status:			Public
		* Purpose:			Performs a Rushmore-optimizable "SKIP"
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tlBackwards   - .T. if we should "SKIP -1"
		*					tcAlias       - the alias of the table to position
		*						(optional: if not specified, the current work area is
		*						used)
		*					tnDataSession - the datasession to use (optional: if not
		*						specified, the current datasession is used)
		* Returns:			.T.
		* Environment in:	there is a file open in the current work area
		* Environment out:	we have moved to the next (or previous if tlBackwards is
		*						true) record
		*==============================================================================
		
		lparameters tlBackwards, ;
			tcAlias, ;
			tnDataSession
		local lnDataSession, ;
			lnCurrSelect, ;
			llDescending, ;
			lnRecno
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
		lnDataSession = set('DATASESSION')
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to tnDataSession
		endif vartype(tnDataSession) = 'N' ...
		
		* If no alias was passed, use the alias in the current workarea.
		
		lnCurrSelect = select()
		do case
			case vartype(tcAlias) <> 'C' or empty(tcAlias)
			case not used(tcAlias)
				error cnERR_ALIAS_NOTFOUND, tcAlias
			otherwise
				select (tcAlias)
		endcase
		
		* If we're going backwards, set the order to the reverse of what it is now.
		
		llDescending = 'DESCENDING' $ upper(set('ORDER'))
		do case
			case not tlBackwards
			case llDescending
				set order to (order()) ascending
			otherwise
				set order to (order()) descending
		endcase
		
		* Use an optimizable LOCATE FOR for speed.
		
		lnRecno = recno()
		locate rest for recno() <> lnRecno
		
		* If we're going backwards, restore the order.
		
		do case
			case not tlBackwards
			case llDescending
				set order to (order()) descending
			otherwise
				set order to (order()) ascending
		endcase
		
		* Restore the former datasession if necessary.
		
		select (lnCurrSelect)
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to lnDataSession
		endif vartype(tnDataSession) = 'N' ...
		return
		
	ENDPROC

	PROCEDURE pleasewait		&& Displays a "please wait" message and shows an hourglass cursor
		*==============================================================================
		* Method:			PleaseWait
		* Status:			Public
		* Purpose:			Display an hourglass and message
		* Author:			Doug Hennig
		* Copyright:		(c) 2000 Stonefield Systems Group Inc.
		* Last Revision:	06/28/2000
		* Parameters:		tcMessage - the message to display (optional: if it isn't
		*						specified, "Please wait" is displayed
		* Returns:			.T.
		* Environment in:	This.nMousePointer contains -1 if we're haven't already
		*						done this
		* Environment out:	_screen.MousePointer is an hourglass and a WAIT WINDOW is
		*						displayed
		*					This.nMousePointer contains the former _screen.MousePointer
		*==============================================================================
		
		lparameters tcMessage
		if This.nMousePointer = -1
			This.nMousePointer   = _screen.MousePointer
			_screen.MousePointer = MOUSE_HOURGLASS
			wait window iif(vartype(tcMessage) = 'C' and not empty(tcMessage), tcMessage, ;
				ccMSG_PLEASE_WAIT) nowait
		endif This.nMousePointer = -1
		
	ENDPROC

	PROCEDURE reposition		&& Reposition a table file to a former record number.
		*==============================================================================
		* Method:			Reposition
		* Status:			Public
		* Purpose:			Reposition a table file to a former record number
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:	06/05/2001
		* Parameters:		tnRecno       - the record number
		*					tcAlias       - the alias of the table to position
		*						(optional: if not specified, the current work area is
		*						used)
		*					tnDataSession - the datasession to use (optional: if not
		*						specified, the current datasession is used)
		* Environment in:	none
		* Environment out:	the table is positioned to record number tnRecno,
		*						unless tnRecno is an invalid record number, in
		*						which case the table is positioned to EOF, or
		*						unless the table isn't open, in which case an error
		*						is given
		*==============================================================================
		
		lparameters tnRecno, ;
			tcAlias, ;
			tnDataSession
		local lnDataSession, ;
			lcAlias
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
		lnDataSession = set('DATASESSION')
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to tnDataSession
		endif vartype(tnDataSession) = 'N' ...
		
		* If no alias was passed, use the alias in the current workarea.
		
		do case
			case vartype(tcAlias) <> 'C' or empty(tcAlias)
				lcAlias = alias()
			case not used(tcAlias)
				error cnERR_ALIAS_NOTFOUND, tcAlias
				lcAlias = ''
			otherwise
				lcAlias = tcAlias
		endcase
		
		* Move the record pointer.
		
		do case
			case empty(lcAlias)
			case tnRecno < 0 or between(tnRecno, 1, reccount(lcAlias))
				go tnRecno in (lcAlias)
			otherwise
				go bottom in (lcAlias)
				if not eof(lcAlias)
					skip in (lcAlias)
				endif not eof(lcAlias)
		endcase
		
		* Restore the former datasession if necessary.
		
		if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
			set datasession to lnDataSession
		endif vartype(tnDataSession) = 'N' ...
		return
		
	ENDPROC

	PROCEDURE reversedecimal2hex		&& Convert a decimal number to a hex string in reverse Intel format (most significant byte first).
		*==============================================================================
		* Method:			ReverseDecimal2Hex
		* Status:			Public
		* Purpose:			Convert a decimal number to a hex string in reverse Intel
		*						format (most significant byte first)
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	09/07/99
		* Parameters:		tnValue  - the decimal value
		*					tnPlaces - the number of places needed (optional: if it
		*						isn't specified, 4 is used)
		* Returns:			the hex string
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tnValue, ;
			tnPlaces
		local lnDecimal, ;
			lcHex, ;
			lnCurrDecimals, ;
			lnPlaces, ;
			lnI, ;
			lnExponent, ;
			lnTemp
		lnDecimal      = tnValue
		lcHex          = ''
		lnCurrDecimals = set('DECIMALS')
		lnPlaces       = iif(pcount() = 1, 4, tnPlaces)
		set decimals to 17
		for lnI = lnPlaces to 1 step -1
			lnExponent = 256 ^ (lnI - 1)
			lnTemp     = int(lnDecimal/lnExponent)
			lcHex      = lcHex + chr(lnTemp)
			lnDecimal  = lnDecimal - lnTemp * lnExponent
		next lnI
		set decimals to lnCurrDecimals
		return lcHex
		
	ENDPROC

	PROCEDURE reversehex2decimal		&& Converts a word in reverse Intel format (most significant byte first) to a decimal value.
		*==============================================================================
		* Method:			ReverseHex2Decimal
		* Status:			Public
		* Purpose:			Converts a word in reverse Intel format (most significant
		*						byte first) to a decimal value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996 Stonefield Systems Group Inc.
		* Last Revision:	11/19/96
		* Parameters:		tcWord - the word to convert
		* Returns:			the numeric value
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcWord
		local lnDecimal, ;
			lnI
		lnDecimal = 0
		for lnI = len(tcWord) to 1 step -1
			lnDecimal = lnDecimal + asc(substr(tcWord, lnI, 1)) * 256^(len(tcWord) - lnI)
		next lnI
		return lnDecimal
		
	ENDPROC

	PROCEDURE runcode		&& Executes the specified code
		*==============================================================================
		* Method:			RunCode
		* Status:			Public
		* Purpose:			Executes the specified code (VFP 6 SP3 or later is required)
		* Author:			Doug Hennig
		* Copyright:		(c) 1999-2003 Stonefield Systems Group Inc.
		* Last revision:	03/04/2003
		* Parameters:		tcCode        - the code to execute
		*					tnDataSession - the datasession to use (optional: if not
		*						specified, the current datasession is used)
		*					tuParm1       - the first parameter to pass to the code
		*						(optional)
		*					tuParm2       - the second parameter to pass to the code
		*						(optional)
		*					tuParm3       - the third parameter to pass to the code
		*						(optional)
		* Returns:			the return value of the code or .NULL. if it couldn't run
		* Environment in:	none
		* Environment out:	This.cErrorMessage contains an error message if the method
		*						failed
		*==============================================================================
		
		lparameters tcCode, ;
			tnDataSession, ;
			tuParm1, ;
			tuParm2, ;
			tuParm3
		local luReturn, ;
			lcVersion, ;
			lcFile, ;
			lcName, ;
			lnDataSession
		luReturn = .NULL.
		with This
			.cErrorMessage = ''
			lcFile = justfname(.TempFile('PRG', 'A'))
			strtofile(tcCode, lcFile)
			if version(5) < 700
				.LockWindow(.T.)
			endif version(5) < 700
			compile (lcFile)
			if version(5) < 700
				.LockWindow()
			endif version(5) < 700
			lcName = juststem(lcFile) + '('
			do case
				case pcount() = 5
					lcName = lcName + 'tuParm1, tuParm2, tuParm3)'
				case pcount() = 4
					lcName = lcName + 'tuParm1, tuParm2)'
				case pcount() = 3
					lcName = lcName + 'tuParm1)'
				otherwise
					lcName = lcName + ')'
			endcase
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
			lnDataSession = set('DATASESSION')
			if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
				set datasession to tnDataSession
			endif vartype(tnDataSession) = 'N' ...
		
		* Run the compiled program.
		
			luReturn = &lcName
		
		* Restore the former datasession if necessary. Erase the PRG and FXP files.
		
			if vartype(tnDataSession) = 'N' and tnDataSession <> lnDataSession
				set datasession to lnDataSession
			endif vartype(tnDataSession) = 'N' ...
			erase (lcFile)
			erase forceext(lcFile, 'FXP')
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE shellexecute
		*==============================================================================
		* Method:			ShellExecute
		* Status:			Public
		* Purpose:			Opens a file in the application it's associated with
		* Author:			Adapted from the FFC _ShellExecute class by Doug Hennig
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	02/08/2001
		* Parameters:		tcFileName   - the filename to open
		*					tcOperation  - the operation to perform (optional: if it
		*						isn't specified, "Open" is used)
		*					tcWorkDir    - the working directory for the application
		*						(optional)
		*					tcParameters - other parameters to pass to the application
		*						(optional)
		* Returns:			-1: if no filename was passed
		*					2:  bad association
		*					29: failure to load application
		*					30: application is busy 
		*					31: no application association
		*					Values over 32 indicate success and return an instance
		*						handle for the application
		* Environment in:	none
		* Environment out:	if a valid value is returned, the application is running
		*==============================================================================
		
		lparameters tcFileName, ;
			tcOperation, ;
			tcWorkDir, ;
			tcParameters
		local lcFileName, ;
			lcWorkDir, ;
			lcOperation, ;
			lcParameters, ;
			lnShow
		if empty(tcFileName)
			return -1
		endif empty(tcFileName)
		lcFileName   = alltrim(tcFileName)
		lcWorkDir    = iif(vartype(tcWorkDir) = 'C', alltrim(tcWorkDir), '')
		lcOperation  = iif(vartype(tcOperation) = 'C' and not empty(tcOperation), ;
			alltrim(tcOperation), 'Open')
		lcParameters = iif(vartype(tcParameters) = 'C', alltrim(tcParameters), '')
		lnShow       = iif(upper(lcOperation) = 'Print', 0, 1)
		declare integer ShellExecute in SHELL32.DLL ;
			integer nWinHandle, ;	&& handle of parent window
			string cOperation, ;	&& operation to perform
			string cFileName, ;		&& filename
			string cParameters, ;	&& parameters for the executable
			string cDirectory, ;	&& default directory
			integer nShowWindow		&& window state
		return ShellExecute(0, lcOperation, lcFilename, lcParameters, lcWorkDir, ;
			lnShow)
		
	ENDPROC

	PROCEDURE shortpath		&& Returns a DOS 8.3 filename from a long filename
		*==============================================================================
		* Method:			ShortPath
		* Status:			Public
		* Purpose:			Returns a DOS 8.3 filename from a long filename
		* Author:			Doug Hennig, adapted from code written by Rick Strahl
		* Copyright:		(c) 2001 Stonefield Systems Group Inc.
		* Last revision:	02/07/2001
		* Parameters:		tcPath - the path to convert
		* Returns:			the path in 8.3 format
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcPath
		local lcPath, ;
			lnLength, ;
			lcBuffer, ;
			lnResult
		declare integer GetShortPathName in Win32API ;
			string @lpszLongPath, string @lpszShortPath, integer cchBuffer
		lcPath   = tcPath
		lnLength = 260
		lcBuffer = space(lnLength)
		lnResult = GetShortPathName(@lcPath, @lcBuffer, lnLength)
		return iif(lnResult = 0, '', left(lcBuffer, lnResult))
		
	ENDPROC

	PROCEDURE stripalias		&& Strips all aliases from the specified expression
		*==============================================================================
		* Method:			StripAlias
		* Status:			Public
		* Purpose:			Strips all aliases from the specified expression
		* Author:			Doug Hennig
		* Copyright:		(c) 2002-2003 Stonefield Systems Group Inc.
		* Last revision:	02/27/2003
		* Parameters:		tcExpr - the expression
		* Returns:			the expression with all aliases stripped out
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcExpr
		local lcExpr, ;
			laFields[1], ;
			lnFields, ;
			lnI, ;
			lcField, ;
			lcAlias
		lcExpr   = tcExpr
		lnFields = This.FieldsInExpr(@laFields, lcExpr)
		for lnI = 1 to lnFields
			lcField = laFields[lnI]
			if '.' $ lcField
				lcAlias = juststem(lcField)
				if type(lcAlias) <> 'O'		&& don't strip if OBJECT.PROPERTY
					lcExpr = strtran(lcExpr, lcAlias + '.')
				endif type(lcAlias) <> 'O'
			endif '.' $ lcField
		next lnI
		return lcExpr
		
	ENDPROC

	PROCEDURE tempfile		&& Create a temporary filename.
		*==============================================================================
		* Method:			TempFile
		* Status:			Public
		* Purpose:			Create a temporary filename
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2001 Stonefield Systems Group Inc.
		* Last Revision:	06/05/2001
		* Parameters:		tcExtension - the file extension
		* 					tcUserName  - the user name (optional)
		* Returns:			a temporary filename with a path of the user's Temp
		*						directory. If tcUserName is passed and not blank, the
		*						first four characters of the filename contain the first
		*						four characters of tcUserName. If tcUserName is passed
		*						but blank, the filename consist of all digits.
		*						Otherwise, the first four characters of the filename
		*						contain "TEMP"
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tcExtension, ;
			tcUserName
		local lcPrefix, ;
			lnLen
		do case
			case vartype(tcUserName) = 'C' and empty(tcUserName)
				lcPrefix = ''
				lnLen    = 0
			case vartype(tcUserName) = 'C'
				lcPrefix = tcUserName
				lnLen    = min(len(trim(lcPrefix)), 4)
			otherwise
				lcPrefix = 'TEMP'
				lnLen    = 4
		endcase
		return This.GetTempDirectory() + ;
			stuff(sys(3), 1, lnLen, left(lcPrefix, lnLen)) + ;
			iif(vartype(tcExtension) = 'L' or empty(tcExtension), '', '.' + ;
			tcExtension)
		
	ENDPROC

	PROCEDURE urldecode		&& Decodes URL encoded text
		*==============================================================================
		* Method:			URLDecode
		* Status:			Public
		* Purpose:			Decodes a string, replacing %xy tokens with ASCII
		*						characters
		* Author:			Doug Hennig, adapted from code by Albert Ballinger
		* Copyright:		(c) 2002 Stonefield Systems Group Inc.
		* Last revision:	04/29/2002
		* Parameters:		tcInput - the string to decode
		* Returns:			the decoded string or a blank string if an error occurred
		* Environment in:	SHLWAPI.DLL must be available (see below)
		* Environment out:	none
		* Note:				Requirements: Version 5.00 and later of Shlwapi.dll, which
		*						is available in Windows 2000 or Windows 98, or Windows
		*						NT 4.0 or 95 with Internet Explorer 5.0 or later
		*==============================================================================
		
		lparameters tcInput
		local lcInput, ;
			lnLength, ;
			lcOutput
		declare integer UrlUnescape in shlwapi.dll string pszURL, ;
			string @pszUnescaped, integer @pcchUnescaped, integer dwFlags
		lcInput  = strtran(tcInput, '+', ' ')
		lnLength = len(lcInput) + 1
		lcOutput = replicate(ccNULL, lnLength)
		if UrlUnescape(lcInput, @lcOutput, @lnLength, 0) = 0
			lcOutput = left(lcOutput, lnLength)
		else
			lcOutput = ''
		endif UrlUnescape(lcInput, @lcOutput, @lnLength, 0) = 0
		return lcOutput
		
	ENDPROC

	PROCEDURE wordstrtran		&& Performs a STRTRAN on whole words, not substrings
		*==============================================================================
		* Method:			WordStrTran
		* Purpose:			Performs a STRTRAN on whole words, not substrings
		* Status:			Public
		* Author:			Doug Hennig
		* Copyright:		(c) 2003 Stonefield Systems Group Inc.
		* Last revision:	04/15/2003
		* Parameters:		tcString  - the string to search and replace in
		*					tcSearch  - the string to search for 
		*					tcReplace - the string to replace tcSearch with
		* Returns:			the string with any replacements does
		* Environment in:	none
		* Environment out:	none
		* Notes:			STRTRAN does a search and replace on anything in a string,
		*						not just words. This can be a problem if you want to
		*						STRTRAN('TABLE.TAX, TABLE.TAX_STATUS', 'TABLE.TAX',
		*						'TABLE.TAX_A'), because TABLE.TAX is matched twice in
		*						the string and you'd end up with TABLE.TAX_A,
		*						TABLE.TAX_A_STATUS. This method won't match substrings,
		*						only whole words
		*==============================================================================
		
		lparameters tcString, ;
			tcSearch, ;
			tcReplace
		local lcString, ;
			lnLen, ;
			llSubString, ;
			lcDelimiters, ;
			lnI, ;
			lnPos, ;
			lcLeftChar, ;
			lcRightChar
		
		* Ensure the necessary parameters were passed.
		
		assert vartype(tcString) = 'C' and not empty(tcString) ;
			message 'SFUtility.WordStrTran: invalid string passed'
		assert vartype(tcSearch) = 'C' and not empty(tcSearch) ;
			message 'SFUtility.WordStrTran: invalid search string passed'
		assert vartype(tcReplace) = 'C' and not empty(tcReplace) ;
			message 'SFUtility.WordStrTran: invalid replacement string passed'
		
		* Create some variables. Determine if we are replacing the search string with a
		* longer string that contains the search string (such as TABLE.TAX with
		* TABLE.TAX_A), in which case we have to be careful not to search for words
		* we've already replaced on the second and subsequent pass.
		
		lcString    = tcString
		lnLen       = len(tcSearch)
		llSubString = tcSearch $ tcReplace
		
		* Define words delimiters in expressions.
		
		lcDelimiters = ' !#%^*()-+/.,<>[]{}='
		
		* Go through all occurrences of the search string within the string and only
		* replace those that are preceded by a word delimiter.
		
		for lnI = 1 to occurs(upper(tcSearch), upper(lcString))
			lnPos       = atc(tcSearch, lcString, iif(llSubString, lnI, 1))
			lcLeftChar  = iif(lnPos = 1, ' ', substr(lcString, lnPos - 1, 1))
			lcRightChar = iif(lnPos + lnLen >= len(lcString), ' ', ;
				substr(lcString, lnPos + lnLen, 1))
			if lcLeftChar $ lcDelimiters and lcRightChar $ lcDelimiters
		#if clVFP7ORLATER
				lcString = strtran(lcString, tcSearch, tcReplace, ;
					iif(llSubString, lnI, 1), 1, 1)
		#else
				lcString = strtran(lcString, tcSearch, tcReplace, ;
					iif(llSubString, lnI, 1), 1)
		#endif
			endif lcLeftChar $ ccDELIMITERS ...
		next lnI
		return lcString
		
	ENDPROC

ENDDEFINE
