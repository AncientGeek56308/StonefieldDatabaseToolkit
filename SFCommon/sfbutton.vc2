*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfbutton.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfcancelbutton AS sfcommandbutton OF "sfctrls.vcx" 		&& A CommandButton that closes the form it's on
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Cancel = .T.
	Caption = "Cancel"
	lcancel = .T.
	Name = "sfcancelbutton"
	
	PROCEDURE about
		*==============================================================================
		* Class:				SFCancelButton
		* Based On:				SFCommandButton (SFCTRLS.VCX)
		* Purpose:				Provides a Cancel button that closes its form
		* Author:				Doug Hennig
		* Copyright:			(c) 1996 Stonefield Systems Group Inc.
		* Last revision:		01/23/97
		*
		* Changes in "Based On" class properties:
		*	Cancel:				.T.
		*	Caption:			Cancel
		*	Default:			.T.
		*	lCancel:			.T.
		*
		* Changes in "Based On" class methods:
		*	Click:				release its form
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		Thisform.Release()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfcolorbutton AS sfcommandbutton OF "sfctrls.vcx" 		&& A CommandButton that displays a GETCOLOR() dialog
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: ncolor		&& The value for the color this button will hold.
	*</DefinedPropArrayMethod>

	Name = "sfcolorbutton"
	ncolor = 0		&& The value for the color this button will hold.
	
	PROCEDURE about
		*==============================================================================
		* Class:				SFColorButon
		* Based On:				SFCommandButton (SFCTRLS.VCX)
		* Purpose:				Display a GETCOLOR() dialog
		* Author:				Doug Hennig
		* Copyright:			(c) 1996 Stonefield Systems Group Inc.
		* Last revision:		01/23/97
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Click:				display a GETCOLOR() dialog
		*	Refresh:			set This.ForeColor to the nColor property
		*
		* Custom public properties added:
		*	nColor:				the value for the color this button will hold
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		local lnColor
		lnColor = getcolor(This.nColor)
		if lnColor >= 0
			This.nColor    = lnColor
			This.ForeColor = lnColor
		endif lnColor >= 0
		
	ENDPROC

	PROCEDURE Refresh
		This.ForeColor = This.nColor
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfdropdownmenubutton AS sfcontainer OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdMain" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdMenu" UniqueID="" Timestamp="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: buttonclicked		&& Called when the button is clicked
		*m: luseformshortcutmenu_assign
		*p: lmenuactive		&& .T. when the menu is active
	*</DefinedPropArrayMethod>

	Height = 22
	lmenuactive = .F.		&& .T. when the menu is active
	Name = "sfdropdownmenubutton"
	Width = 37

	ADD OBJECT 'cmdMain' AS sftoolbarbutton WITH ;
		Name = "cmdMain"
		*< END OBJECT: ClassLib="sfbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdMenu' AS sfdropdownmenutrigger WITH ;
		Left = 23, ;
		Name = "cmdMenu"
		*< END OBJECT: ClassLib="sfbutton.vcx" BaseClass="commandbutton" />
	
	PROCEDURE buttonclicked		&& Called when the button is clicked
	ENDPROC

	PROCEDURE luseformshortcutmenu_assign
		lparameters tlValue
		
	ENDPROC

	PROCEDURE shortcutmenu
		* Set the row and column for the menu.
		
		lparameters toMenu, ;
			tcObject
		local lnScaleMode, ;
			lnPixelHeight, ;
			lnPixelWidth, ;
			lnPixelTop, ;
			lnPixelLeft, ;
			lnVPixelHeight, ;
			lnVPixelWidth, ;
			lnVPixelTop, ;
			lnVPixelLeft, ;
			lnFoxelHeight, ;
			lnFoxelWidth, ;
			lnTopRowDockOffset, ;
			lnLeftColDockOffset, ;
			lnVPosition, ;
			lnHPosition, ;
			lnRow, ;
			lnCol
		with This
		
		* Determine some scaling factors.
		
			lnScaleMode = _screen.ScaleMode
			if lnScaleMode = 3
				lnPixelHeight     = _screen.Height
				lnPixelWidth      = _screen.Width
				lnPixelTop        = _screen.Top
				lnPixelLeft       = _screen.Left
				lnVPixelHeight    = _VFP.Height
				lnVPixelWidth     = _VFP.Width
				lnVPixelTop       = _VFP.Top
				lnVPixelLeft      = _VFP.Left
				_screen.ScaleMode = 0
				lnFoxelHeight     = _screen.Height
				lnFoxelWidth      = _screen.Width
			else
				lnFoxelHeight     = _screen.Height
				lnFoxelWidth      = _screen.Width
				_screen.ScaleMode = 3
				lnPixelHeight     = _screen.Height
				lnPixelWidth      = _screen.Width
				lnPixelTop        = _screen.Top
				lnPixelLeft       = _screen.Left
				lnVPixelHeight    = _VFP.Height
				lnVPixelWidth     = _VFP.Width
				lnVPixelTop       = _VFP.Top
				lnVPixelLeft      = _VFP.Left
			endif lnScaleMode = 3
			_screen.ScaleMode = lnScaleMode
		
		* Calculate some offset positions. The row offset is the based on the heights
		* of the menu bar, the title bar, and the window frame. The column offset is
		* based on the window frame width. The vertical and horizontal offsets combine
		* the form position with that of the cmdMain button.
		
			lnTopRowDockOffset  = lnPixelTop  - lnVPixelTop - sysmetric(9) - ;
				sysmetric(20) - sysmetric(4)
			lnLeftColDockOffset = lnPixelLeft - lnVPixelLeft - sysmetric(4)
			lnVPosition         = Thisform.Top + objtoclient(.cmdMain, 1) + ;
				.cmdMain.Height
			lnHPosition         = Thisform.Left + objtoclient(.cmdMain, 2)
		
		* Get the row for the menu.
		
			do case
		
		* We're not in a toolbar, or we are but the toolbar isn't docked.
		
				case upper(Thisform.BaseClass) <> 'TOOLBAR' or not Thisform.Docked 
					lnRow = lnVPosition + sysmetric(34) + sysmetric(4) - 1
		
		* The toolbar is docked at the top.
		
				case Thisform.DockPosition = 0
					lnRow = lnVPosition -lnTopRowDockOffset - 1
		
		* The toolbar is docked at the bottom.
		
				case Thisform.DockPosition = 3
					lnRow = lnPixelHeight + lnVPosition - 1
		
		* The toolbar is docked at one of the sides.
		
				otherwise
					lnRow = lnVPosition
			endcase
		
		* Get the column for the menu.
		
			do case
		
		* We're not in a toolbar, or we are but the toolbar isn't docked.
		
				case upper(Thisform.BaseClass) <> 'TOOLBAR' or not Thisform.Docked 
					lnCol = sysmetric(3) + lnHPosition
		
		* The toolbar is docked at the left.
		
				case Thisform.DockPosition = 1
					lnCol = lnHPosition - lnLeftColDockOffset
		
		* The toolbar is docked at the right.
		
				case Thisform.DockPosition = 2
					lnCol = lnPixelWidth + Thisform.Left
		
		* The toolbar is docked at the top or bottom.
		
				otherwise
					lnCol = sysmetric(3) + lnHPosition - 4
			endcase
			toMenu.nRow = lnRow * lnFoxelHeight / lnPixelHeight
			toMenu.nCol = lnCol * lnFoxelWidth / lnPixelWidth
			activate screen
		endwith
		return
		
	ENDPROC

	PROCEDURE showmenu
		* Ensure the menu is refreshed every time because the drop down list may
		* change.
		
		if vartype(This.oMenu) = 'O'
			This.oMenu.ClearMenu()
		endif vartype(This.oMenu) = 'O'
		dodefault()
		
	ENDPROC

	PROCEDURE cmdMain.Click
		* Call the ButtonClicked method, where custom code in a subclass will go.
		
		This.Parent.ButtonClicked()
		
	ENDPROC

	PROCEDURE cmdMain.Init
		* Disable hot tracking (which is turned on by SFToolbarButton).
		
		dodefault()
		if clVFP7ORLATER
			This.SpecialEffect = 1
		endif clVFP7ORLATER
		
	ENDPROC

	PROCEDURE cmdMain.MouseEnter
		* Turn off the visual effect of both buttons.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		with This
			if clVFP7ORLATER and .Parent.Enabled
				.VisualEffect = 1
				.Parent.cmdMenu.VisualEffect = 1
			endif clVFP7ORLATER ...
		endwith
		
	ENDPROC

	PROCEDURE cmdMain.MouseLeave
		* Turn on the visual effect of both buttons.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		with This
			if clVFP7ORLATER and .Parent.Enabled
				.VisualEffect = 0
				.Parent.cmdMenu.VisualEffect = 0
			endif clVFP7ORLATER ...
		endwith
		
	ENDPROC

	PROCEDURE cmdMenu.Init
		* Disable hot tracking (which is turned on by SFToolbarButton).
		
		dodefault()
		if clVFP7ORLATER
			This.SpecialEffect = 1
		endif clVFP7ORLATER
		
	ENDPROC

	PROCEDURE cmdMenu.MouseDown
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		local loObject
		with This
			if tnButton = BUTTON_LEFT
				do case
					case not clVFP7ORLATER
		
		* If the menu was displayed and we clicked on this button again, re-enable
		* the raised visual effect.
		
					case .VisualEffect = 0
						.VisualEffect = 1
						.Parent.cmdMain.VisualEffect = 1
						return
		
		* Turn on the sunken visual effect.
		
					case .VisualEffect = 1
						.VisualEffect = 2
				endcase
		
		* Display the menu.
		
				.Parent.lMenuActive = .T.
				.Parent.ShowMenu()
				.Parent.lMenuActive = .F.
		
		* Turn off the visual effect for this button and the other one if the mouse
		* isn't over this button (this prevents flicker if the user clicks this
		* button again to hide the menu).
		
				if clVFP7ORLATER
					.VisualEffect = 0
					loObject = sys(1270)
					if vartype(loObject) <> 'O' or not loObject.Name == This.Name
						.Parent.cmdMain.VisualEffect = 0
					endif vartype(loObject) <> 'O' ...
				endif clVFP7ORLATER
			endif tnButton = BUTTON_LEFT
		endwith
		
	ENDPROC

	PROCEDURE cmdMenu.MouseEnter
		* Turn on the visual effect of both buttons.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		with This
			if clVFP7ORLATER and .Parent.Enabled
				.VisualEffect = 1
				.Parent.cmdMain.VisualEffect = 1
			endif clVFP7ORLATER ...
		endwith
		
	ENDPROC

	PROCEDURE cmdMenu.MouseLeave
		* Turn off the visual effect of both buttons, but only if the menu isn't
		* active.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		with This
			if clVFP7ORLATER and not .Parent.lMenuActive and .Parent.Enabled
				.VisualEffect = 0
				.Parent.cmdMain.VisualEffect = 0
			endif clVFP7ORLATER ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfdropdownmenutrigger AS sftoolbarbutton OF "sfbutton.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: fontname_assign
		*m: fontsize_assign
	*</DefinedPropArrayMethod>

	Caption = "6"
	FontName = "Webdings"
	FontSize = 6
	Name = "sfdropdownmenutrigger"
	Width = 14
	
	PROCEDURE fontname_assign
		* This prevents the font name from being changed since we need the font set in
		* the Property Window for this control to appear correctly.
		
		lparameters tcValue
		
	ENDPROC

	PROCEDURE fontsize_assign
		* This prevents the font size from being changed since we need the size set in
		* the Property Window for this control to appear correctly.
		
		lparameters tnValue
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfgetdir AS sfpicturebutton OF "sfbutton.vcx" 		&& A CommandButton that displays a GETDIR() dialog
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*p: cafterdone		&& The name of a method or function to execute after GETDIR() has finished
		*p: ccaption		&& The caption for the GETDIR() dialog
		*p: cdefaultdir		&& The default directory to use
		*p: cresult		&& The location where to put the return value of GETDIR() (such as a control's Value property)
		*p: ctext		&& The text for the GETDIR() dialog
		*p: leditbox		&& .T. if an editbox should be displayed (only in VFP 7 and later)
		*p: lincludefiles		&& .T. to display files as well as folders (only in VFP 7 or later)
		*p: lusenewui		&& .T. if the Windows 2000 interface should be used (only in VFP 7 and later)
		*p: outility		&& A reference to an SFUtility object
	*</DefinedPropArrayMethod>

	PROTECTED outility
	builder = builders.vcx,SFGetDirBuilder
	cafterdone = 		&& The name of a method or function to execute after GETDIR() has finished
	Caption = "..."
	ccaption = 		&& The caption for the GETDIR() dialog
	cdefaultdir = 		&& The default directory to use
	cresult = 		&& The location where to put the return value of GETDIR() (such as a control's Value property)
	ctext = 		&& The text for the GETDIR() dialog
	leditbox = .F.		&& .T. if an editbox should be displayed (only in VFP 7 and later)
	lincludefiles = .F.		&& .T. to display files as well as folders (only in VFP 7 or later)
	lusenewui = .T.		&& .T. if the Windows 2000 interface should be used (only in VFP 7 and later)
	Name = "sfgetdir"
	outility = .NULL.		&& A reference to an SFUtility object
	StatusBarText = "Select a folder"
	ToolTipText = "Select a folder"
	
	PROCEDURE about
		*==============================================================================
		* Class:					SFGetDir
		* Based On:					SFCommandButton (SFCTRLS.VCX)
		* Purpose:					Displays a GETDIR() dialog
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2002 Stonefield Systems Group Inc.
		* Last revision:			02/25/2002
		* Include file:				SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	Builder:				builders.vcx,SFGetDirBuilder
		*	StatusBarText:			Select a folder
		*	ToolTipText:			Select a folder
		*
		* Changes in "Based On" class methods:
		*	Click:					displays the GETDIR() dialog, puts the result into
		*							the control defined in cResult, and performs any
		*							processing defined in the cAfterDone expression
		*	Init:					get a reference to an SFUtility object
		*
		* Custom public properties added:
		*	cAfterDone:				an expression to evaluate after the directory has
		*							been selected
		*	cCaption:				the caption for GETDIR()
		*	cDefaultDir:			the default directory for GETDIR()
		*	cResult:				the name of the control to put the return value
		*							from GETDIR() into
		*	lEditBox:				.T. if an editbox should be displayed (only in VFP
		*							7 and later)
		*	lIncludeFiles:			.T. to display files as well as folders (only in
		*							VFP 7 or later)
		*	lUseNewUI:				.T. if the Windows 2000 interface should be used
		*							(only in VFP 7 and later)
		*
		* Custom protected properties added:
		*	oUtility:				a reference to an SFUtility object
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		* Display a GETDIR() dialog, using parameters determined from the properties
		* of this object.
		
		local lcResult, ;
			lcOptions, ;
			lnFlags, ;
			lcDir, ;
			lcDirectory, ;
			lnI, ;
			lcCurDir, ;
			laDir[1]
		with This
			assert not empty(.cResult) ;
				message 'SFGetDir: the result container was not defined.'
		
		* Build a string of parameters from the properties of this object.
		
			lcResult = .cResult
			do case
				case empty(.cDefaultDir)
					lcOptions = evaluate(lcResult)
				case left(.cDefaultDir, 1) = '='
					lcOptions = '[' + ;
						evaluate(alltrim(substr(.cDefaultDir, 2))) + ']'
				otherwise
					lcOptions = alltrim(.cDefaultDir)
			endcase
			lcOptions = iif(empty(.cText), lcOptions, lcOptions + ;
				iif(empty(lcOptions), '[]', '') + ',[' + .cText + ']')
			do case
				case empty(.cCaption)
				case empty(lcOptions)
					lcOptions = '[],[],[' + .cCaption + ']'
				case not ',' $ lcOptions
					lcOptions = lcOptions + ',[],[' + .cCaption + ']'
				otherwise
					lcOptions = lcOptions + ',[' + .cCaption + ']'
			endcase
		
		* In VFP 7 or later, support new options.
		
			if clVFP7ORLATER
				#define BIF_RETURNONLYFSDIRS       1
				#define BIF_EDITBOX               16
				#define BIF_VALIDATE              32
				#define BIF_USENEWUI              64
				#define BIF_BROWSEINCLUDEFILES 16384
				lnFlags = 0
				if .lEditBox
					lnFlags = lnFlags + BIF_EDITBOX + BIF_VALIDATE
				endif .lEditBox
				if .lIncludeFiles
					lnFlags = lnFlags + BIF_BROWSEINCLUDEFILES
				endif .lIncludeFiles
				if .lUseNewUI
					lnFlags = lnFlags + BIF_USENEWUI
				endif .lUseNewUI
				if lnFlags > 0
					lnFlags = lnFlags + BIF_RETURNONLYFSDIRS
				endif lnFlags > 0
				do case
					case lnFlags = 0
					case empty(lcOptions)
						lcOptions = '[],[],[],' + transform(lnFlags)
					case not ',' $ lcOptions
						lcOptions = lcOptions + ',[],[],' + transform(lnFlags)
					case occurs(',', lcOptions) = 1
						lcOptions = lcOptions + ',[],' + transform(lnFlags)
					otherwise
						lcOptions = lcOptions + ',' + transform(lnFlags)
				endcase
			endif clVFP7ORLATER
		
		* Use the GETDIR() function, and if a directory was selected, store the result
		* in the specified location. If this is VFP 7 or later, convert to the proper
		* case.
		
			lcDir = getdir(&lcOptions)
			if not empty(lcDir)
				lcDir = .oUtility.GetProperDirectory(lcDir)
				store lcDir to (lcResult)
			endif not empty(lcDir)
		
		* If a method or function was specified to execute after GETDIR(), do it.
		
			if not empty(.cAfterDone)
				evaluate(.cAfterDone)
			endif not empty(.cAfterDone)
		endwith
		
	ENDPROC

	PROCEDURE Destroy
		This.oUtility = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE Init
		* Get a reference to an SFUtility object.
		
		with This
			do case
				case type('.oUtility.Name') = 'C'
				case type('oUtility.Name') = 'C'
					.oUtility = oUtility
				otherwise
					.oUtility = MakeObject('SFUtility', 'SFUtility.vcx')
			endcase
		endwith
		dodefault()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfgetexpression AS sfpicturebutton OF "sfbutton.vcx" 		&& A CommandButton that displays an Expression Builder dialog
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cafterdone		&& The name of a method or function to execute after GETEXPR has finished.
		*p: calias		&& An alias to select before GETEXPR is used.
		*p: ccaptiontext		&& The caption for the GETEXPR dialog.
		*p: cdefaultexpression		&& The default parameter for GETEXPR.
		*p: cerrormessage		&& The error message GETEXPR displays if the expression isn't valid.
		*p: cexpressiontype		&& The type parameter for GETEXPR.
		*p: cresult		&& The location where to put the result of GETEXPR (such as a control's Value property).
		*p: lliteral		&& .T. if the expression should be treated as a literal; in that case, an "=" is added to the start of non-literal expressions.
	*</DefinedPropArrayMethod>

	builder = builders.vcx,SFGetExprBuilder
	cafterdone = 		&& The name of a method or function to execute after GETEXPR has finished.
	calias = 		&& An alias to select before GETEXPR is used.
	Caption = "..."
	ccaptiontext = 		&& The caption for the GETEXPR dialog.
	cdefaultexpression = 		&& The default parameter for GETEXPR.
	cerrormessage = 		&& The error message GETEXPR displays if the expression isn't valid.
	cexpressiontype = L		&& The type parameter for GETEXPR.
	cresult = 		&& The location where to put the result of GETEXPR (such as a control's Value property).
	Height = 23
	Name = "sfgetexpression"
	StatusBarText = "Display Expression Builder"
	ToolTipText = "Display Expression Builder"
	Width = 23
	
	PROCEDURE about
		*==============================================================================
		* Class:				SFGetExpression
		* Based On:				SFCommandButton (SFCTRLS.VCX)
		* Purpose:				Displays the Expression Builder
		* Author:				Doug Hennig
		* Copyright:			(c) 1996 Stonefield Systems Group Inc.
		* Last revision:		01/10/97
		*
		* Changes in "Based On" class properties:
		*	Builder:			builders.vcx,SFGetExprBuilder
		*	Height:				23 so it's the same height as an SFTextBox
		*	StatusBarText:		Display Expression Builder
		*	ToolTipText:		Display Expression Builder
		*	Width:				23 so it's a square
		*
		* Changes in "Based On" class methods:
		*	Click:				displays the Expression Builder dialog, puts the result
		*						into the control defined in cResult, and performs any
		*						processing defined in the cAfterDone expression
		*
		* Custom public properties added:
		*	cAfterDone:			an expression to evaluate after the expression has been
		*						entered
		*	cAlias:				the alias to select before displaying the Expression
		*						Builder
		*	cCaptionText:		the caption for GETEXPR
		*	cDefaultExpression:	the default expression for GETEXPR
		*	cErrorMessage:		the message to display if the expression is invalid
		*	cExpressionType:	the data type of a valid expression (default = L)
		*	cResult:			the name of the control to put the return value from
		*						GETEXPR into
		*	lLiteral:			.T. if the expression is to be treated as a literal
		*						(that is, quotes should be added around it)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		* Display a GETEXPR dialog, using parameters determined from the properties
		* of this object.
		
		local lcType, ;
			lnCurrSelect, ;
			lcAlias, ;
			luDefault, ;
			lcQuote, ;
			lcResult
		
		* If the location to store the result wasn't defined, display an error.
		
		with This
			if empty(.cResult)
				wait window 'The result container was not defined.' nowait
		
		* Build a string of parameters from the properties of this object. If an alias
		* was specified and it's open, select it.
		
			else
				lcType = iif(empty(.cExpressionType), '', 'type "' + ;
					.cExpressionType) + iif(empty(.cErrorMessage), '', ';' + ;
					.cErrorMessage)
				lcType = iif(empty(lcType), '', lcType + '"')
				lnCurrSelect = select()
				if not empty(.cAlias)
					lcAlias = evaluate(.cAlias)
					if used(lcAlias)
						select (lcAlias)
					endif used(lcAlias)
				endif not empty(.cAlias) ...
		
		* If the default expression starts with "=", strip it off. If not, put quotes
		* around it.
		
				lcDefault = alltrim(evaluate(.cDefaultExpression))
				do case
					case not .lLiteral or empty(lcDefault)
					case left(lcDefault, 1) = '='
						lcDefault = substr(lcDefault, 2)
					case left(lcDefault, 1) <> '"' and left(lcDefault, 1) <> "'"
						lcQuote   = iif('"' $ lcDefault, "'", '"')
						lcDefault = lcQuote + lcDefault + lcQuote
				endcase
		
		* Use the GETEXPR command.
		
				getexpr .cCaptionText to lcResult &lcType default lcDefault
		
		* Remove the quotes or add an "=" to the expression.
		
				do case
					case not .lLiteral or empty(lcResult)
					case left(lcResult, 1) = '"' or left(lcResult, 1) = "'"
						lcResult = substr(lcResult, 2, len(lcResult) - 2)
					otherwise
						lcResult = '=' + lcResult
				endcase
		
		* Store the result in the specified location.
		
				store lcResult to (.cResult)
		 
		* If a method or function was specified to execute after GETDIR(), do it.
		* Reselect the former work area.
		
				if not empty(.cAfterDone)
					= evaluate(.cAfterDone)
				endif not empty(.cAfterDone)
				select (lnCurrSelect)
			endif empty(.cResult)
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfgetfile AS sfpicturebutton OF "sfbutton.vcx" 		&& A CommandButton that displays a GETFILE() dialog
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cafterdone		&& An expression to evaluate after the file has been selected
		*p: ccaption		&& The caption for the dialog
		*p: cdefault		&& The expression for the default filename for the dialog (ignored if lUseCommonDialog is .F.; surround literal string with quotes)
		*p: cextensions		&& The extensions parameter for GETFILE() or if lUseCommonDialog, extensions in the format "Descrip,*.EXT;Descrip,*.EXT" (surround literal strings in quotes)
		*p: copenbutton		&& The text to use for the Open button (ignored if lUseCommonDialog is .T.)
		*p: cresult		&& The location where to put the return value into
		*p: ctext		&& The text to appear beside the filename in the dialog (ignored if lUseCommonDialog is .T.)
		*p: lusecommondialog		&& .T. to use the CommonDialog control (requires SFCommonDialog in SFUtility.vcx)
		*p: nbuttontype		&& The button type parameter for GETFILE()
	*</DefinedPropArrayMethod>

	cafterdone = 		&& An expression to evaluate after the file has been selected
	Caption = "..."
	ccaption = 		&& The caption for the dialog
	cdefault = 		&& The expression for the default filename for the dialog (ignored if lUseCommonDialog is .F.; surround literal string with quotes)
	cextensions = 		&& The extensions parameter for GETFILE() or if lUseCommonDialog, extensions in the format "Descrip,*.EXT;Descrip,*.EXT" (surround literal strings in quotes)
	copenbutton = 		&& The text to use for the Open button (ignored if lUseCommonDialog is .T.)
	cresult = 		&& The location where to put the return value into
	ctext = 		&& The text to appear beside the filename in the dialog (ignored if lUseCommonDialog is .T.)
	lusecommondialog = .T.		&& .T. to use the CommonDialog control (requires SFCommonDialog in SFUtility.vcx)
	Name = "sfgetfile"
	nbuttontype = 0		&& The button type parameter for GETFILE()
	StatusBarText = "Select a file and path"
	ToolTipText = "Select a file and path"
	
	PROCEDURE about
		*==============================================================================
		* Class:					SFGetFile
		* Based On:					SFCommandButton (SFCTRLS.VCX)
		* Purpose:					Displays an Open File dialog
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2003 Stonefield Systems Group Inc.
		* Last revision:			01/29/2003
		*
		* Changes in "Based On" class properties:
		*	StatusBarText:			Select a file and path
		*	ToolTipText:			Select a file and path
		*
		* Changes in "Based On" class methods:
		*	Click:					displays the dialog, puts the result into the
		*							control defined in cResult, and performs any
		*							processing defined in the cAfterDone expression
		*
		* Custom public properties added:
		*	cAfterDone:				an expression to evaluate after the file has been
		*							selected
		*	cCaption:				the caption for the dialog
		*	cDefault:				the expression for the default filename for the
		*							dialog (ignored if lUseCommonDialog is .F.;
		*							surround literal string with quotes)
		*	cExtensions:			the extensions parameter for GETFILE() or if
		*							lUseCommonDialog, extensions in the format
		*							"Descrip,*.,EXT;Descrip,*.EXT" (surround literal
		*							strings in quotes)
		*	cOpenButton:			the text to use for the Open button (ignored if
		*							lUseCommonDialog is .T.)
		*	cResult:				the name of the control to put the return value
		*							into
		*	cText:					the text to appear beside the filename in the
		*							dialog (ignored if lUseCommonDialog is .T.)
		*	lUseCommonDialog:		.T. to use the CommonDialog control (requires
		*							SFCommonDialog in SFUtility.vcx)
		*	nButtonType:			the button type parameter for GETFILE()
		*							(default = 0)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		* Display an Open File dialog, using parameters determined from the properties
		* of this object.
		
		local lcResult, ;
			loDialog, ;
			lcExt, ;
			laTypes[1], ;
			lnTypes, ;
			lnI, ;
			lnPos, ;
			lcExt1, ;
			lcExt2, ;
			lcFile, ;
			lcOptions
		with This
			assert not empty(.cResult) ;
				message 'SFGetFile: the result container was not defined.'
			lcResult = .cResult
		
		* If we're using the CommonDialog control, instantiate the SFCommonDialog
		* class, set its properties, and call the ShowDialog method.
		
			if .lUseCommonDialog
				loDialog = MakeObject('SFCommonDialog', 'SFUtility.vcx')
				if not empty(.cDefault)
					loDialog.cFileName = alltrim(evaluate(.cDefault))
				endif not empty(.cDefault)
				if not empty(.cExtensions)
					lcExt   = strtran(evaluate(.cExtensions), ';', chr(13))
					lnTypes = alines(laTypes, lcExt)
					loDialog.ClearFilters(.T.)
					for lnI = 1 to lnTypes
						lcExt = laTypes[lnI]
						if ',' $ lcExt
							lnPos  = at(',', lcExt)
							lcExt1 = alltrim(left(lcExt, lnPos - 1))
							lcExt2 = alltrim(substr(lcExt, lnPos + 1))
						else
							lcExt1 = alltrim(lcExt)
							lcExt2 = '*.' + lcExt
						endif ',' $ lcExt
						if upper(justext(loDialog.cFileName)) == upper(justext(lcExt2))
							loDialog.nFilterIndex = lnI
						endif upper(justext(loDialog.cFileName)) == upper(justext(lcExt2))
						loDialog.AddFilter(lcExt1, lcExt2)
					next lnI
				endif not empty(.cExtensions)
				loDialog.cTitleBarText = .cCaption
				loDialog.lSaveDialog   = .F.
				loDialog.ShowDialog()
				lcFile = addbs(loDialog.cFilePath) + loDialog.cFileTitle
			else
		
		* We're using GETFILE(), so build a string of parameters from the properties
		* of this object and call GETFILE().
		
				lcOptions = iif(empty(.cExtensions), "''", .cExtensions) + ',' + ;
					iif(empty(.cText), "''", "'" + .cText + "'") + ',' + ;
					iif(empty(.cOpenButton), "''", "'" + .cOpenButton + "'") + ',' + ;
					iif(empty(.nButtonType), '0', transform(.nButtonType)) + ;
					iif(empty(.cCaption), '', ",'" + .cCaption + "'")
				lcFile = getfile(&lcOptions)
			endif .lUseCommonDialog
		
		* If the user chose a file, store the result in the specified location.
		
			if not empty(lcFile)
				store lcFile to (lcResult)
		
		* If a method or function was specified to execute after file selection, do it.
		
				if not empty(.cAfterDone)
					evaluate(.cAfterDone)
				endif not empty(.cAfterDone)
			endif not empty(lcFile)
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfgetfiletext AS sfgetfile OF "sfbutton.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = "Browse..."
	Height = 27
	Name = "sfgetfiletext"
	Width = 84

ENDDEFINE

DEFINE CLASS sfgetfont AS sfcommandbutton OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cfontname		&& The font name
		*p: lfontbold		&& .T. if the font is bold
		*p: lfontitalic		&& .T. if the font is italic
		*p: nfontsize		&& The font size
	*</DefinedPropArrayMethod>

	Caption = "Font..."
	cfontname = Arial		&& The font name
	lfontbold = .F.		&& .T. if the font is bold
	lfontitalic = .F.		&& .T. if the font is italic
	Name = "sfgetfont"
	nfontsize = 8		&& The font size
	
	PROCEDURE Click
		local lcStyle, ;
			lcFont, ;
			lnPos1, ;
			lnPos2
		with This
			lcStyle = iif(.lFontBold, 'B', '') + iif(.lFontItalic, 'I', '')
			lcFont  = getfont(.cFontName, .nFontSize, lcStyle)
			if not empty(lcFont)
				lnPos1       = at(',', lcFont)
				lnPos2       = at(',', lcFont, 2)
				.cFontName   = left(lcFont, lnPos1 - 1)
				.nFontSize   = val(substr(lcFont, lnPos1 + 1, lnPos2 - lnPos1 - 1))
				lcStyle      = substr(lcFont, lnPos2 + 1)
				.lFontBold   = 'B' $ lcStyle
				.lFontItalic = 'I' $ lcStyle
			endif not empty(lcFont)
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfgetpicture AS sfcommandbutton OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = ""
	Height = 40
	Name = "sfgetpicture"
	Width = 40
	
	PROCEDURE Click
		local lcPicture
		lcPicture = getpict('BMP|ICO')
		if not empty(lcPicture)
			This.Picture = lcPicture
		endif not empty(lcPicture)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfhelpbutton AS sfcommandbutton OF "sfctrls.vcx" 		&& A CommandButton that brings up help
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = "Help"
	Name = "sfhelpbutton"
	
	PROCEDURE about
		*==============================================================================
		* Class:				SFHelpButton
		* Based On:				SFCommandButton (SFCTRLS.VCX)
		* Purpose:				Brings up the Windows Help
		* Author:				Doug Hennig
		* Copyright:			(c) 1996 Stonefield Systems Group Inc.
		* Last revision:		01/20/97
		* Include file:			none
		*
		* Changes in "Based On" class properties:
		*	Caption:			Help
		*
		* Changes in "Based On" class methods:
		*	Click:				issues a HELP command
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		if Thisform.HelpContextID = 0
			help
		else
			help id Thisform.HelpContextID
		endif Thisform.HelpContextID = 0
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfokbutton AS sfcommandbutton OF "sfctrls.vcx" 		&& A CommandButton that displays OK
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = "OK"
	Default = .T.
	Name = "sfokbutton"
	
	PROCEDURE about
		*==============================================================================
		* Class:				SFOKButton
		* Based On:				SFCommandButton (SFCTRLS.VCX)
		* Purpose:				Provides an OK button
		* Author:				Doug Hennig
		* Copyright:			(c) 1996 Stonefield Systems Group Inc.
		* Last revision:		01/23/97
		*
		* Changes in "Based On" class properties:
		*	Caption:			OK
		*	Default:			.T.
		*
		* Changes in "Based On" class methods:
		*	None
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfpicturebutton AS sfcommandbutton OF "sfctrls.vcx" 		&& The base class for CommandButtons with a picture
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	Caption = ""
	Height = 23
	Name = "sfpicturebutton"
	Width = 23
	
	PROCEDURE about
		*==============================================================================
		* Class:					SFPictureButton
		* Based On:					SFCommandButton (SFCTRLS.VCX)
		* Purpose:					Base class for all CommandButton objects with
		*							pictures
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:			08/15/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in base class properties:
		*	Caption:				None so only a picture will be used
		*	Height:					23
		*	Width:					23
		*
		* Changes in base class methods:
		*	None
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfputfile AS sfpicturebutton OF "sfbutton.vcx" 		&& A CommandButton that displays a PUTFILE() dialog
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cafterdone		&& An expression to evaluate after the file has been selected
		*p: ccaption		&& The caption for the dialog (ignored if lUseCommonDialog is .F.)
		*p: cdefault		&& The default filename for the dialog (surround literal string with quotes)
		*p: cextensions		&& The extensions parameter for PUTFILE() or if lUseCommonDialog, extensions in the format "Descrip,*.EXT;Descrip,*.EXT" (surround literal strings in quotes)
		*p: cresult		&& The location where to put the return value into
		*p: ctext		&& The text to appear beside the filename in the dialog (ignored if lUseCommonDialog is .T.)
		*p: lusecommondialog		&& .T. to use the CommonDialog control (requires SFCommonDialog in SFUtility.vcx)
	*</DefinedPropArrayMethod>

	cafterdone = 		&& An expression to evaluate after the file has been selected
	Caption = "..."
	ccaption = 		&& The caption for the dialog (ignored if lUseCommonDialog is .F.)
	cdefault = 		&& The default filename for the dialog (surround literal string with quotes)
	cextensions = 		&& The extensions parameter for PUTFILE() or if lUseCommonDialog, extensions in the format "Descrip,*.EXT;Descrip,*.EXT" (surround literal strings in quotes)
	cresult = 		&& The location where to put the return value into
	ctext = 		&& The text to appear beside the filename in the dialog (ignored if lUseCommonDialog is .T.)
	lusecommondialog = .T.		&& .T. to use the CommonDialog control (requires SFCommonDialog in SFUtility.vcx)
	Name = "sfputfile"
	StatusBarText = "Select a file and path"
	ToolTipText = "Select a file and path"
	
	PROCEDURE about
		*==============================================================================
		* Class:					SFPutFile
		* Based On:					SFCommandButton (SFCTRLS.VCX)
		* Purpose:					Displays a Save File dialog
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2003 Stonefield Systems Group Inc.
		* Last revision:			01/29/2003
		*
		* Changes in "Based On" class properties:
		*	StatusBarText:			Select a file and path
		*	ToolTipText:			Select a file and path
		*
		* Changes in "Based On" class methods:
		*	Click:					displays the dialog, puts the result into the
		*							control defined in cResult, and performs any
		*							processing defined in the cAfterDone expression
		*
		* Custom public properties added:
		*	cAfterDone:				an expression to evaluate after the file has been
		*							selected
		*	cCaption:				the caption for the dialog (ignored if
		*							lUseCommonDialog is .F.)
		*	cDefault:				the default filename for the dialog (surround
		*							literal string with quotes)
		*	cExtensions:			the extensions parameter for PUTFILE() or if
		*							lUseCommonDialog, extensions in the format
		*							"Descrip,*.,EXT;Descrip,*.EXT" (surround literal
		*							strings in quotes)
		*	cResult:				the name of the control to put the return value
		*							into
		*	cText:					the text to appear beside the filename in the
		*							dialog (ignored if lUseCommonDialog is .T.)
		*	lUseCommonDialog:		.T. to use the CommonDialog control (requires
		*							SFCommonDialog in SFUtility.vcx)
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Click
		* Display a Save File dialog, using parameters determined from the properties
		* of this object.
		
		local lcResult, ;
			loDialog, ;
			lcExt, ;
			laTypes[1], ;
			lnTypes, ;
			lnI, ;
			lnPos, ;
			lcExt1, ;
			lcExt2, ;
			lcFile, ;
			lcOptions
		with This
			assert not empty(.cResult) ;
				message 'SFGetFile: the result container was not defined.'
			lcResult = .cResult
		
		* If we're using the CommonDialog control, instantiate the SFCommonDialog
		* class, set its properties, and call the ShowDialog method.
		
			if .lUseCommonDialog
				loDialog = MakeObject('SFCommonDialog', 'SFUtility.vcx')
				if not empty(.cDefault)
					loDialog.cFileName = alltrim(evaluate(.cDefault))
				endif not empty(.cDefault)
				if not empty(.cExtensions)
					lcExt   = strtran(evaluate(.cExtensions), ';', chr(13))
					lnTypes = alines(laTypes, lcExt)
					loDialog.ClearFilters(.T.)
					for lnI = 1 to lnTypes
						lcExt = laTypes[lnI]
						if ',' $ lcExt
							lnPos  = at(',', lcExt)
							lcExt1 = alltrim(left(lcExt, lnPos - 1))
							lcExt2 = alltrim(substr(lcExt, lnPos + 1))
						else
							lcExt1 = alltrim(lcExt)
							lcExt2 = '*.' + lcExt
						endif ',' $ lcExt
						if upper(justext(loDialog.cFileName)) == upper(justext(lcExt2))
							loDialog.nFilterIndex = lnI
						endif upper(justext(loDialog.cFileName)) == upper(justext(lcExt2))
						loDialog.AddFilter(lcExt1, lcExt2)
					next lnI
				endif not empty(.cExtensions)
				loDialog.cTitleBarText = .cCaption
				loDialog.lSaveDialog   = .T.
				loDialog.ShowDialog()
				lcFile = addbs(loDialog.cFilePath) + loDialog.cFileTitle
			else
		
		* We're using PUTFILE(), so build a string of parameters from the properties
		* of this object and call PUTFILE().
		
				lcOptions = iif(empty(.cText), "''", "'" + .cText+ "'") + ',' + ;
					iif(empty(.cDefault), '', .cDefault) + ',' + ;
					iif(empty(.cExtensions), '', .cExtensions)
				lcFile = putfile(&lcOptions)
			endif .lUseCommonDialog
		
		* If the user chose a file, store the result in the specified location.
		
			if not empty(lcFile)
				store lcFile to (lcResult)
		
		* If a method or function was specified to execute after file selection, do it.
		
				if not empty(.cAfterDone)
					evaluate(.cAfterDone)
				endif not empty(.cAfterDone)
			endif not empty(lcFile)
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sftoolbarbutton AS sfcommandbutton OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	Caption = ""
	Height = 22
	Name = "sftoolbarbutton"
	Width = 22
	
	PROCEDURE about
		*==============================================================================
		* Class:					SFToolbarButton
		* Based On:					SFCommandButton (SFCTRLS.VCX)
		* Purpose:					Base class for all buttons used in toolbars
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2001 Stonefield Systems Group Inc.
		* Last revision:			08/15/2001
		* Include file:				SFCTRLS.H
		*
		* Changes in base class properties:
		*	Caption:				None so only a picture will be used
		*	Height:					22
		*	Width:					22
		*
		* Changes in base class methods:
		*	Init:					turn on hot tracking in VFP 7 or later
		*
		* Custom public properties added:
		*	None
		*
		* Custom protected properties added:
		*	None
		*
		* Custom public methods added:
		*	None
		*
		* Custom protected methods added:
		*	None
		*==============================================================================
		
	ENDPROC

	PROCEDURE Init
		* Turn on hot tracking in VFP 7 or later.
		
		if clVFP7ORLATER
			This.SpecialEffect = 2
		endif clVFP7ORLATER
		
	ENDPROC

ENDDEFINE
