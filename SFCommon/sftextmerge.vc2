*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sftextmerge.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sftextmergeprocessor AS sfcustom OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: executescript
		*m: output		&& Processes the specified string and returns the result
		*m: write		&& Add a string to the output stream
		*p: cfile		&& The file used for streaming output
		*p: cleftdelimiter		&& The left delimiter for script code
		*p: crightdelimiter		&& The right delimiter for script code
		*p: lscript		&& .T. if we're executing script code when an error occurs
		*p: lusehtmlencoding		&& .T. to convert HTML characters to their encoded equivalents
		*p: nhandle		&& The handle of the file used for streaming output
	*</DefinedPropArrayMethod>

	PROTECTED cfile,lscript,nhandle
	cfile = 		&& The file used for streaming output
	cleftdelimiter = <%		&& The left delimiter for script code
	crightdelimiter = %>		&& The right delimiter for script code
	lscript = .F.		&& .T. if we're executing script code when an error occurs
	lusehtmlencoding = .F.		&& .T. to convert HTML characters to their encoded equivalents
	Name = "sftextmergeprocessor"
	nhandle = 0		&& The handle of the file used for streaming output
	
	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1]
		aerror(laError)
		This.cErrorMessage = 'Error #' + transform(tnError) + ;
			' in line ' + transform(tnLine) + ' of ' + ;
			iif(This.lScript, 'script', tcMethod) + ': ' + laError[2]
		
	ENDPROC

	PROCEDURE executescript
		lparameters tcCode
		local luReturn, ;
			lcFile, ;
			lcName
		luReturn = .NULL.
		with This
			.lScript = .T.
			if clVFP7ORLATER and version(2) = 0
				luReturn = execscript(tcCode)
			else
				lcFile = sys(2015) + '.PRG'
				strtofile(tcCode, lcFile)
				compile (lcFile)
				lcName   = juststem(lcFile) + '()'
				luReturn = &lcName
				erase (lcFile)
				erase forceext(lcFile, 'FXP')
			endif clVFP7ORLATER ...
			.lScript = .F.
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE output		&& Processes the specified string and returns the result
		lparameters tcString
		local lcCodeLeft, ;
			lcMergeLeft, ;
			laLines[1], ;
			lnLines, ;
			lnI, ;
			lcLine, ;
			lcCode, ;
			lnJ, ;
			lcReturn
		private Response
		with This
		
		* Open a file for streaming output.
		
			.cFile   = addbs(sys(2023)) + sys(2015)
			.nHandle = fcreate(.cFile)
		
		* Create a reference to this object called "Response" so script code can
		* call methods.
		
			Response = This
		
		* Create variables for the left delimiters for code and for merge strings.
		
			lcCodeLeft  = .cLeftDelimiter + ' '
			lcMergeLeft = .cLeftDelimiter + '='
		
		* Initialize our error message to blank.
		
			.cErrorMessage = ''
		
		* Process each line in the string.
		
			lnLines = alines(laLines, tcString)
			for lnI = 1 to lnLines
				lcLine = laLines[lnI]
		
		* If this line is the start of script code, get all text up to the end of the
		* code and execute it.
		
				if lcLine = lcCodeLeft or (lcLine = trim(lcCodeLeft) and ;
					lcLine <> lcMergeLeft)
					lcCode = ''
					for lnJ = lnI to lnLines
						lcLine     = laLines[lnJ]
						lcCodeLine = alltrim(strtran(strtran(lcLine, ;
							trim(lcCodeLeft)), .cRightDelimiter))
						if not empty(lcCodeLine) and lcCodeLine <> '*' and ;
							lcCodeLine <> chr(38) + chr(38)
							lcCode = lcCode + lcCodeLine + ccCRLF
						endif not empty(lcCodeLine) ...
						if This.cRightDelimiter $ lcLine
							lnI = lnJ
							exit
						endif This.cRightDelimiter $ lcLine
					next lnJ
					if not empty(lcCode)
						.ExecuteScript(lcCode)
					endif not empty(lcCode)
		
		* Use TEXTMERGE() to process the line and add it to the output stream. Because
		* "=" in the left delimiter causes TEXTMERGE() to send the result to the bit
		* bucket, let's strip it off.
		
				else
					lcLine = strtran(lcLine, lcMergeLeft, .cLeftDelimiter)
					if .cLeftDelimiter $ lcLine
						lcResult = textmerge(lcLine + chr(0), .T., .cLeftDelimiter, ;
							.cRightDelimiter)
						lcResult = left(lcResult, len(lcResult) - 1)
					else
						lcResult = lcLine
					endif .cLeftDelimiter $ lcLine
					if .lUseHTMLEncoding
						lcResult = strtran(strtran(lcResult, '<', '&lt;'), '>', '&gt;')
					endif .lUseHTMLEncoding
					.Write(lcResult + ccCRLF)
				endif lcLine = lcCodeLeft ...
		
		* Exit if we had an error.
		
				if not empty(.cErrorMessage)
					exit
				endif not empty(.cErrorMessage)
			next lnI
		
		* Close the streaming output file and retrieve the contents.
		
			fclose(.nHandle)
			lcReturn = filetostr(.cFile)
			erase (.cFile)
		endwith
		return lcReturn
		
	ENDPROC

	PROCEDURE write		&& Add a string to the output stream
		lparameters tcString
		fwrite(This.nHandle, tcString)
		
	ENDPROC

ENDDEFINE
