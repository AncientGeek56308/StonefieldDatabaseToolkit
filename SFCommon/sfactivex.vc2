*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfactivex.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfactivex AS sfcustom OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfactivex.h"
	*<DefinedPropArrayMethod>
		*m: getlongname		&& Returns the long name for a short file name
		*m: getprogid		&& Returns the ProgID for the ActiveX control
		*m: loadactivex		&& Instantiate the specified ActiveX control
		*p: cactivexname		&& The name of the ActiveX control (displayed in an error message)
		*p: cactualclassid		&& The CLSID found in the Registry
		*p: cactualprogid		&& The ProgID found in the Registry
		*p: cclass		&& The name of the class defining the ActiveX control or a subclass of it
		*p: cclassid		&& The Class ID for the object (leave blank if cOLEClass is specified)
		*p: clibrary		&& The name of the library containing the ActiveX control; specify an extension to identify VCX from PRG libraries
		*p: clicensekey		&& The Registry key for the license for this class
		*p: clicensevalue		&& The value of the license key
		*p: cnewobjectname		&& The name to give the ActiveX control this object will create
		*p: cobjectname		&& The name of the placeholder object to replace with the ActiveX control
		*p: cocxfilename		&& The name of the OCX file the ActiveX control lives in
		*p: coleclass		&& The OLE class for the object
		*p: lautoload		&& .T. to automatically load the ActiveX control
		*p: lerror		&& .T. if an error occurred registering an OCX
		*p: lload		&& .T. to load the ActiveX control; .F. to simply ensure it exists and is registered
		*p: oregistry		&& A reference to an SFRegistry object
		*a: aclassinfo[1,5]		&& An array of information about ActiveX controls to use (such as different versions of the same control)
	*</DefinedPropArrayMethod>

	PROTECTED cactualclassid,cactualprogid,lerror,oregistry
	cactivexname = 		&& The name of the ActiveX control (displayed in an error message)
	cactualclassid = 		&& The CLSID found in the Registry
	cactualprogid = 		&& The ProgID found in the Registry
	cclass = OLEControl		&& The name of the class defining the ActiveX control or a subclass of it
	cclassid = 		&& The Class ID for the object (leave blank if cOLEClass is specified)
	clibrary = 		&& The name of the library containing the ActiveX control; specify an extension to identify VCX from PRG libraries
	clicensekey = 		&& The Registry key for the license for this class
	clicensevalue = 		&& The value of the license key
	cnewobjectname = 		&& The name to give the ActiveX control this object will create
	cobjectname = 		&& The name of the placeholder object to replace with the ActiveX control
	cocxfilename = 		&& The name of the OCX file the ActiveX control lives in
	coleclass = 		&& The OLE class for the object
	lautoload = .T.		&& .T. to automatically load the ActiveX control
	lerror = .F.		&& .T. if an error occurred registering an OCX
	lload = .T.		&& .T. to load the ActiveX control; .F. to simply ensure it exists and is registered
	Name = "sfactivex"
	oregistry = .NULL.		&& A reference to an SFRegistry object
	
	PROCEDURE about
		*==============================================================================
		* Class:					SFActiveX
		* Based On:					SFCustom (SFCTRLS.VCX)
		* Purpose:					ActiveX instantiating class
		* Author:					Doug Hennig
		* Copyright:				(c) 1996-2003 Stonefield Systems Group Inc.
		* Last revision:			04/15/2003
		* Include file:				SFACTIVEX.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Error:					handle an error when registering an ActiveX control
		*	Init:					call LoadActiveX method
		*	ReleaseMembers:			nuke member objects
		*
		* Custom public properties added:
		*	aClassInfo:				an array of information about ActiveX controls to
		*							use (such as different versions of the same
		*							control)
		*	cActiveXName:			the name of the ActiveX control (displayed in an
		*							error message)
		*	cClass:					the name of the class defining the ActiveX control
		*							or a subclass of it
		*	cClassID:				the Class ID for the object (leave blank if
		*							cOLEClass is specified)
		*	cLibrary:				the name of the library containing a subclass of
		*							the ActiveX control; specify an extension to
		*							identify VCX from PRG libraries
		*	cLicenseKey:			the Registry key for the license for this class
		*	cLicenseValue:			the value of the license key
		*	cNewObjectName:			the name to give the ActiveX control this object
		*							will create
		*	cObjectName:			the name of the placeholder object to replace with
		*							the ActiveX control
		*	cOCXFileName:			the name of the OCX file the ActiveX control lives
		*							in
		*	cOLEClass:				the OLE class for the object
		*	lAutoLoad:				.T. to automatically load the ActiveX control
		*	lLoad:					.T. to load the ActiveX control; .F. to simply
		*							ensure it exists and is registered
		*
		* Custom protected properties added:
		*	cActualClassID:			the CLSID found in the Registry
		*	cActualProgID:			the ProgID found in the Registry
		*	lError:					.T. if an error occurred registering an OCX
		*	oRegistry:				a reference to an SFRegistry object
		*
		* Custom public methods added:
		*	LoadActiveX:			instantiate the specified ActiveX control
		*
		* Custom protected methods added:
		*	GetLongName:			returns the long name for a short file name
		*	GetProgID:				fills the cActualClassID and cActualProgID
		*							properties with the appropriate information for the
		*							ActiveX control
		*==============================================================================
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lcReturn
		do case
		
		* If the error is "cannot find entry point in DLL", flag that an error occurred
		* and return because the code will handle it.
		
			case tnError = cnERR_CANNOT_FIND_DLL_ENTRY
				This.lError = .T.
				return
		
		* Use the normal error handling mechanism for all other types of errors. Note
		* that we add a period to the method name passed. This tells our parent class
		* to return the error resolution string back to us, which is required for RETRY
		* to work.
		
			otherwise
				lcReturn = dodefault(tnError, '.' + tcMethod, tnLine)
				lcReturn = iif(vartype(lcReturn) <> 'C', ccMSG_CONTINUE, lcReturn)
				do case
					case lcReturn = ccMSG_RETRY
						retry
					case lcReturn = ccMSG_DEBUG
						debug
						if wexist('Visual FoxPro Debugger')
							keyboard '{SHIFT+F7}' plain
						endif wexist('Visual FoxPro Debugger')
						suspend
					case lcReturn = ccMSG_CANCEL
						cancel
					otherwise
						return
				endcase
		endcase
		
	ENDPROC

	PROTECTED PROCEDURE getlongname		&& Returns the long name for a short file name
		lparameters tcFile
		local lcDLL, ;
			lcFunction, ;
			lnHandle, ;
			lcFile, ;
			lnLength, ;
			lcBuffer
		if '~' $ tcFile
		
		* Declare Win32API functions to determine if the GetLongPathName function is
		* available.
		
			declare integer GetModuleHandle in Win32API ;
				string @lpModuleName
			declare integer GetProcAddress in Win32API ;
				integer hModule, string @lpProcName
		
		* See if the GetLongPathName Win32API function is available; if so, call it.
		
			lcDLL      = 'kernel32.dll'
			lcFunction = 'GetLongPathNameA'
			lnHandle   = GetModuleHandle(@lcDLL)
			if GetProcAddress(lnHandle, @lcFunction) > 0
				declare integer GetLongPathName in Win32API ;
					string @lpszShortPath, string @lpszLongPath, integer cchBuffer
				lcFile   = tcFile + ccNULL
				lnLength = 260
				lcBuffer = space(lnLength)
				GetLongPathName(@lcFile, @lcBuffer, lnLength)
				lcFile = left(lcBuffer, at(ccNULL, lcBuffer) - 1)
			endif GetProcAddress(lnHandle, @lcFunction) > 0
		else
			lcFile = tcFile
		endif '~' $ tcFile
		return lcFile
		
	ENDPROC

	PROTECTED PROCEDURE getprogid		&& Returns the ProgID for the ActiveX control
		lparameters tcClassID, ;
			tcOLEClass
		with This
			if empty(.cOLEClass)
				.cActualClassID = iif(left(tcClassID, 1) = '{', tcClassID, ;
					'{' + tcClassID + '}')
				.cActualProgID  = .oRegistry.GetKey('CLSID\' + .cActualClassID + ;
					'\ProgID')
			else
				.cActualProgID  = tcOLEClass
				.cActualClassID = .oRegistry.GetKey(.cActualProgID + '\CLSID')
				if empty(.cActualClassID)
					.cActualProgID  = .cActualProgID + '.1'
					.cActualClassID = .oRegistry.GetKey(.cActualProgID + '\CLSID')
				endif empty(.cActualClassID)
			endif empty(.cOLEClass)
		endwith
		
	ENDPROC

	PROCEDURE Init
		lparameters tlNoLoad
		dodefault()
		if not tlNoLoad and This.lAutoLoad
			return This.LoadActiveX()
		endif not tlNoLoad ...
		
	ENDPROC

	PROCEDURE loadactivex		&& Instantiate the specified ActiveX control
		* Replace the specified placeholder object with the specified ActiveX control.
		
		local lnLength, ;
			lcBuffer, ;
			lcDirectory, ;
			lcLicenseKey, ;
			lcLicenseValue, ;
			lcClassID, ;
			lcOLEClass, ;
			llOK, ;
			lcOCX, ;
			llRegister, ;
			lnI, ;
			lcKey, ;
			llObject, ;
			lcObject, ;
			lnTop, ;
			lnLeft, ;
			lnWidth, ;
			lnHeight, ;
			lnPos, ;
			lcExt, ;
			lcLibrary, ;
			llLibrary, ;
			lcActualProgID, ;
			lcClass, ;
			lcMessage
		with This
		
		* Ensure all the properties we need have valid values.
		
			assert empty(.cObjectName) or (vartype(.cObjectName) = 'C' and ;
				type('This.Parent.' + .cObjectName + '.Top') <> 'U') ;
				message 'Please specify a valid object name for SFActiveX.cObjectName'
			assert not .lLoad or (not empty(.cNewObjectName) and ;
				vartype(.cNewObjectName) = 'C' and ;
				type('This.Parent.' + .cNewObjectName + '.Top') = 'U') ;
				message 'Please specify a valid object name for ' + ;
				'SFActiveX.cNewObjectName'
			assert not empty(.cClass) and vartype(.cClass) = 'C' ;
				message 'Please specify a class name for SFActiveX.cClass'
			assert empty(.cLibrary) or vartype(.cLibrary) = 'C' ;
				message 'Please specify a valid library name for SFActiveX.cLibrary'
			assert (not empty(.cOLEClass) and vartype(.cOLEClass) = 'C') or ;
				(not empty(.cClassID) and vartype(.cClassID) = 'C') ;
				message 'Please specify a valid OLE class for SFActiveX.cOLEClass ' + ;
				'or class ID for SFActiveX.cClassID'
		
		* Instantiate an SFRegistry object.
		
			.oRegistry = MakeObject('SFRegistry', 'SFRegistry.vcx', '', ;
				cnHKEY_CLASSES_ROOT)
		
		* Find the Windows System directory.
		
			declare integer GetSystemDirectory in Win32API ;
				string @szBuffer, ;
				integer nLength
			lnLength = 254
			lcBuffer = space(lnLength)
			GetSystemDirectory(@lcBuffer, lnLength)
			lcDirectory = addbs(alltrim(left(lcBuffer, at(ccNULL, lcBuffer) - 1)))
		
		* Start with the cOLEClass, cClassID, cLicenseKey, and cLicenseValue properties
		* (for backward compatibility and simplicity): see if the specified OLE class
		* is registered. If we can find the class, ensure the OCX exists. If we didn't
		* find the class but the OCX exists, that means it's not properly registered,
		* so flag that we need to do that.
		
			lcLicenseKey   = .cLicenseKey
			lcLicenseValue = .cLicenseValue
			lcClassID      = .cClassID
			lcOLEClass     = .cOLEClass
			.GetProgID(lcClassID, lcOLEClass)
			llOK = not empty(.cActualClassID) and not empty(.cActualProgID)
			if llOK
				lcOCX = .GetLongName(.oRegistry.GetKey('CLSID\' + .cActualClassID + ;
					'\InProcServer32'))
			else
				lcOCX      = .GetLongName(lcDirectory + .cOCXFileName)
				llRegister = .T.
			endif llOK
			llOK = not empty(lcOCX) and file(lcOCX)
		
		* If we didn't find the desired control, use the aClassInfo array for the same
		* tasks as described above.
		
			if not llOK
				for lnI = 1 to alen(.aClassInfo, 1)
					if not empty(.aClassInfo[lnI, 1])
						lcClassID      = .aClassInfo[lnI, 1]
						lcOLEClass     = .aClassInfo[lnI, 2]
						lcLicenseKey   = .aClassInfo[lnI, 3]
						lcLicenseValue = .aClassInfo[lnI, 4]
						llRegister     = .F.
						.GetProgID(lcClassID, lcOLEClass)
						llOK = not empty(.cActualClassID) and not empty(.cActualProgID)
					endif not empty(.aClassInfo[lnI, 1])
					if llOK
						lcOCX = .GetLongName(.oRegistry.GetKey('CLSID\' + ;
							.cActualClassID + '\InProcServer32'))
						if empty(lcOCX)
							lcOCX      = .GetLongName(lcDirectory + ;
								.aClassInfo[lnI, 5])
							llRegister = .T.
						endif empty(lcOCX)
						llOK = not empty(lcOCX) and file(lcOCX)
						if llOK
							exit
						endif llOK
					endif llOK
				next lnI
			endif not llOK
		
		* If the OCX file exists, but isn't properly registered, let's register it
		* now.
		
			if llOK and llRegister
				declare integer DllRegisterServer in (lcOCX) as __DllRegisterServer__
				llOK = __DllRegisterServer__() = 0
				llOK = llOK and not .lError
				if llOK
					.GetProgID(lcClassID, lcOLEClass)
					llOK = not empty(.cActualClassID)
				endif llOK
			endif llOK ...
			do case
		
		* If the ActiveX control is registered but we're not supposed to load it, we're
		* done.
		
				case llOK and not .lLoad
		
		* If the ActiveX control is registered, ensure the license key is registered if
		* necessary.
		
				case llOK
					if not empty(lcLicenseKey)
						lcKey = .oRegistry.GetKey('Licenses\' + lcLicenseKey)
						if empty(lcKey)
							.oRegistry.SetKey('Licenses\' + lcLicenseKey, , ;
								lcLicenseValue)
						endif empty(lcKey)
					endif not empty(lcLicenseKey)
		
		* Save the size and position of the existing object, then nuke it (if one is
		* specified).
		
					llObject = not empty(.cObjectName)
					if llObject
						lcObject = .cObjectName
						with .Parent.&lcObject
							lnTop    = .Top
							lnLeft   = .Left
							lnWidth  = .Width
							lnHeight = .Height
						endwith
						.Parent.RemoveObject(lcObject)
					endif llObject
		
		* Open the library for the new object's class if necessary.
		
					if not empty(.cLibrary)
						lnPos     = rat('.', .cLibrary)
						lcExt     = upper(substr(.cLibrary, lnPos + 1))
						lcExt     = iif(empty(lcExt), 'VCX', lcExt)
						lcLibrary = upper(iif(lnPos = 0, lcLibrary, ;
							left(.cLibrary, lnPos - 1)))
						assert file(lcLibrary + '.' + lcExt) or ;
							(lcExt = 'PRG' and file(lcLibrary + '.FXP')) ;
							message 'SFActiveX.cLibrary (' + .cLibrary + ;
							') cannot be found'
						assert lcExt $ 'PRG,VCX,FXP' ;
							message 'Please specify a valid library name for ' + ;
							'SFActiveX.cLibrary'
						if lcExt = 'VCX'
							llLibrary = '\' + lcLibrary + ;
								'.VCX' $ upper(set('CLASSLIB'))
							if not llLibrary
								set classlib to (lcLibrary) additive
							endif not llLibrary
						else
							llLibrary = '\' + lcLibrary + ;
								'.FXP' $ upper(set('PROCEDURE')) or ;
								'\' + lcLibrary + '.FXP' $ upper(set('LIBRARY'))
							if not llLibrary
								set procedure to (lcLibrary) additive
							endif not llLibrary
						endif lcExt = 'VCX'
					endif not empty(.cLibrary)
		
		* Put the ProgID and class into variables for debugging purposes.
		
					lcActualProgID = .cActualProgID
					lcClass        = .cClass
		
		* Create the new object and set its size and position.
		
					lcObject = .cNewObjectName
					.Parent.AddObject(lcObject, lcClass, lcActualProgID)
					with .Parent.&lcObject
						if llObject
							.Top    = lnTop
							.Left   = lnLeft
							.Width  = lnWidth
							.Height = lnHeight
						endif llObject
						.Visible = .T.
					endwith
		
		* If we opened the library file, close it.
		
					do case
						case llLibrary or empty(.cLibrary)
						case lcExt = 'VCX'
							release classlib (lcLibrary)
						otherwise
							release procedure (lcLibrary)
					endcase
		
		* If we're not loading the ActiveX control, we'll just return .F. instead of
		* giving an error.
		
				case not .lLoad
		
		* The ActiveX control isn't registered or the OCX wasn't found, so give the
		* appropriate error message.
		
				case empty(lcOCX)
					lcMessage = strtran(ccERR_OLE_NOT_REG, ccMSG_INSERT1, ;
						.cActiveXName)
					error lcMessage
				otherwise
					lcMessage = strtran(ccERR_OCX_NOT_FOUND, ccMSG_INSERT1, lcOCX)
					error lcMessage
			endcase
		endwith
		return llOK
		
	ENDPROC

	PROCEDURE releasemembers
		This.oRegistry = .NULL.
		dodefault()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfcommondialog AS sfactivex OF "sfactivex.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	cactivexname = CommonDialog control
	cclassid = F9043C85-F6F2-101A-A3C9-08002B2F49FB
	clicensekey = DB4C0D00-400B-101B-A3C9-08002B2F49FB
	clicensevalue = mgkgtgnnmnmninigthkgogggvmkhinjggnvm
	cocxfilename = COMDLG32.OCX
	Name = "sfcommondialog"

ENDDEFINE

DEFINE CLASS sfimagelist AS sfactivex OF "sfactivex.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	cactivexname = ImageList control
	cclassid = 2C247F23-8591-11D1-B16A-00C0F0283628
	clicensekey = ED4B87C4-9F76-11d1-8BF7-0000F8754DA1
	clicensevalue = knlggnmntgggrninthpgmnngrhqhnnjnslsh
	cocxfilename = MSCOMCTL.OCX
	Name = "sfimagelist"
	
	PROCEDURE Init
		* Fill aClassInfo for information for the version 5 ImageList (the scalar
		* properties have information for the version 6 control, so it'll be
		* preferentially instantiated).
		
		lparameters tlNoLoad
		with This
			dimension .aClassInfo[1, 5]
			.aClassInfo[1, 1] = '58DA8D8F-9D6A-101B-AFC0-4210102A8DA7'
			.aClassInfo[1, 3] = 'DB4C0D00-400B-101B-A3C9-08002B2F49FB'
			.aClassInfo[1, 4] = 'mgkgtgnnmnmninigthkgogggvmkhinjggnvm'
			.aClassInfo[1, 5] = 'COMCTL32.OCX'
		endwith
		return dodefault(tlNoLoad)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sflistbar AS sfactivex OF "sfactivex.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	cactivexname = ListBar control
	cclassid = 6D5E3203-FEE5-11D0-943D-444553540000
	Name = "sflistbar"

ENDDEFINE

DEFINE CLASS sflistview AS sfactivex OF "sfactivex.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	cactivexname = ListView control
	cclassid = BDD1F04B-858B-11D1-B16A-00C0F0283628
	clicensekey = ED4B87C4-9F76-11d1-8BF7-0000F8754DA1
	clicensevalue = knlggnmntgggrninthpgmnngrhqhnnjnslsh
	cocxfilename = MSCOMCTL.OCX
	Name = "sflistview"
	
	PROCEDURE Init
		* Fill aClassInfo for information for the version 5 ListView (the scalar
		* properties have information for the version 6 control, so it'll be
		* preferentially instantiated).
		
		lparameters tlNoLoad
		with This
			dimension .aClassInfo[1, 5]
			.aClassInfo[1, 1] = '58DA8D8A-9D6A-101B-AFC0-4210102A8DA7'
			.aClassInfo[1, 3] = 'DB4C0D00-400B-101B-A3C9-08002B2F49FB'
			.aClassInfo[1, 4] = 'mgkgtgnnmnmninigthkgogggvmkhinjggnvm'
			.aClassInfo[1, 5] = 'COMCTL32.OCX'
		endwith
		return dodefault(tlNoLoad)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfstatusbar AS sfactivex OF "sfactivex.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	cactivexname = StatusBar control
	cclassid = 8E3867A3-8586-11D1-B16A-00C0F0283628
	clicensekey = ED4B87C4-9F76-11d1-8BF7-0000F8754DA1
	clicensevalue = knlggnmntgggrninthpgmnngrhqhnnjnslsh
	cocxfilename = MSCOMCTL.OCX
	Name = "sfstatusbar"
	
	PROCEDURE Init
		* Fill aClassInfo for information for the version 5 StatusBar (the scalar
		* properties have information for the version 6 control, so it'll be
		* preferentially instantiated).
		
		lparameters tlNoLoad
		with This
			dimension .aClassInfo[1, 5]
			.aClassInfo[1, 1] = '6B7E638F-850A-101B-AFC0-4210102A8DA7'
			.aClassInfo[1, 3] = 'DB4C0D00-400B-101B-A3C9-08002B2F49FB'
			.aClassInfo[1, 4] = 'mgkgtgnnmnmninigthkgogggvmkhinjggnvm'
			.aClassInfo[1, 5] = 'COMCTL32.OCX'
		endwith
		return dodefault(tlNoLoad)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sftreeview AS sfactivex OF "sfactivex.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	cactivexname = TreeView control
	cclassid = C74190B6-8589-11D1-B16A-00C0F0283628
	clicensekey = ED4B87C4-9F76-11d1-8BF7-0000F8754DA1
	clicensevalue = knlggnmntgggrninthpgmnngrhqhnnjnslsh
	cocxfilename = MSCOMCTL.OCX
	Name = "sftreeview"
	
	PROCEDURE Init
		* Fill aClassInfo for information for the version 5 TreeView (the scalar
		* properties have information for the version 6 control, so it'll be
		* preferentially instantiated).
		
		lparameters tlNoLoad
		with This
			dimension .aClassInfo[1, 5]
			.aClassInfo[1, 1] = '0713E8A2-850A-101B-AFC0-4210102A8DA7'
			.aClassInfo[1, 3] = 'DB4C0D00-400B-101B-A3C9-08002B2F49FB'
			.aClassInfo[1, 4] = 'mgkgtgnnmnmninigthkgogggvmkhinjggnvm'
			.aClassInfo[1, 5] = 'COMCTL32.OCX'
		endwith
		return dodefault(tlNoLoad)
		
	ENDPROC

ENDDEFINE
